# eBPF 教程：进程级能源监控与功耗分析

您是否想过应用程序到底消耗了多少能源？在数据中心和边缘设备中，能源效率正变得愈发重要，深入了解进程级别的功耗已成为系统优化的关键。本教程将带您构建一个基于 eBPF 的能源监控工具，它能以极低的系统开销实时洞察进程的功耗情况。

## 能源监控和功耗分析简介

长期以来，计算系统的能源监控一直面临着细粒度测量能力不足的挑战。虽然 Intel RAPL（Running Average Power Limit）等硬件计数器能够测量系统总功耗或 CPU 封装功耗，但无法精确定位具体是哪些进程在消耗这些能量。这正是软件层面能源归因技术的用武之地。

进程在 CPU 上运行时，其功耗与 CPU 占用时间和处理器功率状态密切相关。难点在于如何实时精确地追踪这种关系，同时避免监控本身带来的额外功耗和测量偏差。传统的轮询式监控方法容易遗漏短生命周期的进程，而且监控开销会影响测量的准确性。

eBPF 技术的出现彻底改变了这一局面！通过在内核调度器事件上设置钩子，我们能够以纳秒级精度捕获每次上下文切换时的进程 CPU 时间。这种方法不仅能精确测量每个进程的 CPU 时间，完全消除短生命周期进程的采样误差，还能相比轮询方式大幅降低监控开销。更重要的是，它支持实时计算基于 CPU 时间的能源消耗，精准关联能源使用与具体工作负载。

## 理解 CPU 功耗

在深入实现之前，了解 CPU 功耗的工作原理非常重要。现代处理器以几种方式消耗功率：

### 动态功耗

动态功耗产生于晶体管状态切换的过程中。当处理器工作在更高的时钟频率时，单位时间内的状态切换次数增加；当电压升高时，每次切换消耗的能量也相应增大；而执行的指令越多，参与切换的晶体管数量就越多。这些因素共同决定了动态功耗的大小，其关系可以用公式表示为：P_dynamic = C × V² × f × α，其中 C 表示电容，V 表示电压，f 表示频率，α 表示活动因子。

### 静态功耗

即使晶体管不切换，由于通过晶体管的电流泄漏，也会消耗静态（或泄漏）功率。在拥有数十亿个晶体管的现代处理器中，这变得越来越重要。

### 功率状态和 DVFS

现代 CPU 使用动态电压和频率调节（DVFS）来平衡性能和功耗。处理器可以在具有不同频率/电压组合的不同 P 状态（性能状态）下运行，并在不主动计算时进入 C 状态（空闲状态）。

我们的能源监控方法通过将 CPU 时间乘以平均功耗来估算能源消耗。虽然这是一种简化（它不考虑频率变化或空闲状态），但它提供了一个有用的近似值来比较进程之间的相对能源使用。

## 比较传统与 eBPF 能源监控

为了理解为什么 eBPF 在能源监控方面更优越，让我们将其与传统方法进行比较：

### 传统的基于 /proc 的监控

传统的能源监控工具通常通过定期读取 `/proc/stat` 来采样 CPU 使用情况。以下是我们的传统监控器的工作原理：

```bash
# 读取进程的总 CPU 时间
cpu_time=$(awk '{print $14 + $15}' /proc/$pid/stat)

# 基于时间差计算能量
energy = cpu_power * (current_time - previous_time)
```

这种方法存在明显的局限性。首先是**采样误差**问题，在采样间隔内启动和停止的进程会被完全遗漏。其次是**固定开销**，每次采样都需要读取和解析 `/proc` 文件系统。再者是**精度限制**，典型的采样间隔达到 100ms 或更长。最后是**可扩展性**挑战，监控大量进程时需要频繁读取众多文件，开销急剧增加。

### 基于 eBPF 的监控

我们的 eBPF 方法直接挂钩到内核调度器：

```c
SEC("tp/sched/sched_switch")
int monitor_energy(struct trace_event_raw_sched_switch *ctx) {
    u64 ts = bpf_ktime_get_ns();
    // 跟踪进程停止运行的确切时间
    u64 delta = ts - previous_timestamp;
    update_runtime(prev_pid, delta);
}
```

这种方法的优势非常明显。它能够捕获每一次上下文切换，实现**完美精度**；无需轮询或文件解析，保证了**最小开销**；提供**纳秒级精度**的 CPU 时间测量；更重要的是具有出色的**可扩展性**，无论监控 1 个还是 1000 个进程，系统开销基本相同。

## 为什么选择 eBPF 进行能源监控？

能源监控的格局已经显著发展，正如 eBPF 能源项目综合调查中详细描述的那样。让我结合能源监控生态系统的关键见解：

### eBPF 能源项目的当前状态

eBPF 能源管理生态系统正在两个主要类别中快速发展：成熟的遥测解决方案和新兴的功率控制框架。

**能源遥测和计费（生产就绪）**

在生产就绪的能源遥测和计费领域，已经涌现出几个成熟的解决方案。**Kepler** 作为 CNCF 沙箱项目，已经在生产环境中广泛部署，它专注于 Kubernetes 环境中的容器和 pod 能源归因，通过结合 eBPF 跟踪点、RAPL 硬件计数器和性能计数器来实现精确测量。**Wattmeter** 则是一个研究原型，在 HotCarbon '24 会议上展示，它通过在上下文切换时读取 RAPL MSR 寄存器的 eBPF 程序来实现每进程能源跟踪，其开销低于 1 微秒，展现了极高的效率。**DEEP-mon** 提供了另一种经过学术验证的方法，专门针对容器功率监控，通过在内核内对调度器事件进行 eBPF 聚合，巧妙地避免了用户空间的开销。

**通过 eBPF 进行功率控制（研发中）**

新兴的功率控制领域代表了 eBPF 能源管理的下一个前沿。**cpufreq_ext** 是第一个可以通过 `bpf_struct_ops` 接口实际修改 CPU 频率的上游 eBPF 实现，允许用 eBPF 而不是内核 C 代码编写频率调节策略。

研究原型包括一个 **eBPF CPU 空闲调节器**，它用 eBPF 挂钩替换传统的 menu/TEO 调节器，用于动态空闲状态选择和空闲注入。概念性的 **BEAR（BPF 能源感知运行时）** 框架旨在在单个基于 eBPF 的策略引擎下统一 DVFS、空闲和热管理，尽管还没有公开实现。

### 为什么我们的方法很重要

我们的能源监控器属于遥测类别，但特别关注教育清晰度和与传统方法的比较。eBPF 的**事件驱动架构**与基于轮询的方法根本不同，它实时响应内核事件。当调度器切换进程时，我们的代码立即运行，以纳秒精度捕获确切的转换时刻。

**内核内聚合**功能通过在内核中维护每个 CPU 的哈希映射，消除了将每个上下文切换事件发送到用户空间的开销。只有聚合数据或采样事件需要跨越内核-用户边界，大大减少了监控开销。结合 eBPF 在加载前通过程序验证的**安全保证**，这创建了一个生产就绪的解决方案，不会崩溃内核或创建无限循环。

也许最重要的是，eBPF 支持**热插拔分析**，您可以在不重新启动应用程序或重新启动系统的情况下附加和分离能源监控器。这种能力支持对生产工作负载进行临时分析，这是传统内核模块或检测方法无法做到的。

### 现实世界的影响

eBPF 能源监控在不同部署场景中展现出的实际优势令人瞩目。对于**短暂进程**，传统方法经常会完全错过这些快速启动和停止的进程，而 eBPF 方法能够跟踪每一微秒，实现 100% 的可见性。在**容器监控**场景中，传统方法需要为每个容器承担高昂的监控开销，而 eBPF 通过共享内核基础设施，能够将开销降低 10 到 100 倍。对于**生产系统**而言，传统的内核模块存在系统崩溃的风险，而 eBPF 的验证安全程序确保了零崩溃风险。面对**动态工作负载**时，传统的固定采样方式容易错过功耗峰值，而 eBPF 的事件驱动机制能够捕获所有变化，实现准确的峰值检测。

### 何时 eBPF 能源监控至关重要

eBPF 能源监控在多种关键场景中发挥着不可替代的作用。在**电池供电设备**上，每一毫焦耳的能量都至关重要，而 eBPF 的低开销特性确保了监控过程本身不会影响电池寿命。**多租户云**环境需要准确的能源计费和功率预算执行，eBPF 的精确归因能力使得公平的能源计费成为可能。在**热管理**场景中，热约束环境需要实时反馈，eBPF 的事件驱动更新机制能够提供即时的热响应。对于**可持续性报告**，组织需要审计级别的碳足迹测量，eBPF 提供了生产级的精度，同时避免了传统方法的高开销。在进行**性能/瓦特优化**时，开发者需要以最小的干扰测量代码更改的影响，eBPF 提供了接近零偏差的 A/B 测试能力。

这些用例共享传统基于轮询的方法难以满足的共同要求：需要准确、低开销、实时的能源归因，可以在生产环境中可靠运行。

生态系统正在迅速成熟，像 Kepler 这样的项目已经部署在生产 Kubernetes 集群中，cpufreq_ext 正朝着主线内核包含的方向发展。我们的教程为理解和构建这些高级功能提供了基础。

## 架构概述

我们的能源监控解决方案提供了一个全面的比较框架，包含两种不同的实现。**eBPF 能源监控器**通过内核挂钩提供高性能监控，而**传统能源监控器**使用基于 bash 的 `/proc` 采样来代表传统方法。**比较脚本**允许在相同条件下直接评估两种方法。

eBPF 实现架构由三个紧密集成的组件组成：

### 头文件 (energy_monitor.h)

定义内核-用户通信的共享数据结构：

```c
struct energy_event {
    __u64 ts;           // 上下文切换的时间戳
    __u32 cpu;          // 进程运行的 CPU 核心
    __u32 pid;          // 进程 ID
    __u64 runtime_ns;   // 进程运行时间（纳秒）
    char comm[16];      // 进程名称
};
```

### eBPF 程序 (energy_monitor.bpf.c)

使用三个关键映射实现内核端逻辑：

```c
// 跟踪每个进程开始运行的时间
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);
    __uint(max_entries, 10240);
    __type(key, u32);    // PID
    __type(value, u64);  // 开始时间戳
} time_lookup SEC(".maps");

// 累积每个进程的总运行时间
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);
    __uint(max_entries, 10240);
    __type(key, u32);    // PID
    __type(value, u64);  // 总运行时间（微秒）
} runtime_lookup SEC(".maps");

// 向用户空间发送事件
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} rb SEC(".maps");
```

### 用户空间应用程序 (energy_monitor.c)

处理事件并基于配置的 CPU 功率计算能源消耗。

## 实现深入探讨

让我们探索 eBPF 能源监控器实现的关键部分：

### 挂钩到调度器

我们监控器的核心是在每次上下文切换时触发的调度器跟踪点：

```c
SEC("tp/sched/sched_switch")
int monitor_energy(struct trace_event_raw_sched_switch *ctx)
{
    u64 ts = bpf_ktime_get_ns();
    u32 cpu = bpf_get_smp_processor_id();
    
    u32 prev_pid = ctx->prev_pid;
    u32 next_pid = ctx->next_pid;
    
    // 计算刚刚停止的进程的运行时间
    u64 *old_ts_ptr = bpf_map_lookup_elem(&time_lookup, &prev_pid);
    if (old_ts_ptr) {
        u64 delta = ts - *old_ts_ptr;
        update_runtime(prev_pid, delta);
        
        // 向用户空间发送事件以进行实时监控
        struct energy_event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
        if (e) {
            e->ts = ts;
            e->cpu = cpu;
            e->pid = prev_pid;
            e->runtime_ns = delta;
            bpf_probe_read_kernel_str(e->comm, sizeof(e->comm), ctx->prev_comm);
            bpf_ringbuf_submit(e, 0);
        }
    }
    
    // 记录下一个进程开始运行的时间
    bpf_map_update_elem(&time_lookup, &next_pid, &ts, BPF_ANY);
    
    return 0;
}
```

这个函数捕获 CPU 从一个进程切换到另一个进程的确切时刻，使我们能够精确计算每个进程运行了多长时间。

### 高效的时间计算

为了最小化内核中的开销，我们使用优化的除法函数将纳秒转换为微秒：

```c
static inline u64 div_u64_by_1000(u64 n) {
    u64 q, r, t;
    t = (n >> 7) + (n >> 8) + (n >> 12);
    q = (n >> 1) + t + (n >> 15) + (t >> 11) + (t >> 14);
    q = q >> 9;
    r = n - q * 1000;
    return q + ((r + 24) >> 10);
}
```

这种位移方法在内核上下文中比常规除法快得多，在内核上下文中浮点运算不可用。

### 用户空间中的能源计算

用户空间程序接收运行时事件并计算能源消耗：

```c
static int handle_event(void *ctx, void *data, size_t data_sz)
{
    const struct energy_event *e = data;
    
    // 计算能量（纳焦耳）
    // 能量 (J) = 功率 (W) × 时间 (s)
    // 能量 (nJ) = 功率 (W) × 时间 (ns)
    __u64 energy_nj = (__u64)(env.cpu_power_watts * e->runtime_ns);
    
    if (env.verbose) {
        printf("%-16s pid=%-6d cpu=%-2d runtime=%llu ns energy=%llu nJ\n",
               e->comm, e->pid, e->cpu, e->runtime_ns, energy_nj);
    }
    
    return 0;
}
```

### 最终统计

当监控会话结束时，我们聚合来自所有 CPU 核心的数据：

```c
static void print_stats(struct energy_monitor_bpf *skel)
{
    int num_cpus = libbpf_num_possible_cpus();
    __u64 *values = calloc(num_cpus, sizeof(__u64));
    
    // 遍历所有进程
    while (bpf_map_get_next_key(bpf_map__fd(skel->maps.runtime_lookup), 
                                &key, &next_key) == 0) {
        // 汇总来自所有 CPU 的值（percpu map）
        if (bpf_map_lookup_elem(bpf_map__fd(skel->maps.runtime_lookup), 
                               &next_key, values) == 0) {
            for (int i = 0; i < num_cpus; i++) {
                runtime_us += values[i];
            }
            
            // 计算能量
            double energy_mj = (env.cpu_power_watts * runtime_us) / 1000000.0;
            printf("%-10d %-16s %-15.2f %-15.4f\n", 
                   next_key, comm, runtime_ms, energy_mj);
        }
    }
}
```

## 构建和运行能源监控器

### 先决条件

在构建之前，需要确保系统环境满足几个基本要求。首先需要 Linux 内核 5.4 或更新版本，且支持 BTF（BPF 类型格式）功能。其次要安装 libbpf 开发文件，这是 eBPF 程序开发的基础库。编译 eBPF 程序需要 clang 和 llvm 工具链。最后，还需要安装基本的构建工具，包括 make 和 gcc。

### 编译

使用提供的 Makefile 构建所有组件：

```bash
cd /home/yunwei37/bpf-developer-tutorial/src/48-energy
make clean && make
```

编译完成后会生成三个主要的可执行文件。`energy_monitor` 是基于 eBPF 的能源监控器，提供高精度的实时监控功能。`energy_monitor_traditional.sh` 是传统的基于轮询的监控器，使用 `/proc` 文件系统进行采样。`compare_monitors.sh` 则是用于比较两种方法效率和精度的脚本。

### 运行 eBPF 监控器

eBPF 监控器需要 root 权限才能附加到内核跟踪点：

```bash
# 以 15W CPU 功率监控所有进程 10 秒
sudo ./energy_monitor -d 10 -p 15.0

# 详细输出监控
sudo ./energy_monitor -v -d 10

# 持续监控（Ctrl+C 停止）
sudo ./energy_monitor
```

示例输出：

```
能源监控器已启动... 按 Ctrl-C 结束。
CPU 功率：15.00 W
运行 10 秒

=== 能源使用摘要 ===
PID        COMM             运行时间 (ms)    能量 (mJ)    
---------- ---------------- --------------- ---------------
39716      firefox          541.73          8.1260         
19845      node             67.71           1.0157         
39719      vscode           63.15           0.9472         
29712      chrome           13.34           0.2000         
...

总 CPU 时间：2781.52 ms
总估计能量：0.0417 J (41.7229 mJ)
CPU 功率设置：15.00 W
```

### 运行传统监控器

传统监控器使用 `/proc` 采样，无需特殊权限即可运行：

```bash
# 详细输出监控 10 秒
./energy_monitor_traditional.sh -d 10 -v

# 调整采样间隔（默认 100ms）
./energy_monitor_traditional.sh -d 10 -i 0.05
```

### 比较两种方法

使用比较脚本查看差异：

```bash
# 基本比较
sudo ./compare_monitors.sh -d 10

# 带有 CPU 工作负载
sudo ./compare_monitors.sh -d 10 -w "stress --cpu 2 --timeout 10"
```

比较输出示例：

```
比较结果
==================

指标                      传统           eBPF           
------------------------- --------------- ---------------
总能量 (J)                1.050000        0.0288         
监控时间 (s)              5.112031        4.500215       
样本/事件                 50              连续     

性能分析：
- 传统监控开销：与 eBPF 相比为 13.00%
- eBPF 提供每个上下文切换的粒度
- 传统采样以固定间隔（100ms）
```

## 理解能源监控权衡

虽然我们的能源监控器提供了有价值的见解，但了解其局限性和权衡很重要：

### 精度考虑

我们的能源监控模型采用简化方法，使用公式：能量 = CPU_功率 × CPU_时间。虽然这提供了有价值的比较见解，但它没有考虑影响实际功耗的几个动态因素。

**频率调节**是一个重要限制，因为现代 CPU 根据工作负载和热条件动态改变频率。不同的**空闲状态**（C 状态）也消耗不同的功率，从深度睡眠中的接近零到浅空闲状态中的显著待机功率。此外，**工作负载特性**很重要，因为某些指令（特别是向量操作和内存密集型任务）每个周期消耗的功率比简单的算术运算更多。

该模型还忽略了来自缓存、内存控制器和 I/O 子系统的**共享资源消耗**，这些都有助于总系统功率，但不能直接归因于 CPU 执行时间。

对于需要更高精度的生产部署，增强功能将包括读取硬件性能计数器以进行实际功率测量，通过 DVFS 事件跟踪频率变化，基于性能计数器对不同指令类型进行建模，以及合并来自更广泛系统的内存和 I/O 活动指标。

### 何时使用每种方法

在 eBPF 和传统监控之间进行选择取决于您的具体要求和约束。

**eBPF 监控**在您需要准确的 CPU 时间跟踪时表现出色，特别是对于传统采样可能完全错过的短暂进程。其最小的测量开销使其成为生产环境的理想选择，在生产环境中，监控工具本身不应影响被测量的工作负载。eBPF 对于进程之间的比较分析特别有价值，其中相对精度比绝对精度更重要。

**传统监控**在由于权限限制或缺少 BTF 支持的旧内核版本而无法使用 eBPF 时仍然适用。它提供了一个简单、可移植的解决方案，不需要特殊权限，可以跨不同平台工作。对于监控长时间运行的稳定工作负载，其中近似测量就足够了，传统方法提供了足够的洞察力，部署要求更简单。

## 实际用例和部署场景

了解何时以及如何部署 eBPF 能源监控有助于最大化其价值。以下是它表现出色的现实场景：

### 数据中心能源优化

现代数据中心在严格的功率预算和冷却约束下运行，eBPF 能源监控提供了关键的运营能力。当调度器了解不同应用程序的能源配置文件时，**工作负载放置**变得智能化，从而在机架之间实现平衡的功耗，同时避免热点并最大化整体效率。

在高峰需求期间，**功率上限**系统可以利用实时能源归因来识别和选择性地限制最耗电的进程，而不影响关键服务。这种外科手术方法在保持在电力基础设施限制内的同时维持服务水平。

对于云提供商，**计费和退款**准确性推动客户行为朝着更高效的代码发展。当客户可以看到其工作负载的实际能源成本时，他们有直接的财务激励来优化其应用程序的能源效率。

### 移动和边缘计算

电池供电设备提出了独特的能源约束，其中精确监控对于用户体验和设备寿命至关重要。**应用程序能源分析**使开发人员能够在不同操作期间获得准确的能源消耗数据，从而实现有针对性的优化，可以显著延长电池寿命而不牺牲功能。

操作系统受益于**后台任务管理**智能，其中历史能源消耗模式告知有关允许或推迟哪些后台任务的决策。这可以防止耗能的后台进程耗尽电池，同时维护基本服务。

在没有主动冷却的设备中，**热管理**变得至关重要，因为能源监控有助于在节流发生之前预测热量积累。通过了解能源模式，系统可以主动管理工作负载，以在热限制内保持一致的性能。

### 开发和 CI/CD 集成

将能源监控集成到开发工作流中会创建一个连续的反馈循环，防止效率倒退到达生产环境。**能源回归测试**通过 CI/CD 管道变得自动化，这些管道标记将能源消耗增加到预定义阈值以上的代码更改，将能源效率视为一流的软件质量指标。

**性能/瓦特优化**为开发人员提供了对性能改进的真实成本的可见性。一些优化可能会提高速度，同时大幅增加能源消耗，而另一些可能会以最小的性能影响实现更好的效率。这种可见性支持基于实际工作负载要求的明智架构决策，平衡速度和效率。

**绿色软件指标**集成允许组织跟踪和报告能源效率作为可持续性计划的一部分。定期测量为环境影响报告提供了具体数据，同时为软件团队创建了在其开发实践中考虑能源效率的问责制。

### 研究和教育

eBPF 能源监控作为一种强大的研究和教育工具，弥合了理论理解和实际系统行为之间的差距。当研究人员可以在生产现实条件下测量方法之间的能源效率差异时，**算法比较**变得严格，提供了补充理论复杂性分析的经验数据。

**系统行为分析**从能源角度揭示了不同组件之间的复杂交互，发现了仅查看性能指标时不明显的优化机会。这些见解推动了考虑总拥有成本（包括运营能源成本）的系统设计决策。

作为**教学工具**，能源监控通过向学生展示其代码的即时能源影响，使抽象概念变得具体。当算法复杂性讨论与真实能源测量配对时，学生们对其设计选择的实际影响有了直觉，而不仅仅是计算效率。

## 扩展能源监控器

当前的实现为构建更复杂的能源监控功能提供了坚实的基础，有多个扩展方向值得探索。**硬件计数器集成**是最有影响力的增强方向，通过 `PERF_TYPE_POWER` 事件集成 RAPL 计数器，可以用实际的硬件测量来替换我们的估算模型，大幅提升精度。**每核功率建模**在处理异构处理器时尤为重要，通过跟踪进程的核心分配并建模性能核心（P 核）与效率核心（E 核）之间的功耗差异，能够实现更准确的能源归因。**工作负载分类**功能可以识别 CPU 密集型、内存绑定、I/O 绑定和空闲模式等不同工作负载类型，从而实现针对特定工作负载的功率优化策略。**容器运行时集成**使得系统能够按容器或 pod 聚合 Kubernetes 环境中的能源消耗，支持云原生的能源归因和计费。**实时可视化**通过提供带有能源消耗图表的 Web 仪表板，为能源优化提供即时的视觉反馈。

**硬件计数器集成**代表了最有影响力的增强，通过 RAPL（运行平均功率限制）接口用实际硬件测量替换我们的简化估计模型。现代处理器提供详细的能源计数器，可以通过性能事件读取，提供精确到单个 CPU 封装的能源测量。

```c
// 读取 RAPL 计数器以获取实际能源测量
struct perf_event_attr attr = {
    .type = PERF_TYPE_POWER,
    .config = PERF_COUNT_HW_POWER_PKG,
};
```

**每核功率建模**在异构处理器上变得至关重要，其中性能核心和效率核心具有截然不同的功率特性。跟踪每个进程在哪个核心上运行可以实现准确的能源归因：

```c
// 不同的核心可能具有不同的功率特性
double core_power[MAX_CPUS] = {15.0, 15.0, 10.0, 10.0}; // P 核与 E 核
```

**工作负载分类**通过识别不同的计算模式及其相关的能源成本来增强能源监控：

```c
enum workload_type {
    WORKLOAD_CPU_INTENSIVE,
    WORKLOAD_MEMORY_BOUND,
    WORKLOAD_IO_BOUND,
    WORKLOAD_IDLE
};
```

## 故障排除常见问题

部署 eBPF 能源监控时，您可能会遇到这些常见问题：

### 权限被拒绝

如果在运行 eBPF 监控器时看到权限错误：

```bash
# 检查 BPF 是否已启用
sudo sysctl kernel.unprivileged_bpf_disabled

# 启用 BPF 进行调试（不建议用于生产）
sudo sysctl kernel.unprivileged_bpf_disabled=0
```

### 缺少 BTF 信息

如果内核缺少 BTF（BPF 类型格式）数据：

```bash
# 检查 BTF 支持
ls /sys/kernel/btf/vmlinux

# 在较旧的内核上，您可能需要生成 BTF
# 或使用带有 CONFIG_DEBUG_INFO_BTF=y 的内核
```

### 高 CPU 使用率

如果监控器本身导致高 CPU 使用率，可以采取几种优化措施。首先考虑减少 eBPF 程序中的环形缓冲区大小，这能够降低内存压力和处理开销。其次，增加批量读取事件的大小可以减少系统调用的频率。最有效的方法是在内核中添加事件过滤逻辑，从源头上减少需要传递到用户空间的事件数量。

### 缺少进程

当发现某些进程没有被正确跟踪时，需要从几个方面进行排查。首先检查这些进程是否运行在不同的 PID 命名空间中，容器化环境经常会出现这种情况。其次，确保监控器在目标进程启动之前就已经运行，否则可能会错过初始的调度事件。最后，验证 eBPF 程序中的哈希映射大小是否足够容纳所有需要跟踪的进程，必要时可以增加 `max_entries` 的值。

## 未来方向

基于 eBPF 的能源监控领域正在迅速发展。以下是即将到来的令人兴奋的发展：

### 与硬件加速器集成

随着 GPU、TPU 和其他加速器变得普遍，扩展 eBPF 监控以跟踪其能源消耗将提供完整的系统可见性。

### 用于功率预测的机器学习

使用 eBPF 收集的数据来训练模型，这些模型基于工作负载模式预测未来的功耗，从而实现主动电源管理。

### 标准化工作

正在进行标准化 eBPF 能源监控接口的工作，使构建跨不同平台工作的可移植工具变得更加容易。

### 碳感知计算

将能源监控与实时碳强度数据相结合，自动将工作负载转移到具有更清洁能源的时间和地点。

## 参考文献和进一步阅读

要深入了解本教程中涵盖的主题：

### 能源和电源管理

在能源和电源管理领域，有几个重要的参考资源值得深入研究。Intel 的运行平均功率限制 (RAPL) 文档（[https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/running-average-power-limit-energy-reporting.html](https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/running-average-power-limit-energy-reporting.html)）详细解释了如何使用硬件计数器进行精确的能源测量。Linux 电源管理文档（[https://www.kernel.org/doc/html/latest/admin-guide/pm/index.html](https://www.kernel.org/doc/html/latest/admin-guide/pm/index.html)）提供了内核电源管理子系统的全面指南。而 ACPI 规范（[https://uefi.org/specifications](https://uefi.org/specifications)）则定义了现代系统电源管理的标准接口。

### 相关项目

在能源监控生态系统中，有许多值得关注的项目。Kepler（Kubernetes 高效功率级别导出器）作为 CNCF 项目，专门为云原生环境提供能源监控解决方案（[https://sustainable-computing.io/](https://sustainable-computing.io/)）。Scaphandre（[https://github.com/hubblo-org/scaphandre](https://github.com/hubblo-org/scaphandre)）提供了另一种功率测量实现，支持多种硬件平台。经典的 PowerTOP 工具（[https://github.com/fenrus75/powertop](https://github.com/fenrus75/powertop)）一直是 Linux 系统上诊断电源问题的首选工具。最近的 cpufreq_ext eBPF 调节器（[https://lwn.net/Articles/991991/](https://lwn.net/Articles/991991/)）展示了使用 eBPF 进行动态频率调节的可能性。Wattmeter 项目在 HotCarbon '24 会议上的展示（[https://www.asafcidon.com/uploads/5/9/7/0/59701649/energy-aware-ebpf.pdf](https://www.asafcidon.com/uploads/5/9/7/0/59701649/energy-aware-ebpf.pdf)）则代表了该领域的最新研究成果。

### 学术论文

学术界对 eBPF 能源监控的研究日益活跃。HotCarbon '24 会议上发表的 "Linux 中的能源感知进程调度" 论文提出了创新的调度算法。"DEEP-mon：基于容器的基础设施的动态和节能功率监控" 研究展示了如何在容器化环境中实现高效的能源监控。而 "基于 eBPF 的能源感知调度" 等研究论文则探索了将能源感知与任务调度紧密结合的新方法。

本教程的完整代码可在以下位置获得：[https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/48-energy](https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/48-energy)

有关更多 eBPF 教程和项目，请访问：[https://eunomia.dev/tutorials/](https://eunomia.dev/tutorials/)

## 结论

随着我们努力实现更可持续的计算，能源监控变得越来越重要。本教程演示了 eBPF 如何在进程级别提供精确、低开销的能源归因，使开发人员和系统管理员能够就能源效率做出明智的决策。

eBPF 的内核集成和高效事件处理的结合使其成为生产能源监控的理想选择。无论您是优化数据中心工作负载、延长移动设备的电池寿命，还是只是对应用程序的能源足迹感到好奇，eBPF 都提供了您进行详细分析所需的工具。

随着生态系统的成熟，像 Kepler 这样的项目已经投入生产，cpufreq_ext 正在接近主线包含，我们正在进入一个能源感知计算成为默认而不是事后想法的时代。立即开始监控您的应用程序的能源消耗，为更可持续的计算未来做出贡献！